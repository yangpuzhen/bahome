/*!
 * @pixi-spine/runtime-3.7 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-3.7 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{AttachmentType as Ct,Color as tt,MathUtils as A,Utils as V,PowOut as ke,MixBlend as y,MixDirection as rt,IntSet as Pe,Pool as Ne,settings as Ht,TransformMode as ft,RotateMode as kt,PositionMode as Yt,Vector2 as Ye,SkeletonBoundsBase as De,SpineBase as Xe}from"@pixi-spine/base";import{Matrix as ve,BLEND_MODES as _t}from"@pixi/core";class jt{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const he=class extends jt{constructor(i){super(i),this.id=(he.nextID++&65535)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(i,t){this.computeWorldVertices(i,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(i,t,e,a,n,l){e=n+(e>>1)*l;const d=i.bone.skeleton,o=i.attachmentVertices;let s=this.vertices;const r=this.bones;if(r==null){o.length>0&&(s=o);const c=i.bone.matrix,f=c.tx,g=c.ty,E=c.a,p=c.c,b=c.b,M=c.d;for(let w=t,T=n;T<e;w+=2,T+=l){const x=s[w],R=s[w+1];a[T]=x*E+R*p+f,a[T+1]=x*b+R*M+g}return}let h=0,u=0;for(let c=0;c<t;c+=2){const f=r[h];h+=f+1,u+=f}const m=d.bones;if(o.length==0)for(let c=n,f=u*3;c<e;c+=l){let g=0,E=0,p=r[h++];for(p+=h;h<p;h++,f+=3){const b=m[r[h]].matrix,M=s[f],w=s[f+1],T=s[f+2];g+=(M*b.a+w*b.c+b.tx)*T,E+=(M*b.b+w*b.d+b.ty)*T}a[c]=g,a[c+1]=E}else{const c=o;for(let f=n,g=u*3,E=u<<1;f<e;f+=l){let p=0,b=0,M=r[h++];for(M+=h;h<M;h++,g+=3,E+=2){const w=m[r[h]].matrix,T=s[g]+c[E],x=s[g+1]+c[E+1],R=s[g+2];p+=(T*w.a+x*w.c+w.tx)*R,b+=(T*w.b+x*w.d+w.ty)*R}a[f]=p,a[f+1]=b}}}applyDeform(i){return this==i}};let Rt=he;Rt.nextID=0;class ce extends Rt{constructor(t){super(t),this.type=Ct.BoundingBox,this.color=new tt(1,1,1,1)}}class de extends Rt{constructor(t){super(t),this.type=Ct.Clipping,this.color=new tt(.2275,.2275,.8078,1)}}class Gt extends Rt{constructor(t){super(t),this.type=Ct.Mesh,this.color=new tt(1,1,1,1),this.inheritDeform=!1,this.tempColor=new tt(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}}class Dt extends Rt{constructor(t){super(t),this.type=Ct.Path,this.closed=!1,this.constantSpeed=!1,this.color=new tt(1,1,1,1)}}class ue extends Rt{constructor(t){super(t),this.type=Ct.Point,this.color=new tt(.38,.94,0,1)}computeWorldPosition(t,e){const a=t.matrix;return e.x=this.x*a.a+this.y*a.c+t.worldX,e.y=this.x*a.b+this.y*a.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,a=A.cosDeg(this.rotation),n=A.sinDeg(this.rotation),l=a*e.a+n*e.c,d=a*e.b+n*e.d;return Math.atan2(d,l)*A.radDeg}}class Zt{constructor(t,e){if(this.attachmentVertices=new Array,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new tt,this.darkColor=t.darkColor==null?null:new tt,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const J=class extends jt{constructor(i){super(i),this.type=Ct.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new tt(1,1,1,1),this.offset=V.newFloatArray(8),this.uvs=V.newFloatArray(8),this.tempColor=new tt(1,1,1,1)}updateOffset(){const i=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*i,a=-this.height/2*this.scaleY+this.region.offsetY*t,n=e+this.region.width*i,l=a+this.region.height*t,d=this.rotation*Math.PI/180,o=Math.cos(d),s=Math.sin(d),r=e*o+this.x,h=e*s,u=a*o+this.y,m=a*s,c=n*o+this.x,f=n*s,g=l*o+this.y,E=l*s,p=this.offset;p[J.OX1]=r-m,p[J.OY1]=u+h,p[J.OX2]=r-E,p[J.OY2]=g+h,p[J.OX3]=c-E,p[J.OY3]=g+f,p[J.OX4]=c-m,p[J.OY4]=u+f}setRegion(i){this.region=i;const t=this.uvs;i.rotate?(t[2]=i.u,t[3]=i.v2,t[4]=i.u,t[5]=i.v,t[6]=i.u2,t[7]=i.v,t[0]=i.u2,t[1]=i.v2):(t[0]=i.u,t[1]=i.v2,t[2]=i.u,t[3]=i.v,t[4]=i.u2,t[5]=i.v,t[6]=i.u2,t[7]=i.v2)}computeWorldVertices(i,t,e,a){const n=this.offset,l=i instanceof Zt?i.bone.matrix:i.matrix,d=l.tx,o=l.ty,s=l.a,r=l.c,h=l.b,u=l.d;let m=0,c=0;m=n[J.OX1],c=n[J.OY1],t[e]=m*s+c*r+d,t[e+1]=m*h+c*u+o,e+=a,m=n[J.OX2],c=n[J.OY2],t[e]=m*s+c*r+d,t[e+1]=m*h+c*u+o,e+=a,m=n[J.OX3],c=n[J.OY3],t[e]=m*s+c*r+d,t[e+1]=m*h+c*u+o,e+=a,m=n[J.OX4],c=n[J.OY4],t[e]=m*s+c*r+d,t[e+1]=m*h+c*u+o}};let k=J;k.OX1=0,k.OY1=1,k.OX2=2,k.OY2=3,k.OX3=4,k.OY3=5,k.OX4=6,k.OY4=7,k.X1=0,k.Y1=1,k.C1R=2,k.C1G=3,k.C1B=4,k.C1A=5,k.U1=6,k.V1=7,k.X2=8,k.Y2=9,k.C2R=10,k.C2G=11,k.C2B=12,k.C2A=13,k.U2=14,k.V2=15,k.X3=16,k.Y3=17,k.C3R=18,k.C3G=19,k.C3B=20,k.C3A=21,k.U3=22,k.V3=23,k.X4=24,k.Y4=25,k.C4R=26,k.C4G=27,k.C4B=28,k.C4A=29,k.U4=30,k.V4=31;class Fe{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,a,n){t.x+=A.randomTriangular(-this.jitterX,this.jitterY),t.y+=A.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const me=class{constructor(i){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=i}begin(i){this.worldX=i.x+this.centerX,this.worldY=i.y+this.centerY}transform(i,t,e,a){const n=this.angle*A.degreesToRadians,l=i.x-this.worldX,d=i.y-this.worldY,o=Math.sqrt(l*l+d*d);if(o<this.radius){const s=me.interpolation.apply(0,n,(this.radius-o)/this.radius),r=Math.cos(s),h=Math.sin(s);i.x=r*l-h*d+this.worldX,i.y=h*l+r*d+this.worldY}}end(){}};let fe=me;fe.interpolation=new ke(2);class Z{constructor(t,e,a){if(t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=a}apply(t,e,a,n,l,d,o,s){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(a%=this.duration,e>0&&(e%=this.duration));const r=this.timelines;for(let h=0,u=r.length;h<u;h++)r[h].apply(t,e,a,l,d,o,s)}static binarySearch(t,e,a=1){let n=0,l=t.length/a-2;if(l==0)return a;let d=l>>>1;for(;;){if(t[(d+1)*a]<=e?n=d+1:l=d,n==l)return(n+1)*a;d=n+l>>>1}}static linearSearch(t,e,a){for(let n=0,l=t.length-a;n<=l;n+=a)if(t[n]>e)return n;return-1}}var pe=(i=>(i[i.rotate=0]="rotate",i[i.translate=1]="translate",i[i.scale=2]="scale",i[i.shear=3]="shear",i[i.attachment=4]="attachment",i[i.color=5]="color",i[i.deform=6]="deform",i[i.event=7]="event",i[i.drawOrder=8]="drawOrder",i[i.ikConstraint=9]="ikConstraint",i[i.transformConstraint=10]="transformConstraint",i[i.pathConstraintPosition=11]="pathConstraintPosition",i[i.pathConstraintSpacing=12]="pathConstraintSpacing",i[i.pathConstraintMix=13]="pathConstraintMix",i[i.twoColor=14]="twoColor",i))(pe||{});const j=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=V.newFloatArray((t-1)*j.BEZIER_SIZE)}getFrameCount(){return this.curves.length/j.BEZIER_SIZE+1}setLinear(t){this.curves[t*j.BEZIER_SIZE]=j.LINEAR}setStepped(t){this.curves[t*j.BEZIER_SIZE]=j.STEPPED}getCurveType(t){const e=t*j.BEZIER_SIZE;if(e==this.curves.length)return j.LINEAR;const a=this.curves[e];return a==j.LINEAR?j.LINEAR:a==j.STEPPED?j.STEPPED:j.BEZIER}setCurve(t,e,a,n,l){const d=(-e*2+n)*.03,o=(-a*2+l)*.03,s=((e-n)*3+1)*.006,r=((a-l)*3+1)*.006;let h=d*2+s,u=o*2+r,m=e*.3+d+s*.16666667,c=a*.3+o+r*.16666667,f=t*j.BEZIER_SIZE;const g=this.curves;g[f++]=j.BEZIER;let E=m,p=c;for(let b=f+j.BEZIER_SIZE-1;f<b;f+=2)g[f]=E,g[f+1]=p,m+=h,c+=u,h+=s,u+=r,E+=m,p+=c}getCurvePercent(t,e){e=A.clamp(e,0,1);const a=this.curves;let n=t*j.BEZIER_SIZE;const l=a[n];if(l==j.LINEAR)return e;if(l==j.STEPPED)return 0;n++;let d=0;for(let s=n,r=n+j.BEZIER_SIZE-1;n<r;n+=2)if(d=a[n],d>=e){let h,u;return n==s?(h=0,u=0):(h=a[n-2],u=a[n-1]),u+(a[n+1]-u)*(e-h)/(d-h)}const o=a[n-1];return o+(1-o)*(e-d)/(1-d)}};let ot=j;ot.LINEAR=0,ot.STEPPED=1,ot.BEZIER=2,ot.BEZIER_SIZE=10*2-1;const Tt=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(i,t,e){i<<=1,this.frames[i]=t,this.frames[i+Tt.ROTATION]=e}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.bones[this.boneIndex];if(e<o[0]){switch(l){case y.setup:s.rotation=s.data.rotation;return;case y.first:const f=s.data.rotation-s.rotation;s.rotation+=(f-(16384-(16384.499999999996-f/360|0))*360)*n}return}if(e>=o[o.length-Tt.ENTRIES]){let f=o[o.length+Tt.PREV_ROTATION];switch(l){case y.setup:s.rotation=s.data.rotation+f*n;break;case y.first:case y.replace:f+=s.data.rotation-s.rotation,f-=(16384-(16384.499999999996-f/360|0))*360;case y.add:s.rotation+=f*n}return}const r=Z.binarySearch(o,e,Tt.ENTRIES),h=o[r+Tt.PREV_ROTATION],u=o[r],m=this.getCurvePercent((r>>1)-1,1-(e-u)/(o[r+Tt.PREV_TIME]-u));let c=o[r+Tt.ROTATION]-h;switch(c=h+(c-(16384-(16384.499999999996-c/360|0))*360)*m,l){case y.setup:s.rotation=s.data.rotation+(c-(16384-(16384.499999999996-c/360|0))*360)*n;break;case y.first:case y.replace:c+=s.data.rotation-s.rotation;case y.add:s.rotation+=(c-(16384-(16384.499999999996-c/360|0))*360)*n}}};let nt=Tt;nt.ENTRIES=2,nt.PREV_TIME=-2,nt.PREV_ROTATION=-1,nt.ROTATION=1;const st=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*st.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(i,t,e,a){i*=st.ENTRIES,this.frames[i]=t,this.frames[i+st.X]=e,this.frames[i+st.Y]=a}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.bones[this.boneIndex];if(e<o[0]){switch(l){case y.setup:s.x=s.data.x,s.y=s.data.y;return;case y.first:s.x+=(s.data.x-s.x)*n,s.y+=(s.data.y-s.y)*n}return}let r=0,h=0;if(e>=o[o.length-st.ENTRIES])r=o[o.length+st.PREV_X],h=o[o.length+st.PREV_Y];else{const u=Z.binarySearch(o,e,st.ENTRIES);r=o[u+st.PREV_X],h=o[u+st.PREV_Y];const m=o[u],c=this.getCurvePercent(u/st.ENTRIES-1,1-(e-m)/(o[u+st.PREV_TIME]-m));r+=(o[u+st.X]-r)*c,h+=(o[u+st.Y]-h)*c}switch(l){case y.setup:s.x=s.data.x+r*n,s.y=s.data.y+h*n;break;case y.first:case y.replace:s.x+=(s.data.x+r-s.x)*n,s.y+=(s.data.y+h-s.y)*n;break;case y.add:s.x+=r*n,s.y+=h*n}}};let pt=st;pt.ENTRIES=3,pt.PREV_TIME=-3,pt.PREV_X=-2,pt.PREV_Y=-1,pt.X=1,pt.Y=2;class ut extends pt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,a,n,l,d,o){const s=this.frames,r=t.bones[this.boneIndex];if(a<s[0]){switch(d){case y.setup:r.scaleX=r.data.scaleX,r.scaleY=r.data.scaleY;return;case y.first:r.scaleX+=(r.data.scaleX-r.scaleX)*l,r.scaleY+=(r.data.scaleY-r.scaleY)*l}return}let h=0,u=0;if(a>=s[s.length-ut.ENTRIES])h=s[s.length+ut.PREV_X]*r.data.scaleX,u=s[s.length+ut.PREV_Y]*r.data.scaleY;else{const m=Z.binarySearch(s,a,ut.ENTRIES);h=s[m+ut.PREV_X],u=s[m+ut.PREV_Y];const c=s[m],f=this.getCurvePercent(m/ut.ENTRIES-1,1-(a-c)/(s[m+ut.PREV_TIME]-c));h=(h+(s[m+ut.X]-h)*f)*r.data.scaleX,u=(u+(s[m+ut.Y]-u)*f)*r.data.scaleY}if(l==1)d==y.add?(r.scaleX+=h-r.data.scaleX,r.scaleY+=u-r.data.scaleY):(r.scaleX=h,r.scaleY=u);else{let m=0,c=0;if(o==rt.mixOut)switch(d){case y.setup:m=r.data.scaleX,c=r.data.scaleY,r.scaleX=m+(Math.abs(h)*A.signum(m)-m)*l,r.scaleY=c+(Math.abs(u)*A.signum(c)-c)*l;break;case y.first:case y.replace:m=r.scaleX,c=r.scaleY,r.scaleX=m+(Math.abs(h)*A.signum(m)-m)*l,r.scaleY=c+(Math.abs(u)*A.signum(c)-c)*l;break;case y.add:m=r.scaleX,c=r.scaleY,r.scaleX=m+(Math.abs(h)*A.signum(m)-r.data.scaleX)*l,r.scaleY=c+(Math.abs(u)*A.signum(c)-r.data.scaleY)*l}else switch(d){case y.setup:m=Math.abs(r.data.scaleX)*A.signum(h),c=Math.abs(r.data.scaleY)*A.signum(u),r.scaleX=m+(h-m)*l,r.scaleY=c+(u-c)*l;break;case y.first:case y.replace:m=Math.abs(r.scaleX)*A.signum(h),c=Math.abs(r.scaleY)*A.signum(u),r.scaleX=m+(h-m)*l,r.scaleY=c+(u-c)*l;break;case y.add:m=A.signum(h),c=A.signum(u),r.scaleX=Math.abs(r.scaleX)*m+(h-Math.abs(r.data.scaleX)*m)*l,r.scaleY=Math.abs(r.scaleY)*c+(u-Math.abs(r.data.scaleY)*c)*l}}}}class mt extends pt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,a,n,l,d,o){const s=this.frames,r=t.bones[this.boneIndex];if(a<s[0]){switch(d){case y.setup:r.shearX=r.data.shearX,r.shearY=r.data.shearY;return;case y.first:r.shearX+=(r.data.shearX-r.shearX)*l,r.shearY+=(r.data.shearY-r.shearY)*l}return}let h=0,u=0;if(a>=s[s.length-mt.ENTRIES])h=s[s.length+mt.PREV_X],u=s[s.length+mt.PREV_Y];else{const m=Z.binarySearch(s,a,mt.ENTRIES);h=s[m+mt.PREV_X],u=s[m+mt.PREV_Y];const c=s[m],f=this.getCurvePercent(m/mt.ENTRIES-1,1-(a-c)/(s[m+mt.PREV_TIME]-c));h=h+(s[m+mt.X]-h)*f,u=u+(s[m+mt.Y]-u)*f}switch(d){case y.setup:r.shearX=r.data.shearX+h*l,r.shearY=r.data.shearY+u*l;break;case y.first:case y.replace:r.shearX+=(r.data.shearX+h-r.shearX)*l,r.shearY+=(r.data.shearY+u-r.shearY)*l;break;case y.add:r.shearX+=h*l,r.shearY+=u*l}}}const U=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*U.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(i,t,e,a,n,l){i*=U.ENTRIES,this.frames[i]=t,this.frames[i+U.R]=e,this.frames[i+U.G]=a,this.frames[i+U.B]=n,this.frames[i+U.A]=l}apply(i,t,e,a,n,l,d){const o=i.slots[this.slotIndex],s=this.frames;if(e<s[0]){switch(l){case y.setup:o.color.setFromColor(o.data.color);return;case y.first:const c=o.color,f=o.data.color;c.add((f.r-c.r)*n,(f.g-c.g)*n,(f.b-c.b)*n,(f.a-c.a)*n)}return}let r=0,h=0,u=0,m=0;if(e>=s[s.length-U.ENTRIES]){const c=s.length;r=s[c+U.PREV_R],h=s[c+U.PREV_G],u=s[c+U.PREV_B],m=s[c+U.PREV_A]}else{const c=Z.binarySearch(s,e,U.ENTRIES);r=s[c+U.PREV_R],h=s[c+U.PREV_G],u=s[c+U.PREV_B],m=s[c+U.PREV_A];const f=s[c],g=this.getCurvePercent(c/U.ENTRIES-1,1-(e-f)/(s[c+U.PREV_TIME]-f));r+=(s[c+U.R]-r)*g,h+=(s[c+U.G]-h)*g,u+=(s[c+U.B]-u)*g,m+=(s[c+U.A]-m)*g}if(n==1)o.color.set(r,h,u,m);else{const c=o.color;l==y.setup&&c.setFromColor(o.data.color),c.add((r-c.r)*n,(h-c.g)*n,(u-c.b)*n,(m-c.a)*n)}}};let ht=U;ht.ENTRIES=5,ht.PREV_TIME=-5,ht.PREV_R=-4,ht.PREV_G=-3,ht.PREV_B=-2,ht.PREV_A=-1,ht.R=1,ht.G=2,ht.B=3,ht.A=4;const v=class extends ot{constructor(t){super(t),this.frames=V.newFloatArray(t*v.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,a,n,l,d,o,s,r){t*=v.ENTRIES,this.frames[t]=e,this.frames[t+v.R]=a,this.frames[t+v.G]=n,this.frames[t+v.B]=l,this.frames[t+v.A]=d,this.frames[t+v.R2]=o,this.frames[t+v.G2]=s,this.frames[t+v.B2]=r}apply(t,e,a,n,l,d,o){const s=t.slots[this.slotIndex],r=this.frames;if(a<r[0]){switch(d){case y.setup:s.color.setFromColor(s.data.color),s.darkColor.setFromColor(s.data.darkColor);return;case y.first:const p=s.color,b=s.darkColor,M=s.data.color,w=s.data.darkColor;p.add((M.r-p.r)*l,(M.g-p.g)*l,(M.b-p.b)*l,(M.a-p.a)*l),b.add((w.r-b.r)*l,(w.g-b.g)*l,(w.b-b.b)*l,0)}return}let h=0,u=0,m=0,c=0,f=0,g=0,E=0;if(a>=r[r.length-v.ENTRIES]){const p=r.length;h=r[p+v.PREV_R],u=r[p+v.PREV_G],m=r[p+v.PREV_B],c=r[p+v.PREV_A],f=r[p+v.PREV_R2],g=r[p+v.PREV_G2],E=r[p+v.PREV_B2]}else{const p=Z.binarySearch(r,a,v.ENTRIES);h=r[p+v.PREV_R],u=r[p+v.PREV_G],m=r[p+v.PREV_B],c=r[p+v.PREV_A],f=r[p+v.PREV_R2],g=r[p+v.PREV_G2],E=r[p+v.PREV_B2];const b=r[p],M=this.getCurvePercent(p/v.ENTRIES-1,1-(a-b)/(r[p+v.PREV_TIME]-b));h+=(r[p+v.R]-h)*M,u+=(r[p+v.G]-u)*M,m+=(r[p+v.B]-m)*M,c+=(r[p+v.A]-c)*M,f+=(r[p+v.R2]-f)*M,g+=(r[p+v.G2]-g)*M,E+=(r[p+v.B2]-E)*M}if(l==1)s.color.set(h,u,m,c),s.darkColor.set(f,g,E,1);else{const p=s.color,b=s.darkColor;d==y.setup&&(p.setFromColor(s.data.color),b.setFromColor(s.data.darkColor)),p.add((h-p.r)*l,(u-p.g)*l,(m-p.b)*l,(c-p.a)*l),b.add((f-b.r)*l,(g-b.g)*l,(E-b.b)*l,0)}}};let z=v;z.ENTRIES=8,z.PREV_TIME=-8,z.PREV_R=-7,z.PREV_G=-6,z.PREV_B=-5,z.PREV_A=-4,z.PREV_R2=-3,z.PREV_G2=-2,z.PREV_B2=-1,z.R=1,z.G=2,z.B=3,z.A=4,z.R2=5,z.G2=6,z.B2=7;class Lt{constructor(t){this.frames=V.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,a){this.frames[t]=e,this.attachmentNames[t]=a}apply(t,e,a,n,l,d,o){const s=t.slots[this.slotIndex];if(o==rt.mixOut&&d==y.setup){const m=s.data.attachmentName;s.setAttachment(m==null?null:t.getAttachment(this.slotIndex,m));return}const r=this.frames;if(a<r[0]){if(d==y.setup||d==y.first){const m=s.data.attachmentName;s.setAttachment(m==null?null:t.getAttachment(this.slotIndex,m))}return}let h=0;a>=r[r.length-1]?h=r.length-1:h=Z.binarySearch(r,a,1)-1;const u=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(u==null?null:t.getAttachment(this.slotIndex,u))}}let ge=null;class xe extends ot{constructor(t){super(t),this.frames=V.newFloatArray(t),this.frameVertices=new Array(t),ge==null&&(ge=V.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,a){this.frames[t]=e,this.frameVertices[t]=a}apply(t,e,a,n,l,d,o){const s=t.slots[this.slotIndex],r=s.getAttachment();if(!(r instanceof Rt)||!r.applyDeform(this.attachment))return;const h=s.attachmentVertices;h.length==0&&(d=y.setup);const u=this.frameVertices,m=u[0].length,c=this.frames;if(a<c[0]){const w=r;switch(d){case y.setup:h.length=0;return;case y.first:if(l==1){h.length=0;break}const T=V.setArraySize(h,m);if(w.bones==null){const x=w.vertices;for(let R=0;R<m;R++)T[R]+=(x[R]-T[R])*l}else{l=1-l;for(let x=0;x<m;x++)T[x]*=l}}return}const f=V.setArraySize(h,m);if(a>=c[c.length-1]){const w=u[c.length-1];if(l==1)if(d==y.add){const T=r;if(T.bones==null){const x=T.vertices;for(let R=0;R<m;R++)f[R]+=w[R]-x[R]}else for(let x=0;x<m;x++)f[x]+=w[x]}else V.arrayCopy(w,0,f,0,m);else switch(d){case y.setup:{const x=r;if(x.bones==null){const R=x.vertices;for(let S=0;S<m;S++){const I=R[S];f[S]=I+(w[S]-I)*l}}else for(let R=0;R<m;R++)f[R]=w[R]*l;break}case y.first:case y.replace:for(let x=0;x<m;x++)f[x]+=(w[x]-f[x])*l;case y.add:const T=r;if(T.bones==null){const x=T.vertices;for(let R=0;R<m;R++)f[R]+=(w[R]-x[R])*l}else for(let x=0;x<m;x++)f[x]+=w[x]*l}return}const g=Z.binarySearch(c,a),E=u[g-1],p=u[g],b=c[g],M=this.getCurvePercent(g-1,1-(a-b)/(c[g-1]-b));if(l==1)if(d==y.add){const w=r;if(w.bones==null){const T=w.vertices;for(let x=0;x<m;x++){const R=E[x];f[x]+=R+(p[x]-R)*M-T[x]}}else for(let T=0;T<m;T++){const x=E[T];f[T]+=x+(p[T]-x)*M}}else for(let w=0;w<m;w++){const T=E[w];f[w]=T+(p[w]-T)*M}else switch(d){case y.setup:{const T=r;if(T.bones==null){const x=T.vertices;for(let R=0;R<m;R++){const S=E[R],I=x[R];f[R]=I+(S+(p[R]-S)*M-I)*l}}else for(let x=0;x<m;x++){const R=E[x];f[x]=(R+(p[x]-R)*M)*l}break}case y.first:case y.replace:for(let T=0;T<m;T++){const x=E[T];f[T]+=(x+(p[T]-x)*M-f[T])*l}break;case y.add:const w=r;if(w.bones==null){const T=w.vertices;for(let x=0;x<m;x++){const R=E[x];f[x]+=(R+(p[x]-R)*M-T[x])*l}}else for(let T=0;T<m;T++){const x=E[T];f[T]+=(x+(p[T]-x)*M)*l}}}}class Ee{constructor(t){this.frames=V.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,a,n,l,d,o){if(n==null)return;const s=this.frames,r=this.frames.length;if(e>a)this.apply(t,e,Number.MAX_VALUE,n,l,d,o),e=-1;else if(e>=s[r-1])return;if(a<s[0])return;let h=0;if(e<s[0])h=0;else{h=Z.binarySearch(s,e);const u=s[h];for(;h>0&&s[h-1]==u;)h--}for(;h<r&&a>=s[h];h++)n.push(this.events[h])}}class Bt{constructor(t){this.frames=V.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,a){this.frames[t]=e,this.drawOrders[t]=a}apply(t,e,a,n,l,d,o){const s=t.drawOrder,r=t.slots;if(o==rt.mixOut&&d==y.setup){V.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const h=this.frames;if(a<h[0]){(d==y.setup||d==y.first)&&V.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let u=0;a>=h[h.length-1]?u=h.length-1:u=Z.binarySearch(h,a)-1;const m=this.drawOrders[u];if(m==null)V.arrayCopy(r,0,s,0,r.length);else for(let c=0,f=m.length;c<f;c++)s[c]=r[m[c]]}}const L=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*L.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(i,t,e,a,n,l){i*=L.ENTRIES,this.frames[i]=t,this.frames[i+L.MIX]=e,this.frames[i+L.BEND_DIRECTION]=a,this.frames[i+L.COMPRESS]=n?1:0,this.frames[i+L.STRETCH]=l?1:0}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.ikConstraints[this.ikConstraintIndex];if(e<o[0]){switch(l){case y.setup:s.mix=s.data.mix,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case y.first:s.mix+=(s.data.mix-s.mix)*n,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}if(e>=o[o.length-L.ENTRIES]){l==y.setup?(s.mix=s.data.mix+(o[o.length+L.PREV_MIX]-s.data.mix)*n,d==rt.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=o[o.length+L.PREV_BEND_DIRECTION],s.compress=o[o.length+L.PREV_COMPRESS]!=0,s.stretch=o[o.length+L.PREV_STRETCH]!=0)):(s.mix+=(o[o.length+L.PREV_MIX]-s.mix)*n,d==rt.mixIn&&(s.bendDirection=o[o.length+L.PREV_BEND_DIRECTION],s.compress=o[o.length+L.PREV_COMPRESS]!=0,s.stretch=o[o.length+L.PREV_STRETCH]!=0));return}const r=Z.binarySearch(o,e,L.ENTRIES),h=o[r+L.PREV_MIX],u=o[r],m=this.getCurvePercent(r/L.ENTRIES-1,1-(e-u)/(o[r+L.PREV_TIME]-u));l==y.setup?(s.mix=s.data.mix+(h+(o[r+L.MIX]-h)*m-s.data.mix)*n,d==rt.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=o[r+L.PREV_BEND_DIRECTION],s.compress=o[r+L.PREV_COMPRESS]!=0,s.stretch=o[r+L.PREV_STRETCH]!=0)):(s.mix+=(h+(o[r+L.MIX]-h)*m-s.mix)*n,d==rt.mixIn&&(s.bendDirection=o[r+L.PREV_BEND_DIRECTION],s.compress=o[r+L.PREV_COMPRESS]!=0,s.stretch=o[r+L.PREV_STRETCH]!=0))}};let ct=L;ct.ENTRIES=5,ct.PREV_TIME=-5,ct.PREV_MIX=-4,ct.PREV_BEND_DIRECTION=-3,ct.PREV_COMPRESS=-2,ct.PREV_STRETCH=-1,ct.MIX=1,ct.BEND_DIRECTION=2,ct.COMPRESS=3,ct.STRETCH=4;const H=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*H.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(i,t,e,a,n,l){i*=H.ENTRIES,this.frames[i]=t,this.frames[i+H.ROTATE]=e,this.frames[i+H.TRANSLATE]=a,this.frames[i+H.SCALE]=n,this.frames[i+H.SHEAR]=l}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.transformConstraints[this.transformConstraintIndex];if(e<o[0]){const c=s.data;switch(l){case y.setup:s.rotateMix=c.rotateMix,s.translateMix=c.translateMix,s.scaleMix=c.scaleMix,s.shearMix=c.shearMix;return;case y.first:s.rotateMix+=(c.rotateMix-s.rotateMix)*n,s.translateMix+=(c.translateMix-s.translateMix)*n,s.scaleMix+=(c.scaleMix-s.scaleMix)*n,s.shearMix+=(c.shearMix-s.shearMix)*n}return}let r=0,h=0,u=0,m=0;if(e>=o[o.length-H.ENTRIES]){const c=o.length;r=o[c+H.PREV_ROTATE],h=o[c+H.PREV_TRANSLATE],u=o[c+H.PREV_SCALE],m=o[c+H.PREV_SHEAR]}else{const c=Z.binarySearch(o,e,H.ENTRIES);r=o[c+H.PREV_ROTATE],h=o[c+H.PREV_TRANSLATE],u=o[c+H.PREV_SCALE],m=o[c+H.PREV_SHEAR];const f=o[c],g=this.getCurvePercent(c/H.ENTRIES-1,1-(e-f)/(o[c+H.PREV_TIME]-f));r+=(o[c+H.ROTATE]-r)*g,h+=(o[c+H.TRANSLATE]-h)*g,u+=(o[c+H.SCALE]-u)*g,m+=(o[c+H.SHEAR]-m)*g}if(l==y.setup){const c=s.data;s.rotateMix=c.rotateMix+(r-c.rotateMix)*n,s.translateMix=c.translateMix+(h-c.translateMix)*n,s.scaleMix=c.scaleMix+(u-c.scaleMix)*n,s.shearMix=c.shearMix+(m-c.shearMix)*n}else s.rotateMix+=(r-s.rotateMix)*n,s.translateMix+=(h-s.translateMix)*n,s.scaleMix+=(u-s.scaleMix)*n,s.shearMix+=(m-s.shearMix)*n}};let dt=H;dt.ENTRIES=5,dt.PREV_TIME=-5,dt.PREV_ROTATE=-4,dt.PREV_TRANSLATE=-3,dt.PREV_SCALE=-2,dt.PREV_SHEAR=-1,dt.ROTATE=1,dt.TRANSLATE=2,dt.SCALE=3,dt.SHEAR=4;const gt=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*gt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(i,t,e){i*=gt.ENTRIES,this.frames[i]=t,this.frames[i+gt.VALUE]=e}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.pathConstraints[this.pathConstraintIndex];if(e<o[0]){switch(l){case y.setup:s.position=s.data.position;return;case y.first:s.position+=(s.data.position-s.position)*n}return}let r=0;if(e>=o[o.length-gt.ENTRIES])r=o[o.length+gt.PREV_VALUE];else{const h=Z.binarySearch(o,e,gt.ENTRIES);r=o[h+gt.PREV_VALUE];const u=o[h],m=this.getCurvePercent(h/gt.ENTRIES-1,1-(e-u)/(o[h+gt.PREV_TIME]-u));r+=(o[h+gt.VALUE]-r)*m}l==y.setup?s.position=s.data.position+(r-s.data.position)*n:s.position+=(r-s.position)*n}};let At=gt;At.ENTRIES=2,At.PREV_TIME=-2,At.PREV_VALUE=-1,At.VALUE=1;class wt extends At{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,a,n,l,d,o){const s=this.frames,r=t.pathConstraints[this.pathConstraintIndex];if(a<s[0]){switch(d){case y.setup:r.spacing=r.data.spacing;return;case y.first:r.spacing+=(r.data.spacing-r.spacing)*l}return}let h=0;if(a>=s[s.length-wt.ENTRIES])h=s[s.length+wt.PREV_VALUE];else{const u=Z.binarySearch(s,a,wt.ENTRIES);h=s[u+wt.PREV_VALUE];const m=s[u],c=this.getCurvePercent(u/wt.ENTRIES-1,1-(a-m)/(s[u+wt.PREV_TIME]-m));h+=(s[u+wt.VALUE]-h)*c}d==y.setup?r.spacing=r.data.spacing+(h-r.data.spacing)*l:r.spacing+=(h-r.spacing)*l}}const at=class extends ot{constructor(i){super(i),this.frames=V.newFloatArray(i*at.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(i,t,e,a){i*=at.ENTRIES,this.frames[i]=t,this.frames[i+at.ROTATE]=e,this.frames[i+at.TRANSLATE]=a}apply(i,t,e,a,n,l,d){const o=this.frames,s=i.pathConstraints[this.pathConstraintIndex];if(e<o[0]){switch(l){case y.setup:s.rotateMix=s.data.rotateMix,s.translateMix=s.data.translateMix;return;case y.first:s.rotateMix+=(s.data.rotateMix-s.rotateMix)*n,s.translateMix+=(s.data.translateMix-s.translateMix)*n}return}let r=0,h=0;if(e>=o[o.length-at.ENTRIES])r=o[o.length+at.PREV_ROTATE],h=o[o.length+at.PREV_TRANSLATE];else{const u=Z.binarySearch(o,e,at.ENTRIES);r=o[u+at.PREV_ROTATE],h=o[u+at.PREV_TRANSLATE];const m=o[u],c=this.getCurvePercent(u/at.ENTRIES-1,1-(e-m)/(o[u+at.PREV_TIME]-m));r+=(o[u+at.ROTATE]-r)*c,h+=(o[u+at.TRANSLATE]-h)*c}l==y.setup?(s.rotateMix=s.data.rotateMix+(r-s.data.rotateMix)*n,s.translateMix=s.data.translateMix+(h-s.data.translateMix)*n):(s.rotateMix+=(r-s.rotateMix)*n,s.translateMix+=(h-s.translateMix)*n)}};let Mt=at;Mt.ENTRIES=3,Mt.PREV_TIME=-3,Mt.PREV_ROTATE=-2,Mt.PREV_TRANSLATE=-1,Mt.ROTATE=1,Mt.TRANSLATE=2;const K=class{constructor(i){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new Qt(this),this.propertyIDs=new Pe,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new Ne(()=>new Wt),this.data=i}update(i){i*=this.timeScale;const t=this.tracks;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n==null)continue;n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast;let l=i*n.timeScale;if(n.delay>0){if(n.delay-=l,n.delay>0)continue;l=-n.delay,n.delay=0}let d=n.next;if(d!=null){const o=n.trackLast-d.delay;if(o>=0){for(d.delay=0,d.trackTime=n.timeScale==0?0:(o/n.timeScale+i)*d.timeScale,n.trackTime+=l,this.setCurrent(e,d,!0);d.mixingFrom!=null;)d.mixTime+=i,d=d.mixingFrom;continue}}else if(n.trackLast>=n.trackEnd&&n.mixingFrom==null){t[e]=null,this.queue.end(n),this.disposeNext(n);continue}if(n.mixingFrom!=null&&this.updateMixingFrom(n,i)){let o=n.mixingFrom;for(n.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}n.trackTime+=l}this.queue.drain()}updateMixingFrom(i,t){const e=i.mixingFrom;if(e==null)return!0;const a=this.updateMixingFrom(e,t);return e.animationLast=e.nextAnimationLast,e.trackLast=e.nextTrackLast,i.mixTime>0&&i.mixTime>=i.mixDuration?((e.totalAlpha==0||i.mixDuration==0)&&(i.mixingFrom=e.mixingFrom,e.mixingFrom!=null&&(e.mixingFrom.mixingTo=i),i.interruptAlpha=e.interruptAlpha,this.queue.end(e)),a):(e.trackTime+=t*e.timeScale,i.mixTime+=t,!1)}apply(i){if(i==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,e=this.tracks;let a=!1;for(let n=0,l=e.length;n<l;n++){const d=e[n];if(d==null||d.delay>0)continue;a=!0;const o=n==0?y.first:d.mixBlend;let s=d.alpha;d.mixingFrom!=null?s*=this.applyMixingFrom(d,i,o):d.trackTime>=d.trackEnd&&d.next==null&&(s=0);const r=d.animationLast,h=d.getAnimationTime(),u=d.animation.timelines.length,m=d.animation.timelines;if(n==0&&s==1||o==y.add)for(let c=0;c<u;c++)V.webkit602BugfixHelper(s,o),m[c].apply(i,r,h,t,s,o,rt.mixIn);else{const c=d.timelineMode,f=d.timelinesRotation.length==0;f&&V.setArraySize(d.timelinesRotation,u<<1,null);const g=d.timelinesRotation;for(let E=0;E<u;E++){const p=m[E],b=c[E]==K.SUBSEQUENT?o:y.setup;p instanceof nt?this.applyRotateTimeline(p,i,h,s,b,g,E<<1,f):(V.webkit602BugfixHelper(s,o),p.apply(i,r,h,t,s,b,rt.mixIn))}}this.queueEvents(d,h),t.length=0,d.nextAnimationLast=h,d.nextTrackLast=d.trackTime}return this.queue.drain(),a}applyMixingFrom(i,t,e){const a=i.mixingFrom;a.mixingFrom!=null&&this.applyMixingFrom(a,t,e);let n=0;i.mixDuration==0?(n=1,e==y.first&&(e=y.setup)):(n=i.mixTime/i.mixDuration,n>1&&(n=1),e!=y.first&&(e=a.mixBlend));const l=n<a.eventThreshold?this.events:null,d=n<a.attachmentThreshold,o=n<a.drawOrderThreshold,s=a.animationLast,r=a.getAnimationTime(),h=a.animation.timelines.length,u=a.animation.timelines,m=a.alpha*i.interruptAlpha,c=m*(1-n);if(e==y.add)for(let f=0;f<h;f++)u[f].apply(t,s,r,l,c,e,rt.mixOut);else{const f=a.timelineMode,g=a.timelineHoldMix,E=a.timelinesRotation.length==0;E&&V.setArraySize(a.timelinesRotation,h<<1,null);const p=a.timelinesRotation;a.totalAlpha=0;for(let b=0;b<h;b++){const M=u[b];let w=rt.mixOut,T,x=0;switch(f[b]){case K.SUBSEQUENT:if(!d&&M instanceof Lt||!o&&M instanceof Bt)continue;T=e,x=c;break;case K.FIRST:T=y.setup,x=c;break;case K.HOLD:T=y.setup,x=m;break;default:T=y.setup;const R=g[b];x=m*Math.max(0,1-R.mixTime/R.mixDuration);break}a.totalAlpha+=x,M instanceof nt?this.applyRotateTimeline(M,t,r,x,T,p,b<<1,E):(V.webkit602BugfixHelper(x,e),T==y.setup&&(M instanceof Lt?d&&(w=rt.mixOut):M instanceof Bt&&o&&(w=rt.mixOut)),M.apply(t,s,r,l,x,T,w))}}return i.mixDuration>0&&this.queueEvents(a,r),this.events.length=0,a.nextAnimationLast=r,a.nextTrackLast=a.trackTime,n}applyRotateTimeline(i,t,e,a,n,l,d,o){if(o&&(l[d]=0),a==1){i.apply(t,0,e,null,1,n,rt.mixIn);return}const s=i,r=s.frames,h=t.bones[s.boneIndex];let u=0,m=0;if(e<r[0])switch(n){case y.setup:h.rotation=h.data.rotation;default:return;case y.first:u=h.rotation,m=h.data.rotation}else if(u=n==y.setup?h.data.rotation:h.rotation,e>=r[r.length-nt.ENTRIES])m=h.data.rotation+r[r.length+nt.PREV_ROTATION];else{const g=Z.binarySearch(r,e,nt.ENTRIES),E=r[g+nt.PREV_ROTATION],p=r[g],b=s.getCurvePercent((g>>1)-1,1-(e-p)/(r[g+nt.PREV_TIME]-p));m=r[g+nt.ROTATION]-E,m-=(16384-(16384.499999999996-m/360|0))*360,m=E+m*b+h.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let c=0,f=m-u;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)c=l[d];else{let g=0,E=0;o?(g=0,E=f):(g=l[d],E=l[d+1]);const p=f>0;let b=g>=0;A.signum(E)!=A.signum(f)&&Math.abs(E)<=90&&(Math.abs(g)>180&&(g+=360*A.signum(g)),b=p),c=f+g-g%360,b!=p&&(c+=360*A.signum(g)),l[d]=c}l[d+1]=f,u+=c*a,h.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(i,t){const e=i.animationStart,a=i.animationEnd,n=a-e,l=i.trackLast%n,d=this.events;let o=0;const s=d.length;for(;o<s;o++){const h=d[o];if(h.time<l)break;h.time>a||this.queue.event(i,h)}let r=!1;for(i.loop?r=n==0||l>i.trackTime%n:r=t>=a&&i.animationLast<a,r&&this.queue.complete(i);o<s;o++)d[o].time<e||this.queue.event(i,d[o])}clearTracks(){const i=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=i,this.queue.drain()}clearTrack(i){if(i>=this.tracks.length)return;const t=this.tracks[i];if(t==null)return;this.queue.end(t),this.disposeNext(t);let e=t;for(;;){const a=e.mixingFrom;if(a==null)break;this.queue.end(a),e.mixingFrom=null,e.mixingTo=null,e=a}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(i,t,e){const a=this.expandToIndex(i);this.tracks[i]=t,a!=null&&(e&&this.queue.interrupt(a),t.mixingFrom=a,a.mixingTo=t,t.mixTime=0,a.mixingFrom!=null&&a.mixDuration>0&&(t.interruptAlpha*=Math.min(1,a.mixTime/a.mixDuration)),a.timelinesRotation.length=0),this.queue.start(t)}setAnimation(i,t,e){const a=this.data.skeletonData.findAnimation(t);if(a==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(i,a,e)}setAnimationWith(i,t,e){if(t==null)throw new Error("animation cannot be null.");let a=!0,n=this.expandToIndex(i);n!=null&&(n.nextTrackLast==-1?(this.tracks[i]=n.mixingFrom,this.queue.interrupt(n),this.queue.end(n),this.disposeNext(n),n=n.mixingFrom,a=!1):this.disposeNext(n));const l=this.trackEntry(i,t,e,n);return this.setCurrent(i,l,a),this.queue.drain(),l}addAnimation(i,t,e,a){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(i,n,e,a)}addAnimationWith(i,t,e,a){if(t==null)throw new Error("animation cannot be null.");let n=this.expandToIndex(i);if(n!=null)for(;n.next!=null;)n=n.next;const l=this.trackEntry(i,t,e,n);if(n==null)this.setCurrent(i,l,!0),this.queue.drain();else if(n.next=l,a<=0){const d=n.animationEnd-n.animationStart;d!=0?(n.loop?a+=d*(1+(n.trackTime/d|0)):a+=Math.max(d,n.trackTime),a-=this.data.getMix(n.animation,t)):a=n.trackTime}return l.delay=a,l}setEmptyAnimation(i,t){const e=this.setAnimationWith(i,K.emptyAnimation,!1);return e.mixDuration=t,e.trackEnd=t,e}addEmptyAnimation(i,t,e){e<=0&&(e-=t);const a=this.addAnimationWith(i,K.emptyAnimation,!1,e);return a.mixDuration=t,a.trackEnd=t,a}setEmptyAnimations(i){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,a=this.tracks.length;e<a;e++){const n=this.tracks[e];n!=null&&this.setEmptyAnimation(n.trackIndex,i)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(i){return i<this.tracks.length?this.tracks[i]:(V.ensureArrayCapacity(this.tracks,i-this.tracks.length+1,null),this.tracks.length=i+1,null)}trackEntry(i,t,e,a){const n=this.trackEntryPool.obtain();return n.trackIndex=i,n.animation=t,n.loop=e,n.holdPrevious=!1,n.eventThreshold=0,n.attachmentThreshold=0,n.drawOrderThreshold=0,n.animationStart=0,n.animationEnd=t.duration,n.animationLast=-1,n.nextAnimationLast=-1,n.delay=0,n.trackTime=0,n.trackLast=-1,n.nextTrackLast=-1,n.trackEnd=Number.MAX_VALUE,n.timeScale=1,n.alpha=1,n.interruptAlpha=1,n.mixTime=0,n.mixDuration=a==null?0:this.data.getMix(a.animation,t),n}disposeNext(i){let t=i.next;for(;t!=null;)this.queue.dispose(t),t=t.next;i.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let i=0,t=this.tracks.length;i<t;i++){let e=this.tracks[i];if(e!=null){for(;e.mixingFrom!=null;)e=e.mixingFrom;do(e.mixingFrom==null||e.mixBlend!=y.add)&&this.setTimelineModes(e),e=e.mixingTo;while(e!=null)}}}setTimelineModes(i){const t=i.mixingTo,e=i.animation.timelines,a=i.animation.timelines.length,n=V.setArraySize(i.timelineMode,a);i.timelineHoldMix.length=0;const l=V.setArraySize(i.timelineHoldMix,a),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<a;o++)d.add(e[o].getPropertyId()),n[o]=K.HOLD;return}t:for(let o=0;o<a;o++){const s=e[o].getPropertyId();if(!d.add(s))n[o]=K.SUBSEQUENT;else if(t==null||!this.hasTimeline(t,s))n[o]=K.FIRST;else{for(let r=t.mixingTo;r!=null;r=r.mixingTo)if(!this.hasTimeline(r,s)){if(i.mixDuration>0){n[o]=K.HOLD_MIX,l[o]=r;continue t}break}n[o]=K.HOLD}}}hasTimeline(i,t){const e=i.animation.timelines;for(let a=0,n=e.length;a<n;a++)if(e[a].getPropertyId()==t)return!0;return!1}getCurrent(i){return i>=this.tracks.length?null:this.tracks[i]}addListener(i){if(i==null)throw new Error("listener cannot be null.");this.listeners.push(i)}removeListener(i){const t=this.listeners.indexOf(i);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(i,t,e){K.deprecatedWarning1||(K.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(i,t,e)}addAnimationByName(i,t,e,a){K.deprecatedWarning2||(K.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(i,t,e,a)}hasAnimation(i){return this.data.skeletonData.findAnimation(i)!==null}hasAnimationByName(i){return K.deprecatedWarning3||(K.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(i)}};let Et=K;Et.emptyAnimation=new Z("<empty>",[],0),Et.SUBSEQUENT=0,Et.FIRST=1,Et.HOLD=2,Et.HOLD_MIX=3,Et.deprecatedWarning1=!1,Et.deprecatedWarning2=!1,Et.deprecatedWarning3=!1;const bt=class{constructor(){this.mixBlend=y.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const i=this.animationEnd-this.animationStart;return i==0?this.animationStart:this.trackTime%i+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(i){this.animationLast=i,this.nextAnimationLast=i}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return bt.deprecatedWarning1||(bt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(i){bt.deprecatedWarning1||(bt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=i}get endTime(){return bt.deprecatedWarning2||(bt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(i){bt.deprecatedWarning2||(bt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=i}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Wt=bt;Wt.deprecatedWarning1=!1,Wt.deprecatedWarning2=!1;const zt=class{constructor(i){this.objects=[],this.drainDisabled=!1,this.animState=i}start(i){this.objects.push(lt.start),this.objects.push(i),this.animState.animationsChanged=!0}interrupt(i){this.objects.push(lt.interrupt),this.objects.push(i)}end(i){this.objects.push(lt.end),this.objects.push(i),this.animState.animationsChanged=!0}dispose(i){this.objects.push(lt.dispose),this.objects.push(i)}complete(i){this.objects.push(lt.complete),this.objects.push(i)}event(i,t){this.objects.push(lt.event),this.objects.push(i),this.objects.push(t)}deprecateStuff(){return zt.deprecatedWarning1||(zt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const i=this.objects,t=this.animState.listeners;for(let e=0;e<i.length;e+=2){const a=i[e],n=i[e+1];switch(a){case lt.start:n.listener!=null&&n.listener.start&&n.listener.start(n);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(n);n.onStart&&this.deprecateStuff()&&n.onStart(n.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(n.trackIndex);break;case lt.interrupt:n.listener!=null&&n.listener.interrupt&&n.listener.interrupt(n);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(n);break;case lt.end:n.listener!=null&&n.listener.end&&n.listener.end(n);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(n);n.onEnd&&this.deprecateStuff()&&n.onEnd(n.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(n.trackIndex);case lt.dispose:n.listener!=null&&n.listener.dispose&&n.listener.dispose(n);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(n);this.animState.trackEntryPool.free(n);break;case lt.complete:n.listener!=null&&n.listener.complete&&n.listener.complete(n);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(n);const l=A.toInt(n.loopsCount());n.onComplete&&this.deprecateStuff()&&n.onComplete(n.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(n.trackIndex,l);break;case lt.event:const d=i[e+++2];n.listener!=null&&n.listener.event&&n.listener.event(n,d);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(n,d);n.onEvent&&this.deprecateStuff()&&n.onEvent(n.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(n.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Qt=zt;Qt.deprecatedWarning1=!1;var lt=(i=>(i[i.start=0]="start",i[i.interrupt=1]="interrupt",i[i.end=2]="end",i[i.dispose=3]="dispose",i[i.complete=4]="complete",i[i.event=5]="event",i))(lt||{});class Oe{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const Kt=class{constructor(i){if(this.animationToMixTime={},this.defaultMix=0,i==null)throw new Error("skeletonData cannot be null.");this.skeletonData=i}setMix(i,t,e){const a=this.skeletonData.findAnimation(i);if(a==null)throw new Error(`Animation not found: ${i}`);const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(a,n,e)}setMixByName(i,t,e){Kt.deprecatedWarning1||(Kt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(i,t,e)}setMixWith(i,t,e){if(i==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const a=`${i.name}.${t.name}`;this.animationToMixTime[a]=e}getMix(i,t){const e=`${i.name}.${t.name}`,a=this.animationToMixTime[e];return a===void 0?this.defaultMix:a}};let Jt=Kt;Jt.deprecatedWarning1=!1;class _e{constructor(t){this.atlas=t}newRegionAttachment(t,e,a){const n=this.atlas.findRegion(a);if(n==null)throw new Error(`Region not found in atlas: ${a} (region attachment: ${e})`);const l=new k(e);return l.region=n,l}newMeshAttachment(t,e,a){const n=this.atlas.findRegion(a);if(n==null)throw new Error(`Region not found in atlas: ${a} (mesh attachment: ${e})`);const l=new Gt(e);return l.region=n,l}newBoundingBoxAttachment(t,e){return new ce(e)}newPathAttachment(t,e){return new Dt(e)}newPointAttachment(t,e){return new ue(e)}newClippingAttachment(t,e){return new de(e)}}class te{constructor(t,e,a){if(this.matrix=new ve,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!0,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=a,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,a,n,l,d,o){this.ax=t,this.ay=e,this.arotation=a,this.ascaleX=n,this.ascaleY=l,this.ashearX=d,this.ashearY=o,this.appliedValid=!0;const s=this.parent,r=this.matrix,h=this.skeleton.scaleX,u=Ht.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(s==null){const E=this.skeleton,p=a+90+o;r.a=A.cosDeg(a+d)*n*h,r.c=A.cosDeg(p)*l*h,r.b=A.sinDeg(a+d)*n*u,r.d=A.sinDeg(p)*l*u,r.tx=t*h+E.x,r.ty=e*u+E.y;return}let m=s.matrix.a,c=s.matrix.c,f=s.matrix.b,g=s.matrix.d;switch(r.tx=m*t+c*e+s.matrix.tx,r.ty=f*t+g*e+s.matrix.ty,this.data.transformMode){case ft.Normal:{const E=a+90+o,p=A.cosDeg(a+d)*n,b=A.cosDeg(E)*l,M=A.sinDeg(a+d)*n,w=A.sinDeg(E)*l;r.a=m*p+c*M,r.c=m*b+c*w,r.b=f*p+g*M,r.d=f*b+g*w;return}case ft.OnlyTranslation:{const E=a+90+o;r.a=A.cosDeg(a+d)*n,r.c=A.cosDeg(E)*l,r.b=A.sinDeg(a+d)*n,r.d=A.sinDeg(E)*l;break}case ft.NoRotationOrReflection:{let E=m*m+f*f,p=0;E>1e-4?(E=Math.abs(m*g-c*f)/E,c=f*E,g=m*E,p=Math.atan2(f,m)*A.radDeg):(m=0,f=0,p=90-Math.atan2(g,c)*A.radDeg);const b=a+d-p,M=a+o-p+90,w=A.cosDeg(b)*n,T=A.cosDeg(M)*l,x=A.sinDeg(b)*n,R=A.sinDeg(M)*l;r.a=m*w-c*x,r.c=m*T-c*R,r.b=f*w+g*x,r.d=f*T+g*R;break}case ft.NoScale:case ft.NoScaleOrReflection:{const E=A.cosDeg(a),p=A.sinDeg(a);let b=(m*E+c*p)/h,M=(f*E+g*p)/u,w=Math.sqrt(b*b+M*M);w>1e-5&&(w=1/w),b*=w,M*=w,w=Math.sqrt(b*b+M*M),this.data.transformMode==ft.NoScale&&m*g-c*f<0!=(Ht.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(w=-w);const T=Math.PI/2+Math.atan2(M,b),x=Math.cos(T)*w,R=Math.sin(T)*w,S=A.cosDeg(d)*n,I=A.cosDeg(90+o)*l,X=A.sinDeg(d)*n,N=A.sinDeg(90+o)*l;r.a=b*S+x*X,r.c=b*I+x*N,r.b=M*S+R*X,r.d=M*I+R*N;break}}r.a*=h,r.c*=h,r.b*=u,r.d*=u}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*A.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*A.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*A.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*A.radDeg;return}const a=t.matrix,n=1/(a.a*a.d-a.b*a.c),l=e.tx-a.tx,d=e.ty-a.ty;this.ax=l*a.d*n-d*a.c*n,this.ay=d*a.a*n-l*a.b*n;const o=n*a.d,s=n*a.a,r=n*a.c,h=n*a.b,u=o*e.a-r*e.b,m=o*e.c-r*e.d,c=s*e.b-h*e.a,f=s*e.d-h*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(u*u+c*c),this.ascaleX>1e-4){const g=u*f-m*c;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(u*m+c*f,g)*A.radDeg,this.arotation=Math.atan2(c,u)*A.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,m)*A.radDeg}worldToLocal(t){const e=this.matrix,a=e.a,n=e.c,l=e.b,d=e.d,o=1/(a*d-n*l),s=t.x-e.tx,r=t.y-e.ty;return t.x=s*d*o-r*n*o,t.y=r*a*o-s*l*o,t}localToWorld(t){const e=this.matrix,a=t.x,n=t.y;return t.x=a*e.a+n*e.c+e.tx,t.y=a*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=A.sinDeg(t),a=A.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*a,n.d*a-n.c*e)*A.radDeg}localToWorldRotation(t){const e=A.sinDeg(t),a=A.cosDeg(t),n=this.matrix;return Math.atan2(a*n.b+e*n.d,a*n.a+e*n.c)*A.radDeg}rotateWorld(t){const e=this.matrix,a=e.a,n=e.c,l=e.b,d=e.d,o=A.cosDeg(t),s=A.sinDeg(t);e.a=o*a-s*l,e.c=o*n-s*d,e.b=s*a+o*l,e.d=s*n+o*d,this.appliedValid=!1}}class we{constructor(t,e,a){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=ft.Normal,t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=a}}class Me{constructor(t,e){if(e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}}class be{constructor(t){this.name=t}}class Re{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let a=0;a<t.bones.length;a++)this.bones.push(e.findBone(t.bones[a].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix);break}}apply1(t,e,a,n,l,d,o){t.appliedValid||t.updateAppliedTransform();const s=t.parent.matrix,r=1/(s.a*s.d-s.b*s.c),h=e-s.tx,u=a-s.ty,m=(h*s.d-u*s.c)*r-t.ax,c=(u*s.a-h*s.b)*r-t.ay;let f=Math.atan2(c,m)*A.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(f+=180),f>180?f-=360:f<-180&&(f+=360);let g=t.ascaleX,E=t.ascaleY;if(n||l){const p=t.data.length*g,b=Math.sqrt(m*m+c*c);if(n&&b<p||l&&b>p&&p>1e-4){const M=(b/p-1)*o+1;g*=M,d&&(E*=M)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+f*o,g,E,t.ashearX,t.ashearY)}apply2(t,e,a,n,l,d,o){if(o==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const s=t.ax,r=t.ay;let h=t.ascaleX,u=h,m=t.ascaleY,c=e.ascaleX;const f=t.matrix;let g=0,E=0,p=0;h<0?(h=-h,g=180,p=-1):(g=0,p=1),m<0&&(m=-m,p=-p),c<0?(c=-c,E=180):E=0;const b=e.ax;let M=0,w=0,T=0,x=f.a,R=f.c,S=f.b,I=f.d;const X=Math.abs(h-m)<=1e-4;X?(M=e.ay,w=x*b+R*M+f.tx,T=S*b+I*M+f.ty):(M=0,w=x*b+f.tx,T=S*b+f.ty);const N=t.parent.matrix;x=N.a,R=N.c,S=N.b,I=N.d;const W=1/(x*I-R*S);let B=a-N.tx,C=n-N.ty;const Y=(B*I-C*R)*W-s,Q=(C*x-B*S)*W-r,G=Y*Y+Q*Q;B=w-N.tx,C=T-N.ty;const F=(B*I-C*R)*W-s,_=(C*x-B*S)*W-r,P=Math.sqrt(F*F+_*_);let q=e.data.length*c,$=0,O=0;t:if(X){q*=h;let it=(G-P*P-q*q)/(2*P*q);it<-1?it=-1:it>1&&(it=1,d&&P+q>1e-4&&(u*=(Math.sqrt(G)/(P+q)-1)*o+1)),O=Math.acos(it)*l,x=P+q*it,R=q*Math.sin(O),$=Math.atan2(Q*x-Y*R,Y*x+Q*R)}else{x=h*q,R=m*q;const it=x*x,Nt=R*R,qt=Math.atan2(Q,Y);S=Nt*P*P+it*G-it*Nt;const vt=-2*Nt*P,ne=Nt-it;if(I=vt*vt-4*ne*S,I>=0){let It=Math.sqrt(I);vt<0&&(It=-It),It=-(vt+It)/2;const oe=It/ne,le=S/It,Vt=Math.abs(oe)<Math.abs(le)?oe:le;if(Vt*Vt<=G){C=Math.sqrt(G-Vt*Vt)*l,$=qt-Math.atan2(C,Vt),O=Math.atan2(C/m,(Vt-P)/h);break t}}let se=A.PI,Ft=P-x,$t=Ft*Ft,ae=0,ie=0,Ot=P+x,Ut=Ot*Ot,re=0;S=-x*P/(it-Nt),S>=-1&&S<=1&&(S=Math.acos(S),B=x*Math.cos(S)+P,C=R*Math.sin(S),I=B*B+C*C,I<$t&&(se=S,$t=I,Ft=B,ae=C),I>Ut&&(ie=S,Ut=I,Ot=B,re=C)),G<=($t+Ut)/2?($=qt-Math.atan2(ae*l,Ft),O=se*l):($=qt-Math.atan2(re*l,Ot),O=ie*l)}const D=Math.atan2(M,b)*p;let et=t.arotation;$=($-D)*A.radDeg+g-et,$>180?$-=360:$<-180&&($+=360),t.updateWorldTransformWith(s,r,et+$*o,u,t.ascaleY,0,0),et=e.arotation,O=((O+D)*A.radDeg-e.ashearX)*p+E-et,O>180?O-=360:O<-180&&(O+=360),e.updateWorldTransformWith(b,M,et+O*o,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class Te{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}}class Ae{constructor(t){this.order=0,this.bones=new Array,this.name=t}}var xt=(i=>(i[i.Length=0]="Length",i[i.Fixed=1]="Fixed",i[i.Percent=2]="Percent",i))(xt||{});const yt=class{constructor(i,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,i==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=i,this.bones=new Array;for(let e=0,a=i.bones.length;e<a;e++)this.bones.push(t.findBone(i.bones[e].name));this.target=t.findSlot(i.target.name),this.position=i.position,this.spacing=i.spacing,this.rotateMix=i.rotateMix,this.translateMix=i.translateMix}apply(){this.update()}update(){const i=this.target.getAttachment();if(!(i instanceof Dt))return;const t=this.rotateMix,e=this.translateMix,a=e>0,n=t>0;if(!a&&!n)return;const l=this.data,d=l.spacingMode,o=d==xt.Length,s=l.rotateMode,r=s==kt.Tangent,h=s==kt.ChainScale,u=this.bones.length,m=r?u:u+1,c=this.bones,f=V.setArraySize(this.spaces,m);let g=null;const E=this.spacing;if(h||o){h&&(g=V.setArraySize(this.lengths,u));for(let x=0,R=m-1;x<R;){const S=c[x],I=S.data.length;if(I<yt.epsilon)h&&(g[x]=0),f[++x]=0;else{const X=I*S.matrix.a,N=I*S.matrix.b,W=Math.sqrt(X*X+N*N);h&&(g[x]=W),f[++x]=(o?I+E:E)*W/I}}}else for(let x=1;x<m;x++)f[x]=E;const p=this.computeWorldPositions(i,m,r,l.positionMode==Yt.Percent,d==xt.Percent);let b=p[0],M=p[1],w=l.offsetRotation,T=!1;if(w==0)T=s==kt.Chain;else{T=!1;const x=this.target.bone.matrix;w*=x.a*x.d-x.b*x.c>0?A.degRad:-A.degRad}for(let x=0,R=3;x<u;x++,R+=3){const S=c[x],I=S.matrix;I.tx+=(b-I.tx)*e,I.ty+=(M-I.ty)*e;const X=p[R],N=p[R+1],W=X-b,B=N-M;if(h){const C=g[x];if(C!=0){const Y=(Math.sqrt(W*W+B*B)/C-1)*t+1;I.a*=Y,I.b*=Y}}if(b=X,M=N,n){const C=I.a,Y=I.c,Q=I.b,G=I.d;let F=0,_=0,P=0;if(r&&(r?F=p[R-1]:f[x+1]==0?F=p[R+2]:F=Math.atan2(B,W)),F-=Math.atan2(Q,C),T){_=Math.cos(F),P=Math.sin(F);const q=S.data.length;b+=(q*(_*C-P*Q)-W)*t,M+=(q*(P*C+_*Q)-B)*t}else F+=w;F>A.PI?F-=A.PI2:F<-A.PI&&(F+=A.PI2),F*=t,_=Math.cos(F),P=Math.sin(F),I.a=_*C-P*Q,I.c=_*Y-P*G,I.b=P*C+_*Q,I.d=P*Y+_*G}S.appliedValid=!1}}computeWorldPositions(i,t,e,a,n){const l=this.target;let d=this.position;const o=this.spaces,s=V.setArraySize(this.positions,t*3+2);let r=null;const h=i.closed;let u=i.worldVerticesLength,m=u/6,c=yt.NONE;if(!i.constantSpeed){const F=i.lengths;m-=h?1:2;const _=F[m];if(a&&(d*=_),n)for(let P=0;P<t;P++)o[P]*=_;r=V.setArraySize(this.world,8);for(let P=0,q=0,$=0;P<t;P++,q+=3){const O=o[P];d+=O;let D=d;if(h)D%=_,D<0&&(D+=_),$=0;else if(D<0){c!=yt.BEFORE&&(c=yt.BEFORE,i.computeWorldVertices(l,2,4,r,0,2)),this.addBeforePosition(D,r,0,s,q);continue}else if(D>_){c!=yt.AFTER&&(c=yt.AFTER,i.computeWorldVertices(l,u-6,4,r,0,2)),this.addAfterPosition(D-_,r,0,s,q);continue}for(;;$++){const et=F[$];if(!(D>et)){if($==0)D/=et;else{const it=F[$-1];D=(D-it)/(et-it)}break}}$!=c&&(c=$,h&&$==m?(i.computeWorldVertices(l,u-4,4,r,0,2),i.computeWorldVertices(l,0,4,r,4,2)):i.computeWorldVertices(l,$*6+2,8,r,0,2)),this.addCurvePosition(D,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],s,q,e||P>0&&O==0)}return s}h?(u+=2,r=V.setArraySize(this.world,u),i.computeWorldVertices(l,2,u-4,r,0,2),i.computeWorldVertices(l,0,2,r,u-4,2),r[u-2]=r[0],r[u-1]=r[1]):(m--,u-=4,r=V.setArraySize(this.world,u),i.computeWorldVertices(l,2,u,r,0,2));const f=V.setArraySize(this.curves,m);let g=0,E=r[0],p=r[1],b=0,M=0,w=0,T=0,x=0,R=0,S=0,I=0,X=0,N=0,W=0,B=0,C=0,Y=0;for(let F=0,_=2;F<m;F++,_+=6)b=r[_],M=r[_+1],w=r[_+2],T=r[_+3],x=r[_+4],R=r[_+5],S=(E-b*2+w)*.1875,I=(p-M*2+T)*.1875,X=((b-w)*3-E+x)*.09375,N=((M-T)*3-p+R)*.09375,W=S*2+X,B=I*2+N,C=(b-E)*.75+S+X*.16666667,Y=(M-p)*.75+I+N*.16666667,g+=Math.sqrt(C*C+Y*Y),C+=W,Y+=B,W+=X,B+=N,g+=Math.sqrt(C*C+Y*Y),C+=W,Y+=B,g+=Math.sqrt(C*C+Y*Y),C+=W+X,Y+=B+N,g+=Math.sqrt(C*C+Y*Y),f[F]=g,E=x,p=R;if(a&&(d*=g),n)for(let F=0;F<t;F++)o[F]*=g;const Q=this.segments;let G=0;for(let F=0,_=0,P=0,q=0;F<t;F++,_+=3){const $=o[F];d+=$;let O=d;if(h)O%=g,O<0&&(O+=g),P=0;else if(O<0){this.addBeforePosition(O,r,0,s,_);continue}else if(O>g){this.addAfterPosition(O-g,r,u-4,s,_);continue}for(;;P++){const D=f[P];if(!(O>D)){if(P==0)O/=D;else{const et=f[P-1];O=(O-et)/(D-et)}break}}if(P!=c){c=P;let D=P*6;for(E=r[D],p=r[D+1],b=r[D+2],M=r[D+3],w=r[D+4],T=r[D+5],x=r[D+6],R=r[D+7],S=(E-b*2+w)*.03,I=(p-M*2+T)*.03,X=((b-w)*3-E+x)*.006,N=((M-T)*3-p+R)*.006,W=S*2+X,B=I*2+N,C=(b-E)*.3+S+X*.16666667,Y=(M-p)*.3+I+N*.16666667,G=Math.sqrt(C*C+Y*Y),Q[0]=G,D=1;D<8;D++)C+=W,Y+=B,W+=X,B+=N,G+=Math.sqrt(C*C+Y*Y),Q[D]=G;C+=W,Y+=B,G+=Math.sqrt(C*C+Y*Y),Q[8]=G,C+=W+X,Y+=B+N,G+=Math.sqrt(C*C+Y*Y),Q[9]=G,q=0}for(O*=G;;q++){const D=Q[q];if(!(O>D)){if(q==0)O/=D;else{const et=Q[q-1];O=q+(O-et)/(D-et)}break}}this.addCurvePosition(O*.1,E,p,b,M,w,T,x,R,s,_,e||F>0&&$==0)}return s}addBeforePosition(i,t,e,a,n){const l=t[e],d=t[e+1],o=t[e+2]-l,s=t[e+3]-d,r=Math.atan2(s,o);a[n]=l+i*Math.cos(r),a[n+1]=d+i*Math.sin(r),a[n+2]=r}addAfterPosition(i,t,e,a,n){const l=t[e+2],d=t[e+3],o=l-t[e],s=d-t[e+1],r=Math.atan2(s,o);a[n]=l+i*Math.cos(r),a[n+1]=d+i*Math.sin(r),a[n+2]=r}addCurvePosition(i,t,e,a,n,l,d,o,s,r,h,u){(i==0||isNaN(i))&&(i=1e-4);const m=i*i,c=m*i,f=1-i,g=f*f,E=g*f,p=f*i,b=p*3,M=f*b,w=b*i,T=t*E+a*M+l*w+o*c,x=e*E+n*M+d*w+s*c;r[h]=T,r[h+1]=x,u&&(r[h+2]=Math.atan2(x-(e*g+n*p*2+d*m),T-(t*g+a*p*2+l*m)))}getOrder(){return this.data.order}};let Pt=yt;Pt.NONE=-1,Pt.BEFORE=-2,Pt.AFTER=-3,Pt.epsilon=1e-5;class ye{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new Ye,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let a=0;a<t.bones.length;a++)this.bones.push(e.findBone(t.bones[a].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,a=this.scaleMix,n=this.shearMix,l=this.target,d=l.matrix,o=d.a,s=d.c,r=d.b,h=d.d,u=o*h-s*r>0?A.degRad:-A.degRad,m=this.data.offsetRotation*u,c=this.data.offsetShearY*u,f=this.bones;for(let g=0,E=f.length;g<E;g++){const p=f[g];let b=!1;const M=p.matrix;if(t!=0){const w=M.a,T=M.c,x=M.b,R=M.d;let S=Math.atan2(r,o)-Math.atan2(x,w)+m;S>A.PI?S-=A.PI2:S<-A.PI&&(S+=A.PI2),S*=t;const I=Math.cos(S),X=Math.sin(S);M.a=I*w-X*x,M.c=I*T-X*R,M.b=X*w+I*x,M.d=X*T+I*R,b=!0}if(e!=0){const w=this.temp;l.localToWorld(w.set(this.data.offsetX,this.data.offsetY)),M.tx+=(w.x-M.tx)*e,M.ty+=(w.y-M.ty)*e,b=!0}if(a>0){let w=Math.sqrt(M.a*M.a+M.b*M.b),T=Math.sqrt(o*o+r*r);w>1e-5&&(w=(w+(T-w+this.data.offsetScaleX)*a)/w),M.a*=w,M.b*=w,w=Math.sqrt(M.c*M.c+M.d*M.d),T=Math.sqrt(s*s+h*h),w>1e-5&&(w=(w+(T-w+this.data.offsetScaleY)*a)/w),M.c*=w,M.d*=w,b=!0}if(n>0){const w=M.c,T=M.d,x=Math.atan2(T,w);let R=Math.atan2(h,s)-Math.atan2(r,o)-(x-Math.atan2(M.b,M.a));R>A.PI?R-=A.PI2:R<-A.PI&&(R+=A.PI2),R=x+(R+c)*n;const S=Math.sqrt(w*w+T*T);M.c=Math.cos(R)*S,M.d=Math.sin(R)*S,b=!0}b&&(p.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,a=this.scaleMix,n=this.shearMix,l=this.target,d=l.matrix,o=d.a,s=d.c,r=d.b,h=d.d,u=o*h-s*r>0?A.degRad:-A.degRad,m=this.data.offsetRotation*u,c=this.data.offsetShearY*u,f=this.bones;for(let g=0,E=f.length;g<E;g++){const p=f[g];let b=!1;const M=p.matrix;if(t!=0){const w=M.a,T=M.c,x=M.b,R=M.d;let S=Math.atan2(r,o)+m;S>A.PI?S-=A.PI2:S<-A.PI&&(S+=A.PI2),S*=t;const I=Math.cos(S),X=Math.sin(S);M.a=I*w-X*x,M.c=I*T-X*R,M.b=X*w+I*x,M.d=X*T+I*R,b=!0}if(e!=0){const w=this.temp;l.localToWorld(w.set(this.data.offsetX,this.data.offsetY)),M.tx+=w.x*e,M.ty+=w.y*e,b=!0}if(a>0){let w=(Math.sqrt(o*o+r*r)-1+this.data.offsetScaleX)*a+1;M.a*=w,M.b*=w,w=(Math.sqrt(s*s+h*h)-1+this.data.offsetScaleY)*a+1,M.c*=w,M.d*=w,b=!0}if(n>0){let w=Math.atan2(h,s)-Math.atan2(r,o);w>A.PI?w-=A.PI2:w<-A.PI&&(w+=A.PI2);const T=M.c,x=M.d;w=Math.atan2(x,T)+(w-A.PI/2+c)*n;const R=Math.sqrt(T*T+x*x);M.c=Math.cos(w)*R,M.d=Math.sin(w)*R,b=!0}b&&(p.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,a=this.scaleMix,n=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const d=this.bones;for(let o=0,s=d.length;o<s;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;if(t!=0){let E=l.arotation-h+this.data.offsetRotation;E-=(16384-(16384.499999999996-E/360|0))*360,h+=E*t}let u=r.ax,m=r.ay;e!=0&&(u+=(l.ax-u+this.data.offsetX)*e,m+=(l.ay-m+this.data.offsetY)*e);let c=r.ascaleX,f=r.ascaleY;a>0&&(c>1e-5&&(c=(c+(l.ascaleX-c+this.data.offsetScaleX)*a)/c),f>1e-5&&(f=(f+(l.ascaleY-f+this.data.offsetScaleY)*a)/f));const g=r.ashearY;if(n>0){let E=l.ashearY-g+this.data.offsetShearY;E-=(16384-(16384.499999999996-E/360|0))*360,r.shearY+=E*n}r.updateWorldTransformWith(u,m,h,c,f,r.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,a=this.scaleMix,n=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const d=this.bones;for(let o=0,s=d.length;o<s;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;t!=0&&(h+=(l.arotation+this.data.offsetRotation)*t);let u=r.ax,m=r.ay;e!=0&&(u+=(l.ax+this.data.offsetX)*e,m+=(l.ay+this.data.offsetY)*e);let c=r.ascaleX,f=r.ascaleY;a>0&&(c>1e-5&&(c*=(l.ascaleX-1+this.data.offsetScaleX)*a+1),f>1e-5&&(f*=(l.ascaleY-1+this.data.offsetScaleY)*a+1));let g=r.ashearY;n>0&&(g+=(l.ashearY+this.data.offsetShearY)*n),r.updateWorldTransformWith(u,m,h,c,f,r.ashearX,g)}}getOrder(){return this.data.order}}const Xt=class{constructor(i){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,i==null)throw new Error("data cannot be null.");this.data=i,this.bones=new Array;for(let t=0;t<i.bones.length;t++){const e=i.bones[t];let a;if(e.parent==null)a=new te(e,this,null);else{const n=this.bones[e.parent.index];a=new te(e,this,n),n.children.push(a)}this.bones.push(a)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<i.slots.length;t++){const e=i.slots[t],a=this.bones[e.boneData.index],n=new Zt(e,a);this.slots.push(n),this.drawOrder.push(n)}this.ikConstraints=new Array;for(let t=0;t<i.ikConstraints.length;t++){const e=i.ikConstraints[t];this.ikConstraints.push(new Re(e,this))}this.transformConstraints=new Array;for(let t=0;t<i.transformConstraints.length;t++){const e=i.transformConstraints[t];this.transformConstraints.push(new ye(e,this))}this.pathConstraints=new Array;for(let t=0;t<i.pathConstraints.length;t++){const e=i.pathConstraints[t];this.pathConstraints.push(new Pt(e,this))}this.color=new tt(1,1,1,1),this.updateCache()}updateCache(){const i=this._updateCache;i.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let r=0,h=t.length;r<h;r++)t[r].sorted=!1;const e=this.ikConstraints,a=this.transformConstraints,n=this.pathConstraints,l=e.length,d=a.length,o=n.length,s=l+d+o;t:for(let r=0;r<s;r++){for(let h=0;h<l;h++){const u=e[h];if(u.data.order==r){this.sortIkConstraint(u);continue t}}for(let h=0;h<d;h++){const u=a[h];if(u.data.order==r){this.sortTransformConstraint(u);continue t}}for(let h=0;h<o;h++){const u=n[h];if(u.data.order==r){this.sortPathConstraint(u);continue t}}}for(let r=0,h=t.length;r<h;r++)this.sortBone(t[r])}sortIkConstraint(i){const t=i.target;this.sortBone(t);const e=i.bones,a=e[0];if(this.sortBone(a),e.length>1){const n=e[e.length-1];this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}this._updateCache.push(i),this.sortReset(a.children),e[e.length-1].sorted=!0}sortPathConstraint(i){const t=i.target,e=t.data.index,a=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,e,a),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,a);for(let o=0,s=this.data.skins.length;o<s;o++)this.sortPathConstraintAttachment(this.data.skins[o],e,a);const n=t.getAttachment();n instanceof Dt&&this.sortPathConstraintAttachmentWith(n,a);const l=i.bones,d=l.length;for(let o=0;o<d;o++)this.sortBone(l[o]);this._updateCache.push(i);for(let o=0;o<d;o++)this.sortReset(l[o].children);for(let o=0;o<d;o++)l[o].sorted=!0}sortTransformConstraint(i){this.sortBone(i.target);const t=i.bones,e=t.length;if(i.data.local)for(let a=0;a<e;a++){const n=t[a];this.sortBone(n.parent),this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}else for(let a=0;a<e;a++)this.sortBone(t[a]);this._updateCache.push(i);for(let a=0;a<e;a++)this.sortReset(t[a].children);for(let a=0;a<e;a++)t[a].sorted=!0}sortPathConstraintAttachment(i,t,e){const a=i.attachments[t];if(a)for(const n in a)this.sortPathConstraintAttachmentWith(a[n],e)}sortPathConstraintAttachmentWith(i,t){if(!(i instanceof Dt))return;const e=i.bones;if(e==null)this.sortBone(t);else{const a=this.bones;let n=0;for(;n<e.length;){const l=e[n++];for(let d=n+l;n<d;n++){const o=e[n];this.sortBone(a[o])}}}}sortBone(i){if(i.sorted)return;const t=i.parent;t!=null&&this.sortBone(t),i.sorted=!0,this._updateCache.push(i)}sortReset(i){for(let t=0,e=i.length;t<e;t++){const a=i[t];a.sorted&&this.sortReset(a.children),a.sorted=!1}}updateWorldTransform(){const i=this.updateCacheReset;for(let e=0,a=i.length;e<a;e++){const n=i[e];n.ax=n.x,n.ay=n.y,n.arotation=n.rotation,n.ascaleX=n.scaleX,n.ascaleY=n.scaleY,n.ashearX=n.shearX,n.ashearY=n.shearY,n.appliedValid=!0}const t=this._updateCache;for(let e=0,a=t.length;e<a;e++)t[e].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const i=this.bones;for(let n=0,l=i.length;n<l;n++)i[n].setToSetupPose();const t=this.ikConstraints;for(let n=0,l=t.length;n<l;n++){const d=t[n];d.bendDirection=d.data.bendDirection,d.mix=d.data.mix}const e=this.transformConstraints;for(let n=0,l=e.length;n<l;n++){const d=e[n],o=d.data;d.rotateMix=o.rotateMix,d.translateMix=o.translateMix,d.scaleMix=o.scaleMix,d.shearMix=o.shearMix}const a=this.pathConstraints;for(let n=0,l=a.length;n<l;n++){const d=a[n],o=d.data;d.position=o.position,d.spacing=o.spacing,d.rotateMix=o.rotateMix,d.translateMix=o.translateMix}}setSlotsToSetupPose(){const i=this.slots;V.arrayCopy(i,0,this.drawOrder,0,i.length);for(let t=0,e=i.length;t<e;t++)i[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(i){if(i==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n.data.name==i)return n}return null}findBoneIndex(i){if(i==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let e=0,a=t.length;e<a;e++)if(t[e].data.name==i)return e;return-1}findSlot(i){if(i==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n.data.name==i)return n}return null}findSlotIndex(i){if(i==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let e=0,a=t.length;e<a;e++)if(t[e].data.name==i)return e;return-1}setSkinByName(i){const t=this.data.findSkin(i);if(t==null)throw new Error(`Skin not found: ${i}`);this.setSkin(t)}setSkin(i){if(i!=null)if(this.skin!=null)i.attachAll(this,this.skin);else{const t=this.slots;for(let e=0,a=t.length;e<a;e++){const n=t[e],l=n.data.attachmentName;if(l!=null){const d=i.getAttachment(e,l);d!=null&&n.setAttachment(d)}}}this.skin=i}getAttachmentByName(i,t){return this.getAttachment(this.data.findSlotIndex(i),t)}getAttachment(i,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const e=this.skin.getAttachment(i,t);if(e!=null)return e}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(i,t):null}setAttachment(i,t){if(i==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.data.name==i){let d=null;if(t!=null&&(d=this.getAttachment(a,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${i}`);l.setAttachment(d);return}}throw new Error(`Slot not found: ${i}`)}findIkConstraint(i){if(i==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n.data.name==i)return n}return null}findTransformConstraint(i){if(i==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n.data.name==i)return n}return null}findPathConstraint(i){if(i==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let e=0,a=t.length;e<a;e++){const n=t[e];if(n.data.name==i)return n}return null}getBounds(i,t,e){if(i==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const a=this.drawOrder;let n=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let s=0,r=a.length;s<r;s++){const h=a[s];let u=0,m=null;const c=h.getAttachment();if(c instanceof k)u=8,m=V.setArraySize(e,u,0),c.computeWorldVertices(h.bone,m,0,2);else if(c instanceof Gt){const f=c;u=f.worldVerticesLength,m=V.setArraySize(e,u,0),f.computeWorldVertices(h,0,u,m,0,2)}if(m!=null)for(let f=0,g=m.length;f<g;f+=2){const E=m[f],p=m[f+1];n=Math.min(n,E),l=Math.min(l,p),d=Math.max(d,E),o=Math.max(o,p)}}i.set(n,l),t.set(d-n,o-l)}update(i){this.time+=i}get flipX(){return this.scaleX==-1}set flipX(i){Xt.deprecatedWarning1||(Xt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=i?1:-1}get flipY(){return this.scaleY==-1}set flipY(i){Xt.deprecatedWarning1||(Xt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=i?1:-1}};let ee=Xt;ee.deprecatedWarning1=!1;class Le extends De{}class Se{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let a=0,n=e.length;a<n;a++)if(e[a].name==t)return a;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let a=0,n=e.length;a<n;a++)if(e[a].name==t)return a;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let a=0,n=e.length;a<n;a++){const l=e[a];if(l.name==t)return l}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let a=0,n=e.length;a<n;a++)if(e[a].name==t)return a;return-1}}class Ie{constructor(t,e,a){if(this.color=new tt(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(a==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=a}}class Ve{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,t==null)throw new Error("name cannot be null.");this.name=t}}class Ce{constructor(t){if(this.attachments=new Array,t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,a){if(a==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=a}getAttachment(t,e){const a=this.attachments[t];return a?a[e]:null}attachAll(t,e){let a=0;for(let n=0;n<t.slots.length;n++){const l=t.slots[n],d=l.getAttachment();if(d&&a<e.attachments.length){const o=e.attachments[a];for(const s in o){const r=o[s];if(d==r){const h=this.getAttachment(a,s);h!=null&&l.setAttachment(h);break}}}a++}}}class St{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,a=new Se,n=typeof t=="string"?JSON.parse(t):t,l=n.skeleton;if(l!=null&&(a.hash=l.hash,a.version=l.spine,a.width=l.width,a.height=l.height,a.fps=l.fps,a.imagesPath=l.images),n.bones)for(let d=0;d<n.bones.length;d++){const o=n.bones[d];let s=null;const r=this.getValue(o,"parent",null);if(r!=null&&(s=a.findBone(r),s==null))throw new Error(`Parent bone not found: ${r}`);const h=new we(a.bones.length,o.name,s);h.length=this.getValue(o,"length",0)*e,h.x=this.getValue(o,"x",0)*e,h.y=this.getValue(o,"y",0)*e,h.rotation=this.getValue(o,"rotation",0),h.scaleX=this.getValue(o,"scaleX",1),h.scaleY=this.getValue(o,"scaleY",1),h.shearX=this.getValue(o,"shearX",0),h.shearY=this.getValue(o,"shearY",0),h.transformMode=St.transformModeFromString(this.getValue(o,"transform","normal")),a.bones.push(h)}if(n.slots)for(let d=0;d<n.slots.length;d++){const o=n.slots[d],s=o.name,r=o.bone,h=a.findBone(r);if(h==null)throw new Error(`Slot bone not found: ${r}`);const u=new Ie(a.slots.length,s,h),m=this.getValue(o,"color",null);m!=null&&u.color.setFromString(m);const c=this.getValue(o,"dark",null);c!=null&&(u.darkColor=new tt(1,1,1,1),u.darkColor.setFromString(c)),u.attachmentName=this.getValue(o,"attachment",null),u.blendMode=St.blendModeFromString(this.getValue(o,"blend","normal")),a.slots.push(u)}if(n.ik)for(let d=0;d<n.ik.length;d++){const o=n.ik[d],s=new Te(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],m=a.findBone(u);if(m==null)throw new Error(`IK bone not found: ${u}`);s.bones.push(m)}const r=o.target;if(s.target=a.findBone(r),s.target==null)throw new Error(`IK target bone not found: ${r}`);s.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,s.mix=this.getValue(o,"mix",1),a.ikConstraints.push(s)}if(n.transform)for(let d=0;d<n.transform.length;d++){const o=n.transform[d],s=new Ve(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],m=a.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);s.bones.push(m)}const r=o.target;if(s.target=a.findBone(r),s.target==null)throw new Error(`Transform constraint target bone not found: ${r}`);s.local=this.getValue(o,"local",!1),s.relative=this.getValue(o,"relative",!1),s.offsetRotation=this.getValue(o,"rotation",0),s.offsetX=this.getValue(o,"x",0)*e,s.offsetY=this.getValue(o,"y",0)*e,s.offsetScaleX=this.getValue(o,"scaleX",0),s.offsetScaleY=this.getValue(o,"scaleY",0),s.offsetShearY=this.getValue(o,"shearY",0),s.rotateMix=this.getValue(o,"rotateMix",1),s.translateMix=this.getValue(o,"translateMix",1),s.scaleMix=this.getValue(o,"scaleMix",1),s.shearMix=this.getValue(o,"shearMix",1),a.transformConstraints.push(s)}if(n.path)for(let d=0;d<n.path.length;d++){const o=n.path[d],s=new Ae(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],m=a.findBone(u);if(m==null)throw new Error(`Transform constraint bone not found: ${u}`);s.bones.push(m)}const r=o.target;if(s.target=a.findSlot(r),s.target==null)throw new Error(`Path target slot not found: ${r}`);s.positionMode=St.positionModeFromString(this.getValue(o,"positionMode","percent")),s.spacingMode=St.spacingModeFromString(this.getValue(o,"spacingMode","length")),s.rotateMode=St.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),s.offsetRotation=this.getValue(o,"rotation",0),s.position=this.getValue(o,"position",0),s.positionMode==Yt.Fixed&&(s.position*=e),s.spacing=this.getValue(o,"spacing",0),(s.spacingMode==xt.Length||s.spacingMode==xt.Fixed)&&(s.spacing*=e),s.rotateMix=this.getValue(o,"rotateMix",1),s.translateMix=this.getValue(o,"translateMix",1),a.pathConstraints.push(s)}if(n.skins)for(const d in n.skins){const o=n.skins[d],s=new Ce(d);for(const r in o){const h=a.findSlotIndex(r);if(h==-1)throw new Error(`Slot not found: ${r}`);const u=o[r];for(const m in u){const c=this.readAttachment(u[m],s,h,m,a);c!=null&&s.addAttachment(h,m,c)}}a.skins.push(s),s.name=="default"&&(a.defaultSkin=s)}for(let d=0,o=this.linkedMeshes.length;d<o;d++){const s=this.linkedMeshes[d],r=s.skin==null?a.defaultSkin:a.findSkin(s.skin);if(r==null)throw new Error(`Skin not found: ${s.skin}`);const h=r.getAttachment(s.slotIndex,s.parent);if(h==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,n.events)for(const d in n.events){const o=n.events[d],s=new be(d);s.intValue=this.getValue(o,"int",0),s.floatValue=this.getValue(o,"float",0),s.stringValue=this.getValue(o,"string",""),s.audioPath=this.getValue(o,"audio",null),s.audioPath!=null&&(s.volume=this.getValue(o,"volume",1),s.balance=this.getValue(o,"balance",0)),a.events.push(s)}if(n.animations)for(const d in n.animations){const o=n.animations[d];this.readAnimation(o,d,a)}return a}readAttachment(t,e,a,n,l){const d=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",n),s=this.attachmentLoader.newRegionAttachment(e,n,o);if(s==null)return null;s.path=o,s.x=this.getValue(t,"x",0)*d,s.y=this.getValue(t,"y",0)*d,s.scaleX=this.getValue(t,"scaleX",1),s.scaleY=this.getValue(t,"scaleY",1),s.rotation=this.getValue(t,"rotation",0),s.width=t.width*d,s.height=t.height*d;const r=this.getValue(t,"color",null);return r!=null&&s.color.setFromString(r),s}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const s=this.getValue(t,"color",null);return s!=null&&o.color.setFromString(s),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",n),s=this.attachmentLoader.newMeshAttachment(e,n,o);if(s==null)return null;s.path=o;const r=this.getValue(t,"color",null);r!=null&&s.color.setFromString(r);const h=this.getValue(t,"parent",null);if(h!=null)return s.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new Be(s,this.getValue(t,"skin",null),a,h)),s;const u=t.uvs;return this.readVertices(t,s,u.length),s.triangles=t.triangles,s.regionUVs=new Float32Array(u),s.hullLength=this.getValue(t,"hull",0)*2,s}case"path":{const o=this.attachmentLoader.newPathAttachment(e,n);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,o,s<<1);const r=V.newArray(s/3,0);for(let u=0;u<t.lengths.length;u++)r[u]=t.lengths[u]*d;o.lengths=r;const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}case"point":{const o=this.attachmentLoader.newPointAttachment(e,n);if(o==null)return null;o.x=this.getValue(t,"x",0)*d,o.y=this.getValue(t,"y",0)*d,o.rotation=this.getValue(t,"rotation",0);const s=this.getValue(t,"color",null);return s!=null&&o.color.setFromString(s),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(e,n);if(o==null)return null;const s=this.getValue(t,"end",null);if(s!=null){const u=l.findSlot(s);if(u==null)throw new Error(`Clipping end slot not found: ${s}`);o.endSlot=u}const r=t.vertexCount;this.readVertices(t,o,r<<1);const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}}return null}readVertices(t,e,a){const n=this.scale;e.worldVerticesLength=a;const l=t.vertices;if(a==l.length){const s=V.toFloatArray(l);if(n!=1)for(let r=0,h=l.length;r<h;r++)s[r]*=n;e.vertices=s;return}const d=new Array,o=new Array;for(let s=0,r=l.length;s<r;){const h=l[s++];o.push(h);for(let u=s+h*4;s<u;s+=4)o.push(l[s]),d.push(l[s+1]*n),d.push(l[s+2]*n),d.push(l[s+3])}e.bones=o,e.vertices=V.toFloatArray(d)}readAnimation(t,e,a){const n=this.scale,l=new Array;let d=0;if(t.slots)for(const s in t.slots){const r=t.slots[s],h=a.findSlotIndex(s);if(h==-1)throw new Error(`Slot not found: ${s}`);for(const u in r){const m=r[u];if(u=="attachment"){const c=new Lt(m.length);c.slotIndex=h;let f=0;for(let g=0;g<m.length;g++){const E=m[g];c.setFrame(f++,E.time,E.name)}l.push(c),d=Math.max(d,c.frames[c.getFrameCount()-1])}else if(u=="color"){const c=new ht(m.length);c.slotIndex=h;let f=0;for(let g=0;g<m.length;g++){const E=m[g],p=new tt;p.setFromString(E.color||"ffffffff"),c.setFrame(f,E.time,p.r,p.g,p.b,p.a),this.readCurve(E,c,f),f++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*ht.ENTRIES])}else if(u=="twoColor"){const c=new z(m.length);c.slotIndex=h;let f=0;for(let g=0;g<m.length;g++){const E=m[g],p=new tt,b=new tt;p.setFromString(E.light),b.setFromString(E.dark),c.setFrame(f,E.time,p.r,p.g,p.b,p.a,b.r,b.g,b.b),this.readCurve(E,c,f),f++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*z.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${u} (${s})`)}}if(t.bones)for(const s in t.bones){const r=t.bones[s],h=a.findBoneIndex(s);if(h==-1)throw new Error(`Bone not found: ${s}`);for(const u in r){const m=r[u];if(u==="rotate"){const c=new nt(m.length);c.boneIndex=h;let f=0;for(let g=0;g<m.length;g++){const E=m[g];c.setFrame(f,E.time,E.angle),this.readCurve(E,c,f),f++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*nt.ENTRIES])}else if(u==="translate"||u==="scale"||u==="shear"){let c=null,f=1;u==="scale"?c=new ut(m.length):u==="shear"?c=new mt(m.length):(c=new pt(m.length),f=n),c.boneIndex=h;let g=0;for(let E=0;E<m.length;E++){const p=m[E],b=this.getValue(p,"x",0),M=this.getValue(p,"y",0);c.setFrame(g,p.time,b*f,M*f),this.readCurve(p,c,g),g++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*pt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${u} (${s})`)}}if(t.ik)for(const s in t.ik){const r=t.ik[s],h=a.findIkConstraint(s),u=new ct(r.length);u.ikConstraintIndex=a.ikConstraints.indexOf(h);let m=0;for(let c=0;c<r.length;c++){const f=r[c];u.setFrame(m,f.time,this.getValue(f,"mix",1),this.getValue(f,"bendPositive",!0)?1:-1,this.getValue(f,"compress",!1),this.getValue(f,"stretch",!1)),this.readCurve(f,u,m),m++}l.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*ct.ENTRIES])}if(t.transform)for(const s in t.transform){const r=t.transform[s],h=a.findTransformConstraint(s),u=new dt(r.length);u.transformConstraintIndex=a.transformConstraints.indexOf(h);let m=0;for(let c=0;c<r.length;c++){const f=r[c];u.setFrame(m,f.time,this.getValue(f,"rotateMix",1),this.getValue(f,"translateMix",1),this.getValue(f,"scaleMix",1),this.getValue(f,"shearMix",1)),this.readCurve(f,u,m),m++}l.push(u),d=Math.max(d,u.frames[(u.getFrameCount()-1)*dt.ENTRIES])}if(t.paths)for(const s in t.paths){const r=t.paths[s],h=a.findPathConstraintIndex(s);if(h==-1)throw new Error(`Path constraint not found: ${s}`);const u=a.pathConstraints[h];for(const m in r){const c=r[m];if(m==="position"||m==="spacing"){let f=null,g=1;m==="spacing"?(f=new wt(c.length),(u.spacingMode==xt.Length||u.spacingMode==xt.Fixed)&&(g=n)):(f=new At(c.length),u.positionMode==Yt.Fixed&&(g=n)),f.pathConstraintIndex=h;let E=0;for(let p=0;p<c.length;p++){const b=c[p];f.setFrame(E,b.time,this.getValue(b,m,0)*g),this.readCurve(b,f,E),E++}l.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*At.ENTRIES])}else if(m==="mix"){const f=new Mt(c.length);f.pathConstraintIndex=h;let g=0;for(let E=0;E<c.length;E++){const p=c[E];f.setFrame(g,p.time,this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1)),this.readCurve(p,f,g),g++}l.push(f),d=Math.max(d,f.frames[(f.getFrameCount()-1)*Mt.ENTRIES])}}}if(t.deform)for(const s in t.deform){const r=t.deform[s],h=a.findSkin(s);if(h==null){if(Ht.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${s}`);continue}for(const u in r){const m=r[u],c=a.findSlotIndex(u);if(c==-1)throw new Error(`Slot not found: ${m.name}`);for(const f in m){const g=m[f],E=h.getAttachment(c,f);if(E==null)throw new Error(`Deform attachment not found: ${g.name}`);const p=E.bones!=null,b=E.vertices,M=p?b.length/3*2:b.length,w=new xe(g.length);w.slotIndex=c,w.attachment=E;let T=0;for(let x=0;x<g.length;x++){const R=g[x];let S;const I=this.getValue(R,"vertices",null);if(I==null)S=p?V.newFloatArray(M):b;else{S=V.newFloatArray(M);const X=this.getValue(R,"offset",0);if(V.arrayCopy(I,0,S,X,I.length),n!=1)for(let N=X,W=N+I.length;N<W;N++)S[N]*=n;if(!p)for(let N=0;N<M;N++)S[N]+=b[N]}w.setFrame(T,R.time,S),this.readCurve(R,w,T),T++}l.push(w),d=Math.max(d,w.frames[w.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const s=new Bt(o.length),r=a.slots.length;let h=0;for(let u=0;u<o.length;u++){const m=o[u];let c=null;const f=this.getValue(m,"offsets",null);if(f!=null){c=V.newArray(r,-1);const g=V.newArray(r-f.length,0);let E=0,p=0;for(let b=0;b<f.length;b++){const M=f[b],w=a.findSlotIndex(M.slot);if(w==-1)throw new Error(`Slot not found: ${M.slot}`);for(;E!=w;)g[p++]=E++;c[E+M.offset]=E++}for(;E<r;)g[p++]=E++;for(let b=r-1;b>=0;b--)c[b]==-1&&(c[b]=g[--p])}s.setFrame(h++,m.time,c)}l.push(s),d=Math.max(d,s.frames[s.getFrameCount()-1])}if(t.events){const s=new Ee(t.events.length);let r=0;for(let h=0;h<t.events.length;h++){const u=t.events[h],m=a.findEvent(u.name);if(m==null)throw new Error(`Event not found: ${u.name}`);const c=new Me(V.toSinglePrecision(u.time),m);c.intValue=this.getValue(u,"int",m.intValue),c.floatValue=this.getValue(u,"float",m.floatValue),c.stringValue=this.getValue(u,"string",m.stringValue),c.data.audioPath!=null&&(c.volume=this.getValue(u,"volume",1),c.balance=this.getValue(u,"balance",0)),s.setFrame(r++,c)}l.push(s),d=Math.max(d,s.frames[s.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");a.animations.push(new Z(e,l,d))}readCurve(t,e,a){if(t.curve){if(t.curve==="stepped")e.setStepped(a);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const n=t.curve;e.setCurve(a,n[0],n[1],n[2],n[3])}}}getValue(t,e,a){return t[e]!==void 0?t[e]:a}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return _t.NORMAL;if(t=="additive")return _t.ADD;if(t=="multiply")return _t.MULTIPLY;if(t=="screen")return _t.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Yt.Fixed;if(t=="percent")return Yt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return xt.Length;if(t=="fixed")return xt.Fixed;if(t=="percent")return xt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return kt.Tangent;if(t=="chain")return kt.Chain;if(t=="chainscale")return kt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return ft.Normal;if(t=="onlytranslation")return ft.OnlyTranslation;if(t=="norotationorreflection")return ft.NoRotationOrReflection;if(t=="noscale")return ft.NoScale;if(t=="noscaleorreflection")return ft.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Be{constructor(t,e,a,n){this.mesh=t,this.skin=e,this.slotIndex=a,this.parent=n}}class We extends Xe{createSkeleton(t){this.skeleton=new ee(t),this.skeleton.updateWorldTransform(),this.stateData=new Jt(t),this.state=new Et(this.stateData)}}export{Z as Animation,Et as AnimationState,Oe as AnimationStateAdapter2,Jt as AnimationStateData,_e as AtlasAttachmentLoader,jt as Attachment,Lt as AttachmentTimeline,te as Bone,we as BoneData,ce as BoundingBoxAttachment,de as ClippingAttachment,ht as ColorTimeline,ot as CurveTimeline,xe as DeformTimeline,Bt as DrawOrderTimeline,Me as Event,be as EventData,Qt as EventQueue,Ee as EventTimeline,lt as EventType,Re as IkConstraint,Te as IkConstraintData,ct as IkConstraintTimeline,Fe as JitterEffect,Gt as MeshAttachment,Dt as PathAttachment,Pt as PathConstraint,Ae as PathConstraintData,Mt as PathConstraintMixTimeline,At as PathConstraintPositionTimeline,wt as PathConstraintSpacingTimeline,ue as PointAttachment,k as RegionAttachment,nt as RotateTimeline,ut as ScaleTimeline,mt as ShearTimeline,ee as Skeleton,Le as SkeletonBounds,Se as SkeletonData,St as SkeletonJson,Ce as Skin,Zt as Slot,Ie as SlotData,xt as SpacingMode,We as Spine,fe as SwirlEffect,pe as TimelineType,Wt as TrackEntry,ye as TransformConstraint,Ve as TransformConstraintData,dt as TransformConstraintTimeline,pt as TranslateTimeline,z as TwoColorTimeline,Rt as VertexAttachment};
//# sourceMappingURL=runtime-3.7.mjs.map
