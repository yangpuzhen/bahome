{"version":3,"file":"runtime-3.7.mjs","sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/Slot.ts","../src/core/attachments/RegionAttachment.ts","../src/core/vertexeffects/JitterEffect.ts","../src/core/vertexeffects/SwirlEffect.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/Bone.ts","../src/core/BoneData.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"sourcesContent":["import type { IAttachment, ArrayLike, AttachmentType } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n}\n\n/**\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    id = (VertexAttachment.nextID++ & 65535) << 11;\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.attachmentVertices;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n    applyDeform(sourceAttachment: VertexAttachment) {\n        return this == sourceAttachment;\n    }\n}\n","import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n","import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    endSlot: SlotData;\n\n    // Nonessential.\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n","import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion;\n    path: string;\n    regionUVs: Float32Array;\n    uvs: ArrayLike<number>;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    hullLength: number;\n    private parentMesh: MeshAttachment;\n    inheritDeform = false;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n}\n","import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n    lengths: Array<number>;\n    closed = false;\n    constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n","import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n    x: number;\n    y: number;\n    rotation: number;\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n}\n","import { Color, ISlot } from '@pixi-spine/base';\n\nimport type { Attachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\n\n/**\n * @public\n */\nexport class Slot implements ISlot {\n    blendMode: number;\n\n    // this is canon\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    darkColor: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentVertices = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (bone == null) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = data.darkColor == null ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** @return May be null. */\n    getAttachment(): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment(attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    }\n\n    setAttachmentTime(time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime(): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n","import { Attachment } from './Attachment';\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\n\nimport type { Bone } from '../Bone';\nimport { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\n    type = AttachmentType.Region;\n\n    static OX1 = 0;\n    static OY1 = 1;\n    static OX2 = 2;\n    static OY2 = 3;\n    static OX3 = 4;\n    static OY3 = 5;\n    static OX4 = 6;\n    static OY4 = 7;\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n\n    x = 0;\n    y = 0;\n    scaleX = 1;\n    scaleY = 1;\n    rotation = 0;\n    width = 0;\n    height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    rendererObject: any;\n    region: TextureRegion;\n\n    offset = Utils.newFloatArray(8);\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateOffset(): void {\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const localXCos = localX * cos + this.x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + this.y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + this.x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + this.y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n    }\n\n    setRegion(region: TextureRegion): void {\n        this.region = region;\n        const uvs = this.uvs;\n\n        if (region.rotate) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        const vertexOffset = this.offset;\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class JitterEffect implements VertexEffect {\n    jitterX = 0;\n    jitterY = 0;\n\n    constructor(jitterX: number, jitterY: number) {\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n    }\n\n    begin(skeleton: Skeleton): void {}\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    }\n\n    end(): void {}\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SwirlEffect implements VertexEffect {\n    static interpolation = new PowOut(2);\n    centerX = 0;\n    centerY = 0;\n    radius = 0;\n    angle = 0;\n    private worldX = 0;\n    private worldY = 0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    begin(skeleton: Skeleton): void {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n    }\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        const radAngle = this.angle * MathUtils.degreesToRadians;\n        const x = position.x - this.worldX;\n        const y = position.y - this.worldY;\n        const dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n            const cos = Math.cos(theta);\n            const sin = Math.sin(theta);\n\n            position.x = cos * x - sin * y + this.worldX;\n            position.y = sin * x + cos * y + this.worldY;\n        }\n    }\n\n    end(): void {}\n}\n","import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection, IAnimation, ITimeline } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\n\n/**\n * @public\n */\nexport class Animation implements IAnimation<Timeline> {\n    name: string;\n    timelines: Array<Timeline>;\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error('name cannot be null.');\n        if (timelines == null) throw new Error('timelines cannot be null.');\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n\n        if (high == 0) return step;\n        let current = high >>> 1;\n\n        while (true) {\n            if (values[(current + 1) * step] <= target) low = current + 1;\n            else high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\n\n        return -1;\n    }\n}\n\n/**\n * @public\n */\nexport interface Timeline extends ITimeline {\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n    getPropertyId(): number;\n}\n\n/**\n * @public\n */\nexport enum TimelineType {\n    rotate,\n    translate,\n    scale,\n    shear,\n    attachment,\n    color,\n    deform,\n    event,\n    drawOrder,\n    ikConstraint,\n    transformConstraint,\n    pathConstraintPosition,\n    pathConstraintSpacing,\n    pathConstraintMix,\n    twoColor,\n}\n\n/**\n * @public\n */\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0;\n    static STEPPED = 1;\n    static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    abstract getPropertyId(): number;\n\n    constructor(frameCount: number) {\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    getFrameCount() {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    setLinear(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    setStepped(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    getCurveType(frameIndex: number): number {\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\n\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        const type = this.curves[index];\n\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx;\n        let ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const curves = this.curves;\n\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx;\n        let y = dfy;\n\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    getCurvePercent(frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        const curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const type = curves[i];\n\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number;\n                let prevY: number;\n\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\n            }\n        }\n        const y = curves[i - 1];\n\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n}\n\n/**\n * @public\n */\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    getPropertyId() {\n        return (TimelineType.rotate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    const r = bone.data.rotation - bone.rotation;\n\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\n\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation + r * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    r += bone.data.rotation - bone.rotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                case MixBlend.add:\n                    bone.rotation += r * alpha;\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_X = -2;\n    static PREV_Y = -1;\n    static X = 1;\n    static Y = 2;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.translate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + TranslateTimeline.PREV_X];\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n\n            x = frames[frame + TranslateTimeline.PREV_X];\n            y = frames[frame + TranslateTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.scale << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n\n            x = frames[frame + ScaleTimeline.PREV_X];\n            y = frames[frame + ScaleTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n        }\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = MathUtils.signum(x);\n                        by = MathUtils.signum(y);\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ShearTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.shear << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ShearTimeline.PREV_X];\n            y = frames[frames.length + ShearTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n\n            x = frames[frame + ShearTimeline.PREV_X];\n            y = frames[frame + ShearTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_R = -4;\n    static PREV_G = -3;\n    static PREV_B = -2;\n    static PREV_A = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.color << 24) + this.slotIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n\n                    return;\n                case MixBlend.first:\n                    const color = slot.color;\n                    const setup = slot.data.color;\n\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        if (alpha == 1) slot.color.set(r, g, b, a);\n        else {\n            const color = slot.color;\n\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TwoColorTimeline extends CurveTimeline {\n    static ENTRIES = 8;\n    static PREV_TIME = -8;\n    static PREV_R = -7;\n    static PREV_G = -6;\n    static PREV_B = -5;\n    static PREV_A = -4;\n    static PREV_R2 = -3;\n    static PREV_G2 = -2;\n    static PREV_B2 = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n    static R2 = 5;\n    static G2 = 6;\n    static B2 = 7;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.twoColor << 24) + this.slotIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frameIndex *= TwoColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n                    slot.darkColor.setFromColor(slot.data.darkColor);\n\n                    return;\n                case MixBlend.first:\n                    const light = slot.color;\n                    const dark = slot.darkColor;\n                    const setupLight = slot.data.color;\n                    const setupDark = slot.data.darkColor;\n\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + TwoColorTimeline.PREV_R];\n            g = frames[i + TwoColorTimeline.PREV_G];\n            b = frames[i + TwoColorTimeline.PREV_B];\n            a = frames[i + TwoColorTimeline.PREV_A];\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n\n            r = frames[frame + TwoColorTimeline.PREV_R];\n            g = frames[frame + TwoColorTimeline.PREV_G];\n            b = frames[frame + TwoColorTimeline.PREV_B];\n            a = frames[frame + TwoColorTimeline.PREV_A];\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n        }\n        if (alpha == 1) {\n            slot.color.set(r, g, b, a);\n            slot.darkColor.set(r2, g2, b2, 1);\n        } else {\n            const light = slot.color;\n            const dark = slot.darkColor;\n\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                dark.setFromColor(slot.data.darkColor);\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class AttachmentTimeline implements Timeline {\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, ...\n    attachmentNames: Array<string>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.attachment << 24) + this.slotIndex;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n            const attachmentName = slot.data.attachmentName;\n\n            slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n            }\n\n            return;\n        }\n\n        let frameIndex = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        const attachmentName = this.attachmentNames[frameIndex];\n\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nlet zeros: ArrayLike<number> = null;\n\n/**\n * @public\n */\nexport class DeformTimeline extends CurveTimeline {\n    slotIndex: number;\n    attachment: VertexAttachment;\n    frames: ArrayLike<number>; // time, ...\n    frameVertices: Array<ArrayLike<number>>;\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n        if (zeros == null) zeros = Utils.newFloatArray(64);\n    }\n\n    getPropertyId() {\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n        const slotAttachment: Attachment = slot.getAttachment();\n\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n        const verticesArray: Array<number> = slot.attachmentVertices;\n\n        if (verticesArray.length == 0) blend = MixBlend.setup;\n\n        const frameVertices = this.frameVertices;\n        const vertexCount = frameVertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const vertexAttachment = <VertexAttachment>slotAttachment;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    verticesArray.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        verticesArray.length = 0;\n                        break;\n                    }\n                    const vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += (setupVertices[i] - vertices[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) vertices[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        const vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = frameVertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            vertices[i] += lastVertices[i] - setupVertices[i];\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i];\n                    }\n                } else {\n                    Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) vertices[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time);\n        const prevVertices = frameVertices[frame - 1];\n        const nextVertices = frameVertices[frame];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (vertexAttachment.bones == null) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    vertices[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class EventTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    events: Array<Event>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.event << 24;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame(frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > lastTime and <= time. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (firedEvents == null) return;\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n\n        if (lastTime < frames[0]) frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            const frameTime = frames[frame];\n\n            while (frame > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\n    }\n}\n\n/**\n * @public\n */\nexport class DrawOrderTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    drawOrders: Array<Array<number>>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.drawOrder << 24;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe.\n     * @param drawOrder May be null to use bind pose draw order. */\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\n        const slots: Array<Slot> = skeleton.slots;\n\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        let frame = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frame = frames.length - 1;\n        else frame = Animation.binarySearch(frames, time) - 1;\n\n        const drawOrderToSetupIndex = this.drawOrders[frame];\n\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_MIX = -4;\n    static PREV_BEND_DIRECTION = -3;\n    static PREV_COMPRESS = -2;\n    static PREV_STRETCH = -1;\n    static MIX = 1;\n    static BEND_DIRECTION = 2;\n    static COMPRESS = 3;\n    static STRETCH = 4;\n\n    ikConstraintIndex: number;\n    frames: ArrayLike<number>; // time, mix, bendDirection, compress, stretch, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n    }\n\n    /** Sets the time, mix and bend direction of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, mix: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            if (blend == MixBlend.setup) {\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                if (direction == MixDirection.mixOut) {\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n                } else {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            } else {\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                if (direction == MixDirection.mixIn) {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        } else {\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_ROTATE = -4;\n    static PREV_TRANSLATE = -3;\n    static PREV_SCALE = -2;\n    static PREV_SHEAR = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n    static SCALE = 3;\n    static SHEAR = 4;\n\n    transformConstraintIndex: number;\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                    constraint.scaleMix = data.scaleMix;\n                    constraint.shearMix = data.shearMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n        let scale = 0;\n        let shear = 0;\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / TransformConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n        }\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        let position = 0;\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\n            // Time is after last frame.\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n            );\n\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n        }\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        let spacing = 0;\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n            // Time is after last frame.\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n            );\n\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n        }\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_ROTATE = -2;\n    static PREV_TRANSLATE = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = constraint.data.rotateMix;\n                    constraint.translateMix = constraint.data.translateMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n            // Time is after last frame.\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n        }\n    }\n}\n","import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, IntSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static emptyAnimation = new Animation('<empty>', [], 0);\n    static SUBSEQUENT = 0;\n    static FIRST = 1;\n    static HOLD = 2;\n    static HOLD_MIX = 3;\n\n    data: AnimationStateData;\n    tracks = new Array<TrackEntry>();\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new IntSet();\n    animationsChanged = false;\n    timeScale = 1;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next != null) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom != null) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.disposeNext(current);\n                continue;\n            }\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from != null) from.mixingTo = null;\n                while (from != null) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (from == null) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    apply(skeleton: Skeleton): boolean {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            const timelineCount = current.animation.timelines.length;\n            const timelines = current.animation.timelines;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const firstFrame = current.timelinesRotation.length == 0;\n\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                const timelinesRotation = current.timelinesRotation;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const events = mix < from.eventThreshold ? this.events : null;\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        const timelineCount = from.animation.timelines.length;\n        const timelines = from.animation.timelines;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const firstFrame = from.timelinesRotation.length == 0;\n\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            const timelinesRotation = from.timelinesRotation;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!attachments && timeline instanceof AttachmentTimeline) continue;\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.HOLD:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (timelineBlend == MixBlend.setup) {\n                        if (timeline instanceof AttachmentTimeline) {\n                            if (attachments) direction = MixDirection.mixOut;\n                        } else if (timeline instanceof DrawOrderTimeline) {\n                            if (drawOrder) direction = MixDirection.mixOut;\n                        }\n                    }\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const rotateTimeline = timeline as RotateTimeline;\n        const frames = rotateTimeline.frames;\n        const bone = skeleton.bones[rotateTimeline.boneIndex];\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n                // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                const frameTime = frames[frame];\n                const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        r1 += total * alpha;\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, events[i]);\n        }\n    }\n\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (current == null) return;\n\n        this.queue.end(current);\n\n        this.disposeNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (from == null) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n\n        if (from != null) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    setAnimationWith(trackIndex: number, animation: Animation, loop: boolean) {\n        if (animation == null) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current != null) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.disposeNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.disposeNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        if (animation == null) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last != null) {\n            while (last.next != null) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (last == null) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            if (delay <= 0) {\n                const duration = last.animationEnd - last.animationStart;\n\n                if (duration != 0) {\n                    if (last.loop) delay += duration * (1 + ((last.trackTime / duration) | 0));\n                    else delay += Math.max(duration, last.trackTime);\n                    delay -= this.data.getMix(last.animation, animation);\n                } else delay = last.trackTime;\n            }\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    setEmptyAnimation(trackIndex: number, mixDuration: number) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number) {\n        if (delay <= 0) delay -= mixDuration;\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    setEmptyAnimations(mixDuration: number) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n\n        return entry;\n    }\n\n    disposeNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next != null) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            let entry = this.tracks[i];\n\n            if (entry == null) continue;\n            while (entry.mixingFrom != null) entry = entry.mixingFrom;\n\n            do {\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.setTimelineModes(entry);\n                entry = entry.mixingTo;\n            } while (entry != null);\n        }\n    }\n\n    setTimelineModes(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n\n        entry.timelineHoldMix.length = 0;\n        const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n        const propertyIDs = this.propertyIDs;\n\n        if (to != null && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) {\n                propertyIDs.add(timelines[i].getPropertyId());\n                timelineMode[i] = AnimationState.HOLD;\n            }\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const id = timelines[i].getPropertyId();\n\n            if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;\n            else if (to == null || !this.hasTimeline(to, id)) timelineMode[i] = AnimationState.FIRST;\n            else {\n                for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n                    if (this.hasTimeline(next, id)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = AnimationState.HOLD_MIX;\n                        timelineDipMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = AnimationState.HOLD;\n            }\n        }\n    }\n\n    hasTimeline(entry: TrackEntry, id: number): boolean {\n        const timelines = entry.animation.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) if (timelines[i].getPropertyId() == id) return true;\n\n        return false;\n    }\n\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    addListener(listener: AnimationStateListener) {\n        if (listener == null) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/**\n * @public\n */\nexport class TrackEntry implements ITrackEntry {\n    animation: Animation;\n    next: TrackEntry;\n    mixingFrom: TrackEntry;\n    mixingTo: TrackEntry;\n    listener: AnimationStateListener;\n    trackIndex: number;\n    loop: boolean;\n    holdPrevious: boolean;\n    eventThreshold: number;\n    attachmentThreshold: number;\n    drawOrderThreshold: number;\n    animationStart: number;\n    animationEnd: number;\n    animationLast: number;\n    nextAnimationLast: number;\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n    private static deprecatedWarning2 = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    deprecateStuff() {\n        if (!EventQueue.deprecatedWarning1) {\n            EventQueue.deprecatedWarning1 = true;\n            console.warn(\n                \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n            );\n        }\n\n        return true;\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n                    // deprecation\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                    break;\n                case EventType.end:\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n                    // deprecation\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n                    // deprecation\n\n                    const count = MathUtils.toInt(entry.loopsCount());\n\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n                    // deprecation\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/**\n * @public\n */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?(entry: TrackEntry): void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?(entry: TrackEntry): void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?(entry: TrackEntry): void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?(entry: TrackEntry): void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?(entry: TrackEntry): void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?(entry: TrackEntry, event: Event): void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter2 implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n","import type { SkeletonData } from './SkeletonData';\nimport type { IAnimationStateData, Map } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/**\n * @public\n */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = {};\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.');\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith(from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error('from cannot be null.');\n        if (to == null) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix(from: Animation, to: Animation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n        const attachment = new RegionAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n        const attachment = new MeshAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n","import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 0;\n    scaleY = 0;\n    shearX = 0;\n    shearY = 0;\n    ax = 0;\n    ay = 0;\n    arotation = 0;\n    ascaleX = 0;\n    ascaleY = 0;\n    ashearX = 0;\n    ashearY = 0;\n    appliedValid = false;\n\n    sorted = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** NOT USED IN 3.7. Needed for the debug graph code */\n    active = true;\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (parent == null) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (\n                    this.data.transformMode == TransformMode.NoScale &&\n                    pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\n                )\n                    s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n    }\n\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n    }\n\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n    updateAppliedTransform() {\n        this.appliedValid = true;\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (parent == null) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    localToWorldRotation(localRotation: number) {\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        this.appliedValid = false;\n    }\n}\n","import { TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 1;\n    scaleY = 1;\n    shearX = 0;\n    shearY = 0;\n    transformMode = TransformMode.Normal;\n\n    constructor(index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n","import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n    volume: number;\n    balance: number;\n\n    constructor(time: number, data: EventData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n","import type { IEventData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class EventData implements IEventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    audioPath: string;\n    volume: number;\n    balance: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n","import type { Constraint } from './Constraint';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraint implements Constraint {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    bendDirection = 0;\n    compress = false;\n    stretch = false;\n    mix = 1;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\n                break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        const p = bone.parent.matrix;\n        const id = 1 / (p.a * p.d - p.b * p.c);\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const tx = (x * p.d - y * p.c) * id - bone.ax;\n        const ty = (y * p.a - x * p.b) * id - bone.ay;\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n\n            return;\n        }\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let sx = psx;\n        let psy = parent.ascaleY;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = targetX - pp.tx;\n        let y = targetY - pp.ty;\n        const tx = (x * d - y * b) * id - px;\n        const ty = (y * a - x * c) * id - py;\n        const dd = tx * tx + ty * ty;\n\n        x = cwx - pp.tx;\n        y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1 = 0;\n        let a2 = 0;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) cos = -1;\n            else if (cos > 1) {\n                cos = 1;\n                if (stretch && l1 + l2 > 0.0001) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n            }\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n","import type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class IkConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    compress = false;\n    stretch = false;\n    uniform = false;\n    mix = 1;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n","import type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport type { RotateMode, PositionMode, IPathConstraintData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraintData implements IPathConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n    rotateMix: number;\n    translateMix: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\n/**\n * @public\n */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n}\n","import { PathAttachment } from './attachments';\nimport type { Constraint } from './Constraint';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraint implements Constraint {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0;\n    spacing = 0;\n    rotateMix = 0;\n    translateMix = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const translate = translateMix > 0;\n        const rotate = rotateMix > 0;\n\n        if (!translate && !rotate) return;\n\n        const data = this.data;\n        const spacingMode = data.spacingMode;\n        const lengthSpacing = spacingMode == SpacingMode.Length;\n        const rotateMode = data.rotateMode;\n        const tangents = rotateMode == RotateMode.Tangent;\n        const scale = rotateMode == RotateMode.ChainScale;\n        const boneCount = this.bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const bones = this.bones;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        let lengths: Array<number> = null;\n        const spacing = this.spacing;\n\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n; ) {\n                const bone = bones[i];\n                const setupLength = bone.data.length;\n\n                if (setupLength < PathConstraint.epsilon) {\n                    if (scale) lengths[i] = 0;\n                    spaces[++i] = 0;\n                } else {\n                    const x = setupLength * bone.matrix.a;\n                    const y = setupLength * bone.matrix.b;\n                    const length = Math.sqrt(x * x + y * y);\n\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                }\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++) spaces[i] = spacing;\n        }\n\n        const positions = this.computeWorldPositions(\n            <PathAttachment>attachment,\n            spacesCount,\n            tangents,\n            data.positionMode == PositionMode.Percent,\n            spacingMode == SpacingMode.Percent\n        );\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * translateMix;\n            mat.ty += (boneY - mat.ty) * translateMix;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents)\n                    if (tangents) r = positions[p - 1];\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\n                    else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.appliedValid = false;\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = null;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i];\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i];\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n}\n","import type { Constraint } from './Constraint';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class TransformConstraint implements Constraint {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    temp = new Vector2();\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * translateMix;\n                mat.ty += (temp.y - mat.ty) * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                mat.a *= s;\n                mat.b *= s;\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyRelativeWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * translateMix;\n                mat.ty += temp.y * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * rotateMix;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax - x + this.data.offsetX) * translateMix;\n                y += (target.ay - y + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n            }\n\n            const shearY = bone.ashearY;\n\n            if (shearMix > 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.shearY += r * shearMix;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax + this.data.offsetX) * translateMix;\n                y += (target.ay + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n            }\n\n            let shearY = bone.ashearY;\n\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n}\n","import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    updateCacheReset = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    scaleX = 1;\n    scaleY = 1;\n    x = 0;\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (boneData.parent == null) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n        this.updateCacheReset.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].sorted = false;\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n            const child = constrained[constrained.length - 1];\n\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (pathBones == null) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n            let i = 0;\n\n            while (i < pathBones.length) {\n                const boneCount = pathBones[i++];\n\n                for (let n = i + boneCount; i < n; i++) {\n                    const boneIndex = pathBones[i];\n\n                    this.sortBone(bones[boneIndex]);\n                }\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform() {\n        const updateCacheReset = this.updateCacheReset;\n\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n            const bone = updateCacheReset[i] as Bone;\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n            bone.appliedValid = true;\n        }\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.mix = constraint.data.mix;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (skin == null) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin | null) {\n        if (newSkin != null) {\n            if (this.skin != null) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name != null) {\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    }\n\n    /** @return May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error('attachmentName cannot be null.');\n        if (this.skin != null) {\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment(slotName: string, attachmentName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB.\n     * @param temp Working memory */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number>) {\n        if (offset == null) throw new Error('offset cannot be null.');\n        if (size == null) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n            let verticesLength = 0;\n            let vertices: ArrayLike<number> = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update(delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n","import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n","import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/**\n * @public\n */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    width: number;\n    height: number;\n    version: string;\n    hash: string;\n\n    // Nonessential\n    fps = 0;\n    imagesPath: string;\n\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    findSkin(skinName: string) {\n        if (skinName == null) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    findEvent(eventDataName: string) {\n        if (eventDataName == null) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    findAnimation(animationName: string) {\n        if (animationName == null) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n","import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport type { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class SlotData implements ISlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        if (boneData == null) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n","import type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class TransformConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    offsetRotation = 0;\n    offsetX = 0;\n    offsetY = 0;\n    offsetScaleX = 0;\n    offsetScaleY = 0;\n    offsetShearY = 0;\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n}\n","import type { Attachment } from './attachments';\nimport type { Skeleton } from './Skeleton';\n\nimport type { Map, ISkin } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skin implements ISkin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    addAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, name: string): Attachment {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport {\n    Animation,\n    AttachmentTimeline,\n    ColorTimeline,\n    CurveTimeline,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ShearTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TwoColorTimeline,\n} from './Animation';\nimport { ArrayLike, Color, Utils, PositionMode, RotateMode, TransformMode, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/**\n * @public\n */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = this.getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const slotName: string = slotMap.name;\n                const boneName: string = slotMap.bone;\n                const boneData = skeletonData.findBone(boneName);\n\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                const color: string = this.getValue(slotMap, 'color', null);\n\n                if (color != null) data.color.setFromString(color);\n\n                const dark: string = this.getValue(slotMap, 'dark', null);\n\n                if (dark != null) {\n                    data.darkColor = new Color(1, 1, 1, 1);\n                    data.darkColor.setFromString(dark);\n                }\n\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\n\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.mix = this.getValue(constraintMap, 'mix', 1);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = this.getValue(constraintMap, 'local', false);\n                data.relative = this.getValue(constraintMap, 'relative', false);\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\n\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.position = this.getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (const skinName in root.skins) {\n                const skinMap = root.skins[skinName];\n                const skin = new Skin(skinName);\n\n                for (const slotName in skinMap) {\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = this.getValue(eventMap, 'int', 0);\n                data.floatValue = this.getValue(eventMap, 'float', 0);\n                data.stringValue = this.getValue(eventMap, 'string', '');\n                data.audioPath = this.getValue(eventMap, 'audio', null);\n                if (data.audioPath != null) {\n                    data.volume = this.getValue(eventMap, 'volume', 1);\n                    data.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = this.getValue(map, 'name', name);\n\n        const type = this.getValue(map, 'type', 'region');\n\n        switch (type) {\n            case 'region': {\n                const path = this.getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, 'x', 0) * scale;\n                region.y = this.getValue(map, 'y', 0) * scale;\n                region.scaleX = this.getValue(map, 'scaleX', 1);\n                region.scaleY = this.getValue(map, 'scaleY', 1);\n                region.rotation = this.getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = this.getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) mesh.color.setFromString(color);\n\n                const parent: string = this.getValue(map, 'parent', null);\n\n                if (parent != null) {\n                    mesh.inheritDeform = this.getValue(map, 'deform', true);\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (path == null) return null;\n                path.closed = this.getValue(map, 'closed', false);\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (point == null) return null;\n                point.x = this.getValue(map, 'x', 0) * scale;\n                point.y = this.getValue(map, 'y', 0) * scale;\n                point.rotation = this.getValue(map, 'rotation', 0);\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (clip == null) return null;\n\n                const end = this.getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else if (timelineName == 'color') {\n                        const timeline = new ColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const color = new Color();\n\n                            color.setFromString(valueMap.color || 'ffffffff');\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n                    } else if (timelineName == 'twoColor') {\n                        const timeline = new TwoColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const light = new Color();\n                            const dark = new Color();\n\n                            light.setFromString(valueMap.light);\n                            dark.setFromString(valueMap.dark);\n                            timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBoneIndex(boneName);\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n\n                    if (timelineName === 'rotate') {\n                        const timeline = new RotateTimeline(timelineMap.length);\n\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'scale') timeline = new ScaleTimeline(timelineMap.length);\n                        else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const x = this.getValue(valueMap, 'x', 0);\n                            const y = this.getValue(valueMap, 'y', 0);\n\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const timeline = new IkConstraintTimeline(constraintMap.length);\n\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        valueMap.time,\n                        this.getValue(valueMap, 'mix', 1),\n                        this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\n                        this.getValue(valueMap, 'compress', false),\n                        this.getValue(valueMap, 'stretch', false)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const constraintMap = map.transform[constraintName];\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\n\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        valueMap.time,\n                        this.getValue(valueMap, 'rotateMix', 1),\n                        this.getValue(valueMap, 'translateMix', 1),\n                        this.getValue(valueMap, 'scaleMix', 1),\n                        this.getValue(valueMap, 'shearMix', 1)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.paths) {\n            for (const constraintName in map.paths) {\n                const constraintMap = map.paths[constraintName];\n                const index = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const data = skeletonData.pathConstraints[index];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n\n                    if (timelineName === 'position' || timelineName === 'spacing') {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'spacing') {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\n\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n                        const weighted = attachment.bones != null;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            const valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            const verticesValue: Array<number> = this.getValue(valueMap, 'vertices', null);\n\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\n            const slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                const drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let i = 0; i < offsets.length; i++) {\n                        const offsetMap = offsets[i];\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n\n            for (let i = 0; i < map.events.length; i++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\n\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath != null) {\n                    event.volume = this.getValue(eventMap, 'volume', 1);\n                    event.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.curve) return;\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n            const curve: Array<number> = map.curve;\n\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n    }\n\n    getValue(map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'fixed') return PositionMode.Fixed;\n        if (str == 'percent') return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'length') return SpacingMode.Length;\n        if (str == 'fixed') return SpacingMode.Fixed;\n        if (str == 'percent') return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'tangent') return RotateMode.Tangent;\n        if (str == 'chain') return RotateMode.Chain;\n        if (str == 'chainscale') return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n\n    static transformModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return TransformMode.Normal;\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\n        if (str == 'noscale') return TransformMode.NoScale;\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\n        throw new Error(`Unknown transform mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n    }\n}\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n"],"names":["Attachment","name","_VertexAttachment","slot","worldVertices","start","count","offset","stride","skeleton","deformArray","vertices","bones","mat","x","y","a","b","c","d","v","w","vx","vy","skip","i","n","skeletonBones","wx","wy","weight","deform","f","sourceAttachment","VertexAttachment","BoundingBoxAttachment","AttachmentType","Color","ClippingAttachment","MeshAttachment","parentMesh","PathAttachment","PointAttachment","bone","point","cos","MathUtils","sin","Slot","data","attachment","time","_RegionAttachment","Utils","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","region","uvs","vertexOffset","offsetX","offsetY","RegionAttachment","JitterEffect","jitterX","jitterY","position","uv","light","dark","_SwirlEffect","radius","radAngle","dist","theta","SwirlEffect","PowOut","Animation","timelines","duration","lastTime","loop","events","alpha","blend","direction","values","target","step","low","high","current","last","TimelineType","s","_CurveTimeline","frameCount","frameIndex","index","type","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","curves","percent","prevX","prevY","CurveTimeline","_RotateTimeline","degrees","frames","MixBlend","r","frame","prevRotation","frameTime","RotateTimeline","_TranslateTimeline","TranslateTimeline","ScaleTimeline","bx","by","MixDirection","ShearTimeline","_ColorTimeline","g","color","setup","ColorTimeline","_TwoColorTimeline","r2","g2","b2","setupLight","setupDark","TwoColorTimeline","AttachmentTimeline","attachmentName","zeros","DeformTimeline","firedEvents","slotAttachment","verticesArray","frameVertices","vertexCount","vertexAttachment","setupVertices","lastVertices","prevVertices","nextVertices","prev","EventTimeline","event","DrawOrderTimeline","drawOrder","slots","drawOrderToSetupIndex","_IkConstraintTimeline","mix","bendDirection","compress","stretch","constraint","IkConstraintTimeline","_TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","rotate","translate","scale","shear","TransformConstraintTimeline","_PathConstraintPositionTimeline","value","PathConstraintPositionTimeline","PathConstraintSpacingTimeline","spacing","_PathConstraintMixTimeline","PathConstraintMixTimeline","_AnimationState","EventQueue","IntSet","Pool","TrackEntry","delta","tracks","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","timelineCount","ii","timelineMode","firstFrame","timelinesRotation","timeline","timelineBlend","attachments","alphaHold","alphaMix","timelineHoldMix","holdMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","interrupt","animationName","animation","delay","mixDuration","timelinesCount","timelineDipMix","propertyIDs","outer","id","listener","AnimationState","_TrackEntry","_EventQueue","animState","EventType","objects","listeners","o","AnimationStateAdapter2","_AnimationStateData","skeletonData","fromName","toName","key","AnimationStateData","AtlasAttachmentLoader","atlas","skin","path","Bone","parent","Matrix","rotation","scaleX","scaleY","shearX","shearY","m","sx","sy","settings","rotationY","pa","pb","pc","pd","TransformMode","la","lb","lc","ld","prx","rx","ry","za","zc","zb","zd","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","BoneData","Event","EventData","IkConstraint","targetX","targetY","uniform","p","tx","ty","rotationIK","dd","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","l1","l2","a1","a2","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraintData","SpacingMode","t","_PathConstraint","spacingMode","lengthSpacing","rotateMode","tangents","RotateMode","boneCount","spacesCount","spaces","lengths","setupLength","length","positions","PositionMode","boneX","boneY","offsetRotation","tip","percentPosition","percentSpacing","out","closed","verticesLength","curveCount","prevCurve","pathLength","curve","space","x1","y1","x2","y2","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","TransformConstraint","Vector2","targetMat","tb","tc","td","degRadReflect","offsetShearY","modified","ts","_Skeleton","boneData","slotData","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotIndex","slotBone","pathBones","boneIndex","updateCacheReset","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","size","mesh","nn","Skeleton","SkeletonBounds","SkeletonBoundsBase","SkeletonData","skins","eventDataName","animations","pathConstraintName","SlotData","TransformConstraintData","Skin","dictionary","oldSkin","skinAttachment","SkeletonJson","attachmentLoader","json","root","skeletonMap","boneMap","parentName","slotMap","constraintMap","j","targetName","skinMap","entryName","linkedMesh","eventName","eventMap","animationMap","map","box","LinkedMesh","clip","end","scaledVertices","weights","timelineName","timelineMap","valueMap","timelineScale","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","slotCount","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","prop","defaultValue","str","BLEND_MODES","Spine","SpineBase","spineData"],"mappings":"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"}