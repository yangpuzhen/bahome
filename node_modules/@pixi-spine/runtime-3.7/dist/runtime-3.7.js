/*!
 * @pixi-spine/runtime-3.7 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-3.7 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine37=function(C,u,It){"use strict";class Ut{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const Gt=class extends Ut{constructor(a){super(a),this.id=(Gt.nextID++&65535)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(a,t){this.computeWorldVertices(a,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(a,t,e,i,n,l){e=n+(e>>1)*l;const d=a.bone.skeleton,o=a.attachmentVertices;let s=this.vertices;const r=this.bones;if(r==null){o.length>0&&(s=o);const c=a.bone.matrix,g=c.tx,M=c.ty,E=c.a,p=c.c,R=c.b,T=c.d;for(let w=t,S=n;S<e;w+=2,S+=l){const x=s[w],A=s[w+1];i[S]=x*E+A*p+g,i[S+1]=x*R+A*T+M}return}let h=0,m=0;for(let c=0;c<t;c+=2){const g=r[h];h+=g+1,m+=g}const f=d.bones;if(o.length==0)for(let c=n,g=m*3;c<e;c+=l){let M=0,E=0,p=r[h++];for(p+=h;h<p;h++,g+=3){const R=f[r[h]].matrix,T=s[g],w=s[g+1],S=s[g+2];M+=(T*R.a+w*R.c+R.tx)*S,E+=(T*R.b+w*R.d+R.ty)*S}i[c]=M,i[c+1]=E}else{const c=o;for(let g=n,M=m*3,E=m<<1;g<e;g+=l){let p=0,R=0,T=r[h++];for(T+=h;h<T;h++,M+=3,E+=2){const w=f[r[h]].matrix,S=s[M]+c[E],x=s[M+1]+c[E+1],A=s[M+2];p+=(S*w.a+x*w.c+w.tx)*A,R+=(S*w.b+x*w.d+w.ty)*A}i[g]=p,i[g+1]=R}}}applyDeform(a){return this==a}};let xt=Gt;xt.nextID=0;class Zt extends xt{constructor(t){super(t),this.type=u.AttachmentType.BoundingBox,this.color=new u.Color(1,1,1,1)}}class zt extends xt{constructor(t){super(t),this.type=u.AttachmentType.Clipping,this.color=new u.Color(.2275,.2275,.8078,1)}}class vt extends xt{constructor(t){super(t),this.type=u.AttachmentType.Mesh,this.color=new u.Color(1,1,1,1),this.inheritDeform=!1,this.tempColor=new u.Color(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}}class Ct extends xt{constructor(t){super(t),this.type=u.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new u.Color(1,1,1,1)}}class Qt extends xt{constructor(t){super(t),this.type=u.AttachmentType.Point,this.color=new u.Color(.38,.94,0,1)}computeWorldPosition(t,e){const i=t.matrix;return e.x=this.x*i.a+this.y*i.c+t.worldX,e.y=this.x*i.b+this.y*i.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,i=u.MathUtils.cosDeg(this.rotation),n=u.MathUtils.sinDeg(this.rotation),l=i*e.a+n*e.c,d=i*e.b+n*e.d;return Math.atan2(d,l)*u.MathUtils.radDeg}}class Ft{constructor(t,e){if(this.attachmentVertices=new Array,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new u.Color,this.darkColor=t.darkColor==null?null:new u.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const K=class extends Ut{constructor(a){super(a),this.type=u.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new u.Color(1,1,1,1),this.offset=u.Utils.newFloatArray(8),this.uvs=u.Utils.newFloatArray(8),this.tempColor=new u.Color(1,1,1,1)}updateOffset(){const a=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*a,i=-this.height/2*this.scaleY+this.region.offsetY*t,n=e+this.region.width*a,l=i+this.region.height*t,d=this.rotation*Math.PI/180,o=Math.cos(d),s=Math.sin(d),r=e*o+this.x,h=e*s,m=i*o+this.y,f=i*s,c=n*o+this.x,g=n*s,M=l*o+this.y,E=l*s,p=this.offset;p[K.OX1]=r-f,p[K.OY1]=m+h,p[K.OX2]=r-E,p[K.OY2]=M+h,p[K.OX3]=c-E,p[K.OY3]=M+g,p[K.OX4]=c-f,p[K.OY4]=m+g}setRegion(a){this.region=a;const t=this.uvs;a.rotate?(t[2]=a.u,t[3]=a.v2,t[4]=a.u,t[5]=a.v,t[6]=a.u2,t[7]=a.v,t[0]=a.u2,t[1]=a.v2):(t[0]=a.u,t[1]=a.v2,t[2]=a.u,t[3]=a.v,t[4]=a.u2,t[5]=a.v,t[6]=a.u2,t[7]=a.v2)}computeWorldVertices(a,t,e,i){const n=this.offset,l=a instanceof Ft?a.bone.matrix:a.matrix,d=l.tx,o=l.ty,s=l.a,r=l.c,h=l.b,m=l.d;let f=0,c=0;f=n[K.OX1],c=n[K.OY1],t[e]=f*s+c*r+d,t[e+1]=f*h+c*m+o,e+=i,f=n[K.OX2],c=n[K.OY2],t[e]=f*s+c*r+d,t[e+1]=f*h+c*m+o,e+=i,f=n[K.OX3],c=n[K.OY3],t[e]=f*s+c*r+d,t[e+1]=f*h+c*m+o,e+=i,f=n[K.OX4],c=n[K.OY4],t[e]=f*s+c*r+d,t[e+1]=f*h+c*m+o}};let P=K;P.OX1=0,P.OY1=1,P.OX2=2,P.OY2=3,P.OX3=4,P.OY3=5,P.OX4=6,P.OY4=7,P.X1=0,P.Y1=1,P.C1R=2,P.C1G=3,P.C1B=4,P.C1A=5,P.U1=6,P.V1=7,P.X2=8,P.Y2=9,P.C2R=10,P.C2G=11,P.C2B=12,P.C2A=13,P.U2=14,P.V2=15,P.X3=16,P.Y3=17,P.C3R=18,P.C3G=19,P.C3B=20,P.C3A=21,P.U3=22,P.V3=23,P.X4=24,P.Y4=25,P.C4R=26,P.C4G=27,P.C4B=28,P.C4A=29,P.U4=30,P.V4=31;class Re{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,i,n){t.x+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Kt=class{constructor(a){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=a}begin(a){this.worldX=a.x+this.centerX,this.worldY=a.y+this.centerY}transform(a,t,e,i){const n=this.angle*u.MathUtils.degreesToRadians,l=a.x-this.worldX,d=a.y-this.worldY,o=Math.sqrt(l*l+d*d);if(o<this.radius){const s=Kt.interpolation.apply(0,n,(this.radius-o)/this.radius),r=Math.cos(s),h=Math.sin(s);a.x=r*l-h*d+this.worldX,a.y=h*l+r*d+this.worldY}}end(){}};let Jt=Kt;Jt.interpolation=new u.PowOut(2);class j{constructor(t,e,i){if(t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=i}apply(t,e,i,n,l,d,o,s){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(i%=this.duration,e>0&&(e%=this.duration));const r=this.timelines;for(let h=0,m=r.length;h<m;h++)r[h].apply(t,e,i,l,d,o,s)}static binarySearch(t,e,i=1){let n=0,l=t.length/i-2;if(l==0)return i;let d=l>>>1;for(;;){if(t[(d+1)*i]<=e?n=d+1:l=d,n==l)return(n+1)*i;d=n+l>>>1}}static linearSearch(t,e,i){for(let n=0,l=t.length-i;n<=l;n+=i)if(t[n]>e)return n;return-1}}var te=(a=>(a[a.rotate=0]="rotate",a[a.translate=1]="translate",a[a.scale=2]="scale",a[a.shear=3]="shear",a[a.attachment=4]="attachment",a[a.color=5]="color",a[a.deform=6]="deform",a[a.event=7]="event",a[a.drawOrder=8]="drawOrder",a[a.ikConstraint=9]="ikConstraint",a[a.transformConstraint=10]="transformConstraint",a[a.pathConstraintPosition=11]="pathConstraintPosition",a[a.pathConstraintSpacing=12]="pathConstraintSpacing",a[a.pathConstraintMix=13]="pathConstraintMix",a[a.twoColor=14]="twoColor",a))(te||{});const H=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=u.Utils.newFloatArray((t-1)*H.BEZIER_SIZE)}getFrameCount(){return this.curves.length/H.BEZIER_SIZE+1}setLinear(t){this.curves[t*H.BEZIER_SIZE]=H.LINEAR}setStepped(t){this.curves[t*H.BEZIER_SIZE]=H.STEPPED}getCurveType(t){const e=t*H.BEZIER_SIZE;if(e==this.curves.length)return H.LINEAR;const i=this.curves[e];return i==H.LINEAR?H.LINEAR:i==H.STEPPED?H.STEPPED:H.BEZIER}setCurve(t,e,i,n,l){const d=(-e*2+n)*.03,o=(-i*2+l)*.03,s=((e-n)*3+1)*.006,r=((i-l)*3+1)*.006;let h=d*2+s,m=o*2+r,f=e*.3+d+s*.16666667,c=i*.3+o+r*.16666667,g=t*H.BEZIER_SIZE;const M=this.curves;M[g++]=H.BEZIER;let E=f,p=c;for(let R=g+H.BEZIER_SIZE-1;g<R;g+=2)M[g]=E,M[g+1]=p,f+=h,c+=m,h+=s,m+=r,E+=f,p+=c}getCurvePercent(t,e){e=u.MathUtils.clamp(e,0,1);const i=this.curves;let n=t*H.BEZIER_SIZE;const l=i[n];if(l==H.LINEAR)return e;if(l==H.STEPPED)return 0;n++;let d=0;for(let s=n,r=n+H.BEZIER_SIZE-1;n<r;n+=2)if(d=i[n],d>=e){let h,m;return n==s?(h=0,m=0):(h=i[n-2],m=i[n-1]),m+(i[n+1]-m)*(e-h)/(d-h)}const o=i[n-1];return o+(1-o)*(e-d)/(1-d)}};let st=H;st.LINEAR=0,st.STEPPED=1,st.BEZIER=2,st.BEZIER_SIZE=10*2-1;const Et=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(a,t,e){a<<=1,this.frames[a]=t,this.frames[a+Et.ROTATION]=e}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.bones[this.boneIndex];if(e<o[0]){switch(l){case u.MixBlend.setup:s.rotation=s.data.rotation;return;case u.MixBlend.first:const g=s.data.rotation-s.rotation;s.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*n}return}if(e>=o[o.length-Et.ENTRIES]){let g=o[o.length+Et.PREV_ROTATION];switch(l){case u.MixBlend.setup:s.rotation=s.data.rotation+g*n;break;case u.MixBlend.first:case u.MixBlend.replace:g+=s.data.rotation-s.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case u.MixBlend.add:s.rotation+=g*n}return}const r=j.binarySearch(o,e,Et.ENTRIES),h=o[r+Et.PREV_ROTATION],m=o[r],f=this.getCurvePercent((r>>1)-1,1-(e-m)/(o[r+Et.PREV_TIME]-m));let c=o[r+Et.ROTATION]-h;switch(c=h+(c-(16384-(16384.499999999996-c/360|0))*360)*f,l){case u.MixBlend.setup:s.rotation=s.data.rotation+(c-(16384-(16384.499999999996-c/360|0))*360)*n;break;case u.MixBlend.first:case u.MixBlend.replace:c+=s.data.rotation-s.rotation;case u.MixBlend.add:s.rotation+=(c-(16384-(16384.499999999996-c/360|0))*360)*n}}};let J=Et;J.ENTRIES=2,J.PREV_TIME=-2,J.PREV_ROTATION=-1,J.ROTATION=1;const tt=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*tt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(a,t,e,i){a*=tt.ENTRIES,this.frames[a]=t,this.frames[a+tt.X]=e,this.frames[a+tt.Y]=i}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.bones[this.boneIndex];if(e<o[0]){switch(l){case u.MixBlend.setup:s.x=s.data.x,s.y=s.data.y;return;case u.MixBlend.first:s.x+=(s.data.x-s.x)*n,s.y+=(s.data.y-s.y)*n}return}let r=0,h=0;if(e>=o[o.length-tt.ENTRIES])r=o[o.length+tt.PREV_X],h=o[o.length+tt.PREV_Y];else{const m=j.binarySearch(o,e,tt.ENTRIES);r=o[m+tt.PREV_X],h=o[m+tt.PREV_Y];const f=o[m],c=this.getCurvePercent(m/tt.ENTRIES-1,1-(e-f)/(o[m+tt.PREV_TIME]-f));r+=(o[m+tt.X]-r)*c,h+=(o[m+tt.Y]-h)*c}switch(l){case u.MixBlend.setup:s.x=s.data.x+r*n,s.y=s.data.y+h*n;break;case u.MixBlend.first:case u.MixBlend.replace:s.x+=(s.data.x+r-s.x)*n,s.y+=(s.data.y+h-s.y)*n;break;case u.MixBlend.add:s.x+=r*n,s.y+=h*n}}};let dt=tt;dt.ENTRIES=3,dt.PREV_TIME=-3,dt.PREV_X=-2,dt.PREV_Y=-1,dt.X=1,dt.Y=2;class rt extends dt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,i,n,l,d,o){const s=this.frames,r=t.bones[this.boneIndex];if(i<s[0]){switch(d){case u.MixBlend.setup:r.scaleX=r.data.scaleX,r.scaleY=r.data.scaleY;return;case u.MixBlend.first:r.scaleX+=(r.data.scaleX-r.scaleX)*l,r.scaleY+=(r.data.scaleY-r.scaleY)*l}return}let h=0,m=0;if(i>=s[s.length-rt.ENTRIES])h=s[s.length+rt.PREV_X]*r.data.scaleX,m=s[s.length+rt.PREV_Y]*r.data.scaleY;else{const f=j.binarySearch(s,i,rt.ENTRIES);h=s[f+rt.PREV_X],m=s[f+rt.PREV_Y];const c=s[f],g=this.getCurvePercent(f/rt.ENTRIES-1,1-(i-c)/(s[f+rt.PREV_TIME]-c));h=(h+(s[f+rt.X]-h)*g)*r.data.scaleX,m=(m+(s[f+rt.Y]-m)*g)*r.data.scaleY}if(l==1)d==u.MixBlend.add?(r.scaleX+=h-r.data.scaleX,r.scaleY+=m-r.data.scaleY):(r.scaleX=h,r.scaleY=m);else{let f=0,c=0;if(o==u.MixDirection.mixOut)switch(d){case u.MixBlend.setup:f=r.data.scaleX,c=r.data.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-f)*l,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-c)*l;break;case u.MixBlend.first:case u.MixBlend.replace:f=r.scaleX,c=r.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-f)*l,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-c)*l;break;case u.MixBlend.add:f=r.scaleX,c=r.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-r.data.scaleX)*l,r.scaleY=c+(Math.abs(m)*u.MathUtils.signum(c)-r.data.scaleY)*l}else switch(d){case u.MixBlend.setup:f=Math.abs(r.data.scaleX)*u.MathUtils.signum(h),c=Math.abs(r.data.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(h-f)*l,r.scaleY=c+(m-c)*l;break;case u.MixBlend.first:case u.MixBlend.replace:f=Math.abs(r.scaleX)*u.MathUtils.signum(h),c=Math.abs(r.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(h-f)*l,r.scaleY=c+(m-c)*l;break;case u.MixBlend.add:f=u.MathUtils.signum(h),c=u.MathUtils.signum(m),r.scaleX=Math.abs(r.scaleX)*f+(h-Math.abs(r.data.scaleX)*f)*l,r.scaleY=Math.abs(r.scaleY)*c+(m-Math.abs(r.data.scaleY)*c)*l}}}}class ot extends dt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,i,n,l,d,o){const s=this.frames,r=t.bones[this.boneIndex];if(i<s[0]){switch(d){case u.MixBlend.setup:r.shearX=r.data.shearX,r.shearY=r.data.shearY;return;case u.MixBlend.first:r.shearX+=(r.data.shearX-r.shearX)*l,r.shearY+=(r.data.shearY-r.shearY)*l}return}let h=0,m=0;if(i>=s[s.length-ot.ENTRIES])h=s[s.length+ot.PREV_X],m=s[s.length+ot.PREV_Y];else{const f=j.binarySearch(s,i,ot.ENTRIES);h=s[f+ot.PREV_X],m=s[f+ot.PREV_Y];const c=s[f],g=this.getCurvePercent(f/ot.ENTRIES-1,1-(i-c)/(s[f+ot.PREV_TIME]-c));h=h+(s[f+ot.X]-h)*g,m=m+(s[f+ot.Y]-m)*g}switch(d){case u.MixBlend.setup:r.shearX=r.data.shearX+h*l,r.shearY=r.data.shearY+m*l;break;case u.MixBlend.first:case u.MixBlend.replace:r.shearX+=(r.data.shearX+h-r.shearX)*l,r.shearY+=(r.data.shearY+m-r.shearY)*l;break;case u.MixBlend.add:r.shearX+=h*l,r.shearY+=m*l}}}const q=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*q.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(a,t,e,i,n,l){a*=q.ENTRIES,this.frames[a]=t,this.frames[a+q.R]=e,this.frames[a+q.G]=i,this.frames[a+q.B]=n,this.frames[a+q.A]=l}apply(a,t,e,i,n,l,d){const o=a.slots[this.slotIndex],s=this.frames;if(e<s[0]){switch(l){case u.MixBlend.setup:o.color.setFromColor(o.data.color);return;case u.MixBlend.first:const c=o.color,g=o.data.color;c.add((g.r-c.r)*n,(g.g-c.g)*n,(g.b-c.b)*n,(g.a-c.a)*n)}return}let r=0,h=0,m=0,f=0;if(e>=s[s.length-q.ENTRIES]){const c=s.length;r=s[c+q.PREV_R],h=s[c+q.PREV_G],m=s[c+q.PREV_B],f=s[c+q.PREV_A]}else{const c=j.binarySearch(s,e,q.ENTRIES);r=s[c+q.PREV_R],h=s[c+q.PREV_G],m=s[c+q.PREV_B],f=s[c+q.PREV_A];const g=s[c],M=this.getCurvePercent(c/q.ENTRIES-1,1-(e-g)/(s[c+q.PREV_TIME]-g));r+=(s[c+q.R]-r)*M,h+=(s[c+q.G]-h)*M,m+=(s[c+q.B]-m)*M,f+=(s[c+q.A]-f)*M}if(n==1)o.color.set(r,h,m,f);else{const c=o.color;l==u.MixBlend.setup&&c.setFromColor(o.data.color),c.add((r-c.r)*n,(h-c.g)*n,(m-c.b)*n,(f-c.a)*n)}}};let lt=q;lt.ENTRIES=5,lt.PREV_TIME=-5,lt.PREV_R=-4,lt.PREV_G=-3,lt.PREV_B=-2,lt.PREV_A=-1,lt.R=1,lt.G=2,lt.B=3,lt.A=4;const X=class extends st{constructor(t){super(t),this.frames=u.Utils.newFloatArray(t*X.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,i,n,l,d,o,s,r){t*=X.ENTRIES,this.frames[t]=e,this.frames[t+X.R]=i,this.frames[t+X.G]=n,this.frames[t+X.B]=l,this.frames[t+X.A]=d,this.frames[t+X.R2]=o,this.frames[t+X.G2]=s,this.frames[t+X.B2]=r}apply(t,e,i,n,l,d,o){const s=t.slots[this.slotIndex],r=this.frames;if(i<r[0]){switch(d){case u.MixBlend.setup:s.color.setFromColor(s.data.color),s.darkColor.setFromColor(s.data.darkColor);return;case u.MixBlend.first:const p=s.color,R=s.darkColor,T=s.data.color,w=s.data.darkColor;p.add((T.r-p.r)*l,(T.g-p.g)*l,(T.b-p.b)*l,(T.a-p.a)*l),R.add((w.r-R.r)*l,(w.g-R.g)*l,(w.b-R.b)*l,0)}return}let h=0,m=0,f=0,c=0,g=0,M=0,E=0;if(i>=r[r.length-X.ENTRIES]){const p=r.length;h=r[p+X.PREV_R],m=r[p+X.PREV_G],f=r[p+X.PREV_B],c=r[p+X.PREV_A],g=r[p+X.PREV_R2],M=r[p+X.PREV_G2],E=r[p+X.PREV_B2]}else{const p=j.binarySearch(r,i,X.ENTRIES);h=r[p+X.PREV_R],m=r[p+X.PREV_G],f=r[p+X.PREV_B],c=r[p+X.PREV_A],g=r[p+X.PREV_R2],M=r[p+X.PREV_G2],E=r[p+X.PREV_B2];const R=r[p],T=this.getCurvePercent(p/X.ENTRIES-1,1-(i-R)/(r[p+X.PREV_TIME]-R));h+=(r[p+X.R]-h)*T,m+=(r[p+X.G]-m)*T,f+=(r[p+X.B]-f)*T,c+=(r[p+X.A]-c)*T,g+=(r[p+X.R2]-g)*T,M+=(r[p+X.G2]-M)*T,E+=(r[p+X.B2]-E)*T}if(l==1)s.color.set(h,m,f,c),s.darkColor.set(g,M,E,1);else{const p=s.color,R=s.darkColor;d==u.MixBlend.setup&&(p.setFromColor(s.data.color),R.setFromColor(s.data.darkColor)),p.add((h-p.r)*l,(m-p.g)*l,(f-p.b)*l,(c-p.a)*l),R.add((g-R.r)*l,(M-R.g)*l,(E-R.b)*l,0)}}};let G=X;G.ENTRIES=8,G.PREV_TIME=-8,G.PREV_R=-7,G.PREV_G=-6,G.PREV_B=-5,G.PREV_A=-4,G.PREV_R2=-3,G.PREV_G2=-2,G.PREV_B2=-1,G.R=1,G.G=2,G.B=3,G.A=4,G.R2=5,G.G2=6,G.B2=7;class kt{constructor(t){this.frames=u.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,i){this.frames[t]=e,this.attachmentNames[t]=i}apply(t,e,i,n,l,d,o){const s=t.slots[this.slotIndex];if(o==u.MixDirection.mixOut&&d==u.MixBlend.setup){const f=s.data.attachmentName;s.setAttachment(f==null?null:t.getAttachment(this.slotIndex,f));return}const r=this.frames;if(i<r[0]){if(d==u.MixBlend.setup||d==u.MixBlend.first){const f=s.data.attachmentName;s.setAttachment(f==null?null:t.getAttachment(this.slotIndex,f))}return}let h=0;i>=r[r.length-1]?h=r.length-1:h=j.binarySearch(r,i,1)-1;const m=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(m==null?null:t.getAttachment(this.slotIndex,m))}}let ee=null;class ne extends st{constructor(t){super(t),this.frames=u.Utils.newFloatArray(t),this.frameVertices=new Array(t),ee==null&&(ee=u.Utils.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,i){this.frames[t]=e,this.frameVertices[t]=i}apply(t,e,i,n,l,d,o){const s=t.slots[this.slotIndex],r=s.getAttachment();if(!(r instanceof xt)||!r.applyDeform(this.attachment))return;const h=s.attachmentVertices;h.length==0&&(d=u.MixBlend.setup);const m=this.frameVertices,f=m[0].length,c=this.frames;if(i<c[0]){const w=r;switch(d){case u.MixBlend.setup:h.length=0;return;case u.MixBlend.first:if(l==1){h.length=0;break}const S=u.Utils.setArraySize(h,f);if(w.bones==null){const x=w.vertices;for(let A=0;A<f;A++)S[A]+=(x[A]-S[A])*l}else{l=1-l;for(let x=0;x<f;x++)S[x]*=l}}return}const g=u.Utils.setArraySize(h,f);if(i>=c[c.length-1]){const w=m[c.length-1];if(l==1)if(d==u.MixBlend.add){const S=r;if(S.bones==null){const x=S.vertices;for(let A=0;A<f;A++)g[A]+=w[A]-x[A]}else for(let x=0;x<f;x++)g[x]+=w[x]}else u.Utils.arrayCopy(w,0,g,0,f);else switch(d){case u.MixBlend.setup:{const x=r;if(x.bones==null){const A=x.vertices;for(let y=0;y<f;y++){const I=A[y];g[y]=I+(w[y]-I)*l}}else for(let A=0;A<f;A++)g[A]=w[A]*l;break}case u.MixBlend.first:case u.MixBlend.replace:for(let x=0;x<f;x++)g[x]+=(w[x]-g[x])*l;case u.MixBlend.add:const S=r;if(S.bones==null){const x=S.vertices;for(let A=0;A<f;A++)g[A]+=(w[A]-x[A])*l}else for(let x=0;x<f;x++)g[x]+=w[x]*l}return}const M=j.binarySearch(c,i),E=m[M-1],p=m[M],R=c[M],T=this.getCurvePercent(M-1,1-(i-R)/(c[M-1]-R));if(l==1)if(d==u.MixBlend.add){const w=r;if(w.bones==null){const S=w.vertices;for(let x=0;x<f;x++){const A=E[x];g[x]+=A+(p[x]-A)*T-S[x]}}else for(let S=0;S<f;S++){const x=E[S];g[S]+=x+(p[S]-x)*T}}else for(let w=0;w<f;w++){const S=E[w];g[w]=S+(p[w]-S)*T}else switch(d){case u.MixBlend.setup:{const S=r;if(S.bones==null){const x=S.vertices;for(let A=0;A<f;A++){const y=E[A],I=x[A];g[A]=I+(y+(p[A]-y)*T-I)*l}}else for(let x=0;x<f;x++){const A=E[x];g[x]=(A+(p[x]-A)*T)*l}break}case u.MixBlend.first:case u.MixBlend.replace:for(let S=0;S<f;S++){const x=E[S];g[S]+=(x+(p[S]-x)*T-g[S])*l}break;case u.MixBlend.add:const w=r;if(w.bones==null){const S=w.vertices;for(let x=0;x<f;x++){const A=E[x];g[x]+=(A+(p[x]-A)*T-S[x])*l}}else for(let S=0;S<f;S++){const x=E[S];g[S]+=(x+(p[S]-x)*T)*l}}}}class se{constructor(t){this.frames=u.Utils.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,i,n,l,d,o){if(n==null)return;const s=this.frames,r=this.frames.length;if(e>i)this.apply(t,e,Number.MAX_VALUE,n,l,d,o),e=-1;else if(e>=s[r-1])return;if(i<s[0])return;let h=0;if(e<s[0])h=0;else{h=j.binarySearch(s,e);const m=s[h];for(;h>0&&s[h-1]==m;)h--}for(;h<r&&i>=s[h];h++)n.push(this.events[h])}}class Bt{constructor(t){this.frames=u.Utils.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,i){this.frames[t]=e,this.drawOrders[t]=i}apply(t,e,i,n,l,d,o){const s=t.drawOrder,r=t.slots;if(o==u.MixDirection.mixOut&&d==u.MixBlend.setup){u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const h=this.frames;if(i<h[0]){(d==u.MixBlend.setup||d==u.MixBlend.first)&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let m=0;i>=h[h.length-1]?m=h.length-1:m=j.binarySearch(h,i)-1;const f=this.drawOrders[m];if(f==null)u.Utils.arrayCopy(r,0,s,0,r.length);else for(let c=0,g=f.length;c<g;c++)s[c]=r[f[c]]}}const O=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*O.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(a,t,e,i,n,l){a*=O.ENTRIES,this.frames[a]=t,this.frames[a+O.MIX]=e,this.frames[a+O.BEND_DIRECTION]=i,this.frames[a+O.COMPRESS]=n?1:0,this.frames[a+O.STRETCH]=l?1:0}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.ikConstraints[this.ikConstraintIndex];if(e<o[0]){switch(l){case u.MixBlend.setup:s.mix=s.data.mix,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case u.MixBlend.first:s.mix+=(s.data.mix-s.mix)*n,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}if(e>=o[o.length-O.ENTRIES]){l==u.MixBlend.setup?(s.mix=s.data.mix+(o[o.length+O.PREV_MIX]-s.data.mix)*n,d==u.MixDirection.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=o[o.length+O.PREV_BEND_DIRECTION],s.compress=o[o.length+O.PREV_COMPRESS]!=0,s.stretch=o[o.length+O.PREV_STRETCH]!=0)):(s.mix+=(o[o.length+O.PREV_MIX]-s.mix)*n,d==u.MixDirection.mixIn&&(s.bendDirection=o[o.length+O.PREV_BEND_DIRECTION],s.compress=o[o.length+O.PREV_COMPRESS]!=0,s.stretch=o[o.length+O.PREV_STRETCH]!=0));return}const r=j.binarySearch(o,e,O.ENTRIES),h=o[r+O.PREV_MIX],m=o[r],f=this.getCurvePercent(r/O.ENTRIES-1,1-(e-m)/(o[r+O.PREV_TIME]-m));l==u.MixBlend.setup?(s.mix=s.data.mix+(h+(o[r+O.MIX]-h)*f-s.data.mix)*n,d==u.MixDirection.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=o[r+O.PREV_BEND_DIRECTION],s.compress=o[r+O.PREV_COMPRESS]!=0,s.stretch=o[r+O.PREV_STRETCH]!=0)):(s.mix+=(h+(o[r+O.MIX]-h)*f-s.mix)*n,d==u.MixDirection.mixIn&&(s.bendDirection=o[r+O.PREV_BEND_DIRECTION],s.compress=o[r+O.PREV_COMPRESS]!=0,s.stretch=o[r+O.PREV_STRETCH]!=0))}};let ht=O;ht.ENTRIES=5,ht.PREV_TIME=-5,ht.PREV_MIX=-4,ht.PREV_BEND_DIRECTION=-3,ht.PREV_COMPRESS=-2,ht.PREV_STRETCH=-1,ht.MIX=1,ht.BEND_DIRECTION=2,ht.COMPRESS=3,ht.STRETCH=4;const $=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*$.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(a,t,e,i,n,l){a*=$.ENTRIES,this.frames[a]=t,this.frames[a+$.ROTATE]=e,this.frames[a+$.TRANSLATE]=i,this.frames[a+$.SCALE]=n,this.frames[a+$.SHEAR]=l}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.transformConstraints[this.transformConstraintIndex];if(e<o[0]){const c=s.data;switch(l){case u.MixBlend.setup:s.rotateMix=c.rotateMix,s.translateMix=c.translateMix,s.scaleMix=c.scaleMix,s.shearMix=c.shearMix;return;case u.MixBlend.first:s.rotateMix+=(c.rotateMix-s.rotateMix)*n,s.translateMix+=(c.translateMix-s.translateMix)*n,s.scaleMix+=(c.scaleMix-s.scaleMix)*n,s.shearMix+=(c.shearMix-s.shearMix)*n}return}let r=0,h=0,m=0,f=0;if(e>=o[o.length-$.ENTRIES]){const c=o.length;r=o[c+$.PREV_ROTATE],h=o[c+$.PREV_TRANSLATE],m=o[c+$.PREV_SCALE],f=o[c+$.PREV_SHEAR]}else{const c=j.binarySearch(o,e,$.ENTRIES);r=o[c+$.PREV_ROTATE],h=o[c+$.PREV_TRANSLATE],m=o[c+$.PREV_SCALE],f=o[c+$.PREV_SHEAR];const g=o[c],M=this.getCurvePercent(c/$.ENTRIES-1,1-(e-g)/(o[c+$.PREV_TIME]-g));r+=(o[c+$.ROTATE]-r)*M,h+=(o[c+$.TRANSLATE]-h)*M,m+=(o[c+$.SCALE]-m)*M,f+=(o[c+$.SHEAR]-f)*M}if(l==u.MixBlend.setup){const c=s.data;s.rotateMix=c.rotateMix+(r-c.rotateMix)*n,s.translateMix=c.translateMix+(h-c.translateMix)*n,s.scaleMix=c.scaleMix+(m-c.scaleMix)*n,s.shearMix=c.shearMix+(f-c.shearMix)*n}else s.rotateMix+=(r-s.rotateMix)*n,s.translateMix+=(h-s.translateMix)*n,s.scaleMix+=(m-s.scaleMix)*n,s.shearMix+=(f-s.shearMix)*n}};let ct=$;ct.ENTRIES=5,ct.PREV_TIME=-5,ct.PREV_ROTATE=-4,ct.PREV_TRANSLATE=-3,ct.PREV_SCALE=-2,ct.PREV_SHEAR=-1,ct.ROTATE=1,ct.TRANSLATE=2,ct.SCALE=3,ct.SHEAR=4;const ut=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*ut.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(a,t,e){a*=ut.ENTRIES,this.frames[a]=t,this.frames[a+ut.VALUE]=e}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.pathConstraints[this.pathConstraintIndex];if(e<o[0]){switch(l){case u.MixBlend.setup:s.position=s.data.position;return;case u.MixBlend.first:s.position+=(s.data.position-s.position)*n}return}let r=0;if(e>=o[o.length-ut.ENTRIES])r=o[o.length+ut.PREV_VALUE];else{const h=j.binarySearch(o,e,ut.ENTRIES);r=o[h+ut.PREV_VALUE];const m=o[h],f=this.getCurvePercent(h/ut.ENTRIES-1,1-(e-m)/(o[h+ut.PREV_TIME]-m));r+=(o[h+ut.VALUE]-r)*f}l==u.MixBlend.setup?s.position=s.data.position+(r-s.data.position)*n:s.position+=(r-s.position)*n}};let wt=ut;wt.ENTRIES=2,wt.PREV_TIME=-2,wt.PREV_VALUE=-1,wt.VALUE=1;class ft extends wt{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,i,n,l,d,o){const s=this.frames,r=t.pathConstraints[this.pathConstraintIndex];if(i<s[0]){switch(d){case u.MixBlend.setup:r.spacing=r.data.spacing;return;case u.MixBlend.first:r.spacing+=(r.data.spacing-r.spacing)*l}return}let h=0;if(i>=s[s.length-ft.ENTRIES])h=s[s.length+ft.PREV_VALUE];else{const m=j.binarySearch(s,i,ft.ENTRIES);h=s[m+ft.PREV_VALUE];const f=s[m],c=this.getCurvePercent(m/ft.ENTRIES-1,1-(i-f)/(s[m+ft.PREV_TIME]-f));h+=(s[m+ft.VALUE]-h)*c}d==u.MixBlend.setup?r.spacing=r.data.spacing+(h-r.data.spacing)*l:r.spacing+=(h-r.spacing)*l}}const et=class extends st{constructor(a){super(a),this.frames=u.Utils.newFloatArray(a*et.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(a,t,e,i){a*=et.ENTRIES,this.frames[a]=t,this.frames[a+et.ROTATE]=e,this.frames[a+et.TRANSLATE]=i}apply(a,t,e,i,n,l,d){const o=this.frames,s=a.pathConstraints[this.pathConstraintIndex];if(e<o[0]){switch(l){case u.MixBlend.setup:s.rotateMix=s.data.rotateMix,s.translateMix=s.data.translateMix;return;case u.MixBlend.first:s.rotateMix+=(s.data.rotateMix-s.rotateMix)*n,s.translateMix+=(s.data.translateMix-s.translateMix)*n}return}let r=0,h=0;if(e>=o[o.length-et.ENTRIES])r=o[o.length+et.PREV_ROTATE],h=o[o.length+et.PREV_TRANSLATE];else{const m=j.binarySearch(o,e,et.ENTRIES);r=o[m+et.PREV_ROTATE],h=o[m+et.PREV_TRANSLATE];const f=o[m],c=this.getCurvePercent(m/et.ENTRIES-1,1-(e-f)/(o[m+et.PREV_TIME]-f));r+=(o[m+et.ROTATE]-r)*c,h+=(o[m+et.TRANSLATE]-h)*c}l==u.MixBlend.setup?(s.rotateMix=s.data.rotateMix+(r-s.data.rotateMix)*n,s.translateMix=s.data.translateMix+(h-s.data.translateMix)*n):(s.rotateMix+=(r-s.rotateMix)*n,s.translateMix+=(h-s.translateMix)*n)}};let pt=et;pt.ENTRIES=3,pt.PREV_TIME=-3,pt.PREV_ROTATE=-2,pt.PREV_TRANSLATE=-1,pt.ROTATE=1,pt.TRANSLATE=2;const z=class{constructor(a){this.tracks=new Array,this.events=new Array,this.listeners=new Array,this.queue=new _t(this),this.propertyIDs=new u.IntSet,this.animationsChanged=!1,this.timeScale=1,this.trackEntryPool=new u.Pool(()=>new Nt),this.data=a}update(a){a*=this.timeScale;const t=this.tracks;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n==null)continue;n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast;let l=a*n.timeScale;if(n.delay>0){if(n.delay-=l,n.delay>0)continue;l=-n.delay,n.delay=0}let d=n.next;if(d!=null){const o=n.trackLast-d.delay;if(o>=0){for(d.delay=0,d.trackTime=n.timeScale==0?0:(o/n.timeScale+a)*d.timeScale,n.trackTime+=l,this.setCurrent(e,d,!0);d.mixingFrom!=null;)d.mixTime+=a,d=d.mixingFrom;continue}}else if(n.trackLast>=n.trackEnd&&n.mixingFrom==null){t[e]=null,this.queue.end(n),this.disposeNext(n);continue}if(n.mixingFrom!=null&&this.updateMixingFrom(n,a)){let o=n.mixingFrom;for(n.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}n.trackTime+=l}this.queue.drain()}updateMixingFrom(a,t){const e=a.mixingFrom;if(e==null)return!0;const i=this.updateMixingFrom(e,t);return e.animationLast=e.nextAnimationLast,e.trackLast=e.nextTrackLast,a.mixTime>0&&a.mixTime>=a.mixDuration?((e.totalAlpha==0||a.mixDuration==0)&&(a.mixingFrom=e.mixingFrom,e.mixingFrom!=null&&(e.mixingFrom.mixingTo=a),a.interruptAlpha=e.interruptAlpha,this.queue.end(e)),i):(e.trackTime+=t*e.timeScale,a.mixTime+=t,!1)}apply(a){if(a==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,e=this.tracks;let i=!1;for(let n=0,l=e.length;n<l;n++){const d=e[n];if(d==null||d.delay>0)continue;i=!0;const o=n==0?u.MixBlend.first:d.mixBlend;let s=d.alpha;d.mixingFrom!=null?s*=this.applyMixingFrom(d,a,o):d.trackTime>=d.trackEnd&&d.next==null&&(s=0);const r=d.animationLast,h=d.getAnimationTime(),m=d.animation.timelines.length,f=d.animation.timelines;if(n==0&&s==1||o==u.MixBlend.add)for(let c=0;c<m;c++)u.Utils.webkit602BugfixHelper(s,o),f[c].apply(a,r,h,t,s,o,u.MixDirection.mixIn);else{const c=d.timelineMode,g=d.timelinesRotation.length==0;g&&u.Utils.setArraySize(d.timelinesRotation,m<<1,null);const M=d.timelinesRotation;for(let E=0;E<m;E++){const p=f[E],R=c[E]==z.SUBSEQUENT?o:u.MixBlend.setup;p instanceof J?this.applyRotateTimeline(p,a,h,s,R,M,E<<1,g):(u.Utils.webkit602BugfixHelper(s,o),p.apply(a,r,h,t,s,R,u.MixDirection.mixIn))}}this.queueEvents(d,h),t.length=0,d.nextAnimationLast=h,d.nextTrackLast=d.trackTime}return this.queue.drain(),i}applyMixingFrom(a,t,e){const i=a.mixingFrom;i.mixingFrom!=null&&this.applyMixingFrom(i,t,e);let n=0;a.mixDuration==0?(n=1,e==u.MixBlend.first&&(e=u.MixBlend.setup)):(n=a.mixTime/a.mixDuration,n>1&&(n=1),e!=u.MixBlend.first&&(e=i.mixBlend));const l=n<i.eventThreshold?this.events:null,d=n<i.attachmentThreshold,o=n<i.drawOrderThreshold,s=i.animationLast,r=i.getAnimationTime(),h=i.animation.timelines.length,m=i.animation.timelines,f=i.alpha*a.interruptAlpha,c=f*(1-n);if(e==u.MixBlend.add)for(let g=0;g<h;g++)m[g].apply(t,s,r,l,c,e,u.MixDirection.mixOut);else{const g=i.timelineMode,M=i.timelineHoldMix,E=i.timelinesRotation.length==0;E&&u.Utils.setArraySize(i.timelinesRotation,h<<1,null);const p=i.timelinesRotation;i.totalAlpha=0;for(let R=0;R<h;R++){const T=m[R];let w=u.MixDirection.mixOut,S,x=0;switch(g[R]){case z.SUBSEQUENT:if(!d&&T instanceof kt||!o&&T instanceof Bt)continue;S=e,x=c;break;case z.FIRST:S=u.MixBlend.setup,x=c;break;case z.HOLD:S=u.MixBlend.setup,x=f;break;default:S=u.MixBlend.setup;const A=M[R];x=f*Math.max(0,1-A.mixTime/A.mixDuration);break}i.totalAlpha+=x,T instanceof J?this.applyRotateTimeline(T,t,r,x,S,p,R<<1,E):(u.Utils.webkit602BugfixHelper(x,e),S==u.MixBlend.setup&&(T instanceof kt?d&&(w=u.MixDirection.mixOut):T instanceof Bt&&o&&(w=u.MixDirection.mixOut)),T.apply(t,s,r,l,x,S,w))}}return a.mixDuration>0&&this.queueEvents(i,r),this.events.length=0,i.nextAnimationLast=r,i.nextTrackLast=i.trackTime,n}applyRotateTimeline(a,t,e,i,n,l,d,o){if(o&&(l[d]=0),i==1){a.apply(t,0,e,null,1,n,u.MixDirection.mixIn);return}const s=a,r=s.frames,h=t.bones[s.boneIndex];let m=0,f=0;if(e<r[0])switch(n){case u.MixBlend.setup:h.rotation=h.data.rotation;default:return;case u.MixBlend.first:m=h.rotation,f=h.data.rotation}else if(m=n==u.MixBlend.setup?h.data.rotation:h.rotation,e>=r[r.length-J.ENTRIES])f=h.data.rotation+r[r.length+J.PREV_ROTATION];else{const M=j.binarySearch(r,e,J.ENTRIES),E=r[M+J.PREV_ROTATION],p=r[M],R=s.getCurvePercent((M>>1)-1,1-(e-p)/(r[M+J.PREV_TIME]-p));f=r[M+J.ROTATION]-E,f-=(16384-(16384.499999999996-f/360|0))*360,f=E+f*R+h.data.rotation,f-=(16384-(16384.499999999996-f/360|0))*360}let c=0,g=f-m;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)c=l[d];else{let M=0,E=0;o?(M=0,E=g):(M=l[d],E=l[d+1]);const p=g>0;let R=M>=0;u.MathUtils.signum(E)!=u.MathUtils.signum(g)&&Math.abs(E)<=90&&(Math.abs(M)>180&&(M+=360*u.MathUtils.signum(M)),R=p),c=g+M-M%360,R!=p&&(c+=360*u.MathUtils.signum(M)),l[d]=c}l[d+1]=g,m+=c*i,h.rotation=m-(16384-(16384.499999999996-m/360|0))*360}queueEvents(a,t){const e=a.animationStart,i=a.animationEnd,n=i-e,l=a.trackLast%n,d=this.events;let o=0;const s=d.length;for(;o<s;o++){const h=d[o];if(h.time<l)break;h.time>i||this.queue.event(a,h)}let r=!1;for(a.loop?r=n==0||l>a.trackTime%n:r=t>=i&&a.animationLast<i,r&&this.queue.complete(a);o<s;o++)d[o].time<e||this.queue.event(a,d[o])}clearTracks(){const a=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=a,this.queue.drain()}clearTrack(a){if(a>=this.tracks.length)return;const t=this.tracks[a];if(t==null)return;this.queue.end(t),this.disposeNext(t);let e=t;for(;;){const i=e.mixingFrom;if(i==null)break;this.queue.end(i),e.mixingFrom=null,e.mixingTo=null,e=i}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(a,t,e){const i=this.expandToIndex(a);this.tracks[a]=t,i!=null&&(e&&this.queue.interrupt(i),t.mixingFrom=i,i.mixingTo=t,t.mixTime=0,i.mixingFrom!=null&&i.mixDuration>0&&(t.interruptAlpha*=Math.min(1,i.mixTime/i.mixDuration)),i.timelinesRotation.length=0),this.queue.start(t)}setAnimation(a,t,e){const i=this.data.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(a,i,e)}setAnimationWith(a,t,e){if(t==null)throw new Error("animation cannot be null.");let i=!0,n=this.expandToIndex(a);n!=null&&(n.nextTrackLast==-1?(this.tracks[a]=n.mixingFrom,this.queue.interrupt(n),this.queue.end(n),this.disposeNext(n),n=n.mixingFrom,i=!1):this.disposeNext(n));const l=this.trackEntry(a,t,e,n);return this.setCurrent(a,l,i),this.queue.drain(),l}addAnimation(a,t,e,i){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(a,n,e,i)}addAnimationWith(a,t,e,i){if(t==null)throw new Error("animation cannot be null.");let n=this.expandToIndex(a);if(n!=null)for(;n.next!=null;)n=n.next;const l=this.trackEntry(a,t,e,n);if(n==null)this.setCurrent(a,l,!0),this.queue.drain();else if(n.next=l,i<=0){const d=n.animationEnd-n.animationStart;d!=0?(n.loop?i+=d*(1+(n.trackTime/d|0)):i+=Math.max(d,n.trackTime),i-=this.data.getMix(n.animation,t)):i=n.trackTime}return l.delay=i,l}setEmptyAnimation(a,t){const e=this.setAnimationWith(a,z.emptyAnimation,!1);return e.mixDuration=t,e.trackEnd=t,e}addEmptyAnimation(a,t,e){e<=0&&(e-=t);const i=this.addAnimationWith(a,z.emptyAnimation,!1,e);return i.mixDuration=t,i.trackEnd=t,i}setEmptyAnimations(a){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,i=this.tracks.length;e<i;e++){const n=this.tracks[e];n!=null&&this.setEmptyAnimation(n.trackIndex,a)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(a){return a<this.tracks.length?this.tracks[a]:(u.Utils.ensureArrayCapacity(this.tracks,a-this.tracks.length+1,null),this.tracks.length=a+1,null)}trackEntry(a,t,e,i){const n=this.trackEntryPool.obtain();return n.trackIndex=a,n.animation=t,n.loop=e,n.holdPrevious=!1,n.eventThreshold=0,n.attachmentThreshold=0,n.drawOrderThreshold=0,n.animationStart=0,n.animationEnd=t.duration,n.animationLast=-1,n.nextAnimationLast=-1,n.delay=0,n.trackTime=0,n.trackLast=-1,n.nextTrackLast=-1,n.trackEnd=Number.MAX_VALUE,n.timeScale=1,n.alpha=1,n.interruptAlpha=1,n.mixTime=0,n.mixDuration=i==null?0:this.data.getMix(i.animation,t),n}disposeNext(a){let t=a.next;for(;t!=null;)this.queue.dispose(t),t=t.next;a.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let a=0,t=this.tracks.length;a<t;a++){let e=this.tracks[a];if(e!=null){for(;e.mixingFrom!=null;)e=e.mixingFrom;do(e.mixingFrom==null||e.mixBlend!=u.MixBlend.add)&&this.setTimelineModes(e),e=e.mixingTo;while(e!=null)}}}setTimelineModes(a){const t=a.mixingTo,e=a.animation.timelines,i=a.animation.timelines.length,n=u.Utils.setArraySize(a.timelineMode,i);a.timelineHoldMix.length=0;const l=u.Utils.setArraySize(a.timelineHoldMix,i),d=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<i;o++)d.add(e[o].getPropertyId()),n[o]=z.HOLD;return}t:for(let o=0;o<i;o++){const s=e[o].getPropertyId();if(!d.add(s))n[o]=z.SUBSEQUENT;else if(t==null||!this.hasTimeline(t,s))n[o]=z.FIRST;else{for(let r=t.mixingTo;r!=null;r=r.mixingTo)if(!this.hasTimeline(r,s)){if(a.mixDuration>0){n[o]=z.HOLD_MIX,l[o]=r;continue t}break}n[o]=z.HOLD}}}hasTimeline(a,t){const e=a.animation.timelines;for(let i=0,n=e.length;i<n;i++)if(e[i].getPropertyId()==t)return!0;return!1}getCurrent(a){return a>=this.tracks.length?null:this.tracks[a]}addListener(a){if(a==null)throw new Error("listener cannot be null.");this.listeners.push(a)}removeListener(a){const t=this.listeners.indexOf(a);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(a,t,e){z.deprecatedWarning1||(z.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(a,t,e)}addAnimationByName(a,t,e,i){z.deprecatedWarning2||(z.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(a,t,e,i)}hasAnimation(a){return this.data.skeletonData.findAnimation(a)!==null}hasAnimationByName(a){return z.deprecatedWarning3||(z.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(a)}};let gt=z;gt.emptyAnimation=new j("<empty>",[],0),gt.SUBSEQUENT=0,gt.FIRST=1,gt.HOLD=2,gt.HOLD_MIX=3,gt.deprecatedWarning1=!1,gt.deprecatedWarning2=!1,gt.deprecatedWarning3=!1;const Mt=class{constructor(){this.mixBlend=u.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const a=this.animationEnd-this.animationStart;return a==0?this.animationStart:this.trackTime%a+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(a){this.animationLast=a,this.nextAnimationLast=a}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Mt.deprecatedWarning1||(Mt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(a){Mt.deprecatedWarning1||(Mt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=a}get endTime(){return Mt.deprecatedWarning2||(Mt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(a){Mt.deprecatedWarning2||(Mt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=a}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Nt=Mt;Nt.deprecatedWarning1=!1,Nt.deprecatedWarning2=!1;const Ot=class{constructor(a){this.objects=[],this.drainDisabled=!1,this.animState=a}start(a){this.objects.push(it.start),this.objects.push(a),this.animState.animationsChanged=!0}interrupt(a){this.objects.push(it.interrupt),this.objects.push(a)}end(a){this.objects.push(it.end),this.objects.push(a),this.animState.animationsChanged=!0}dispose(a){this.objects.push(it.dispose),this.objects.push(a)}complete(a){this.objects.push(it.complete),this.objects.push(a)}event(a,t){this.objects.push(it.event),this.objects.push(a),this.objects.push(t)}deprecateStuff(){return Ot.deprecatedWarning1||(Ot.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const a=this.objects,t=this.animState.listeners;for(let e=0;e<a.length;e+=2){const i=a[e],n=a[e+1];switch(i){case it.start:n.listener!=null&&n.listener.start&&n.listener.start(n);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(n);n.onStart&&this.deprecateStuff()&&n.onStart(n.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(n.trackIndex);break;case it.interrupt:n.listener!=null&&n.listener.interrupt&&n.listener.interrupt(n);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(n);break;case it.end:n.listener!=null&&n.listener.end&&n.listener.end(n);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(n);n.onEnd&&this.deprecateStuff()&&n.onEnd(n.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(n.trackIndex);case it.dispose:n.listener!=null&&n.listener.dispose&&n.listener.dispose(n);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(n);this.animState.trackEntryPool.free(n);break;case it.complete:n.listener!=null&&n.listener.complete&&n.listener.complete(n);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(n);const l=u.MathUtils.toInt(n.loopsCount());n.onComplete&&this.deprecateStuff()&&n.onComplete(n.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(n.trackIndex,l);break;case it.event:const d=a[e+++2];n.listener!=null&&n.listener.event&&n.listener.event(n,d);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(n,d);n.onEvent&&this.deprecateStuff()&&n.onEvent(n.trackIndex,d),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(n.trackIndex,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let _t=Ot;_t.deprecatedWarning1=!1;var it=(a=>(a[a.start=0]="start",a[a.interrupt=1]="interrupt",a[a.end=2]="end",a[a.dispose=3]="dispose",a[a.complete=4]="complete",a[a.event=5]="event",a))(it||{});class Ae{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const Lt=class{constructor(a){if(this.animationToMixTime={},this.defaultMix=0,a==null)throw new Error("skeletonData cannot be null.");this.skeletonData=a}setMix(a,t,e){const i=this.skeletonData.findAnimation(a);if(i==null)throw new Error(`Animation not found: ${a}`);const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(i,n,e)}setMixByName(a,t,e){Lt.deprecatedWarning1||(Lt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(a,t,e)}setMixWith(a,t,e){if(a==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const i=`${a.name}.${t.name}`;this.animationToMixTime[i]=e}getMix(a,t){const e=`${a.name}.${t.name}`,i=this.animationToMixTime[e];return i===void 0?this.defaultMix:i}};let Wt=Lt;Wt.deprecatedWarning1=!1;class Se{constructor(t){this.atlas=t}newRegionAttachment(t,e,i){const n=this.atlas.findRegion(i);if(n==null)throw new Error(`Region not found in atlas: ${i} (region attachment: ${e})`);const l=new P(e);return l.region=n,l}newMeshAttachment(t,e,i){const n=this.atlas.findRegion(i);if(n==null)throw new Error(`Region not found in atlas: ${i} (mesh attachment: ${e})`);const l=new vt(e);return l.region=n,l}newBoundingBoxAttachment(t,e){return new Zt(e)}newPathAttachment(t,e){return new Ct(e)}newPointAttachment(t,e){return new Qt(e)}newClippingAttachment(t,e){return new zt(e)}}class bt{constructor(t,e,i){if(this.matrix=new It.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!0,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=i,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,i,n,l,d,o){this.ax=t,this.ay=e,this.arotation=i,this.ascaleX=n,this.ascaleY=l,this.ashearX=d,this.ashearY=o,this.appliedValid=!0;const s=this.parent,r=this.matrix,h=this.skeleton.scaleX,m=u.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(s==null){const E=this.skeleton,p=i+90+o;r.a=u.MathUtils.cosDeg(i+d)*n*h,r.c=u.MathUtils.cosDeg(p)*l*h,r.b=u.MathUtils.sinDeg(i+d)*n*m,r.d=u.MathUtils.sinDeg(p)*l*m,r.tx=t*h+E.x,r.ty=e*m+E.y;return}let f=s.matrix.a,c=s.matrix.c,g=s.matrix.b,M=s.matrix.d;switch(r.tx=f*t+c*e+s.matrix.tx,r.ty=g*t+M*e+s.matrix.ty,this.data.transformMode){case u.TransformMode.Normal:{const E=i+90+o,p=u.MathUtils.cosDeg(i+d)*n,R=u.MathUtils.cosDeg(E)*l,T=u.MathUtils.sinDeg(i+d)*n,w=u.MathUtils.sinDeg(E)*l;r.a=f*p+c*T,r.c=f*R+c*w,r.b=g*p+M*T,r.d=g*R+M*w;return}case u.TransformMode.OnlyTranslation:{const E=i+90+o;r.a=u.MathUtils.cosDeg(i+d)*n,r.c=u.MathUtils.cosDeg(E)*l,r.b=u.MathUtils.sinDeg(i+d)*n,r.d=u.MathUtils.sinDeg(E)*l;break}case u.TransformMode.NoRotationOrReflection:{let E=f*f+g*g,p=0;E>1e-4?(E=Math.abs(f*M-c*g)/E,c=g*E,M=f*E,p=Math.atan2(g,f)*u.MathUtils.radDeg):(f=0,g=0,p=90-Math.atan2(M,c)*u.MathUtils.radDeg);const R=i+d-p,T=i+o-p+90,w=u.MathUtils.cosDeg(R)*n,S=u.MathUtils.cosDeg(T)*l,x=u.MathUtils.sinDeg(R)*n,A=u.MathUtils.sinDeg(T)*l;r.a=f*w-c*x,r.c=f*S-c*A,r.b=g*w+M*x,r.d=g*S+M*A;break}case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:{const E=u.MathUtils.cosDeg(i),p=u.MathUtils.sinDeg(i);let R=(f*E+c*p)/h,T=(g*E+M*p)/m,w=Math.sqrt(R*R+T*T);w>1e-5&&(w=1/w),R*=w,T*=w,w=Math.sqrt(R*R+T*T),this.data.transformMode==u.TransformMode.NoScale&&f*M-c*g<0!=(u.settings.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(w=-w);const S=Math.PI/2+Math.atan2(T,R),x=Math.cos(S)*w,A=Math.sin(S)*w,y=u.MathUtils.cosDeg(d)*n,I=u.MathUtils.cosDeg(90+o)*l,Y=u.MathUtils.sinDeg(d)*n,B=u.MathUtils.sinDeg(90+o)*l;r.a=R*y+x*Y,r.c=R*I+x*B,r.b=T*y+A*Y,r.d=T*I+A*B;break}}r.a*=h,r.c*=h,r.b*=m,r.d*=m}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*u.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*u.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*u.MathUtils.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*u.MathUtils.radDeg;return}const i=t.matrix,n=1/(i.a*i.d-i.b*i.c),l=e.tx-i.tx,d=e.ty-i.ty;this.ax=l*i.d*n-d*i.c*n,this.ay=d*i.a*n-l*i.b*n;const o=n*i.d,s=n*i.a,r=n*i.c,h=n*i.b,m=o*e.a-r*e.b,f=o*e.c-r*e.d,c=s*e.b-h*e.a,g=s*e.d-h*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+c*c),this.ascaleX>1e-4){const M=m*g-f*c;this.ascaleY=M/this.ascaleX,this.ashearY=Math.atan2(m*f+c*g,M)*u.MathUtils.radDeg,this.arotation=Math.atan2(c,m)*u.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,f)*u.MathUtils.radDeg}worldToLocal(t){const e=this.matrix,i=e.a,n=e.c,l=e.b,d=e.d,o=1/(i*d-n*l),s=t.x-e.tx,r=t.y-e.ty;return t.x=s*d*o-r*n*o,t.y=r*i*o-s*l*o,t}localToWorld(t){const e=this.matrix,i=t.x,n=t.y;return t.x=i*e.a+n*e.c+e.tx,t.y=i*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=u.MathUtils.sinDeg(t),i=u.MathUtils.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*i,n.d*i-n.c*e)*u.MathUtils.radDeg}localToWorldRotation(t){const e=u.MathUtils.sinDeg(t),i=u.MathUtils.cosDeg(t),n=this.matrix;return Math.atan2(i*n.b+e*n.d,i*n.a+e*n.c)*u.MathUtils.radDeg}rotateWorld(t){const e=this.matrix,i=e.a,n=e.c,l=e.b,d=e.d,o=u.MathUtils.cosDeg(t),s=u.MathUtils.sinDeg(t);e.a=o*i-s*l,e.c=o*n-s*d,e.b=s*i+o*l,e.d=s*n+o*d,this.appliedValid=!1}}class ie{constructor(t,e,i){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=u.TransformMode.Normal,t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=i}}class ae{constructor(t,e){if(e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}}class re{constructor(t){this.name=t}}class oe{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let i=0;i<t.bones.length;i++)this.bones.push(e.findBone(t.bones[i].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix);break}}apply1(t,e,i,n,l,d,o){t.appliedValid||t.updateAppliedTransform();const s=t.parent.matrix,r=1/(s.a*s.d-s.b*s.c),h=e-s.tx,m=i-s.ty,f=(h*s.d-m*s.c)*r-t.ax,c=(m*s.a-h*s.b)*r-t.ay;let g=Math.atan2(c,f)*u.MathUtils.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(g+=180),g>180?g-=360:g<-180&&(g+=360);let M=t.ascaleX,E=t.ascaleY;if(n||l){const p=t.data.length*M,R=Math.sqrt(f*f+c*c);if(n&&R<p||l&&R>p&&p>1e-4){const T=(R/p-1)*o+1;M*=T,d&&(E*=T)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+g*o,M,E,t.ashearX,t.ashearY)}apply2(t,e,i,n,l,d,o){if(o==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const s=t.ax,r=t.ay;let h=t.ascaleX,m=h,f=t.ascaleY,c=e.ascaleX;const g=t.matrix;let M=0,E=0,p=0;h<0?(h=-h,M=180,p=-1):(M=0,p=1),f<0&&(f=-f,p=-p),c<0?(c=-c,E=180):E=0;const R=e.ax;let T=0,w=0,S=0,x=g.a,A=g.c,y=g.b,I=g.d;const Y=Math.abs(h-f)<=1e-4;Y?(T=e.ay,w=x*R+A*T+g.tx,S=y*R+I*T+g.ty):(T=0,w=x*R+g.tx,S=y*R+g.ty);const B=t.parent.matrix;x=B.a,A=B.c,y=B.b,I=B.d;const L=1/(x*I-A*y);let _=i-B.tx,V=n-B.ty;const N=(_*I-V*A)*L-s,Q=(V*x-_*y)*L-r,Z=N*N+Q*Q;_=w-B.tx,V=S-B.ty;const U=(_*I-V*A)*L-s,F=(V*x-_*y)*L-r,k=Math.sqrt(U*U+F*F);let W=e.data.length*c,b=0,v=0;t:if(Y){W*=h;let at=(Z-k*k-W*W)/(2*k*W);at<-1?at=-1:at>1&&(at=1,d&&k+W>1e-4&&(m*=(Math.sqrt(Z)/(k+W)-1)*o+1)),v=Math.acos(at)*l,x=k+W*at,A=W*Math.sin(v),b=Math.atan2(Q*x-N*A,N*x+Q*A)}else{x=h*W,A=f*W;const at=x*x,Pt=A*A,$t=Math.atan2(Q,N);y=Pt*k*k+at*Z-at*Pt;const Dt=-2*Pt*k,ge=Pt-at;if(I=Dt*Dt-4*ge*y,I>=0){let St=Math.sqrt(I);Dt<0&&(St=-St),St=-(Dt+St)/2;const we=St/ge,Te=y/St,yt=Math.abs(we)<Math.abs(Te)?we:Te;if(yt*yt<=Z){V=Math.sqrt(Z-yt*yt)*l,b=$t-Math.atan2(V,yt),v=Math.atan2(V/f,(yt-k)/h);break t}}let pe=u.MathUtils.PI,Xt=k-x,Ht=Xt*Xt,Me=0,xe=0,Yt=k+x,jt=Yt*Yt,Ee=0;y=-x*k/(at-Pt),y>=-1&&y<=1&&(y=Math.acos(y),_=x*Math.cos(y)+k,V=A*Math.sin(y),I=_*_+V*V,I<Ht&&(pe=y,Ht=I,Xt=_,Me=V),I>jt&&(xe=y,jt=I,Yt=_,Ee=V)),Z<=(Ht+jt)/2?(b=$t-Math.atan2(Me*l,Xt),v=pe*l):(b=$t-Math.atan2(Ee*l,Yt),v=xe*l)}const D=Math.atan2(T,R)*p;let nt=t.arotation;b=(b-D)*u.MathUtils.radDeg+M-nt,b>180?b-=360:b<-180&&(b+=360),t.updateWorldTransformWith(s,r,nt+b*o,m,t.ascaleY,0,0),nt=e.arotation,v=((v+D)*u.MathUtils.radDeg-e.ashearX)*p+E-nt,v>180?v-=360:v<-180&&(v+=360),e.updateWorldTransformWith(R,T,nt+v*o,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}class le{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}}class he{constructor(t){this.order=0,this.bones=new Array,this.name=t}}var mt=(a=>(a[a.Length=0]="Length",a[a.Fixed=1]="Fixed",a[a.Percent=2]="Percent",a))(mt||{});const Tt=class{constructor(a,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,a==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=a,this.bones=new Array;for(let e=0,i=a.bones.length;e<i;e++)this.bones.push(t.findBone(a.bones[e].name));this.target=t.findSlot(a.target.name),this.position=a.position,this.spacing=a.spacing,this.rotateMix=a.rotateMix,this.translateMix=a.translateMix}apply(){this.update()}update(){const a=this.target.getAttachment();if(!(a instanceof Ct))return;const t=this.rotateMix,e=this.translateMix,i=e>0,n=t>0;if(!i&&!n)return;const l=this.data,d=l.spacingMode,o=d==mt.Length,s=l.rotateMode,r=s==u.RotateMode.Tangent,h=s==u.RotateMode.ChainScale,m=this.bones.length,f=r?m:m+1,c=this.bones,g=u.Utils.setArraySize(this.spaces,f);let M=null;const E=this.spacing;if(h||o){h&&(M=u.Utils.setArraySize(this.lengths,m));for(let x=0,A=f-1;x<A;){const y=c[x],I=y.data.length;if(I<Tt.epsilon)h&&(M[x]=0),g[++x]=0;else{const Y=I*y.matrix.a,B=I*y.matrix.b,L=Math.sqrt(Y*Y+B*B);h&&(M[x]=L),g[++x]=(o?I+E:E)*L/I}}}else for(let x=1;x<f;x++)g[x]=E;const p=this.computeWorldPositions(a,f,r,l.positionMode==u.PositionMode.Percent,d==mt.Percent);let R=p[0],T=p[1],w=l.offsetRotation,S=!1;if(w==0)S=s==u.RotateMode.Chain;else{S=!1;const x=this.target.bone.matrix;w*=x.a*x.d-x.b*x.c>0?u.MathUtils.degRad:-u.MathUtils.degRad}for(let x=0,A=3;x<m;x++,A+=3){const y=c[x],I=y.matrix;I.tx+=(R-I.tx)*e,I.ty+=(T-I.ty)*e;const Y=p[A],B=p[A+1],L=Y-R,_=B-T;if(h){const V=M[x];if(V!=0){const N=(Math.sqrt(L*L+_*_)/V-1)*t+1;I.a*=N,I.b*=N}}if(R=Y,T=B,n){const V=I.a,N=I.c,Q=I.b,Z=I.d;let U=0,F=0,k=0;if(r&&(r?U=p[A-1]:g[x+1]==0?U=p[A+2]:U=Math.atan2(_,L)),U-=Math.atan2(Q,V),S){F=Math.cos(U),k=Math.sin(U);const W=y.data.length;R+=(W*(F*V-k*Q)-L)*t,T+=(W*(k*V+F*Q)-_)*t}else U+=w;U>u.MathUtils.PI?U-=u.MathUtils.PI2:U<-u.MathUtils.PI&&(U+=u.MathUtils.PI2),U*=t,F=Math.cos(U),k=Math.sin(U),I.a=F*V-k*Q,I.c=F*N-k*Z,I.b=k*V+F*Q,I.d=k*N+F*Z}y.appliedValid=!1}}computeWorldPositions(a,t,e,i,n){const l=this.target;let d=this.position;const o=this.spaces,s=u.Utils.setArraySize(this.positions,t*3+2);let r=null;const h=a.closed;let m=a.worldVerticesLength,f=m/6,c=Tt.NONE;if(!a.constantSpeed){const U=a.lengths;f-=h?1:2;const F=U[f];if(i&&(d*=F),n)for(let k=0;k<t;k++)o[k]*=F;r=u.Utils.setArraySize(this.world,8);for(let k=0,W=0,b=0;k<t;k++,W+=3){const v=o[k];d+=v;let D=d;if(h)D%=F,D<0&&(D+=F),b=0;else if(D<0){c!=Tt.BEFORE&&(c=Tt.BEFORE,a.computeWorldVertices(l,2,4,r,0,2)),this.addBeforePosition(D,r,0,s,W);continue}else if(D>F){c!=Tt.AFTER&&(c=Tt.AFTER,a.computeWorldVertices(l,m-6,4,r,0,2)),this.addAfterPosition(D-F,r,0,s,W);continue}for(;;b++){const nt=U[b];if(!(D>nt)){if(b==0)D/=nt;else{const at=U[b-1];D=(D-at)/(nt-at)}break}}b!=c&&(c=b,h&&b==f?(a.computeWorldVertices(l,m-4,4,r,0,2),a.computeWorldVertices(l,0,4,r,4,2)):a.computeWorldVertices(l,b*6+2,8,r,0,2)),this.addCurvePosition(D,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],s,W,e||k>0&&v==0)}return s}h?(m+=2,r=u.Utils.setArraySize(this.world,m),a.computeWorldVertices(l,2,m-4,r,0,2),a.computeWorldVertices(l,0,2,r,m-4,2),r[m-2]=r[0],r[m-1]=r[1]):(f--,m-=4,r=u.Utils.setArraySize(this.world,m),a.computeWorldVertices(l,2,m,r,0,2));const g=u.Utils.setArraySize(this.curves,f);let M=0,E=r[0],p=r[1],R=0,T=0,w=0,S=0,x=0,A=0,y=0,I=0,Y=0,B=0,L=0,_=0,V=0,N=0;for(let U=0,F=2;U<f;U++,F+=6)R=r[F],T=r[F+1],w=r[F+2],S=r[F+3],x=r[F+4],A=r[F+5],y=(E-R*2+w)*.1875,I=(p-T*2+S)*.1875,Y=((R-w)*3-E+x)*.09375,B=((T-S)*3-p+A)*.09375,L=y*2+Y,_=I*2+B,V=(R-E)*.75+y+Y*.16666667,N=(T-p)*.75+I+B*.16666667,M+=Math.sqrt(V*V+N*N),V+=L,N+=_,L+=Y,_+=B,M+=Math.sqrt(V*V+N*N),V+=L,N+=_,M+=Math.sqrt(V*V+N*N),V+=L+Y,N+=_+B,M+=Math.sqrt(V*V+N*N),g[U]=M,E=x,p=A;if(i&&(d*=M),n)for(let U=0;U<t;U++)o[U]*=M;const Q=this.segments;let Z=0;for(let U=0,F=0,k=0,W=0;U<t;U++,F+=3){const b=o[U];d+=b;let v=d;if(h)v%=M,v<0&&(v+=M),k=0;else if(v<0){this.addBeforePosition(v,r,0,s,F);continue}else if(v>M){this.addAfterPosition(v-M,r,m-4,s,F);continue}for(;;k++){const D=g[k];if(!(v>D)){if(k==0)v/=D;else{const nt=g[k-1];v=(v-nt)/(D-nt)}break}}if(k!=c){c=k;let D=k*6;for(E=r[D],p=r[D+1],R=r[D+2],T=r[D+3],w=r[D+4],S=r[D+5],x=r[D+6],A=r[D+7],y=(E-R*2+w)*.03,I=(p-T*2+S)*.03,Y=((R-w)*3-E+x)*.006,B=((T-S)*3-p+A)*.006,L=y*2+Y,_=I*2+B,V=(R-E)*.3+y+Y*.16666667,N=(T-p)*.3+I+B*.16666667,Z=Math.sqrt(V*V+N*N),Q[0]=Z,D=1;D<8;D++)V+=L,N+=_,L+=Y,_+=B,Z+=Math.sqrt(V*V+N*N),Q[D]=Z;V+=L,N+=_,Z+=Math.sqrt(V*V+N*N),Q[8]=Z,V+=L+Y,N+=_+B,Z+=Math.sqrt(V*V+N*N),Q[9]=Z,W=0}for(v*=Z;;W++){const D=Q[W];if(!(v>D)){if(W==0)v/=D;else{const nt=Q[W-1];v=W+(v-nt)/(D-nt)}break}}this.addCurvePosition(v*.1,E,p,R,T,w,S,x,A,s,F,e||U>0&&b==0)}return s}addBeforePosition(a,t,e,i,n){const l=t[e],d=t[e+1],o=t[e+2]-l,s=t[e+3]-d,r=Math.atan2(s,o);i[n]=l+a*Math.cos(r),i[n+1]=d+a*Math.sin(r),i[n+2]=r}addAfterPosition(a,t,e,i,n){const l=t[e+2],d=t[e+3],o=l-t[e],s=d-t[e+1],r=Math.atan2(s,o);i[n]=l+a*Math.cos(r),i[n+1]=d+a*Math.sin(r),i[n+2]=r}addCurvePosition(a,t,e,i,n,l,d,o,s,r,h,m){(a==0||isNaN(a))&&(a=1e-4);const f=a*a,c=f*a,g=1-a,M=g*g,E=M*g,p=g*a,R=p*3,T=g*R,w=R*a,S=t*E+i*T+l*w+o*c,x=e*E+n*T+d*w+s*c;r[h]=S,r[h+1]=x,m&&(r[h+2]=Math.atan2(x-(e*M+n*p*2+d*f),S-(t*M+i*p*2+l*f)))}getOrder(){return this.data.order}};let At=Tt;At.NONE=-1,At.BEFORE=-2,At.AFTER=-3,At.epsilon=1e-5;class ce{constructor(t,e){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new u.Vector2,t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let i=0;i<t.bones.length;i++)this.bones.push(e.findBone(t.bones[i].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,i=this.scaleMix,n=this.shearMix,l=this.target,d=l.matrix,o=d.a,s=d.c,r=d.b,h=d.d,m=o*h-s*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,c=this.data.offsetShearY*m,g=this.bones;for(let M=0,E=g.length;M<E;M++){const p=g[M];let R=!1;const T=p.matrix;if(t!=0){const w=T.a,S=T.c,x=T.b,A=T.d;let y=Math.atan2(r,o)-Math.atan2(x,w)+f;y>u.MathUtils.PI?y-=u.MathUtils.PI2:y<-u.MathUtils.PI&&(y+=u.MathUtils.PI2),y*=t;const I=Math.cos(y),Y=Math.sin(y);T.a=I*w-Y*x,T.c=I*S-Y*A,T.b=Y*w+I*x,T.d=Y*S+I*A,R=!0}if(e!=0){const w=this.temp;l.localToWorld(w.set(this.data.offsetX,this.data.offsetY)),T.tx+=(w.x-T.tx)*e,T.ty+=(w.y-T.ty)*e,R=!0}if(i>0){let w=Math.sqrt(T.a*T.a+T.b*T.b),S=Math.sqrt(o*o+r*r);w>1e-5&&(w=(w+(S-w+this.data.offsetScaleX)*i)/w),T.a*=w,T.b*=w,w=Math.sqrt(T.c*T.c+T.d*T.d),S=Math.sqrt(s*s+h*h),w>1e-5&&(w=(w+(S-w+this.data.offsetScaleY)*i)/w),T.c*=w,T.d*=w,R=!0}if(n>0){const w=T.c,S=T.d,x=Math.atan2(S,w);let A=Math.atan2(h,s)-Math.atan2(r,o)-(x-Math.atan2(T.b,T.a));A>u.MathUtils.PI?A-=u.MathUtils.PI2:A<-u.MathUtils.PI&&(A+=u.MathUtils.PI2),A=x+(A+c)*n;const y=Math.sqrt(w*w+S*S);T.c=Math.cos(A)*y,T.d=Math.sin(A)*y,R=!0}R&&(p.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,i=this.scaleMix,n=this.shearMix,l=this.target,d=l.matrix,o=d.a,s=d.c,r=d.b,h=d.d,m=o*h-s*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,c=this.data.offsetShearY*m,g=this.bones;for(let M=0,E=g.length;M<E;M++){const p=g[M];let R=!1;const T=p.matrix;if(t!=0){const w=T.a,S=T.c,x=T.b,A=T.d;let y=Math.atan2(r,o)+f;y>u.MathUtils.PI?y-=u.MathUtils.PI2:y<-u.MathUtils.PI&&(y+=u.MathUtils.PI2),y*=t;const I=Math.cos(y),Y=Math.sin(y);T.a=I*w-Y*x,T.c=I*S-Y*A,T.b=Y*w+I*x,T.d=Y*S+I*A,R=!0}if(e!=0){const w=this.temp;l.localToWorld(w.set(this.data.offsetX,this.data.offsetY)),T.tx+=w.x*e,T.ty+=w.y*e,R=!0}if(i>0){let w=(Math.sqrt(o*o+r*r)-1+this.data.offsetScaleX)*i+1;T.a*=w,T.b*=w,w=(Math.sqrt(s*s+h*h)-1+this.data.offsetScaleY)*i+1,T.c*=w,T.d*=w,R=!0}if(n>0){let w=Math.atan2(h,s)-Math.atan2(r,o);w>u.MathUtils.PI?w-=u.MathUtils.PI2:w<-u.MathUtils.PI&&(w+=u.MathUtils.PI2);const S=T.c,x=T.d;w=Math.atan2(x,S)+(w-u.MathUtils.PI/2+c)*n;const A=Math.sqrt(S*S+x*x);T.c=Math.cos(w)*A,T.d=Math.sin(w)*A,R=!0}R&&(p.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,i=this.scaleMix,n=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const d=this.bones;for(let o=0,s=d.length;o<s;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;if(t!=0){let E=l.arotation-h+this.data.offsetRotation;E-=(16384-(16384.499999999996-E/360|0))*360,h+=E*t}let m=r.ax,f=r.ay;e!=0&&(m+=(l.ax-m+this.data.offsetX)*e,f+=(l.ay-f+this.data.offsetY)*e);let c=r.ascaleX,g=r.ascaleY;i>0&&(c>1e-5&&(c=(c+(l.ascaleX-c+this.data.offsetScaleX)*i)/c),g>1e-5&&(g=(g+(l.ascaleY-g+this.data.offsetScaleY)*i)/g));const M=r.ashearY;if(n>0){let E=l.ashearY-M+this.data.offsetShearY;E-=(16384-(16384.499999999996-E/360|0))*360,r.shearY+=E*n}r.updateWorldTransformWith(m,f,h,c,g,r.ashearX,M)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,i=this.scaleMix,n=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const d=this.bones;for(let o=0,s=d.length;o<s;o++){const r=d[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;t!=0&&(h+=(l.arotation+this.data.offsetRotation)*t);let m=r.ax,f=r.ay;e!=0&&(m+=(l.ax+this.data.offsetX)*e,f+=(l.ay+this.data.offsetY)*e);let c=r.ascaleX,g=r.ascaleY;i>0&&(c>1e-5&&(c*=(l.ascaleX-1+this.data.offsetScaleX)*i+1),g>1e-5&&(g*=(l.ascaleY-1+this.data.offsetScaleY)*i+1));let M=r.ashearY;n>0&&(M+=(l.ashearY+this.data.offsetShearY)*n),r.updateWorldTransformWith(m,f,h,c,g,r.ashearX,M)}}getOrder(){return this.data.order}}const Vt=class{constructor(a){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,a==null)throw new Error("data cannot be null.");this.data=a,this.bones=new Array;for(let t=0;t<a.bones.length;t++){const e=a.bones[t];let i;if(e.parent==null)i=new bt(e,this,null);else{const n=this.bones[e.parent.index];i=new bt(e,this,n),n.children.push(i)}this.bones.push(i)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<a.slots.length;t++){const e=a.slots[t],i=this.bones[e.boneData.index],n=new Ft(e,i);this.slots.push(n),this.drawOrder.push(n)}this.ikConstraints=new Array;for(let t=0;t<a.ikConstraints.length;t++){const e=a.ikConstraints[t];this.ikConstraints.push(new oe(e,this))}this.transformConstraints=new Array;for(let t=0;t<a.transformConstraints.length;t++){const e=a.transformConstraints[t];this.transformConstraints.push(new ce(e,this))}this.pathConstraints=new Array;for(let t=0;t<a.pathConstraints.length;t++){const e=a.pathConstraints[t];this.pathConstraints.push(new At(e,this))}this.color=new u.Color(1,1,1,1),this.updateCache()}updateCache(){const a=this._updateCache;a.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let r=0,h=t.length;r<h;r++)t[r].sorted=!1;const e=this.ikConstraints,i=this.transformConstraints,n=this.pathConstraints,l=e.length,d=i.length,o=n.length,s=l+d+o;t:for(let r=0;r<s;r++){for(let h=0;h<l;h++){const m=e[h];if(m.data.order==r){this.sortIkConstraint(m);continue t}}for(let h=0;h<d;h++){const m=i[h];if(m.data.order==r){this.sortTransformConstraint(m);continue t}}for(let h=0;h<o;h++){const m=n[h];if(m.data.order==r){this.sortPathConstraint(m);continue t}}}for(let r=0,h=t.length;r<h;r++)this.sortBone(t[r])}sortIkConstraint(a){const t=a.target;this.sortBone(t);const e=a.bones,i=e[0];if(this.sortBone(i),e.length>1){const n=e[e.length-1];this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}this._updateCache.push(a),this.sortReset(i.children),e[e.length-1].sorted=!0}sortPathConstraint(a){const t=a.target,e=t.data.index,i=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,e,i),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,i);for(let o=0,s=this.data.skins.length;o<s;o++)this.sortPathConstraintAttachment(this.data.skins[o],e,i);const n=t.getAttachment();n instanceof Ct&&this.sortPathConstraintAttachmentWith(n,i);const l=a.bones,d=l.length;for(let o=0;o<d;o++)this.sortBone(l[o]);this._updateCache.push(a);for(let o=0;o<d;o++)this.sortReset(l[o].children);for(let o=0;o<d;o++)l[o].sorted=!0}sortTransformConstraint(a){this.sortBone(a.target);const t=a.bones,e=t.length;if(a.data.local)for(let i=0;i<e;i++){const n=t[i];this.sortBone(n.parent),this._updateCache.indexOf(n)>-1||this.updateCacheReset.push(n)}else for(let i=0;i<e;i++)this.sortBone(t[i]);this._updateCache.push(a);for(let i=0;i<e;i++)this.sortReset(t[i].children);for(let i=0;i<e;i++)t[i].sorted=!0}sortPathConstraintAttachment(a,t,e){const i=a.attachments[t];if(i)for(const n in i)this.sortPathConstraintAttachmentWith(i[n],e)}sortPathConstraintAttachmentWith(a,t){if(!(a instanceof Ct))return;const e=a.bones;if(e==null)this.sortBone(t);else{const i=this.bones;let n=0;for(;n<e.length;){const l=e[n++];for(let d=n+l;n<d;n++){const o=e[n];this.sortBone(i[o])}}}}sortBone(a){if(a.sorted)return;const t=a.parent;t!=null&&this.sortBone(t),a.sorted=!0,this._updateCache.push(a)}sortReset(a){for(let t=0,e=a.length;t<e;t++){const i=a[t];i.sorted&&this.sortReset(i.children),i.sorted=!1}}updateWorldTransform(){const a=this.updateCacheReset;for(let e=0,i=a.length;e<i;e++){const n=a[e];n.ax=n.x,n.ay=n.y,n.arotation=n.rotation,n.ascaleX=n.scaleX,n.ascaleY=n.scaleY,n.ashearX=n.shearX,n.ashearY=n.shearY,n.appliedValid=!0}const t=this._updateCache;for(let e=0,i=t.length;e<i;e++)t[e].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const a=this.bones;for(let n=0,l=a.length;n<l;n++)a[n].setToSetupPose();const t=this.ikConstraints;for(let n=0,l=t.length;n<l;n++){const d=t[n];d.bendDirection=d.data.bendDirection,d.mix=d.data.mix}const e=this.transformConstraints;for(let n=0,l=e.length;n<l;n++){const d=e[n],o=d.data;d.rotateMix=o.rotateMix,d.translateMix=o.translateMix,d.scaleMix=o.scaleMix,d.shearMix=o.shearMix}const i=this.pathConstraints;for(let n=0,l=i.length;n<l;n++){const d=i[n],o=d.data;d.position=o.position,d.spacing=o.spacing,d.rotateMix=o.rotateMix,d.translateMix=o.translateMix}}setSlotsToSetupPose(){const a=this.slots;u.Utils.arrayCopy(a,0,this.drawOrder,0,a.length);for(let t=0,e=a.length;t<e;t++)a[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(a){if(a==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n.data.name==a)return n}return null}findBoneIndex(a){if(a==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let e=0,i=t.length;e<i;e++)if(t[e].data.name==a)return e;return-1}findSlot(a){if(a==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n.data.name==a)return n}return null}findSlotIndex(a){if(a==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let e=0,i=t.length;e<i;e++)if(t[e].data.name==a)return e;return-1}setSkinByName(a){const t=this.data.findSkin(a);if(t==null)throw new Error(`Skin not found: ${a}`);this.setSkin(t)}setSkin(a){if(a!=null)if(this.skin!=null)a.attachAll(this,this.skin);else{const t=this.slots;for(let e=0,i=t.length;e<i;e++){const n=t[e],l=n.data.attachmentName;if(l!=null){const d=a.getAttachment(e,l);d!=null&&n.setAttachment(d)}}}this.skin=a}getAttachmentByName(a,t){return this.getAttachment(this.data.findSlotIndex(a),t)}getAttachment(a,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const e=this.skin.getAttachment(a,t);if(e!=null)return e}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(a,t):null}setAttachment(a,t){if(a==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.data.name==a){let d=null;if(t!=null&&(d=this.getAttachment(i,t),d==null))throw new Error(`Attachment not found: ${t}, for slot: ${a}`);l.setAttachment(d);return}}throw new Error(`Slot not found: ${a}`)}findIkConstraint(a){if(a==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n.data.name==a)return n}return null}findTransformConstraint(a){if(a==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n.data.name==a)return n}return null}findPathConstraint(a){if(a==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let e=0,i=t.length;e<i;e++){const n=t[e];if(n.data.name==a)return n}return null}getBounds(a,t,e){if(a==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const i=this.drawOrder;let n=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let s=0,r=i.length;s<r;s++){const h=i[s];let m=0,f=null;const c=h.getAttachment();if(c instanceof P)m=8,f=u.Utils.setArraySize(e,m,0),c.computeWorldVertices(h.bone,f,0,2);else if(c instanceof vt){const g=c;m=g.worldVerticesLength,f=u.Utils.setArraySize(e,m,0),g.computeWorldVertices(h,0,m,f,0,2)}if(f!=null)for(let g=0,M=f.length;g<M;g+=2){const E=f[g],p=f[g+1];n=Math.min(n,E),l=Math.min(l,p),d=Math.max(d,E),o=Math.max(o,p)}}a.set(n,l),t.set(d-n,o-l)}update(a){this.time+=a}get flipX(){return this.scaleX==-1}set flipX(a){Vt.deprecatedWarning1||(Vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=a?1:-1}get flipY(){return this.scaleY==-1}set flipY(a){Vt.deprecatedWarning1||(Vt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=a?1:-1}};let qt=Vt;qt.deprecatedWarning1=!1;class ye extends u.SkeletonBoundsBase{}class de{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let i=0,n=e.length;i<n;i++)if(e[i].name==t)return i;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let i=0,n=e.length;i<n;i++)if(e[i].name==t)return i;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let i=0,n=e.length;i<n;i++){const l=e[i];if(l.name==t)return l}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let i=0,n=e.length;i<n;i++)if(e[i].name==t)return i;return-1}}class ue{constructor(t,e,i){if(this.color=new u.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(i==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=i}}class me{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,t==null)throw new Error("name cannot be null.");this.name=t}}class fe{constructor(t){if(this.attachments=new Array,t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,i){if(i==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=i}getAttachment(t,e){const i=this.attachments[t];return i?i[e]:null}attachAll(t,e){let i=0;for(let n=0;n<t.slots.length;n++){const l=t.slots[n],d=l.getAttachment();if(d&&i<e.attachments.length){const o=e.attachments[i];for(const s in o){const r=o[s];if(d==r){const h=this.getAttachment(i,s);h!=null&&l.setAttachment(h);break}}}i++}}}class Rt{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,i=new de,n=typeof t=="string"?JSON.parse(t):t,l=n.skeleton;if(l!=null&&(i.hash=l.hash,i.version=l.spine,i.width=l.width,i.height=l.height,i.fps=l.fps,i.imagesPath=l.images),n.bones)for(let d=0;d<n.bones.length;d++){const o=n.bones[d];let s=null;const r=this.getValue(o,"parent",null);if(r!=null&&(s=i.findBone(r),s==null))throw new Error(`Parent bone not found: ${r}`);const h=new ie(i.bones.length,o.name,s);h.length=this.getValue(o,"length",0)*e,h.x=this.getValue(o,"x",0)*e,h.y=this.getValue(o,"y",0)*e,h.rotation=this.getValue(o,"rotation",0),h.scaleX=this.getValue(o,"scaleX",1),h.scaleY=this.getValue(o,"scaleY",1),h.shearX=this.getValue(o,"shearX",0),h.shearY=this.getValue(o,"shearY",0),h.transformMode=Rt.transformModeFromString(this.getValue(o,"transform","normal")),i.bones.push(h)}if(n.slots)for(let d=0;d<n.slots.length;d++){const o=n.slots[d],s=o.name,r=o.bone,h=i.findBone(r);if(h==null)throw new Error(`Slot bone not found: ${r}`);const m=new ue(i.slots.length,s,h),f=this.getValue(o,"color",null);f!=null&&m.color.setFromString(f);const c=this.getValue(o,"dark",null);c!=null&&(m.darkColor=new u.Color(1,1,1,1),m.darkColor.setFromString(c)),m.attachmentName=this.getValue(o,"attachment",null),m.blendMode=Rt.blendModeFromString(this.getValue(o,"blend","normal")),i.slots.push(m)}if(n.ik)for(let d=0;d<n.ik.length;d++){const o=n.ik[d],s=new le(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=i.findBone(m);if(f==null)throw new Error(`IK bone not found: ${m}`);s.bones.push(f)}const r=o.target;if(s.target=i.findBone(r),s.target==null)throw new Error(`IK target bone not found: ${r}`);s.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,s.mix=this.getValue(o,"mix",1),i.ikConstraints.push(s)}if(n.transform)for(let d=0;d<n.transform.length;d++){const o=n.transform[d],s=new me(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=i.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);s.bones.push(f)}const r=o.target;if(s.target=i.findBone(r),s.target==null)throw new Error(`Transform constraint target bone not found: ${r}`);s.local=this.getValue(o,"local",!1),s.relative=this.getValue(o,"relative",!1),s.offsetRotation=this.getValue(o,"rotation",0),s.offsetX=this.getValue(o,"x",0)*e,s.offsetY=this.getValue(o,"y",0)*e,s.offsetScaleX=this.getValue(o,"scaleX",0),s.offsetScaleY=this.getValue(o,"scaleY",0),s.offsetShearY=this.getValue(o,"shearY",0),s.rotateMix=this.getValue(o,"rotateMix",1),s.translateMix=this.getValue(o,"translateMix",1),s.scaleMix=this.getValue(o,"scaleMix",1),s.shearMix=this.getValue(o,"shearMix",1),i.transformConstraints.push(s)}if(n.path)for(let d=0;d<n.path.length;d++){const o=n.path[d],s=new he(o.name);s.order=this.getValue(o,"order",0);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=i.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);s.bones.push(f)}const r=o.target;if(s.target=i.findSlot(r),s.target==null)throw new Error(`Path target slot not found: ${r}`);s.positionMode=Rt.positionModeFromString(this.getValue(o,"positionMode","percent")),s.spacingMode=Rt.spacingModeFromString(this.getValue(o,"spacingMode","length")),s.rotateMode=Rt.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),s.offsetRotation=this.getValue(o,"rotation",0),s.position=this.getValue(o,"position",0),s.positionMode==u.PositionMode.Fixed&&(s.position*=e),s.spacing=this.getValue(o,"spacing",0),(s.spacingMode==mt.Length||s.spacingMode==mt.Fixed)&&(s.spacing*=e),s.rotateMix=this.getValue(o,"rotateMix",1),s.translateMix=this.getValue(o,"translateMix",1),i.pathConstraints.push(s)}if(n.skins)for(const d in n.skins){const o=n.skins[d],s=new fe(d);for(const r in o){const h=i.findSlotIndex(r);if(h==-1)throw new Error(`Slot not found: ${r}`);const m=o[r];for(const f in m){const c=this.readAttachment(m[f],s,h,f,i);c!=null&&s.addAttachment(h,f,c)}}i.skins.push(s),s.name=="default"&&(i.defaultSkin=s)}for(let d=0,o=this.linkedMeshes.length;d<o;d++){const s=this.linkedMeshes[d],r=s.skin==null?i.defaultSkin:i.findSkin(s.skin);if(r==null)throw new Error(`Skin not found: ${s.skin}`);const h=r.getAttachment(s.slotIndex,s.parent);if(h==null)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,n.events)for(const d in n.events){const o=n.events[d],s=new re(d);s.intValue=this.getValue(o,"int",0),s.floatValue=this.getValue(o,"float",0),s.stringValue=this.getValue(o,"string",""),s.audioPath=this.getValue(o,"audio",null),s.audioPath!=null&&(s.volume=this.getValue(o,"volume",1),s.balance=this.getValue(o,"balance",0)),i.events.push(s)}if(n.animations)for(const d in n.animations){const o=n.animations[d];this.readAnimation(o,d,i)}return i}readAttachment(t,e,i,n,l){const d=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",n),s=this.attachmentLoader.newRegionAttachment(e,n,o);if(s==null)return null;s.path=o,s.x=this.getValue(t,"x",0)*d,s.y=this.getValue(t,"y",0)*d,s.scaleX=this.getValue(t,"scaleX",1),s.scaleY=this.getValue(t,"scaleY",1),s.rotation=this.getValue(t,"rotation",0),s.width=t.width*d,s.height=t.height*d;const r=this.getValue(t,"color",null);return r!=null&&s.color.setFromString(r),s}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const s=this.getValue(t,"color",null);return s!=null&&o.color.setFromString(s),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",n),s=this.attachmentLoader.newMeshAttachment(e,n,o);if(s==null)return null;s.path=o;const r=this.getValue(t,"color",null);r!=null&&s.color.setFromString(r);const h=this.getValue(t,"parent",null);if(h!=null)return s.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new Ie(s,this.getValue(t,"skin",null),i,h)),s;const m=t.uvs;return this.readVertices(t,s,m.length),s.triangles=t.triangles,s.regionUVs=new Float32Array(m),s.hullLength=this.getValue(t,"hull",0)*2,s}case"path":{const o=this.attachmentLoader.newPathAttachment(e,n);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,o,s<<1);const r=u.Utils.newArray(s/3,0);for(let m=0;m<t.lengths.length;m++)r[m]=t.lengths[m]*d;o.lengths=r;const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}case"point":{const o=this.attachmentLoader.newPointAttachment(e,n);if(o==null)return null;o.x=this.getValue(t,"x",0)*d,o.y=this.getValue(t,"y",0)*d,o.rotation=this.getValue(t,"rotation",0);const s=this.getValue(t,"color",null);return s!=null&&o.color.setFromString(s),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(e,n);if(o==null)return null;const s=this.getValue(t,"end",null);if(s!=null){const m=l.findSlot(s);if(m==null)throw new Error(`Clipping end slot not found: ${s}`);o.endSlot=m}const r=t.vertexCount;this.readVertices(t,o,r<<1);const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}}return null}readVertices(t,e,i){const n=this.scale;e.worldVerticesLength=i;const l=t.vertices;if(i==l.length){const s=u.Utils.toFloatArray(l);if(n!=1)for(let r=0,h=l.length;r<h;r++)s[r]*=n;e.vertices=s;return}const d=new Array,o=new Array;for(let s=0,r=l.length;s<r;){const h=l[s++];o.push(h);for(let m=s+h*4;s<m;s+=4)o.push(l[s]),d.push(l[s+1]*n),d.push(l[s+2]*n),d.push(l[s+3])}e.bones=o,e.vertices=u.Utils.toFloatArray(d)}readAnimation(t,e,i){const n=this.scale,l=new Array;let d=0;if(t.slots)for(const s in t.slots){const r=t.slots[s],h=i.findSlotIndex(s);if(h==-1)throw new Error(`Slot not found: ${s}`);for(const m in r){const f=r[m];if(m=="attachment"){const c=new kt(f.length);c.slotIndex=h;let g=0;for(let M=0;M<f.length;M++){const E=f[M];c.setFrame(g++,E.time,E.name)}l.push(c),d=Math.max(d,c.frames[c.getFrameCount()-1])}else if(m=="color"){const c=new lt(f.length);c.slotIndex=h;let g=0;for(let M=0;M<f.length;M++){const E=f[M],p=new u.Color;p.setFromString(E.color||"ffffffff"),c.setFrame(g,E.time,p.r,p.g,p.b,p.a),this.readCurve(E,c,g),g++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*lt.ENTRIES])}else if(m=="twoColor"){const c=new G(f.length);c.slotIndex=h;let g=0;for(let M=0;M<f.length;M++){const E=f[M],p=new u.Color,R=new u.Color;p.setFromString(E.light),R.setFromString(E.dark),c.setFrame(g,E.time,p.r,p.g,p.b,p.a,R.r,R.g,R.b),this.readCurve(E,c,g),g++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*G.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${m} (${s})`)}}if(t.bones)for(const s in t.bones){const r=t.bones[s],h=i.findBoneIndex(s);if(h==-1)throw new Error(`Bone not found: ${s}`);for(const m in r){const f=r[m];if(m==="rotate"){const c=new J(f.length);c.boneIndex=h;let g=0;for(let M=0;M<f.length;M++){const E=f[M];c.setFrame(g,E.time,E.angle),this.readCurve(E,c,g),g++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*J.ENTRIES])}else if(m==="translate"||m==="scale"||m==="shear"){let c=null,g=1;m==="scale"?c=new rt(f.length):m==="shear"?c=new ot(f.length):(c=new dt(f.length),g=n),c.boneIndex=h;let M=0;for(let E=0;E<f.length;E++){const p=f[E],R=this.getValue(p,"x",0),T=this.getValue(p,"y",0);c.setFrame(M,p.time,R*g,T*g),this.readCurve(p,c,M),M++}l.push(c),d=Math.max(d,c.frames[(c.getFrameCount()-1)*dt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${m} (${s})`)}}if(t.ik)for(const s in t.ik){const r=t.ik[s],h=i.findIkConstraint(s),m=new ht(r.length);m.ikConstraintIndex=i.ikConstraints.indexOf(h);let f=0;for(let c=0;c<r.length;c++){const g=r[c];m.setFrame(f,g.time,this.getValue(g,"mix",1),this.getValue(g,"bendPositive",!0)?1:-1,this.getValue(g,"compress",!1),this.getValue(g,"stretch",!1)),this.readCurve(g,m,f),f++}l.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*ht.ENTRIES])}if(t.transform)for(const s in t.transform){const r=t.transform[s],h=i.findTransformConstraint(s),m=new ct(r.length);m.transformConstraintIndex=i.transformConstraints.indexOf(h);let f=0;for(let c=0;c<r.length;c++){const g=r[c];m.setFrame(f,g.time,this.getValue(g,"rotateMix",1),this.getValue(g,"translateMix",1),this.getValue(g,"scaleMix",1),this.getValue(g,"shearMix",1)),this.readCurve(g,m,f),f++}l.push(m),d=Math.max(d,m.frames[(m.getFrameCount()-1)*ct.ENTRIES])}if(t.paths)for(const s in t.paths){const r=t.paths[s],h=i.findPathConstraintIndex(s);if(h==-1)throw new Error(`Path constraint not found: ${s}`);const m=i.pathConstraints[h];for(const f in r){const c=r[f];if(f==="position"||f==="spacing"){let g=null,M=1;f==="spacing"?(g=new ft(c.length),(m.spacingMode==mt.Length||m.spacingMode==mt.Fixed)&&(M=n)):(g=new wt(c.length),m.positionMode==u.PositionMode.Fixed&&(M=n)),g.pathConstraintIndex=h;let E=0;for(let p=0;p<c.length;p++){const R=c[p];g.setFrame(E,R.time,this.getValue(R,f,0)*M),this.readCurve(R,g,E),E++}l.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*wt.ENTRIES])}else if(f==="mix"){const g=new pt(c.length);g.pathConstraintIndex=h;let M=0;for(let E=0;E<c.length;E++){const p=c[E];g.setFrame(M,p.time,this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1)),this.readCurve(p,g,M),M++}l.push(g),d=Math.max(d,g.frames[(g.getFrameCount()-1)*pt.ENTRIES])}}}if(t.deform)for(const s in t.deform){const r=t.deform[s],h=i.findSkin(s);if(h==null){if(u.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${s}`);continue}for(const m in r){const f=r[m],c=i.findSlotIndex(m);if(c==-1)throw new Error(`Slot not found: ${f.name}`);for(const g in f){const M=f[g],E=h.getAttachment(c,g);if(E==null)throw new Error(`Deform attachment not found: ${M.name}`);const p=E.bones!=null,R=E.vertices,T=p?R.length/3*2:R.length,w=new ne(M.length);w.slotIndex=c,w.attachment=E;let S=0;for(let x=0;x<M.length;x++){const A=M[x];let y;const I=this.getValue(A,"vertices",null);if(I==null)y=p?u.Utils.newFloatArray(T):R;else{y=u.Utils.newFloatArray(T);const Y=this.getValue(A,"offset",0);if(u.Utils.arrayCopy(I,0,y,Y,I.length),n!=1)for(let B=Y,L=B+I.length;B<L;B++)y[B]*=n;if(!p)for(let B=0;B<T;B++)y[B]+=R[B]}w.setFrame(S,A.time,y),this.readCurve(A,w,S),S++}l.push(w),d=Math.max(d,w.frames[w.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const s=new Bt(o.length),r=i.slots.length;let h=0;for(let m=0;m<o.length;m++){const f=o[m];let c=null;const g=this.getValue(f,"offsets",null);if(g!=null){c=u.Utils.newArray(r,-1);const M=u.Utils.newArray(r-g.length,0);let E=0,p=0;for(let R=0;R<g.length;R++){const T=g[R],w=i.findSlotIndex(T.slot);if(w==-1)throw new Error(`Slot not found: ${T.slot}`);for(;E!=w;)M[p++]=E++;c[E+T.offset]=E++}for(;E<r;)M[p++]=E++;for(let R=r-1;R>=0;R--)c[R]==-1&&(c[R]=M[--p])}s.setFrame(h++,f.time,c)}l.push(s),d=Math.max(d,s.frames[s.getFrameCount()-1])}if(t.events){const s=new se(t.events.length);let r=0;for(let h=0;h<t.events.length;h++){const m=t.events[h],f=i.findEvent(m.name);if(f==null)throw new Error(`Event not found: ${m.name}`);const c=new ae(u.Utils.toSinglePrecision(m.time),f);c.intValue=this.getValue(m,"int",f.intValue),c.floatValue=this.getValue(m,"float",f.floatValue),c.stringValue=this.getValue(m,"string",f.stringValue),c.data.audioPath!=null&&(c.volume=this.getValue(m,"volume",1),c.balance=this.getValue(m,"balance",0)),s.setFrame(r++,c)}l.push(s),d=Math.max(d,s.frames[s.getFrameCount()-1])}if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");i.animations.push(new j(e,l,d))}readCurve(t,e,i){if(t.curve){if(t.curve==="stepped")e.setStepped(i);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const n=t.curve;e.setCurve(i,n[0],n[1],n[2],n[3])}}}getValue(t,e,i){return t[e]!==void 0?t[e]:i}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return It.BLEND_MODES.NORMAL;if(t=="additive")return It.BLEND_MODES.ADD;if(t=="multiply")return It.BLEND_MODES.MULTIPLY;if(t=="screen")return It.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return u.PositionMode.Fixed;if(t=="percent")return u.PositionMode.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return mt.Length;if(t=="fixed")return mt.Fixed;if(t=="percent")return mt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return u.RotateMode.Tangent;if(t=="chain")return u.RotateMode.Chain;if(t=="chainscale")return u.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return u.TransformMode.Normal;if(t=="onlytranslation")return u.TransformMode.OnlyTranslation;if(t=="norotationorreflection")return u.TransformMode.NoRotationOrReflection;if(t=="noscale")return u.TransformMode.NoScale;if(t=="noscaleorreflection")return u.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ie{constructor(t,e,i,n){this.mesh=t,this.skin=e,this.slotIndex=i,this.parent=n}}class Ce extends u.SpineBase{createSkeleton(t){this.skeleton=new qt(t),this.skeleton.updateWorldTransform(),this.stateData=new Wt(t),this.state=new gt(this.stateData)}}return C.Animation=j,C.AnimationState=gt,C.AnimationStateAdapter2=Ae,C.AnimationStateData=Wt,C.AtlasAttachmentLoader=Se,C.Attachment=Ut,C.AttachmentTimeline=kt,C.Bone=bt,C.BoneData=ie,C.BoundingBoxAttachment=Zt,C.ClippingAttachment=zt,C.ColorTimeline=lt,C.CurveTimeline=st,C.DeformTimeline=ne,C.DrawOrderTimeline=Bt,C.Event=ae,C.EventData=re,C.EventQueue=_t,C.EventTimeline=se,C.EventType=it,C.IkConstraint=oe,C.IkConstraintData=le,C.IkConstraintTimeline=ht,C.JitterEffect=Re,C.MeshAttachment=vt,C.PathAttachment=Ct,C.PathConstraint=At,C.PathConstraintData=he,C.PathConstraintMixTimeline=pt,C.PathConstraintPositionTimeline=wt,C.PathConstraintSpacingTimeline=ft,C.PointAttachment=Qt,C.RegionAttachment=P,C.RotateTimeline=J,C.ScaleTimeline=rt,C.ShearTimeline=ot,C.Skeleton=qt,C.SkeletonBounds=ye,C.SkeletonData=de,C.SkeletonJson=Rt,C.Skin=fe,C.Slot=Ft,C.SlotData=ue,C.SpacingMode=mt,C.Spine=Ce,C.SwirlEffect=Jt,C.TimelineType=te,C.TrackEntry=Nt,C.TransformConstraint=ce,C.TransformConstraintData=me,C.TransformConstraintTimeline=ct,C.TranslateTimeline=dt,C.TwoColorTimeline=G,C.VertexAttachment=xt,C}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-3.7.js.map
