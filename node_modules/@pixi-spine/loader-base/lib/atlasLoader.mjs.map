{"version":3,"file":"atlasLoader.mjs","sources":["../src/atlasLoader.ts"],"sourcesContent":["import { TextureAtlas } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n\n        const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n        const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n        textureLoadedCallback(texture.baseTexture);\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n"],"names":[],"mappings":"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"}