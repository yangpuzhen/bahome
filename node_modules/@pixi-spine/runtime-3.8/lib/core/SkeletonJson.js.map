{"version":3,"file":"SkeletonJson.js","sources":["../../src/core/SkeletonJson.ts"],"sourcesContent":["import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport {\n    Animation,\n    AttachmentTimeline,\n    ColorTimeline,\n    CurveTimeline,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ShearTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TwoColorTimeline,\n} from './Animation';\nimport { ArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/**\n * @public\n */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            if (skeletonData.version.substr(0, 3) !== '3.8') {\n                const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            if (skeletonData.version === '3.8.75') {\n                const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = this.getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\n                data.skinRequired = this.getValue(boneMap, 'skin', false);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const slotName: string = slotMap.name;\n                const boneName: string = slotMap.bone;\n                const boneData = skeletonData.findBone(boneName);\n\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                const color: string = this.getValue(slotMap, 'color', null);\n\n                if (color != null) data.color.setFromString(color);\n\n                const dark: string = this.getValue(slotMap, 'dark', null);\n\n                if (dark != null) {\n                    data.darkColor = new Color(1, 1, 1, 1);\n                    data.darkColor.setFromString(dark);\n                }\n\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\n\n                data.mix = this.getValue(constraintMap, 'mix', 1);\n                data.softness = this.getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = this.getValue(constraintMap, 'compress', false);\n                data.stretch = this.getValue(constraintMap, 'stretch', false);\n                data.uniform = this.getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = this.getValue(constraintMap, 'local', false);\n                data.relative = this.getValue(constraintMap, 'relative', false);\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\n\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.position = this.getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\n\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = this.getValue(eventMap, 'int', 0);\n                data.floatValue = this.getValue(eventMap, 'float', 0);\n                data.stringValue = this.getValue(eventMap, 'string', '');\n                data.audioPath = this.getValue(eventMap, 'audio', null);\n                if (data.audioPath != null) {\n                    data.volume = this.getValue(eventMap, 'volume', 1);\n                    data.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = this.getValue(map, 'name', name);\n\n        const type = this.getValue(map, 'type', 'region');\n\n        switch (type) {\n            case 'region': {\n                const path = this.getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, 'x', 0) * scale;\n                region.y = this.getValue(map, 'y', 0) * scale;\n                region.scaleX = this.getValue(map, 'scaleX', 1);\n                region.scaleY = this.getValue(map, 'scaleY', 1);\n                region.rotation = this.getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = this.getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) mesh.color.setFromString(color);\n\n                mesh.width = this.getValue(map, 'width', 0) * scale;\n                mesh.height = this.getValue(map, 'height', 0) * scale;\n\n                const parent: string = this.getValue(map, 'parent', null);\n\n                if (parent != null) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent, this.getValue(map, 'deform', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.edges = this.getValue(map, 'edges', null);\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (path == null) return null;\n                path.closed = this.getValue(map, 'closed', false);\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (point == null) return null;\n                point.x = this.getValue(map, 'x', 0) * scale;\n                point.y = this.getValue(map, 'y', 0) * scale;\n                point.rotation = this.getValue(map, 'rotation', 0);\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (clip == null) return null;\n\n                const end = this.getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex++, this.getValue(valueMap, 'time', 0), valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else if (timelineName == 'color') {\n                        const timeline = new ColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const color = new Color();\n\n                            color.setFromString(valueMap.color || 'ffffffff');\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n                    } else if (timelineName == 'twoColor') {\n                        const timeline = new TwoColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const light = new Color();\n                            const dark = new Color();\n\n                            light.setFromString(valueMap.light);\n                            dark.setFromString(valueMap.dark);\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBoneIndex(boneName);\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n\n                    if (timelineName === 'rotate') {\n                        const timeline = new RotateTimeline(timelineMap.length);\n\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'angle', 0));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n                        let defaultValue = 0;\n\n                        if (timelineName === 'scale') {\n                            timeline = new ScaleTimeline(timelineMap.length);\n                            defaultValue = 1;\n                        } else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const x = this.getValue(valueMap, 'x', defaultValue);\n                            const y = this.getValue(valueMap, 'y', defaultValue);\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const timeline = new IkConstraintTimeline(constraintMap.length);\n\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        this.getValue(valueMap, 'time', 0),\n                        this.getValue(valueMap, 'mix', 1),\n                        this.getValue(valueMap, 'softness', 0) * scale,\n                        this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\n                        this.getValue(valueMap, 'compress', false),\n                        this.getValue(valueMap, 'stretch', false)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const constraintMap = map.transform[constraintName];\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\n\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        this.getValue(valueMap, 'time', 0),\n                        this.getValue(valueMap, 'rotateMix', 1),\n                        this.getValue(valueMap, 'translateMix', 1),\n                        this.getValue(valueMap, 'scaleMix', 1),\n                        this.getValue(valueMap, 'shearMix', 1)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const index = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const data = skeletonData.pathConstraints[index];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n\n                    if (timelineName === 'position' || timelineName === 'spacing') {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'spacing') {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\n\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n                        const weighted = attachment.bones != null;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            const valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            const verticesValue: Array<Number> = this.getValue(valueMap, 'vertices', null);\n\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\n            const slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                const drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let i = 0; i < offsets.length; i++) {\n                        const offsetMap = offsets[i];\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n\n            for (let i = 0; i < map.events.length; i++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath != null) {\n                    event.volume = this.getValue(eventMap, 'volume', 1);\n                    event.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.hasOwnProperty('curve')) return;\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\n        else {\n            const curve: number = map.curve;\n\n            timeline.setCurve(frameIndex, curve, this.getValue(map, 'c2', 0), this.getValue(map, 'c3', 1), this.getValue(map, 'c4', 1));\n        }\n    }\n\n    getValue(map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'fixed') return PositionMode.Fixed;\n        if (str == 'percent') return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'length') return SpacingMode.Length;\n        if (str == 'fixed') return SpacingMode.Fixed;\n        if (str == 'percent') return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'tangent') return RotateMode.Tangent;\n        if (str == 'chain') return RotateMode.Chain;\n        if (str == 'chainscale') return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n\n    static transformModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return TransformMode.Normal;\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\n        if (str == 'noscale') return TransformMode.NoScale;\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\n        throw new Error(`Unknown transform mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n"],"names":["SkeletonData","BoneData","SlotData","Color","IkConstraintData","TransformConstraintData","PathConstraintData","PositionMode","SpacingMode","Skin","EventData","Utils","AttachmentTimeline","ColorTimeline","TwoColorTimeline","RotateTimeline","ScaleTimeline","ShearTimeline","TranslateTimeline","IkConstraintTimeline","TransformConstraintTimeline","PathConstraintSpacingTimeline","PathConstraintPositionTimeline","PathConstraintMixTimeline","settings","DeformTimeline","DrawOrderTimeline","EventTimeline","Event","Animation","BLEND_MODES","RotateMode","TransformMode"],"mappings":"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"}