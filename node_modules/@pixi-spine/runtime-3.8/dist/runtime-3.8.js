/*!
 * @pixi-spine/runtime-3.8 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:36 UTC
 *
 * @pixi-spine/runtime-3.8 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine38=function(C,u,wt){"use strict";class Gt{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const me=class extends Gt{constructor(e){super(e),this.id=(me.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,s,n,i,l){s=i+(s>>1)*l;const c=e.bone.skeleton,o=e.deform;let a=this.vertices;const r=this.bones;if(r==null){o.length>0&&(a=o);const d=e.bone.matrix,g=d.tx,p=d.ty,w=d.a,M=d.c,E=d.b,x=d.d;for(let S=t,A=i;A<s;S+=2,A+=l){const I=a[S],T=a[S+1];n[A]=I*w+T*M+g,n[A+1]=I*E+T*x+p}return}let h=0,m=0;for(let d=0;d<t;d+=2){const g=r[h];h+=g+1,m+=g}const f=c.bones;if(o.length==0)for(let d=i,g=m*3;d<s;d+=l){let p=0,w=0,M=r[h++];for(M+=h;h<M;h++,g+=3){const E=f[r[h]].matrix,x=a[g],S=a[g+1],A=a[g+2];p+=(x*E.a+S*E.c+E.tx)*A,w+=(x*E.b+S*E.d+E.ty)*A}n[d]=p,n[d+1]=w}else{const d=o;for(let g=i,p=m*3,w=m<<1;g<s;g+=l){let M=0,E=0,x=r[h++];for(x+=h;h<x;h++,p+=3,w+=2){const S=f[r[h]].matrix,A=a[p]+d[w],I=a[p+1]+d[w+1],T=a[p+2];M+=(A*S.a+I*S.c+S.tx)*T,E+=(A*S.b+I*S.d+S.ty)*T}n[g]=M,n[g+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),u.Utils.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=u.Utils.newFloatArray(this.vertices.length),u.Utils.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let At=me;At.nextID=0;class Xt extends At{constructor(t){super(t),this.type=u.AttachmentType.BoundingBox,this.color=new u.Color(1,1,1,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Ot extends At{constructor(t){super(t),this.type=u.AttachmentType.Clipping,this.color=new u.Color(.2275,.2275,.8078,1)}copy(){const t=new Ot(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ct extends At{constructor(t){super(t),this.type=u.AttachmentType.Mesh,this.color=new u.Color(1,1,1,1),this.tempColor=new u.Color(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),u.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),u.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),u.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ct(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class kt extends At{constructor(t){super(t),this.type=u.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new u.Color(1,1,1,1)}copy(){const t=new kt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),u.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Yt extends At{constructor(t){super(t),this.type=u.AttachmentType.Point,this.color=new u.Color(.38,.94,0,1)}computeWorldPosition(t,s){const n=t.matrix;return s.x=this.x*n.a+this.y*n.c+t.worldX,s.y=this.x*n.b+this.y*n.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,n=u.MathUtils.cosDeg(this.rotation),i=u.MathUtils.sinDeg(this.rotation),l=n*s.a+i*s.c,c=n*s.b+i*s.d;return Math.atan2(c,l)*u.MathUtils.radDeg}copy(){const t=new Yt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class jt{constructor(t,s){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new u.Color,this.darkColor=t.darkColor==null?null:new u.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const K=class extends Gt{constructor(e){super(e),this.type=u.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new u.Color(1,1,1,1),this.offset=u.Utils.newFloatArray(8),this.uvs=u.Utils.newFloatArray(8),this.tempColor=new u.Color(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*e,n=-this.height/2*this.scaleY+this.region.offsetY*t,i=s+this.region.width*e,l=n+this.region.height*t,c=this.rotation*Math.PI/180,o=Math.cos(c),a=Math.sin(c),r=s*o+this.x,h=s*a,m=n*o+this.y,f=n*a,d=i*o+this.x,g=i*a,p=l*o+this.y,w=l*a,M=this.offset;M[K.OX1]=r-f,M[K.OY1]=m+h,M[K.OX2]=r-w,M[K.OY2]=p+h,M[K.OX3]=d-w,M[K.OY3]=p+g,M[K.OX4]=d-f,M[K.OY4]=m+g}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,s,n){const i=this.offset,l=e instanceof jt?e.bone.matrix:e.matrix,c=l.tx,o=l.ty,a=l.a,r=l.c,h=l.b,m=l.d;let f=0,d=0;f=i[K.OX1],d=i[K.OY1],t[s]=f*a+d*r+c,t[s+1]=f*h+d*m+o,s+=n,f=i[K.OX2],d=i[K.OY2],t[s]=f*a+d*r+c,t[s+1]=f*h+d*m+o,s+=n,f=i[K.OX3],d=i[K.OY3],t[s]=f*a+d*r+c,t[s+1]=f*h+d*m+o,s+=n,f=i[K.OX4],d=i[K.OY4],t[s]=f*a+d*r+c,t[s+1]=f*h+d*m+o}copy(){const e=new K(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,u.Utils.arrayCopy(this.uvs,0,e.uvs,0,8),u.Utils.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let B=K;B.OX1=0,B.OY1=1,B.OX2=2,B.OY2=3,B.OX3=4,B.OY3=5,B.OX4=6,B.OY4=7,B.X1=0,B.Y1=1,B.C1R=2,B.C1G=3,B.C1B=4,B.C1A=5,B.U1=6,B.V1=7,B.X2=8,B.Y2=9,B.C2R=10,B.C2G=11,B.C2B=12,B.C2A=13,B.U2=14,B.V2=15,B.X3=16,B.Y3=17,B.C3R=18,B.C3G=19,B.C3B=20,B.C3A=21,B.U3=22,B.V3=23,B.X4=24,B.Y4=25,B.C4R=26,B.C4G=27,B.C4B=28,B.C4A=29,B.U4=30,B.V4=31;class Ce{constructor(t,s){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=s}begin(t){}transform(t,s,n,i){t.x+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const fe=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,s,n){const i=this.angle*u.MathUtils.degreesToRadians,l=e.x-this.worldX,c=e.y-this.worldY,o=Math.sqrt(l*l+c*c);if(o<this.radius){const a=fe.interpolation.apply(0,i,(this.radius-o)/this.radius),r=Math.cos(a),h=Math.sin(a);e.x=r*l-h*c+this.worldX,e.y=h*l+r*c+this.worldY}}end(){}};let ge=fe;ge.interpolation=new u.PowOut(2);class j{constructor(t,s,n){if(t==null)throw new Error("name cannot be null.");if(s==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=s,this.timelineIds=[];for(let i=0;i<s.length;i++)this.timelineIds[s[i].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,s,n,i,l,c,o,a){if(t==null)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(n%=this.duration,s>0&&(s%=this.duration));const r=this.timelines;for(let h=0,m=r.length;h<m;h++)r[h].apply(t,s,n,l,c,o,a)}static binarySearch(t,s,n=1){let i=0,l=t.length/n-2;if(l==0)return n;let c=l>>>1;for(;;){if(t[(c+1)*n]<=s?i=c+1:l=c,i==l)return(i+1)*n;c=i+l>>>1}}static linearSearch(t,s,n){for(let i=0,l=t.length-n;i<=l;i+=n)if(t[i]>s)return i;return-1}}var pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(pe||{});const Z=class{constructor(e){if(e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=u.Utils.newFloatArray((e-1)*Z.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Z.BEZIER_SIZE+1}setLinear(e){this.curves[e*Z.BEZIER_SIZE]=Z.LINEAR}setStepped(e){this.curves[e*Z.BEZIER_SIZE]=Z.STEPPED}getCurveType(e){const t=e*Z.BEZIER_SIZE;if(t==this.curves.length)return Z.LINEAR;const s=this.curves[t];return s==Z.LINEAR?Z.LINEAR:s==Z.STEPPED?Z.STEPPED:Z.BEZIER}setCurve(e,t,s,n,i){const l=(-t*2+n)*.03,c=(-s*2+i)*.03,o=((t-n)*3+1)*.006,a=((s-i)*3+1)*.006;let r=l*2+o,h=c*2+a,m=t*.3+l+o*.16666667,f=s*.3+c+a*.16666667,d=e*Z.BEZIER_SIZE;const g=this.curves;g[d++]=Z.BEZIER;let p=m,w=f;for(let M=d+Z.BEZIER_SIZE-1;d<M;d+=2)g[d]=p,g[d+1]=w,m+=r,f+=h,r+=o,h+=a,p+=m,w+=f}getCurvePercent(e,t){t=u.MathUtils.clamp(t,0,1);const s=this.curves;let n=e*Z.BEZIER_SIZE;const i=s[n];if(i==Z.LINEAR)return t;if(i==Z.STEPPED)return 0;n++;let l=0;for(let o=n,a=n+Z.BEZIER_SIZE-1;n<a;n+=2)if(l=s[n],l>=t){let r,h;return n==o?(r=0,h=0):(r=s[n-2],h=s[n-1]),h+(s[n+1]-h)*(t-r)/(l-r)}const c=s[n-1];return c+(1-c)*(t-l)/(1-l)}};let lt=Z;lt.LINEAR=0,lt.STEPPED=1,lt.BEZIER=2,lt.BEZIER_SIZE=10*2-1;const Rt=class extends lt{constructor(t){super(t),this.frames=u.Utils.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,s,n){t<<=1,this.frames[t]=s,this.frames[t+Rt.ROTATION]=n}apply(t,s,n,i,l,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.rotation=r.data.rotation;return;case u.MixBlend.first:const p=r.data.rotation-r.rotation;r.rotation+=(p-(16384-(16384.499999999996-p/360|0))*360)*l}return}if(n>=a[a.length-Rt.ENTRIES]){let p=a[a.length+Rt.PREV_ROTATION];switch(c){case u.MixBlend.setup:r.rotation=r.data.rotation+p*l;break;case u.MixBlend.first:case u.MixBlend.replace:p+=r.data.rotation-r.rotation,p-=(16384-(16384.499999999996-p/360|0))*360;case u.MixBlend.add:r.rotation+=p*l}return}const h=j.binarySearch(a,n,Rt.ENTRIES),m=a[h+Rt.PREV_ROTATION],f=a[h],d=this.getCurvePercent((h>>1)-1,1-(n-f)/(a[h+Rt.PREV_TIME]-f));let g=a[h+Rt.ROTATION]-m;switch(g=m+(g-(16384-(16384.499999999996-g/360|0))*360)*d,c){case u.MixBlend.setup:r.rotation=r.data.rotation+(g-(16384-(16384.499999999996-g/360|0))*360)*l;break;case u.MixBlend.first:case u.MixBlend.replace:g+=r.data.rotation-r.rotation;case u.MixBlend.add:r.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*l}}};let tt=Rt;tt.ENTRIES=2,tt.PREV_TIME=-2,tt.PREV_ROTATION=-1,tt.ROTATION=1;const nt=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*nt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,s,n){e*=nt.ENTRIES,this.frames[e]=t,this.frames[e+nt.X]=s,this.frames[e+nt.Y]=n}apply(e,t,s,n,i,l,c){const o=this.frames,a=e.bones[this.boneIndex];if(!a.active)return;if(s<o[0]){switch(l){case u.MixBlend.setup:a.x=a.data.x,a.y=a.data.y;return;case u.MixBlend.first:a.x+=(a.data.x-a.x)*i,a.y+=(a.data.y-a.y)*i}return}let r=0,h=0;if(s>=o[o.length-nt.ENTRIES])r=o[o.length+nt.PREV_X],h=o[o.length+nt.PREV_Y];else{const m=j.binarySearch(o,s,nt.ENTRIES);r=o[m+nt.PREV_X],h=o[m+nt.PREV_Y];const f=o[m],d=this.getCurvePercent(m/nt.ENTRIES-1,1-(s-f)/(o[m+nt.PREV_TIME]-f));r+=(o[m+nt.X]-r)*d,h+=(o[m+nt.Y]-h)*d}switch(l){case u.MixBlend.setup:a.x=a.data.x+r*i,a.y=a.data.y+h*i;break;case u.MixBlend.first:case u.MixBlend.replace:a.x+=(a.data.x+r-a.x)*i,a.y+=(a.data.y+h-a.y)*i;break;case u.MixBlend.add:a.x+=r*i,a.y+=h*i}}};let mt=nt;mt.ENTRIES=3,mt.PREV_TIME=-3,mt.PREV_X=-2,mt.PREV_Y=-1,mt.X=1,mt.Y=2;class ht extends mt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,s,n,i,l,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.scaleX=r.data.scaleX,r.scaleY=r.data.scaleY;return;case u.MixBlend.first:r.scaleX+=(r.data.scaleX-r.scaleX)*l,r.scaleY+=(r.data.scaleY-r.scaleY)*l}return}let h=0,m=0;if(n>=a[a.length-ht.ENTRIES])h=a[a.length+ht.PREV_X]*r.data.scaleX,m=a[a.length+ht.PREV_Y]*r.data.scaleY;else{const f=j.binarySearch(a,n,ht.ENTRIES);h=a[f+ht.PREV_X],m=a[f+ht.PREV_Y];const d=a[f],g=this.getCurvePercent(f/ht.ENTRIES-1,1-(n-d)/(a[f+ht.PREV_TIME]-d));h=(h+(a[f+ht.X]-h)*g)*r.data.scaleX,m=(m+(a[f+ht.Y]-m)*g)*r.data.scaleY}if(l==1)c==u.MixBlend.add?(r.scaleX+=h-r.data.scaleX,r.scaleY+=m-r.data.scaleY):(r.scaleX=h,r.scaleY=m);else{let f=0,d=0;if(o==u.MixDirection.mixOut)switch(c){case u.MixBlend.setup:f=r.data.scaleX,d=r.data.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-f)*l,r.scaleY=d+(Math.abs(m)*u.MathUtils.signum(d)-d)*l;break;case u.MixBlend.first:case u.MixBlend.replace:f=r.scaleX,d=r.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-f)*l,r.scaleY=d+(Math.abs(m)*u.MathUtils.signum(d)-d)*l;break;case u.MixBlend.add:f=r.scaleX,d=r.scaleY,r.scaleX=f+(Math.abs(h)*u.MathUtils.signum(f)-r.data.scaleX)*l,r.scaleY=d+(Math.abs(m)*u.MathUtils.signum(d)-r.data.scaleY)*l}else switch(c){case u.MixBlend.setup:f=Math.abs(r.data.scaleX)*u.MathUtils.signum(h),d=Math.abs(r.data.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(h-f)*l,r.scaleY=d+(m-d)*l;break;case u.MixBlend.first:case u.MixBlend.replace:f=Math.abs(r.scaleX)*u.MathUtils.signum(h),d=Math.abs(r.scaleY)*u.MathUtils.signum(m),r.scaleX=f+(h-f)*l,r.scaleY=d+(m-d)*l;break;case u.MixBlend.add:f=u.MathUtils.signum(h),d=u.MathUtils.signum(m),r.scaleX=Math.abs(r.scaleX)*f+(h-Math.abs(r.data.scaleX)*f)*l,r.scaleY=Math.abs(r.scaleY)*d+(m-Math.abs(r.data.scaleY)*d)*l}}}}class ct extends mt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,s,n,i,l,c,o){const a=this.frames,r=t.bones[this.boneIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.shearX=r.data.shearX,r.shearY=r.data.shearY;return;case u.MixBlend.first:r.shearX+=(r.data.shearX-r.shearX)*l,r.shearY+=(r.data.shearY-r.shearY)*l}return}let h=0,m=0;if(n>=a[a.length-ct.ENTRIES])h=a[a.length+ct.PREV_X],m=a[a.length+ct.PREV_Y];else{const f=j.binarySearch(a,n,ct.ENTRIES);h=a[f+ct.PREV_X],m=a[f+ct.PREV_Y];const d=a[f],g=this.getCurvePercent(f/ct.ENTRIES-1,1-(n-d)/(a[f+ct.PREV_TIME]-d));h=h+(a[f+ct.X]-h)*g,m=m+(a[f+ct.Y]-m)*g}switch(c){case u.MixBlend.setup:r.shearX=r.data.shearX+h*l,r.shearY=r.data.shearY+m*l;break;case u.MixBlend.first:case u.MixBlend.replace:r.shearX+=(r.data.shearX+h-r.shearX)*l,r.shearY+=(r.data.shearY+m-r.shearY)*l;break;case u.MixBlend.add:r.shearX+=h*l,r.shearY+=m*l}}}const W=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*W.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,s,n,i,l){e*=W.ENTRIES,this.frames[e]=t,this.frames[e+W.R]=s,this.frames[e+W.G]=n,this.frames[e+W.B]=i,this.frames[e+W.A]=l}apply(e,t,s,n,i,l,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(s<a[0]){switch(l){case u.MixBlend.setup:o.color.setFromColor(o.data.color);return;case u.MixBlend.first:const d=o.color,g=o.data.color;d.add((g.r-d.r)*i,(g.g-d.g)*i,(g.b-d.b)*i,(g.a-d.a)*i)}return}let r=0,h=0,m=0,f=0;if(s>=a[a.length-W.ENTRIES]){const d=a.length;r=a[d+W.PREV_R],h=a[d+W.PREV_G],m=a[d+W.PREV_B],f=a[d+W.PREV_A]}else{const d=j.binarySearch(a,s,W.ENTRIES);r=a[d+W.PREV_R],h=a[d+W.PREV_G],m=a[d+W.PREV_B],f=a[d+W.PREV_A];const g=a[d],p=this.getCurvePercent(d/W.ENTRIES-1,1-(s-g)/(a[d+W.PREV_TIME]-g));r+=(a[d+W.R]-r)*p,h+=(a[d+W.G]-h)*p,m+=(a[d+W.B]-m)*p,f+=(a[d+W.A]-f)*p}if(i==1)o.color.set(r,h,m,f);else{const d=o.color;l==u.MixBlend.setup&&d.setFromColor(o.data.color),d.add((r-d.r)*i,(h-d.g)*i,(m-d.b)*i,(f-d.a)*i)}}};let st=W;st.ENTRIES=5,st.PREV_TIME=-5,st.PREV_R=-4,st.PREV_G=-3,st.PREV_B=-2,st.PREV_A=-1,st.R=1,st.G=2,st.B=3,st.A=4;const X=class extends lt{constructor(t){super(t),this.frames=u.Utils.newFloatArray(t*X.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,s,n,i,l,c,o,a,r){t*=X.ENTRIES,this.frames[t]=s,this.frames[t+X.R]=n,this.frames[t+X.G]=i,this.frames[t+X.B]=l,this.frames[t+X.A]=c,this.frames[t+X.R2]=o,this.frames[t+X.G2]=a,this.frames[t+X.B2]=r}apply(t,s,n,i,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const r=this.frames;if(n<r[0]){switch(c){case u.MixBlend.setup:a.color.setFromColor(a.data.color),a.darkColor.setFromColor(a.data.darkColor);return;case u.MixBlend.first:const M=a.color,E=a.darkColor,x=a.data.color,S=a.data.darkColor;M.add((x.r-M.r)*l,(x.g-M.g)*l,(x.b-M.b)*l,(x.a-M.a)*l),E.add((S.r-E.r)*l,(S.g-E.g)*l,(S.b-E.b)*l,0)}return}let h=0,m=0,f=0,d=0,g=0,p=0,w=0;if(n>=r[r.length-X.ENTRIES]){const M=r.length;h=r[M+X.PREV_R],m=r[M+X.PREV_G],f=r[M+X.PREV_B],d=r[M+X.PREV_A],g=r[M+X.PREV_R2],p=r[M+X.PREV_G2],w=r[M+X.PREV_B2]}else{const M=j.binarySearch(r,n,X.ENTRIES);h=r[M+X.PREV_R],m=r[M+X.PREV_G],f=r[M+X.PREV_B],d=r[M+X.PREV_A],g=r[M+X.PREV_R2],p=r[M+X.PREV_G2],w=r[M+X.PREV_B2];const E=r[M],x=this.getCurvePercent(M/X.ENTRIES-1,1-(n-E)/(r[M+X.PREV_TIME]-E));h+=(r[M+X.R]-h)*x,m+=(r[M+X.G]-m)*x,f+=(r[M+X.B]-f)*x,d+=(r[M+X.A]-d)*x,g+=(r[M+X.R2]-g)*x,p+=(r[M+X.G2]-p)*x,w+=(r[M+X.B2]-w)*x}if(l==1)a.color.set(h,m,f,d),a.darkColor.set(g,p,w,1);else{const M=a.color,E=a.darkColor;c==u.MixBlend.setup&&(M.setFromColor(a.data.color),E.setFromColor(a.data.darkColor)),M.add((h-M.r)*l,(m-M.g)*l,(f-M.b)*l,(d-M.a)*l),E.add((g-E.r)*l,(p-E.g)*l,(w-E.b)*l,0)}}};let z=X;z.ENTRIES=8,z.PREV_TIME=-8,z.PREV_R=-7,z.PREV_G=-6,z.PREV_B=-5,z.PREV_A=-4,z.PREV_R2=-3,z.PREV_G2=-2,z.PREV_B2=-1,z.R=1,z.G=2,z.B=3,z.A=4,z.R2=5,z.G2=6,z.B2=7;class Vt{constructor(t){this.frames=u.Utils.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.frames[t]=s,this.attachmentNames[t]=n}apply(t,s,n,i,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;if(o==u.MixDirection.mixOut){c==u.MixBlend.setup&&this.setAttachment(t,a,a.data.attachmentName);return}const r=this.frames;if(n<r[0]){(c==u.MixBlend.setup||c==u.MixBlend.first)&&this.setAttachment(t,a,a.data.attachmentName);return}let h=0;n>=r[r.length-1]?h=r.length-1:h=j.binarySearch(r,n,1)-1;const m=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(m==null?null:t.getAttachment(this.slotIndex,m))}setAttachment(t,s,n){s.setAttachment(n==null?null:t.getAttachment(this.slotIndex,n))}}let Me=null;class Zt extends lt{constructor(t){super(t),this.frames=u.Utils.newFloatArray(t),this.frameVertices=new Array(t),Me==null&&(Me=u.Utils.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,s,n){this.frames[t]=s,this.frameVertices[t]=n}apply(t,s,n,i,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const r=a.getAttachment();if(!(r instanceof At)||r.deformAttachment!=this.attachment)return;const h=a.deform;h.length==0&&(c=u.MixBlend.setup);const m=this.frameVertices,f=m[0].length,d=this.frames;if(n<d[0]){const S=r;switch(c){case u.MixBlend.setup:h.length=0;return;case u.MixBlend.first:if(l==1){h.length=0;break}const A=u.Utils.setArraySize(h,f);if(S.bones==null){const I=S.vertices;for(let T=0;T<f;T++)A[T]+=(I[T]-A[T])*l}else{l=1-l;for(let I=0;I<f;I++)A[I]*=l}}return}const g=u.Utils.setArraySize(h,f);if(n>=d[d.length-1]){const S=m[d.length-1];if(l==1)if(c==u.MixBlend.add){const A=r;if(A.bones==null){const I=A.vertices;for(let T=0;T<f;T++)g[T]+=S[T]-I[T]}else for(let I=0;I<f;I++)g[I]+=S[I]}else u.Utils.arrayCopy(S,0,g,0,f);else switch(c){case u.MixBlend.setup:{const I=r;if(I.bones==null){const T=I.vertices;for(let y=0;y<f;y++){const R=T[y];g[y]=R+(S[y]-R)*l}}else for(let T=0;T<f;T++)g[T]=S[T]*l;break}case u.MixBlend.first:case u.MixBlend.replace:for(let I=0;I<f;I++)g[I]+=(S[I]-g[I])*l;break;case u.MixBlend.add:const A=r;if(A.bones==null){const I=A.vertices;for(let T=0;T<f;T++)g[T]+=(S[T]-I[T])*l}else for(let I=0;I<f;I++)g[I]+=S[I]*l}return}const p=j.binarySearch(d,n),w=m[p-1],M=m[p],E=d[p],x=this.getCurvePercent(p-1,1-(n-E)/(d[p-1]-E));if(l==1)if(c==u.MixBlend.add){const S=r;if(S.bones==null){const A=S.vertices;for(let I=0;I<f;I++){const T=w[I];g[I]+=T+(M[I]-T)*x-A[I]}}else for(let A=0;A<f;A++){const I=w[A];g[A]+=I+(M[A]-I)*x}}else for(let S=0;S<f;S++){const A=w[S];g[S]=A+(M[S]-A)*x}else switch(c){case u.MixBlend.setup:{const A=r;if(A.bones==null){const I=A.vertices;for(let T=0;T<f;T++){const y=w[T],R=I[T];g[T]=R+(y+(M[T]-y)*x-R)*l}}else for(let I=0;I<f;I++){const T=w[I];g[I]=(T+(M[I]-T)*x)*l}break}case u.MixBlend.first:case u.MixBlend.replace:for(let A=0;A<f;A++){const I=w[A];g[A]+=(I+(M[A]-I)*x-g[A])*l}break;case u.MixBlend.add:const S=r;if(S.bones==null){const A=S.vertices;for(let I=0;I<f;I++){const T=w[I];g[I]+=(T+(M[I]-T)*x-A[I])*l}}else for(let A=0;A<f;A++){const I=w[A];g[A]+=(I+(M[A]-I)*x)*l}}}}class Lt{constructor(t){this.frames=u.Utils.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,s){this.frames[t]=s.time,this.events[t]=s}apply(t,s,n,i,l,c,o){if(i==null)return;const a=this.frames,r=this.frames.length;if(s>n)this.apply(t,s,Number.MAX_VALUE,i,l,c,o),s=-1;else if(s>=a[r-1])return;if(n<a[0])return;let h=0;if(s<a[0])h=0;else{h=j.binarySearch(a,s);const m=a[h];for(;h>0&&a[h-1]==m;)h--}for(;h<r&&n>=a[h];h++)i.push(this.events[h])}}class Bt{constructor(t){this.frames=u.Utils.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.frames[t]=s,this.drawOrders[t]=n}apply(t,s,n,i,l,c,o){const a=t.drawOrder,r=t.slots;if(o==u.MixDirection.mixOut&&c==u.MixBlend.setup){u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const h=this.frames;if(n<h[0]){(c==u.MixBlend.setup||c==u.MixBlend.first)&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let m=0;n>=h[h.length-1]?m=h.length-1:m=j.binarySearch(h,n)-1;const f=this.drawOrders[m];if(f==null)u.Utils.arrayCopy(r,0,a,0,r.length);else for(let d=0,g=f.length;d<g;d++)a[d]=r[f[d]]}}const O=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*O.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,s,n,i,l,c){e*=O.ENTRIES,this.frames[e]=t,this.frames[e+O.MIX]=s,this.frames[e+O.SOFTNESS]=n,this.frames[e+O.BEND_DIRECTION]=i,this.frames[e+O.COMPRESS]=l?1:0,this.frames[e+O.STRETCH]=c?1:0}apply(e,t,s,n,i,l,c){const o=this.frames,a=e.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case u.MixBlend.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case u.MixBlend.first:a.mix+=(a.data.mix-a.mix)*i,a.softness+=(a.data.softness-a.softness)*i,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=o[o.length-O.ENTRIES]){l==u.MixBlend.setup?(a.mix=a.data.mix+(o[o.length+O.PREV_MIX]-a.data.mix)*i,a.softness=a.data.softness+(o[o.length+O.PREV_SOFTNESS]-a.data.softness)*i,c==u.MixDirection.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[o.length+O.PREV_BEND_DIRECTION],a.compress=o[o.length+O.PREV_COMPRESS]!=0,a.stretch=o[o.length+O.PREV_STRETCH]!=0)):(a.mix+=(o[o.length+O.PREV_MIX]-a.mix)*i,a.softness+=(o[o.length+O.PREV_SOFTNESS]-a.softness)*i,c==u.MixDirection.mixIn&&(a.bendDirection=o[o.length+O.PREV_BEND_DIRECTION],a.compress=o[o.length+O.PREV_COMPRESS]!=0,a.stretch=o[o.length+O.PREV_STRETCH]!=0));return}const r=j.binarySearch(o,s,O.ENTRIES),h=o[r+O.PREV_MIX],m=o[r+O.PREV_SOFTNESS],f=o[r],d=this.getCurvePercent(r/O.ENTRIES-1,1-(s-f)/(o[r+O.PREV_TIME]-f));l==u.MixBlend.setup?(a.mix=a.data.mix+(h+(o[r+O.MIX]-h)*d-a.data.mix)*i,a.softness=a.data.softness+(m+(o[r+O.SOFTNESS]-m)*d-a.data.softness)*i,c==u.MixDirection.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[r+O.PREV_BEND_DIRECTION],a.compress=o[r+O.PREV_COMPRESS]!=0,a.stretch=o[r+O.PREV_STRETCH]!=0)):(a.mix+=(h+(o[r+O.MIX]-h)*d-a.mix)*i,a.softness+=(m+(o[r+O.SOFTNESS]-m)*d-a.softness)*i,c==u.MixDirection.mixIn&&(a.bendDirection=o[r+O.PREV_BEND_DIRECTION],a.compress=o[r+O.PREV_COMPRESS]!=0,a.stretch=o[r+O.PREV_STRETCH]!=0))}};let et=O;et.ENTRIES=6,et.PREV_TIME=-6,et.PREV_MIX=-5,et.PREV_SOFTNESS=-4,et.PREV_BEND_DIRECTION=-3,et.PREV_COMPRESS=-2,et.PREV_STRETCH=-1,et.MIX=1,et.SOFTNESS=2,et.BEND_DIRECTION=3,et.COMPRESS=4,et.STRETCH=5;const q=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,s,n,i,l){e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.ROTATE]=s,this.frames[e+q.TRANSLATE]=n,this.frames[e+q.SCALE]=i,this.frames[e+q.SHEAR]=l}apply(e,t,s,n,i,l,c){const o=this.frames,a=e.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(s<o[0]){const d=a.data;switch(l){case u.MixBlend.setup:a.rotateMix=d.rotateMix,a.translateMix=d.translateMix,a.scaleMix=d.scaleMix,a.shearMix=d.shearMix;return;case u.MixBlend.first:a.rotateMix+=(d.rotateMix-a.rotateMix)*i,a.translateMix+=(d.translateMix-a.translateMix)*i,a.scaleMix+=(d.scaleMix-a.scaleMix)*i,a.shearMix+=(d.shearMix-a.shearMix)*i}return}let r=0,h=0,m=0,f=0;if(s>=o[o.length-q.ENTRIES]){const d=o.length;r=o[d+q.PREV_ROTATE],h=o[d+q.PREV_TRANSLATE],m=o[d+q.PREV_SCALE],f=o[d+q.PREV_SHEAR]}else{const d=j.binarySearch(o,s,q.ENTRIES);r=o[d+q.PREV_ROTATE],h=o[d+q.PREV_TRANSLATE],m=o[d+q.PREV_SCALE],f=o[d+q.PREV_SHEAR];const g=o[d],p=this.getCurvePercent(d/q.ENTRIES-1,1-(s-g)/(o[d+q.PREV_TIME]-g));r+=(o[d+q.ROTATE]-r)*p,h+=(o[d+q.TRANSLATE]-h)*p,m+=(o[d+q.SCALE]-m)*p,f+=(o[d+q.SHEAR]-f)*p}if(l==u.MixBlend.setup){const d=a.data;a.rotateMix=d.rotateMix+(r-d.rotateMix)*i,a.translateMix=d.translateMix+(h-d.translateMix)*i,a.scaleMix=d.scaleMix+(m-d.scaleMix)*i,a.shearMix=d.shearMix+(f-d.shearMix)*i}else a.rotateMix+=(r-a.rotateMix)*i,a.translateMix+=(h-a.translateMix)*i,a.scaleMix+=(m-a.scaleMix)*i,a.shearMix+=(f-a.shearMix)*i}};let at=q;at.ENTRIES=5,at.PREV_TIME=-5,at.PREV_ROTATE=-4,at.PREV_TRANSLATE=-3,at.PREV_SCALE=-2,at.PREV_SHEAR=-1,at.ROTATE=1,at.TRANSLATE=2,at.SCALE=3,at.SHEAR=4;const pt=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*pt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,s){e*=pt.ENTRIES,this.frames[e]=t,this.frames[e+pt.VALUE]=s}apply(e,t,s,n,i,l,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case u.MixBlend.setup:a.position=a.data.position;return;case u.MixBlend.first:a.position+=(a.data.position-a.position)*i}return}let r=0;if(s>=o[o.length-pt.ENTRIES])r=o[o.length+pt.PREV_VALUE];else{const h=j.binarySearch(o,s,pt.ENTRIES);r=o[h+pt.PREV_VALUE];const m=o[h],f=this.getCurvePercent(h/pt.ENTRIES-1,1-(s-m)/(o[h+pt.PREV_TIME]-m));r+=(o[h+pt.VALUE]-r)*f}l==u.MixBlend.setup?a.position=a.data.position+(r-a.data.position)*i:a.position+=(r-a.position)*i}};let Et=pt;Et.ENTRIES=2,Et.PREV_TIME=-2,Et.PREV_VALUE=-1,Et.VALUE=1;class Mt extends Et{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,s,n,i,l,c,o){const a=this.frames,r=t.pathConstraints[this.pathConstraintIndex];if(!r.active)return;if(n<a[0]){switch(c){case u.MixBlend.setup:r.spacing=r.data.spacing;return;case u.MixBlend.first:r.spacing+=(r.data.spacing-r.spacing)*l}return}let h=0;if(n>=a[a.length-Mt.ENTRIES])h=a[a.length+Mt.PREV_VALUE];else{const m=j.binarySearch(a,n,Mt.ENTRIES);h=a[m+Mt.PREV_VALUE];const f=a[m],d=this.getCurvePercent(m/Mt.ENTRIES-1,1-(n-f)/(a[m+Mt.PREV_TIME]-f));h+=(a[m+Mt.VALUE]-h)*d}c==u.MixBlend.setup?r.spacing=r.data.spacing+(h-r.data.spacing)*l:r.spacing+=(h-r.spacing)*l}}const it=class extends lt{constructor(e){super(e),this.frames=u.Utils.newFloatArray(e*it.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,s,n){e*=it.ENTRIES,this.frames[e]=t,this.frames[e+it.ROTATE]=s,this.frames[e+it.TRANSLATE]=n}apply(e,t,s,n,i,l,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case u.MixBlend.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case u.MixBlend.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*i,a.translateMix+=(a.data.translateMix-a.translateMix)*i}return}let r=0,h=0;if(s>=o[o.length-it.ENTRIES])r=o[o.length+it.PREV_ROTATE],h=o[o.length+it.PREV_TRANSLATE];else{const m=j.binarySearch(o,s,it.ENTRIES);r=o[m+it.PREV_ROTATE],h=o[m+it.PREV_TRANSLATE];const f=o[m],d=this.getCurvePercent(m/it.ENTRIES-1,1-(s-f)/(o[m+it.PREV_TIME]-f));r+=(o[m+it.ROTATE]-r)*d,h+=(o[m+it.TRANSLATE]-h)*d}l==u.MixBlend.setup?(a.rotateMix=a.data.rotateMix+(r-a.data.rotateMix)*i,a.translateMix=a.data.translateMix+(h-a.data.translateMix)*i):(a.rotateMix+=(r-a.rotateMix)*i,a.translateMix+=(h-a.translateMix)*i)}};let xt=it;xt.ENTRIES=3,xt.PREV_TIME=-3,xt.PREV_ROTATE=-2,xt.PREV_TRANSLATE=-1,xt.ROTATE=1,xt.TRANSLATE=2;const $=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Qt(this),this.propertyIDs=new u.IntSet,this.animationsChanged=!1,this.trackEntryPool=new u.Pool(()=>new _t),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i==null)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let l=e*i.timeScale;if(i.delay>0){if(i.delay-=l,i.delay>0)continue;l=-i.delay,i.delay=0}let c=i.next;if(c!=null){const o=i.trackLast-c.delay;if(o>=0){for(c.delay=0,c.trackTime+=i.timeScale==0?0:(o/i.timeScale+e)*c.timeScale,i.trackTime+=l,this.setCurrent(s,c,!0);c.mixingFrom!=null;)c.mixTime+=e,c=c.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&i.mixingFrom==null){t[s]=null,this.queue.end(i),this.disposeNext(i);continue}if(i.mixingFrom!=null&&this.updateMixingFrom(i,e)){let o=i.mixingFrom;for(i.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}i.trackTime+=l}this.queue.drain()}updateMixingFrom(e,t){const s=e.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((s.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=e),e.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=t*s.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let n=!1;for(let c=0,o=s.length;c<o;c++){const a=s[c];if(a==null||a.delay>0)continue;n=!0;const r=c==0?u.MixBlend.first:a.mixBlend;let h=a.alpha;a.mixingFrom!=null?h*=this.applyMixingFrom(a,e,r):a.trackTime>=a.trackEnd&&a.next==null&&(h=0);const m=a.animationLast,f=a.getAnimationTime(),d=a.animation.timelines.length,g=a.animation.timelines;if(c==0&&h==1||r==u.MixBlend.add)for(let p=0;p<d;p++){u.Utils.webkit602BugfixHelper(h,r);const w=g[p];w instanceof Vt?this.applyAttachmentTimeline(w,e,f,r,!0):w.apply(e,m,f,t,h,r,u.MixDirection.mixIn)}else{const p=a.timelineMode,w=a.timelinesRotation.length==0;w&&u.Utils.setArraySize(a.timelinesRotation,d<<1,null);const M=a.timelinesRotation;for(let E=0;E<d;E++){const x=g[E],S=p[E]==$.SUBSEQUENT?r:u.MixBlend.setup;x instanceof tt?this.applyRotateTimeline(x,e,f,h,S,M,E<<1,w):x instanceof Vt?this.applyAttachmentTimeline(x,e,f,r,!0):(u.Utils.webkit602BugfixHelper(h,r),x.apply(e,m,f,t,h,S,u.MixDirection.mixIn))}}this.queueEvents(a,f),t.length=0,a.nextAnimationLast=f,a.nextTrackLast=a.trackTime}const i=this.unkeyedState+$.SETUP,l=e.slots;for(let c=0,o=e.slots.length;c<o;c++){const a=l[c];if(a.attachmentState==i){const r=a.data.attachmentName;a.setAttachment(r==null?null:e.getAttachment(a.data.index,r))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(e,t,s){const n=e.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,t,s);let i=0;e.mixDuration==0?(i=1,s==u.MixBlend.first&&(s=u.MixBlend.setup)):(i=e.mixTime/e.mixDuration,i>1&&(i=1),s!=u.MixBlend.first&&(s=n.mixBlend));const l=i<n.eventThreshold?this.events:null,c=i<n.attachmentThreshold,o=i<n.drawOrderThreshold,a=n.animationLast,r=n.getAnimationTime(),h=n.animation.timelines.length,m=n.animation.timelines,f=n.alpha*e.interruptAlpha,d=f*(1-i);if(s==u.MixBlend.add)for(let g=0;g<h;g++)m[g].apply(t,a,r,l,d,s,u.MixDirection.mixOut);else{const g=n.timelineMode,p=n.timelineHoldMix,w=n.timelinesRotation.length==0;w&&u.Utils.setArraySize(n.timelinesRotation,h<<1,null);const M=n.timelinesRotation;n.totalAlpha=0;for(let E=0;E<h;E++){const x=m[E];let S=u.MixDirection.mixOut,A,I=0;switch(g[E]){case $.SUBSEQUENT:if(!o&&x instanceof Bt)continue;A=s,I=d;break;case $.FIRST:A=u.MixBlend.setup,I=d;break;case $.HOLD_SUBSEQUENT:A=s,I=f;break;case $.HOLD_FIRST:A=u.MixBlend.setup,I=f;break;default:A=u.MixBlend.setup;const T=p[E];I=f*Math.max(0,1-T.mixTime/T.mixDuration);break}n.totalAlpha+=I,x instanceof tt?this.applyRotateTimeline(x,t,r,I,A,M,E<<1,w):x instanceof Vt?this.applyAttachmentTimeline(x,t,r,A,c):(u.Utils.webkit602BugfixHelper(I,s),o&&x instanceof Bt&&A==u.MixBlend.setup&&(S=u.MixDirection.mixIn),x.apply(t,a,r,l,I,A,S))}}return e.mixDuration>0&&this.queueEvents(n,r),this.events.length=0,n.nextAnimationLast=r,n.nextTrackLast=n.trackTime,i}applyAttachmentTimeline(e,t,s,n,i){const l=t.slots[e.slotIndex];if(!l.bone.active)return;const c=e.frames;if(s<c[0])(n==u.MixBlend.setup||n==u.MixBlend.first)&&this.setAttachment(t,l,l.data.attachmentName,i);else{let o;s>=c[c.length-1]?o=c.length-1:o=j.binarySearch(c,s)-1,this.setAttachment(t,l,e.attachmentNames[o],i)}l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+$.SETUP)}setAttachment(e,t,s,n){t.setAttachment(s==null?null:e.getAttachment(t.data.index,s)),n&&(t.attachmentState=this.unkeyedState+$.CURRENT)}applyRotateTimeline(e,t,s,n,i,l,c,o){if(o&&(l[c]=0),n==1){e.apply(t,0,s,null,1,i,u.MixDirection.mixIn);return}const a=e,r=a.frames,h=t.bones[a.boneIndex];if(!h.active)return;let m=0,f=0;if(s<r[0])switch(i){case u.MixBlend.setup:h.rotation=h.data.rotation;default:return;case u.MixBlend.first:m=h.rotation,f=h.data.rotation}else if(m=i==u.MixBlend.setup?h.data.rotation:h.rotation,s>=r[r.length-tt.ENTRIES])f=h.data.rotation+r[r.length+tt.PREV_ROTATION];else{const p=j.binarySearch(r,s,tt.ENTRIES),w=r[p+tt.PREV_ROTATION],M=r[p],E=a.getCurvePercent((p>>1)-1,1-(s-M)/(r[p+tt.PREV_TIME]-M));f=r[p+tt.ROTATION]-w,f-=(16384-(16384.499999999996-f/360|0))*360,f=w+f*E+h.data.rotation,f-=(16384-(16384.499999999996-f/360|0))*360}let d=0,g=f-m;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)d=l[c];else{let p=0,w=0;o?(p=0,w=g):(p=l[c],w=l[c+1]);const M=g>0;let E=p>=0;u.MathUtils.signum(w)!=u.MathUtils.signum(g)&&Math.abs(w)<=90&&(Math.abs(p)>180&&(p+=360*u.MathUtils.signum(p)),E=M),d=g+p-p%360,E!=M&&(d+=360*u.MathUtils.signum(p)),l[c]=d}l[c+1]=g,m+=d*n,h.rotation=m-(16384-(16384.499999999996-m/360|0))*360}queueEvents(e,t){const s=e.animationStart,n=e.animationEnd,i=n-s,l=e.trackLast%i,c=this.events;let o=0;const a=c.length;for(;o<a;o++){const h=c[o];if(h.time<l)break;h.time>n||this.queue.event(e,h)}let r=!1;for(e.loop?r=i==0||l>e.trackTime%i:r=t>=n&&e.animationLast<n,r&&this.queue.complete(e);o<a;o++)c[o].time<s||this.queue.event(e,c[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let s=t;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,s){const n=this.expandToIndex(e);this.tracks[e]=t,n!=null&&(s&&this.queue.interrupt(n),t.mixingFrom=n,n.mixingTo=t,t.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(t.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,s){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,n,s)}setAnimationWith(e,t,s){if(t==null)throw new Error("animation cannot be null.");let n=!0,i=this.expandToIndex(e);i!=null&&(i.nextTrackLast==-1?(this.tracks[e]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.disposeNext(i),i=i.mixingFrom,n=!1):this.disposeNext(i));const l=this.trackEntry(e,t,s,i);return this.setCurrent(e,l,n),this.queue.drain(),l}addAnimation(e,t,s,n){const i=this.data.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,i,s,n)}addAnimationWith(e,t,s,n){if(t==null)throw new Error("animation cannot be null.");let i=this.expandToIndex(e);if(i!=null)for(;i.next!=null;)i=i.next;const l=this.trackEntry(e,t,s,i);if(i==null)this.setCurrent(e,l,!0),this.queue.drain();else if(i.next=l,n<=0){const c=i.animationEnd-i.animationStart;c!=0?(i.loop?n+=c*(1+(i.trackTime/c|0)):n+=Math.max(c,i.trackTime),n-=this.data.getMix(i.animation,t)):n=i.trackTime}return l.delay=n,l}setEmptyAnimation(e,t){const s=this.setAnimationWith(e,$.emptyAnimation,!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(e,t,s){s<=0&&(s-=t);const n=this.addAnimationWith(e,$.emptyAnimation,!1,s);return n.mixDuration=t,n.trackEnd=t,n}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const i=this.tracks[s];i!=null&&this.setEmptyAnimation(i.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(u.Utils.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,s,n){const i=this.trackEntryPool.obtain();return i.trackIndex=e,i.animation=t,i.loop=s,i.holdPrevious=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=t.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.interruptAlpha=1,i.mixTime=0,i.mixDuration=n==null?0:this.data.getMix(n.animation,t),i.mixBlend=u.MixBlend.replace,i}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let s=this.tracks[e];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=u.MixBlend.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(e){const t=e.mixingTo,s=e.animation.timelines,n=e.animation.timelines.length,i=u.Utils.setArraySize(e.timelineMode,n);e.timelineHoldMix.length=0;const l=u.Utils.setArraySize(e.timelineHoldMix,n),c=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<n;o++)i[o]=c.add(s[o].getPropertyId())?$.HOLD_FIRST:$.HOLD_SUBSEQUENT;return}t:for(let o=0;o<n;o++){const a=s[o],r=a.getPropertyId();if(!c.add(r))i[o]=$.SUBSEQUENT;else if(t==null||a instanceof Vt||a instanceof Bt||a instanceof Lt||!t.animation.hasTimeline(r))i[o]=$.FIRST;else{for(let h=t.mixingTo;h!=null;h=h.mixingTo)if(!h.animation.hasTimeline(r)){if(e.mixDuration>0){i[o]=$.HOLD_MIX,l[o]=h;continue t}break}i[o]=$.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,s){$.deprecatedWarning1||($.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,s)}addAnimationByName(e,t,s,n){$.deprecatedWarning2||($.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,s,n)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return $.deprecatedWarning3||($.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let ft=$;ft.emptyAnimation=new j("<empty>",[],0),ft.SUBSEQUENT=0,ft.FIRST=1,ft.HOLD_SUBSEQUENT=2,ft.HOLD_FIRST=3,ft.HOLD_MIX=4,ft.SETUP=1,ft.CURRENT=2,ft.deprecatedWarning1=!1,ft.deprecatedWarning2=!1,ft.deprecatedWarning3=!1;const St=class{constructor(){this.mixBlend=u.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){St.deprecatedWarning1||(St.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){St.deprecatedWarning2||(St.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let _t=St;_t.deprecatedWarning1=!1,_t.deprecatedWarning2=!1;const zt=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(dt.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(dt.interrupt),this.objects.push(e)}end(e){this.objects.push(dt.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(dt.dispose),this.objects.push(e)}complete(e){this.objects.push(dt.complete),this.objects.push(e)}event(e,t){this.objects.push(dt.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return zt.deprecatedWarning1||(zt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let s=0;s<e.length;s+=2){const n=e[s],i=e[s+1];switch(n){case dt.start:i.listener!=null&&i.listener.start&&i.listener.start(i);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(i);i.onStart&&this.deprecateStuff()&&i.onStart(i.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(i.trackIndex);break;case dt.interrupt:i.listener!=null&&i.listener.interrupt&&i.listener.interrupt(i);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(i);break;case dt.end:i.listener!=null&&i.listener.end&&i.listener.end(i);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(i);i.onEnd&&this.deprecateStuff()&&i.onEnd(i.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(i.trackIndex);case dt.dispose:i.listener!=null&&i.listener.dispose&&i.listener.dispose(i);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(i);this.animState.trackEntryPool.free(i);break;case dt.complete:i.listener!=null&&i.listener.complete&&i.listener.complete(i);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(i);const l=u.MathUtils.toInt(i.loopsCount());i.onComplete&&this.deprecateStuff()&&i.onComplete(i.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(i.trackIndex,l);break;case dt.event:const c=e[s+++2];i.listener!=null&&i.listener.event&&i.listener.event(i,c);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(i,c);i.onEvent&&this.deprecateStuff()&&i.onEvent(i.trackIndex,c),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(i.trackIndex,c);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let Qt=zt;Qt.deprecatedWarning1=!1;var dt=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(dt||{});class ke{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const Kt=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,s){const n=this.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);const i=this.skeletonData.findAnimation(t);if(i==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(n,i,s)}setMixByName(e,t,s){Kt.deprecatedWarning1||(Kt.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,s)}setMixWith(e,t,s){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const n=`${e.name}.${t.name}`;this.animationToMixTime[n]=s}getMix(e,t){const s=`${e.name}.${t.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};let Jt=Kt;Jt.deprecatedWarning1=!1;class Ve{constructor(t){this.atlas=t}newRegionAttachment(t,s,n){const i=this.atlas.findRegion(n);if(i==null)throw new Error(`Region not found in atlas: ${n} (region attachment: ${s})`);const l=new B(s);return l.region=i,l}newMeshAttachment(t,s,n){const i=this.atlas.findRegion(n);if(i==null)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${s})`);const l=new Ct(s);return l.region=i,l}newBoundingBoxAttachment(t,s){return new Xt(s)}newPathAttachment(t,s){return new kt(s)}newPointAttachment(t,s){return new Yt(s)}newClippingAttachment(t,s){return new Ot(s)}}class te{constructor(t,s,n){if(this.matrix=new wt.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,n,i,l,c,o){this.ax=t,this.ay=s,this.arotation=n,this.ascaleX=i,this.ascaleY=l,this.ashearX=c,this.ashearY=o,this.appliedValid=!0;const a=this.parent,r=this.matrix,h=this.skeleton.scaleX,m=u.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(a==null){const w=this.skeleton,M=n+90+o;r.a=u.MathUtils.cosDeg(n+c)*i*h,r.c=u.MathUtils.cosDeg(M)*l*h,r.b=u.MathUtils.sinDeg(n+c)*i*m,r.d=u.MathUtils.sinDeg(M)*l*m,r.tx=t*h+w.x,r.ty=s*m+w.y;return}let f=a.matrix.a,d=a.matrix.c,g=a.matrix.b,p=a.matrix.d;switch(r.tx=f*t+d*s+a.matrix.tx,r.ty=g*t+p*s+a.matrix.ty,this.data.transformMode){case u.TransformMode.Normal:{const w=n+90+o,M=u.MathUtils.cosDeg(n+c)*i,E=u.MathUtils.cosDeg(w)*l,x=u.MathUtils.sinDeg(n+c)*i,S=u.MathUtils.sinDeg(w)*l;r.a=f*M+d*x,r.c=f*E+d*S,r.b=g*M+p*x,r.d=g*E+p*S;return}case u.TransformMode.OnlyTranslation:{const w=n+90+o;r.a=u.MathUtils.cosDeg(n+c)*i,r.c=u.MathUtils.cosDeg(w)*l,r.b=u.MathUtils.sinDeg(n+c)*i,r.d=u.MathUtils.sinDeg(w)*l;break}case u.TransformMode.NoRotationOrReflection:{let w=f*f+g*g,M=0;w>1e-4?(w=Math.abs(f*p-d*g)/w,f/=this.skeleton.scaleX,g/=this.skeleton.scaleY,d=g*w,p=f*w,M=Math.atan2(g,f)*u.MathUtils.radDeg):(f=0,g=0,M=90-Math.atan2(p,d)*u.MathUtils.radDeg);const E=n+c-M,x=n+o-M+90,S=u.MathUtils.cosDeg(E)*i,A=u.MathUtils.cosDeg(x)*l,I=u.MathUtils.sinDeg(E)*i,T=u.MathUtils.sinDeg(x)*l;r.a=f*S-d*I,r.c=f*A-d*T,r.b=g*S+p*I,r.d=g*A+p*T;break}case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:{const w=u.MathUtils.cosDeg(n),M=u.MathUtils.sinDeg(n);let E=(f*w+d*M)/h,x=(g*w+p*M)/m,S=Math.sqrt(E*E+x*x);S>1e-5&&(S=1/S),E*=S,x*=S,S=Math.sqrt(E*E+x*x),this.data.transformMode==u.TransformMode.NoScale&&f*p-d*g<0!=(u.settings.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(S=-S);const A=Math.PI/2+Math.atan2(x,E),I=Math.cos(A)*S,T=Math.sin(A)*S,y=u.MathUtils.cosDeg(c)*i,R=u.MathUtils.cosDeg(90+o)*l,k=u.MathUtils.sinDeg(c)*i,D=u.MathUtils.sinDeg(90+o)*l;r.a=E*y+I*k,r.c=E*R+I*D,r.b=x*y+T*k,r.d=x*R+T*D;break}}r.a*=h,r.c*=h,r.b*=m,r.d*=m}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*u.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*u.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,s=this.matrix;if(t==null){this.ax=s.tx,this.ay=s.ty,this.arotation=Math.atan2(s.b,s.a)*u.MathUtils.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*u.MathUtils.radDeg;return}const n=t.matrix,i=1/(n.a*n.d-n.b*n.c),l=s.tx-n.tx,c=s.ty-n.ty;this.ax=l*n.d*i-c*n.c*i,this.ay=c*n.a*i-l*n.b*i;const o=i*n.d,a=i*n.a,r=i*n.c,h=i*n.b,m=o*s.a-r*s.b,f=o*s.c-r*s.d,d=a*s.b-h*s.a,g=a*s.d-h*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+d*d),this.ascaleX>1e-4){const p=m*g-f*d;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(m*f+d*g,p)*u.MathUtils.radDeg,this.arotation=Math.atan2(d,m)*u.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,f)*u.MathUtils.radDeg}worldToLocal(t){const s=this.matrix,n=s.a,i=s.c,l=s.b,c=s.d,o=1/(n*c-i*l),a=t.x-s.tx,r=t.y-s.ty;return t.x=a*c*o-r*i*o,t.y=r*n*o-a*l*o,t}localToWorld(t){const s=this.matrix,n=t.x,i=t.y;return t.x=n*s.a+i*s.c+s.tx,t.y=n*s.b+i*s.d+s.ty,t}worldToLocalRotation(t){const s=u.MathUtils.sinDeg(t),n=u.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(i.a*s-i.b*n,i.d*n-i.c*s)*u.MathUtils.radDeg}localToWorldRotation(t){const s=u.MathUtils.sinDeg(t),n=u.MathUtils.cosDeg(t),i=this.matrix;return Math.atan2(n*i.b+s*i.d,n*i.a+s*i.c)*u.MathUtils.radDeg}rotateWorld(t){const s=this.matrix,n=s.a,i=s.c,l=s.b,c=s.d,o=u.MathUtils.cosDeg(t),a=u.MathUtils.sinDeg(t);s.a=o*n-a*l,s.c=o*i-a*c,s.b=a*n+o*l,s.d=a*i+o*c,this.appliedValid=!1}}class ee{constructor(t,s,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=u.TransformMode.Normal,this.skinRequired=!1,this.color=new u.Color,t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=n}}class bt{constructor(t,s,n){this.name=t,this.order=s,this.skinRequired=n}}class ne{constructor(t,s){if(s==null)throw new Error("data cannot be null.");this.time=t,this.data=s}}class se{constructor(t){this.name=t}}class xe{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,s,n,i,l,c,o){t.appliedValid||t.updateAppliedTransform();const a=t.parent.matrix,r=a.a;let h=a.c;const m=a.b;let f=a.d,d=-t.ashearX-t.arotation,g=0,p=0;switch(t.data.transformMode){case u.TransformMode.OnlyTranslation:g=s-t.worldX,p=n-t.worldY;break;case u.TransformMode.NoRotationOrReflection:const E=Math.abs(r*f-h*m)/(r*r+m*m),x=r/t.skeleton.scaleX,S=m/t.skeleton.scaleY;h=-S*E*t.skeleton.scaleX,f=x*E*t.skeleton.scaleY,d+=Math.atan2(S,x)*u.MathUtils.radDeg;default:const A=s-a.tx,I=n-a.ty,T=r*f-h*m;g=(A*f-I*h)/T-t.ax,p=(I*r-A*m)/T-t.ay}d+=Math.atan2(p,g)*u.MathUtils.radDeg,t.ascaleX<0&&(d+=180),d>180?d-=360:d<-180&&(d+=360);let w=t.ascaleX,M=t.ascaleY;if(i||l){switch(t.data.transformMode){case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:g=s-t.worldX,p=n-t.worldY}const E=t.data.length*w,x=Math.sqrt(g*g+p*p);if(i&&x<E||l&&x>E&&E>1e-4){const S=(x/E-1)*o+1;w*=S,c&&(M*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+d*o,w,M,t.ashearX,t.ashearY)}apply2(t,s,n,i,l,c,o,a){if(a==0){s.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),s.appliedValid||s.updateAppliedTransform();const r=t.ax,h=t.ay;let m=t.ascaleX,f=m,d=t.ascaleY,g=s.ascaleX;const p=t.matrix;let w=0,M=0,E=0;m<0?(m=-m,w=180,E=-1):(w=0,E=1),d<0&&(d=-d,E=-E),g<0?(g=-g,M=180):M=0;const x=s.ax;let S=0,A=0,I=0,T=p.a,y=p.c,R=p.b,k=p.d;const D=Math.abs(m-d)<=1e-4;D?(S=s.ay,A=T*x+y*S+p.tx,I=R*x+k*S+p.ty):(S=0,A=T*x+p.tx,I=R*x+p.ty);const Y=t.parent.matrix;T=Y.a,y=Y.c,R=Y.b,k=Y.d;const L=1/(T*k-y*R);let P=A-Y.tx,F=I-Y.ty;const rt=(P*k-F*y)*L-r,ot=(F*T-P*R)*L-h,V=Math.sqrt(rt*rt+ot*ot);let v=s.data.length*g,U,b;if(V<1e-4){this.apply1(t,n,i,!1,c,!1,a),s.updateWorldTransformWith(x,S,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}P=n-Y.tx,F=i-Y.ty;let G=(P*k-F*y)*L-r,_=(F*T-P*R)*L-h,N=G*G+_*_;if(o!=0){o*=m*(g+1)/2;const ut=Math.sqrt(N),It=ut-V-v*m+o;if(It>0){let Tt=Math.min(1,It/(o*2))-1;Tt=(It-o*(1-Tt*Tt))/ut,G-=Tt*G,_-=Tt*_,N=G*G+_*_}}t:if(D){v*=m;let ut=(N-V*V-v*v)/(2*V*v);ut<-1?ut=-1:ut>1&&(ut=1,c&&(f*=(Math.sqrt(N)/(V+v)-1)*a+1)),b=Math.acos(ut)*l,T=V+v*ut,y=v*Math.sin(b),U=Math.atan2(_*T-G*y,G*T+_*y)}else{T=m*v,y=d*v;const ut=T*T,It=y*y,Tt=Math.atan2(_,G);R=It*V*V+ut*N-ut*It;const qt=-2*It*V,we=It-ut;if(k=qt*qt-4*we*R,k>=0){let vt=Math.sqrt(k);qt<0&&(vt=-vt),vt=-(qt+vt)/2;const Re=vt/we,ye=R/vt,Ut=Math.abs(Re)<Math.abs(ye)?Re:ye;if(Ut*Ut<=N){F=Math.sqrt(N-Ut*Ut)*l,U=Tt-Math.atan2(F,Ut),b=Math.atan2(F/d,(Ut-V)/m);break t}}let Se=u.MathUtils.PI,$t=V-T,de=$t*$t,Ie=0,Te=0,Ht=V+T,ue=Ht*Ht,Ae=0;R=-T*V/(ut-It),R>=-1&&R<=1&&(R=Math.acos(R),P=T*Math.cos(R)+V,F=y*Math.sin(R),k=P*P+F*F,k<de&&(Se=R,de=k,$t=P,Ie=F),k>ue&&(Te=R,ue=k,Ht=P,Ae=F)),N<=(de+ue)/2?(U=Tt-Math.atan2(Ie*l,$t),b=Se*l):(U=Tt-Math.atan2(Ae*l,Ht),b=Te*l)}const gt=Math.atan2(S,x)*E;let yt=t.arotation;U=(U-gt)*u.MathUtils.radDeg+w-yt,U>180?U-=360:U<-180&&(U+=360),t.updateWorldTransformWith(r,h,yt+U*a,f,t.ascaleY,0,0),yt=s.arotation,b=((b+gt)*u.MathUtils.radDeg-s.ashearX)*E+M-yt,b>180?b-=360:b<-180&&(b+=360),s.updateWorldTransformWith(x,S,yt+b*a,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class ae extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ie extends bt{constructor(t){super(t,0,!1),this.bones=new Array}}var J=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(J||{});const Pt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let s=0,n=e.bones.length;s<n;s++)this.bones.push(t.findBone(e.bones[s].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof kt))return;const t=this.rotateMix,s=this.translateMix,n=s>0,i=t>0;if(!n&&!i)return;const l=this.data,c=l.spacingMode,o=c==J.Length,a=l.rotateMode,r=a==u.RotateMode.Tangent,h=a==u.RotateMode.ChainScale,m=this.bones.length,f=r?m:m+1,d=this.bones,g=u.Utils.setArraySize(this.spaces,f);let p=null;const w=this.spacing;if(h||o){h&&(p=u.Utils.setArraySize(this.lengths,m));for(let I=0,T=f-1;I<T;){const y=d[I],R=y.data.length;if(R<Pt.epsilon)h&&(p[I]=0),g[++I]=0;else{const k=R*y.matrix.a,D=R*y.matrix.b,Y=Math.sqrt(k*k+D*D);h&&(p[I]=Y),g[++I]=(o?R+w:w)*Y/R}}}else for(let I=1;I<f;I++)g[I]=w;const M=this.computeWorldPositions(e,f,r,l.positionMode==u.PositionMode.Percent,c==J.Percent);let E=M[0],x=M[1],S=l.offsetRotation,A=!1;if(S==0)A=a==u.RotateMode.Chain;else{A=!1;const I=this.target.bone.matrix;S*=I.a*I.d-I.b*I.c>0?u.MathUtils.degRad:-u.MathUtils.degRad}for(let I=0,T=3;I<m;I++,T+=3){const y=d[I],R=y.matrix;R.tx+=(E-R.tx)*s,R.ty+=(x-R.ty)*s;const k=M[T],D=M[T+1],Y=k-E,L=D-x;if(h){const P=p[I];if(P!=0){const F=(Math.sqrt(Y*Y+L*L)/P-1)*t+1;R.a*=F,R.b*=F}}if(E=k,x=D,i){const P=R.a,F=R.c,rt=R.b,ot=R.d;let V=0,v=0,U=0;if(r&&(r?V=M[T-1]:g[I+1]==0?V=M[T+2]:V=Math.atan2(L,Y)),V-=Math.atan2(rt,P),A){v=Math.cos(V),U=Math.sin(V);const b=y.data.length;E+=(b*(v*P-U*rt)-Y)*t,x+=(b*(U*P+v*rt)-L)*t}else V+=S;V>u.MathUtils.PI?V-=u.MathUtils.PI2:V<-u.MathUtils.PI&&(V+=u.MathUtils.PI2),V*=t,v=Math.cos(V),U=Math.sin(V),R.a=v*P-U*rt,R.c=v*F-U*ot,R.b=U*P+v*rt,R.d=U*F+v*ot}y.appliedValid=!1}}computeWorldPositions(e,t,s,n,i){const l=this.target;let c=this.position;const o=this.spaces,a=u.Utils.setArraySize(this.positions,t*3+2);let r=null;const h=e.closed;let m=e.worldVerticesLength,f=m/6,d=Pt.NONE;if(!e.constantSpeed){const V=e.lengths;f-=h?1:2;const v=V[f];if(n&&(c*=v),i)for(let U=0;U<t;U++)o[U]*=v;r=u.Utils.setArraySize(this.world,8);for(let U=0,b=0,G=0;U<t;U++,b+=3){const _=o[U];c+=_;let N=c;if(h)N%=v,N<0&&(N+=v),G=0;else if(N<0){d!=Pt.BEFORE&&(d=Pt.BEFORE,e.computeWorldVertices(l,2,4,r,0,2)),this.addBeforePosition(N,r,0,a,b);continue}else if(N>v){d!=Pt.AFTER&&(d=Pt.AFTER,e.computeWorldVertices(l,m-6,4,r,0,2)),this.addAfterPosition(N-v,r,0,a,b);continue}for(;;G++){const gt=V[G];if(!(N>gt)){if(G==0)N/=gt;else{const yt=V[G-1];N=(N-yt)/(gt-yt)}break}}G!=d&&(d=G,h&&G==f?(e.computeWorldVertices(l,m-4,4,r,0,2),e.computeWorldVertices(l,0,4,r,4,2)):e.computeWorldVertices(l,G*6+2,8,r,0,2)),this.addCurvePosition(N,r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],a,b,s||U>0&&_==0)}return a}h?(m+=2,r=u.Utils.setArraySize(this.world,m),e.computeWorldVertices(l,2,m-4,r,0,2),e.computeWorldVertices(l,0,2,r,m-4,2),r[m-2]=r[0],r[m-1]=r[1]):(f--,m-=4,r=u.Utils.setArraySize(this.world,m),e.computeWorldVertices(l,2,m,r,0,2));const g=u.Utils.setArraySize(this.curves,f);let p=0,w=r[0],M=r[1],E=0,x=0,S=0,A=0,I=0,T=0,y=0,R=0,k=0,D=0,Y=0,L=0,P=0,F=0;for(let V=0,v=2;V<f;V++,v+=6)E=r[v],x=r[v+1],S=r[v+2],A=r[v+3],I=r[v+4],T=r[v+5],y=(w-E*2+S)*.1875,R=(M-x*2+A)*.1875,k=((E-S)*3-w+I)*.09375,D=((x-A)*3-M+T)*.09375,Y=y*2+k,L=R*2+D,P=(E-w)*.75+y+k*.16666667,F=(x-M)*.75+R+D*.16666667,p+=Math.sqrt(P*P+F*F),P+=Y,F+=L,Y+=k,L+=D,p+=Math.sqrt(P*P+F*F),P+=Y,F+=L,p+=Math.sqrt(P*P+F*F),P+=Y+k,F+=L+D,p+=Math.sqrt(P*P+F*F),g[V]=p,w=I,M=T;if(n&&(c*=p),i)for(let V=0;V<t;V++)o[V]*=p;const rt=this.segments;let ot=0;for(let V=0,v=0,U=0,b=0;V<t;V++,v+=3){const G=o[V];c+=G;let _=c;if(h)_%=p,_<0&&(_+=p),U=0;else if(_<0){this.addBeforePosition(_,r,0,a,v);continue}else if(_>p){this.addAfterPosition(_-p,r,m-4,a,v);continue}for(;;U++){const N=g[U];if(!(_>N)){if(U==0)_/=N;else{const gt=g[U-1];_=(_-gt)/(N-gt)}break}}if(U!=d){d=U;let N=U*6;for(w=r[N],M=r[N+1],E=r[N+2],x=r[N+3],S=r[N+4],A=r[N+5],I=r[N+6],T=r[N+7],y=(w-E*2+S)*.03,R=(M-x*2+A)*.03,k=((E-S)*3-w+I)*.006,D=((x-A)*3-M+T)*.006,Y=y*2+k,L=R*2+D,P=(E-w)*.3+y+k*.16666667,F=(x-M)*.3+R+D*.16666667,ot=Math.sqrt(P*P+F*F),rt[0]=ot,N=1;N<8;N++)P+=Y,F+=L,Y+=k,L+=D,ot+=Math.sqrt(P*P+F*F),rt[N]=ot;P+=Y,F+=L,ot+=Math.sqrt(P*P+F*F),rt[8]=ot,P+=Y+k,F+=L+D,ot+=Math.sqrt(P*P+F*F),rt[9]=ot,b=0}for(_*=ot;;b++){const N=rt[b];if(!(_>N)){if(b==0)_/=N;else{const gt=rt[b-1];_=b+(_-gt)/(N-gt)}break}}this.addCurvePosition(_*.1,w,M,E,x,S,A,I,T,a,v,s||V>0&&G==0)}return a}addBeforePosition(e,t,s,n,i){const l=t[s],c=t[s+1],o=t[s+2]-l,a=t[s+3]-c,r=Math.atan2(a,o);n[i]=l+e*Math.cos(r),n[i+1]=c+e*Math.sin(r),n[i+2]=r}addAfterPosition(e,t,s,n,i){const l=t[s+2],c=t[s+3],o=l-t[s],a=c-t[s+1],r=Math.atan2(a,o);n[i]=l+e*Math.cos(r),n[i+1]=c+e*Math.sin(r),n[i+2]=r}addCurvePosition(e,t,s,n,i,l,c,o,a,r,h,m){(e==0||isNaN(e))&&(e=1e-4);const f=e*e,d=f*e,g=1-e,p=g*g,w=p*g,M=g*e,E=M*3,x=g*E,S=E*e,A=t*w+n*x+l*S+o*d,I=s*w+i*x+c*S+a*d;r[h]=A,r[h+1]=I,m&&(r[h+2]=Math.atan2(I-(s*p+i*M*2+c*f),A-(t*p+n*M*2+l*f)))}};let Nt=Pt;Nt.NONE=-1,Nt.BEFORE=-2,Nt.AFTER=-3,Nt.epsilon=1e-5;class Ee{constructor(t,s){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new u.Vector2,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,l=this.target,c=l.matrix,o=c.a,a=c.c,r=c.b,h=c.d,m=o*h-a*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,d=this.data.offsetShearY*m,g=this.bones;for(let p=0,w=g.length;p<w;p++){const M=g[p];let E=!1;const x=M.matrix;if(t!=0){const S=x.a,A=x.c,I=x.b,T=x.d;let y=Math.atan2(r,o)-Math.atan2(I,S)+f;y>u.MathUtils.PI?y-=u.MathUtils.PI2:y<-u.MathUtils.PI&&(y+=u.MathUtils.PI2),y*=t;const R=Math.cos(y),k=Math.sin(y);x.a=R*S-k*I,x.c=R*A-k*T,x.b=k*S+R*I,x.d=k*A+R*T,E=!0}if(s!=0){const S=this.temp;l.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),x.tx+=(S.x-x.tx)*s,x.ty+=(S.y-x.ty)*s,E=!0}if(n>0){let S=Math.sqrt(x.a*x.a+x.b*x.b),A=Math.sqrt(o*o+r*r);S>1e-5&&(S=(S+(A-S+this.data.offsetScaleX)*n)/S),x.a*=S,x.b*=S,S=Math.sqrt(x.c*x.c+x.d*x.d),A=Math.sqrt(a*a+h*h),S>1e-5&&(S=(S+(A-S+this.data.offsetScaleY)*n)/S),x.c*=S,x.d*=S,E=!0}if(i>0){const S=x.c,A=x.d,I=Math.atan2(A,S);let T=Math.atan2(h,a)-Math.atan2(r,o)-(I-Math.atan2(x.b,x.a));T>u.MathUtils.PI?T-=u.MathUtils.PI2:T<-u.MathUtils.PI&&(T+=u.MathUtils.PI2),T=I+(T+d)*i;const y=Math.sqrt(S*S+A*A);x.c=Math.cos(T)*y,x.d=Math.sin(T)*y,E=!0}E&&(M.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,l=this.target,c=l.matrix,o=c.a,a=c.c,r=c.b,h=c.d,m=o*h-a*r>0?u.MathUtils.degRad:-u.MathUtils.degRad,f=this.data.offsetRotation*m,d=this.data.offsetShearY*m,g=this.bones;for(let p=0,w=g.length;p<w;p++){const M=g[p];let E=!1;const x=M.matrix;if(t!=0){const S=x.a,A=x.c,I=x.b,T=x.d;let y=Math.atan2(r,o)+f;y>u.MathUtils.PI?y-=u.MathUtils.PI2:y<-u.MathUtils.PI&&(y+=u.MathUtils.PI2),y*=t;const R=Math.cos(y),k=Math.sin(y);x.a=R*S-k*I,x.c=R*A-k*T,x.b=k*S+R*I,x.d=k*A+R*T,E=!0}if(s!=0){const S=this.temp;l.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),x.tx+=S.x*s,x.ty+=S.y*s,E=!0}if(n>0){let S=(Math.sqrt(o*o+r*r)-1+this.data.offsetScaleX)*n+1;x.a*=S,x.b*=S,S=(Math.sqrt(a*a+h*h)-1+this.data.offsetScaleY)*n+1,x.c*=S,x.d*=S,E=!0}if(i>0){let S=Math.atan2(h,a)-Math.atan2(r,o);S>u.MathUtils.PI?S-=u.MathUtils.PI2:S<-u.MathUtils.PI&&(S+=u.MathUtils.PI2);const A=x.c,I=x.d;S=Math.atan2(I,A)+(S-u.MathUtils.PI/2+d)*i;const T=Math.sqrt(A*A+I*I);x.c=Math.cos(S)*T,x.d=Math.sin(S)*T,E=!0}E&&(M.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const r=c[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;if(t!=0){let w=l.arotation-h+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,h+=w*t}let m=r.ax,f=r.ay;s!=0&&(m+=(l.ax-m+this.data.offsetX)*s,f+=(l.ay-f+this.data.offsetY)*s);let d=r.ascaleX,g=r.ascaleY;n>0&&(d>1e-5&&(d=(d+(l.ascaleX-d+this.data.offsetScaleX)*n)/d),g>1e-5&&(g=(g+(l.ascaleY-g+this.data.offsetScaleY)*n)/g));const p=r.ashearY;if(i>0){let w=l.ashearY-p+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,r.shearY+=w*i}r.updateWorldTransformWith(m,f,h,d,g,r.ashearX,p)}}applyRelativeLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,i=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const r=c[o];r.appliedValid||r.updateAppliedTransform();let h=r.arotation;t!=0&&(h+=(l.arotation+this.data.offsetRotation)*t);let m=r.ax,f=r.ay;s!=0&&(m+=(l.ax+this.data.offsetX)*s,f+=(l.ay+this.data.offsetY)*s);let d=r.ascaleX,g=r.ascaleY;n>0&&(d>1e-5&&(d*=(l.ascaleX-1+this.data.offsetScaleX)*n+1),g>1e-5&&(g*=(l.ascaleY-1+this.data.offsetScaleY)*n+1));let p=r.ashearY;i>0&&(p+=(l.ashearY+this.data.offsetShearY)*i),r.updateWorldTransformWith(m,f,h,d,g,r.ashearX,p)}}}const Dt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const s=e.bones[t];let n;if(s.parent==null)n=new te(s,this,null);else{const i=this.bones[s.parent.index];n=new te(s,this,i),i.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const s=e.slots[t],n=this.bones[s.boneData.index],i=new jt(s,n);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const s=e.ikConstraints[t];this.ikConstraints.push(new xe(s,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const s=e.transformConstraints[t];this.transformConstraints.push(new Ee(s,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const s=e.pathConstraints[t];this.pathConstraints.push(new Nt(s,this))}this.color=new u.Color(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let r=0,h=t.length;r<h;r++){const m=t[r];m.sorted=m.data.skinRequired,m.active=!m.sorted}if(this.skin!=null){const r=this.skin.bones;for(let h=0,m=this.skin.bones.length;h<m;h++){let f=this.bones[r[h].index];do f.sorted=!1,f.active=!0,f=f.parent;while(f!=null)}}const s=this.ikConstraints,n=this.transformConstraints,i=this.pathConstraints,l=s.length,c=n.length,o=i.length,a=l+c+o;t:for(let r=0;r<a;r++){for(let h=0;h<l;h++){const m=s[h];if(m.data.order==r){this.sortIkConstraint(m);continue t}}for(let h=0;h<c;h++){const m=n[h];if(m.data.order==r){this.sortTransformConstraint(m);continue t}}for(let h=0;h<o;h++){const m=i[h];if(m.data.order==r){this.sortPathConstraint(m);continue t}}}for(let r=0,h=t.length;r<h;r++)this.sortBone(t[r])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const s=e.bones,n=s[0];if(this.sortBone(n),s.length>1){const i=s[s.length-1];this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}this._updateCache.push(e),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,s=t.data.index,n=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let o=0,a=this.data.skins.length;o<a;o++)this.sortPathConstraintAttachment(this.data.skins[o],s,n);const i=t.getAttachment();i instanceof kt&&this.sortPathConstraintAttachmentWith(i,n);const l=e.bones,c=l.length;for(let o=0;o<c;o++)this.sortBone(l[o]);this._updateCache.push(e);for(let o=0;o<c;o++)this.sortReset(l[o].children);for(let o=0;o<c;o++)l[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&u.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,s=t.length;if(e.data.local)for(let n=0;n<s;n++){const i=t[n];this.sortBone(i.parent),this._updateCache.indexOf(i)>-1||this.updateCacheReset.push(i)}else for(let n=0;n<s;n++)this.sortBone(t[n]);this._updateCache.push(e);for(let n=0;n<s;n++)this.sortReset(t[n].children);for(let n=0;n<s;n++)t[n].sorted=!0}sortPathConstraintAttachment(e,t,s){const n=e.attachments[t];if(n)for(const i in n)this.sortPathConstraintAttachmentWith(n[i],s)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof kt))return;const s=e.bones;if(s==null)this.sortBone(t);else{const n=this.bones;let i=0;for(;i<s.length;){const l=s[i++];for(let c=i+l;i<c;i++){const o=s[i];this.sortBone(n[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,s=e.length;t<s;t++){const n=e[t];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let s=0,n=e.length;s<n;s++){const i=e[s];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY,i.appliedValid=!0}const t=this._updateCache;for(let s=0,n=t.length;s<n;s++)t[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let i=0,l=e.length;i<l;i++)e[i].setToSetupPose();const t=this.ikConstraints;for(let i=0,l=t.length;i<l;i++){const c=t[i];c.mix=c.data.mix,c.softness=c.data.softness,c.bendDirection=c.data.bendDirection,c.compress=c.data.compress,c.stretch=c.data.stretch}const s=this.transformConstraints;for(let i=0,l=s.length;i<l;i++){const c=s[i],o=c.data;c.rotateMix=o.rotateMix,c.translateMix=o.translateMix,c.scaleMix=o.scaleMix,c.shearMix=o.shearMix}const n=this.pathConstraints;for(let i=0,l=n.length;i<l;i++){const c=n[i],o=c.data;c.position=o.position,c.spacing=o.spacing,c.rotateMix=o.rotateMix,c.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;u.Utils.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,s=e.length;t<s;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,n=t.length;s<n;s++){const i=t[s],l=i.data.attachmentName;if(l!=null){const c=e.getAttachment(s,l);c!=null&&i.setAttachment(c)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(e,t);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.data.name==e){let c=null;if(t!=null&&(c=this.getAttachment(n,t),c==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);l.setAttachment(c);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,n=t.length;s<n;s++){const i=t[s];if(i.data.name==e)return i}return null}getBounds(e,t,s=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const n=this.drawOrder;let i=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0,r=n.length;a<r;a++){const h=n[a];if(!h.bone.active)continue;let m=0,f=null;const d=h.getAttachment();if(d instanceof B)m=8,f=u.Utils.setArraySize(s,m,0),d.computeWorldVertices(h.bone,f,0,2);else if(d instanceof Ct){const g=d;m=g.worldVerticesLength,f=u.Utils.setArraySize(s,m,0),g.computeWorldVertices(h,0,m,f,0,2)}if(f!=null)for(let g=0,p=f.length;g<p;g+=2){const w=f[g],M=f[g+1];i=Math.min(i,w),l=Math.min(l,M),c=Math.max(c,w),o=Math.max(o,M)}}e.set(i,l),t.set(c-i,o-l)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let re=Dt;re.deprecatedWarning1=!1;class oe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const s=this.skins;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const s=this.events;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const s=this.animations;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let n=0,i=s.length;n<i;n++){const l=s[n];if(l.name==t)return l}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let n=0,i=s.length;n<i;n++)if(s[n].name==t)return n;return-1}}class le{constructor(t,s,n){if(this.color=new u.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");if(n==null)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=n}}class he extends bt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class ce{constructor(t,s,n){this.slotIndex=t,this.name=s,this.attachment=n}}class Wt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,n){if(n==null)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][s]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const i=t.bones[n];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==i){l=!0;break}l||this.bones.push(i)}for(let n=0;n<t.constraints.length;n++){const i=t.constraints[n];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==i){l=!0;break}l||this.constraints.push(i)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const i=s[n];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const i=t.bones[n];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==i){l=!0;break}l||this.bones.push(i)}for(let n=0;n<t.constraints.length;n++){const i=t.constraints[n];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==i){l=!0;break}l||this.constraints.push(i)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const i=s[n];i.attachment!=null&&(i.attachment instanceof Ct?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,s){const n=this.attachments[t];return n?n[s]:null}removeAttachment(t,s){const n=this.attachments[t];n&&(n[s]=null)}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const n=this.attachments[s];if(n)for(const i in n){const l=n[i];l&&t.push(new ce(s,i,l))}}return t}getAttachmentsForSlot(t,s){const n=this.attachments[t];if(n)for(const i in n){const l=n[i];l&&s.push(new ce(t,i,l))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let n=0;for(let i=0;i<t.slots.length;i++){const l=t.slots[i],c=l.getAttachment();if(c&&n<s.attachments.length){const o=s.attachments[n];for(const a in o){const r=o[a];if(c==r){const h=this.getAttachment(n,a);h!=null&&l.setAttachment(h);break}}}n++}}}const H=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,s=new oe;s.name="";const n=new u.BinaryInput(e);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let l=0;l=n.readInt(!0);for(let o=0;o<l;o++)n.strings.push(n.readString());l=n.readInt(!0);for(let o=0;o<l;o++){const a=n.readString(),r=o==0?null:s.bones[n.readInt(!0)],h=new ee(o,a,r);h.rotation=n.readFloat(),h.x=n.readFloat()*t,h.y=n.readFloat()*t,h.scaleX=n.readFloat(),h.scaleY=n.readFloat(),h.shearX=n.readFloat(),h.shearY=n.readFloat(),h.length=n.readFloat()*t,h.transformMode=H.TransformModeValues[n.readInt(!0)],h.skinRequired=n.readBoolean(),i&&u.Color.rgba8888ToColor(h.color,n.readInt32()),s.bones.push(h)}l=n.readInt(!0);for(let o=0;o<l;o++){const a=n.readString(),r=s.bones[n.readInt(!0)],h=new le(o,a,r);u.Color.rgba8888ToColor(h.color,n.readInt32());const m=n.readInt32();m!=-1&&u.Color.rgb888ToColor(h.darkColor=new u.Color,m),h.attachmentName=n.readStringRef(),h.blendMode=H.BlendModeValues[n.readInt(!0)],s.slots.push(h)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const r=new ae(n.readString());r.order=n.readInt(!0),r.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)r.bones.push(s.bones[n.readInt(!0)]);r.target=s.bones[n.readInt(!0)],r.mix=n.readFloat(),r.softness=n.readFloat()*t,r.bendDirection=n.readByte(),r.compress=n.readBoolean(),r.stretch=n.readBoolean(),r.uniform=n.readBoolean(),s.ikConstraints.push(r)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const r=new he(n.readString());r.order=n.readInt(!0),r.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)r.bones.push(s.bones[n.readInt(!0)]);r.target=s.bones[n.readInt(!0)],r.local=n.readBoolean(),r.relative=n.readBoolean(),r.offsetRotation=n.readFloat(),r.offsetX=n.readFloat()*t,r.offsetY=n.readFloat()*t,r.offsetScaleX=n.readFloat(),r.offsetScaleY=n.readFloat(),r.offsetShearY=n.readFloat(),r.rotateMix=n.readFloat(),r.translateMix=n.readFloat(),r.scaleMix=n.readFloat(),r.shearMix=n.readFloat(),s.transformConstraints.push(r)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const r=new ie(n.readString());r.order=n.readInt(!0),r.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)r.bones.push(s.bones[n.readInt(!0)]);r.target=s.slots[n.readInt(!0)],r.positionMode=H.PositionModeValues[n.readInt(!0)],r.spacingMode=H.SpacingModeValues[n.readInt(!0)],r.rotateMode=H.RotateModeValues[n.readInt(!0)],r.offsetRotation=n.readFloat(),r.position=n.readFloat(),r.positionMode==u.PositionMode.Fixed&&(r.position*=t),r.spacing=n.readFloat(),(r.spacingMode==J.Length||r.spacingMode==J.Fixed)&&(r.spacing*=t),r.rotateMix=n.readFloat(),r.translateMix=n.readFloat(),s.pathConstraints.push(r)}const c=this.readSkin(n,s,!0,i);c!=null&&(s.defaultSkin=c,s.skins.push(c));{let o=s.skins.length;for(u.Utils.setArraySize(s.skins,l=o+n.readInt(!0));o<l;o++)s.skins[o]=this.readSkin(n,s,!1,i)}l=this.linkedMeshes.length;for(let o=0;o<l;o++){const a=this.linkedMeshes[o],r=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(r==null)throw new Error(`Skin not found: ${a.skin}`);const h=r.getAttachment(a.slotIndex,a.parent);if(h==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?h:a.mesh,a.mesh.setParentMesh(h)}this.linkedMeshes.length=0,l=n.readInt(!0);for(let o=0;o<l;o++){const a=new se(n.readStringRef());a.intValue=n.readInt(!1),a.floatValue=n.readFloat(),a.stringValue=n.readString(),a.audioPath=n.readString(),a.audioPath!=null&&(a.volume=n.readFloat(),a.balance=n.readFloat()),s.events.push(a)}l=n.readInt(!0);for(let o=0;o<l;o++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(e,t,s,n){let i=null,l=0;if(s){if(l=e.readInt(!0),l==0)return null;i=new Wt("default")}else{i=new Wt(e.readStringRef()),i.bones.length=e.readInt(!0);for(let c=0,o=i.bones.length;c<o;c++)i.bones[c]=t.bones[e.readInt(!0)];for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)i.constraints.push(t.pathConstraints[e.readInt(!0)]);l=e.readInt(!0)}for(let c=0;c<l;c++){const o=e.readInt(!0);for(let a=0,r=e.readInt(!0);a<r;a++){const h=e.readStringRef(),m=this.readAttachment(e,t,i,o,h,n);m!=null&&i.setAttachment(o,h,m)}}return i}readAttachment(e,t,s,n,i,l){const c=this.scale;let o=e.readStringRef();o==null&&(o=i);const a=e.readByte();switch(H.AttachmentTypeValues[a]){case u.AttachmentType.Region:{let r=e.readStringRef();const h=e.readFloat(),m=e.readFloat(),f=e.readFloat(),d=e.readFloat(),g=e.readFloat(),p=e.readFloat(),w=e.readFloat(),M=e.readInt32();r==null&&(r=o);const E=this.attachmentLoader.newRegionAttachment(s,o,r);return E==null?null:(E.path=r,E.x=m*c,E.y=f*c,E.scaleX=d,E.scaleY=g,E.rotation=h,E.width=p*c,E.height=w*c,u.Color.rgba8888ToColor(E.color,M),E)}case u.AttachmentType.BoundingBox:{const r=e.readInt(!0),h=this.readVertices(e,r),m=l?e.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,o);return f==null?null:(f.worldVerticesLength=r<<1,f.vertices=h.vertices,f.bones=h.bones,l&&u.Color.rgba8888ToColor(f.color,m),f)}case u.AttachmentType.Mesh:{let r=e.readStringRef();const h=e.readInt32(),m=e.readInt(!0),f=this.readFloatArray(e,m<<1,1),d=this.readShortArray(e),g=this.readVertices(e,m),p=e.readInt(!0);let w=null,M=0,E=0;l&&(w=this.readShortArray(e),M=e.readFloat(),E=e.readFloat()),r==null&&(r=o);const x=this.attachmentLoader.newMeshAttachment(s,o,r);return x==null?null:(x.path=r,u.Color.rgba8888ToColor(x.color,h),x.bones=g.bones,x.vertices=g.vertices,x.worldVerticesLength=m<<1,x.triangles=d,x.regionUVs=new Float32Array(f),x.hullLength=p<<1,l&&(x.edges=w,x.width=M*c,x.height=E*c),x)}case u.AttachmentType.LinkedMesh:{let r=e.readStringRef();const h=e.readInt32(),m=e.readStringRef(),f=e.readStringRef(),d=e.readBoolean();let g=0,p=0;l&&(g=e.readFloat(),p=e.readFloat()),r==null&&(r=o);const w=this.attachmentLoader.newMeshAttachment(s,o,r);return w==null?null:(w.path=r,u.Color.rgba8888ToColor(w.color,h),l&&(w.width=g*c,w.height=p*c),this.linkedMeshes.push(new Pe(w,m,n,f,d)),w)}case u.AttachmentType.Path:{const r=e.readBoolean(),h=e.readBoolean(),m=e.readInt(!0),f=this.readVertices(e,m),d=u.Utils.newArray(m/3,0);for(let w=0,M=d.length;w<M;w++)d[w]=e.readFloat()*c;const g=l?e.readInt32():0,p=this.attachmentLoader.newPathAttachment(s,o);return p==null?null:(p.closed=r,p.constantSpeed=h,p.worldVerticesLength=m<<1,p.vertices=f.vertices,p.bones=f.bones,p.lengths=d,l&&u.Color.rgba8888ToColor(p.color,g),p)}case u.AttachmentType.Point:{const r=e.readFloat(),h=e.readFloat(),m=e.readFloat(),f=l?e.readInt32():0,d=this.attachmentLoader.newPointAttachment(s,o);return d==null?null:(d.x=h*c,d.y=m*c,d.rotation=r,l&&u.Color.rgba8888ToColor(d.color,f),d)}case u.AttachmentType.Clipping:{const r=e.readInt(!0),h=e.readInt(!0),m=this.readVertices(e,h),f=l?e.readInt32():0,d=this.attachmentLoader.newClippingAttachment(s,o);return d==null?null:(d.endSlot=t.slots[r],d.worldVerticesLength=h<<1,d.vertices=m.vertices,d.bones=m.bones,l&&u.Color.rgba8888ToColor(d.color,f),d)}}return null}readVertices(e,t){const s=t<<1,n=new Fe,i=this.scale;if(!e.readBoolean())return n.vertices=this.readFloatArray(e,s,i),n;const l=new Array,c=new Array;for(let o=0;o<t;o++){const a=e.readInt(!0);c.push(a);for(let r=0;r<a;r++)c.push(e.readInt(!0)),l.push(e.readFloat()*i),l.push(e.readFloat()*i),l.push(e.readFloat())}return n.vertices=u.Utils.toFloatArray(l),n.bones=c,n}readFloatArray(e,t,s){const n=new Array(t);if(s==1)for(let i=0;i<t;i++)n[i]=e.readFloat();else for(let i=0;i<t;i++)n[i]=e.readFloat()*s;return n}readShortArray(e){const t=e.readInt(!0),s=new Array(t);for(let n=0;n<t;n++)s[n]=e.readShort();return s}readAnimation(e,t,s){const n=new Array,i=this.scale;let l=0;const c=new u.Color,o=new u.Color;for(let h=0,m=e.readInt(!0);h<m;h++){const f=e.readInt(!0);for(let d=0,g=e.readInt(!0);d<g;d++){const p=e.readByte(),w=e.readInt(!0);switch(p){case H.SLOT_ATTACHMENT:{const M=new Vt(w);M.slotIndex=f;for(let E=0;E<w;E++)M.setFrame(E,e.readFloat(),e.readStringRef());n.push(M),l=Math.max(l,M.frames[w-1]);break}case H.SLOT_COLOR:{const M=new st(w);M.slotIndex=f;for(let E=0;E<w;E++){const x=e.readFloat();u.Color.rgba8888ToColor(c,e.readInt32()),M.setFrame(E,x,c.r,c.g,c.b,c.a),E<w-1&&this.readCurve(e,E,M)}n.push(M),l=Math.max(l,M.frames[(w-1)*st.ENTRIES]);break}case H.SLOT_TWO_COLOR:{const M=new z(w);M.slotIndex=f;for(let E=0;E<w;E++){const x=e.readFloat();u.Color.rgba8888ToColor(c,e.readInt32()),u.Color.rgb888ToColor(o,e.readInt32()),M.setFrame(E,x,c.r,c.g,c.b,c.a,o.r,o.g,o.b),E<w-1&&this.readCurve(e,E,M)}n.push(M),l=Math.max(l,M.frames[(w-1)*z.ENTRIES]);break}}}}for(let h=0,m=e.readInt(!0);h<m;h++){const f=e.readInt(!0);for(let d=0,g=e.readInt(!0);d<g;d++){const p=e.readByte(),w=e.readInt(!0);switch(p){case H.BONE_ROTATE:{const M=new tt(w);M.boneIndex=f;for(let E=0;E<w;E++)M.setFrame(E,e.readFloat(),e.readFloat()),E<w-1&&this.readCurve(e,E,M);n.push(M),l=Math.max(l,M.frames[(w-1)*tt.ENTRIES]);break}case H.BONE_TRANSLATE:case H.BONE_SCALE:case H.BONE_SHEAR:{let M,E=1;p==H.BONE_SCALE?M=new ht(w):p==H.BONE_SHEAR?M=new ct(w):(M=new mt(w),E=i),M.boneIndex=f;for(let x=0;x<w;x++)M.setFrame(x,e.readFloat(),e.readFloat()*E,e.readFloat()*E),x<w-1&&this.readCurve(e,x,M);n.push(M),l=Math.max(l,M.frames[(w-1)*mt.ENTRIES]);break}}}}for(let h=0,m=e.readInt(!0);h<m;h++){const f=e.readInt(!0),d=e.readInt(!0),g=new et(d);g.ikConstraintIndex=f;for(let p=0;p<d;p++)g.setFrame(p,e.readFloat(),e.readFloat(),e.readFloat()*i,e.readByte(),e.readBoolean(),e.readBoolean()),p<d-1&&this.readCurve(e,p,g);n.push(g),l=Math.max(l,g.frames[(d-1)*et.ENTRIES])}for(let h=0,m=e.readInt(!0);h<m;h++){const f=e.readInt(!0),d=e.readInt(!0),g=new at(d);g.transformConstraintIndex=f;for(let p=0;p<d;p++)g.setFrame(p,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),p<d-1&&this.readCurve(e,p,g);n.push(g),l=Math.max(l,g.frames[(d-1)*at.ENTRIES])}for(let h=0,m=e.readInt(!0);h<m;h++){const f=e.readInt(!0),d=s.pathConstraints[f];for(let g=0,p=e.readInt(!0);g<p;g++){const w=e.readByte(),M=e.readInt(!0);switch(w){case H.PATH_POSITION:case H.PATH_SPACING:{let E,x=1;w==H.PATH_SPACING?(E=new Mt(M),(d.spacingMode==J.Length||d.spacingMode==J.Fixed)&&(x=i)):(E=new Et(M),d.positionMode==u.PositionMode.Fixed&&(x=i)),E.pathConstraintIndex=f;for(let S=0;S<M;S++)E.setFrame(S,e.readFloat(),e.readFloat()*x),S<M-1&&this.readCurve(e,S,E);n.push(E),l=Math.max(l,E.frames[(M-1)*Et.ENTRIES]);break}case H.PATH_MIX:{const E=new xt(M);E.pathConstraintIndex=f;for(let x=0;x<M;x++)E.setFrame(x,e.readFloat(),e.readFloat(),e.readFloat()),x<M-1&&this.readCurve(e,x,E);n.push(E),l=Math.max(l,E.frames[(M-1)*xt.ENTRIES]);break}}}}for(let h=0,m=e.readInt(!0);h<m;h++){const f=s.skins[e.readInt(!0)];for(let d=0,g=e.readInt(!0);d<g;d++){const p=e.readInt(!0);for(let w=0,M=e.readInt(!0);w<M;w++){const E=f.getAttachment(p,e.readStringRef()),x=E.bones!=null,S=E.vertices,A=x?S.length/3*2:S.length,I=e.readInt(!0),T=new Zt(I);T.slotIndex=p,T.attachment=E;for(let y=0;y<I;y++){const R=e.readFloat();let k,D=e.readInt(!0);if(D==0)k=x?u.Utils.newFloatArray(A):S;else{k=u.Utils.newFloatArray(A);const Y=e.readInt(!0);if(D+=Y,i==1)for(let L=Y;L<D;L++)k[L]=e.readFloat();else for(let L=Y;L<D;L++)k[L]=e.readFloat()*i;if(!x)for(let L=0,P=k.length;L<P;L++)k[L]+=S[L]}T.setFrame(y,R,k),y<I-1&&this.readCurve(e,y,T)}n.push(T),l=Math.max(l,T.frames[I-1])}}}const a=e.readInt(!0);if(a>0){const h=new Bt(a),m=s.slots.length;for(let f=0;f<a;f++){const d=e.readFloat(),g=e.readInt(!0),p=u.Utils.newArray(m,0);for(let x=m-1;x>=0;x--)p[x]=-1;const w=u.Utils.newArray(m-g,0);let M=0,E=0;for(let x=0;x<g;x++){const S=e.readInt(!0);for(;M!=S;)w[E++]=M++;p[M+e.readInt(!0)]=M++}for(;M<m;)w[E++]=M++;for(let x=m-1;x>=0;x--)p[x]==-1&&(p[x]=w[--E]);h.setFrame(f,d,p)}n.push(h),l=Math.max(l,h.frames[a-1])}const r=e.readInt(!0);if(r>0){const h=new Lt(r);for(let m=0;m<r;m++){const f=e.readFloat(),d=s.events[e.readInt(!0)],g=new ne(f,d);g.intValue=e.readInt(!1),g.floatValue=e.readFloat(),g.stringValue=e.readBoolean()?e.readString():d.stringValue,g.data.audioPath!=null&&(g.volume=e.readFloat(),g.balance=e.readFloat()),h.setFrame(m,g)}n.push(h),l=Math.max(l,h.frames[r-1])}return new j(t,n,l)}readCurve(e,t,s){switch(e.readByte()){case H.CURVE_STEPPED:s.setStepped(t);break;case H.CURVE_BEZIER:this.setCurve(s,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,s,n,i,l){e.setCurve(t,s,n,i,l)}};let Q=H;Q.AttachmentTypeValues=[0,1,2,3,4,5,6],Q.TransformModeValues=[u.TransformMode.Normal,u.TransformMode.OnlyTranslation,u.TransformMode.NoRotationOrReflection,u.TransformMode.NoScale,u.TransformMode.NoScaleOrReflection],Q.PositionModeValues=[u.PositionMode.Fixed,u.PositionMode.Percent],Q.SpacingModeValues=[J.Length,J.Fixed,J.Percent],Q.RotateModeValues=[u.RotateMode.Tangent,u.RotateMode.Chain,u.RotateMode.ChainScale],Q.BlendModeValues=[wt.BLEND_MODES.NORMAL,wt.BLEND_MODES.ADD,wt.BLEND_MODES.MULTIPLY,wt.BLEND_MODES.SCREEN],Q.BONE_ROTATE=0,Q.BONE_TRANSLATE=1,Q.BONE_SCALE=2,Q.BONE_SHEAR=3,Q.SLOT_ATTACHMENT=0,Q.SLOT_COLOR=1,Q.SLOT_TWO_COLOR=2,Q.PATH_POSITION=0,Q.PATH_SPACING=1,Q.PATH_MIX=2,Q.CURVE_LINEAR=0,Q.CURVE_STEPPED=1,Q.CURVE_BEZIER=2;class Pe{constructor(t,s,n,i,l){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=i,this.inheritDeform=l}}class Fe{constructor(t=null,s=null){this.bones=t,this.vertices=s}}class Be extends u.SkeletonBoundsBase{}class Ft{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,n=new oe,i=typeof t=="string"?JSON.parse(t):t,l=i.skeleton;if(l!=null){if(n.hash=l.hash,n.version=l.spine,n.version.substr(0,3)!=="3.8"){const c=`Spine 3.8 loader cant load version ${l.spine}. Please configure your pixi-spine bundle`;console.error(c)}n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.x=l.x,n.y=l.y,n.width=l.width,n.height=l.height,n.fps=l.fps,n.imagesPath=l.images}if(i.bones)for(let c=0;c<i.bones.length;c++){const o=i.bones[c];let a=null;const r=this.getValue(o,"parent",null);if(r!=null&&(a=n.findBone(r),a==null))throw new Error(`Parent bone not found: ${r}`);const h=new ee(n.bones.length,o.name,a);h.length=this.getValue(o,"length",0)*s,h.x=this.getValue(o,"x",0)*s,h.y=this.getValue(o,"y",0)*s,h.rotation=this.getValue(o,"rotation",0),h.scaleX=this.getValue(o,"scaleX",1),h.scaleY=this.getValue(o,"scaleY",1),h.shearX=this.getValue(o,"shearX",0),h.shearY=this.getValue(o,"shearY",0),h.transformMode=Ft.transformModeFromString(this.getValue(o,"transform","normal")),h.skinRequired=this.getValue(o,"skin",!1),n.bones.push(h)}if(i.slots)for(let c=0;c<i.slots.length;c++){const o=i.slots[c],a=o.name,r=o.bone,h=n.findBone(r);if(h==null)throw new Error(`Slot bone not found: ${r}`);const m=new le(n.slots.length,a,h),f=this.getValue(o,"color",null);f!=null&&m.color.setFromString(f);const d=this.getValue(o,"dark",null);d!=null&&(m.darkColor=new u.Color(1,1,1,1),m.darkColor.setFromString(d)),m.attachmentName=this.getValue(o,"attachment",null),m.blendMode=Ft.blendModeFromString(this.getValue(o,"blend","normal")),n.slots.push(m)}if(i.ik)for(let c=0;c<i.ik.length;c++){const o=i.ik[c],a=new ae(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=n.findBone(m);if(f==null)throw new Error(`IK bone not found: ${m}`);a.bones.push(f)}const r=o.target;if(a.target=n.findBone(r),a.target==null)throw new Error(`IK target bone not found: ${r}`);a.mix=this.getValue(o,"mix",1),a.softness=this.getValue(o,"softness",0)*s,a.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,a.compress=this.getValue(o,"compress",!1),a.stretch=this.getValue(o,"stretch",!1),a.uniform=this.getValue(o,"uniform",!1),n.ikConstraints.push(a)}if(i.transform)for(let c=0;c<i.transform.length;c++){const o=i.transform[c],a=new he(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=n.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);a.bones.push(f)}const r=o.target;if(a.target=n.findBone(r),a.target==null)throw new Error(`Transform constraint target bone not found: ${r}`);a.local=this.getValue(o,"local",!1),a.relative=this.getValue(o,"relative",!1),a.offsetRotation=this.getValue(o,"rotation",0),a.offsetX=this.getValue(o,"x",0)*s,a.offsetY=this.getValue(o,"y",0)*s,a.offsetScaleX=this.getValue(o,"scaleX",0),a.offsetScaleY=this.getValue(o,"scaleY",0),a.offsetShearY=this.getValue(o,"shearY",0),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),a.scaleMix=this.getValue(o,"scaleMix",1),a.shearMix=this.getValue(o,"shearMix",1),n.transformConstraints.push(a)}if(i.path)for(let c=0;c<i.path.length;c++){const o=i.path[c],a=new ie(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const m=o.bones[h],f=n.findBone(m);if(f==null)throw new Error(`Transform constraint bone not found: ${m}`);a.bones.push(f)}const r=o.target;if(a.target=n.findSlot(r),a.target==null)throw new Error(`Path target slot not found: ${r}`);a.positionMode=Ft.positionModeFromString(this.getValue(o,"positionMode","percent")),a.spacingMode=Ft.spacingModeFromString(this.getValue(o,"spacingMode","length")),a.rotateMode=Ft.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),a.offsetRotation=this.getValue(o,"rotation",0),a.position=this.getValue(o,"position",0),a.positionMode==u.PositionMode.Fixed&&(a.position*=s),a.spacing=this.getValue(o,"spacing",0),(a.spacingMode==J.Length||a.spacingMode==J.Fixed)&&(a.spacing*=s),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),n.pathConstraints.push(a)}if(i.skins)for(let c=0;c<i.skins.length;c++){const o=i.skins[c],a=new Wt(o.name);if(o.bones)for(let r=0;r<o.bones.length;r++){const h=n.findBone(o.bones[r]);if(h==null)throw new Error(`Skin bone not found: ${o.bones[c]}`);a.bones.push(h)}if(o.ik)for(let r=0;r<o.ik.length;r++){const h=n.findIkConstraint(o.ik[r]);if(h==null)throw new Error(`Skin IK constraint not found: ${o.ik[c]}`);a.constraints.push(h)}if(o.transform)for(let r=0;r<o.transform.length;r++){const h=n.findTransformConstraint(o.transform[r]);if(h==null)throw new Error(`Skin transform constraint not found: ${o.transform[c]}`);a.constraints.push(h)}if(o.path)for(let r=0;r<o.path.length;r++){const h=n.findPathConstraint(o.path[r]);if(h==null)throw new Error(`Skin path constraint not found: ${o.path[c]}`);a.constraints.push(h)}for(const r in o.attachments){const h=n.findSlot(r);if(h==null)throw new Error(`Slot not found: ${r}`);const m=o.attachments[r];for(const f in m){const d=this.readAttachment(m[f],a,h.index,f,n);d!=null&&a.setAttachment(h.index,f,d)}}n.skins.push(a),a.name=="default"&&(n.defaultSkin=a)}for(let c=0,o=this.linkedMeshes.length;c<o;c++){const a=this.linkedMeshes[c],r=a.skin==null?n.defaultSkin:n.findSkin(a.skin);if(r==null)throw new Error(`Skin not found: ${a.skin}`);const h=r.getAttachment(a.slotIndex,a.parent);if(h==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?h:a.mesh,a.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,i.events)for(const c in i.events){const o=i.events[c],a=new se(c);a.intValue=this.getValue(o,"int",0),a.floatValue=this.getValue(o,"float",0),a.stringValue=this.getValue(o,"string",""),a.audioPath=this.getValue(o,"audio",null),a.audioPath!=null&&(a.volume=this.getValue(o,"volume",1),a.balance=this.getValue(o,"balance",0)),n.events.push(a)}if(i.animations)for(const c in i.animations){const o=i.animations[c];this.readAnimation(o,c,n)}return n}readAttachment(t,s,n,i,l){const c=this.scale;switch(i=this.getValue(t,"name",i),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",i),a=this.attachmentLoader.newRegionAttachment(s,i,o);if(a==null)return null;a.path=o,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const r=this.getValue(t,"color",null);return r!=null&&a.color.setFromString(r),a}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(s,i);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",i),a=this.attachmentLoader.newMeshAttachment(s,i,o);if(a==null)return null;a.path=o;const r=this.getValue(t,"color",null);r!=null&&a.color.setFromString(r),a.width=this.getValue(t,"width",0)*c,a.height=this.getValue(t,"height",0)*c;const h=this.getValue(t,"parent",null);if(h!=null)return this.linkedMeshes.push(new Ne(a,this.getValue(t,"skin",null),n,h,this.getValue(t,"deform",!0))),a;const m=t.uvs;return this.readVertices(t,a,m.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(m),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const o=this.attachmentLoader.newPathAttachment(s,i);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,o,a<<1);const r=u.Utils.newArray(a/3,0);for(let m=0;m<t.lengths.length;m++)r[m]=t.lengths[m]*c;o.lengths=r;const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}case"point":{const o=this.attachmentLoader.newPointAttachment(s,i);if(o==null)return null;o.x=this.getValue(t,"x",0)*c,o.y=this.getValue(t,"y",0)*c,o.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(s,i);if(o==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const m=l.findSlot(a);if(m==null)throw new Error(`Clipping end slot not found: ${a}`);o.endSlot=m}const r=t.vertexCount;this.readVertices(t,o,r<<1);const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}}return null}readVertices(t,s,n){const i=this.scale;s.worldVerticesLength=n;const l=t.vertices;if(n==l.length){const a=u.Utils.toFloatArray(l);if(i!=1)for(let r=0,h=l.length;r<h;r++)a[r]*=i;s.vertices=a;return}const c=new Array,o=new Array;for(let a=0,r=l.length;a<r;){const h=l[a++];o.push(h);for(let m=a+h*4;a<m;a+=4)o.push(l[a]),c.push(l[a+1]*i),c.push(l[a+2]*i),c.push(l[a+3])}s.bones=o,s.vertices=u.Utils.toFloatArray(c)}readAnimation(t,s,n){const i=this.scale,l=new Array;let c=0;if(t.slots)for(const a in t.slots){const r=t.slots[a],h=n.findSlotIndex(a);if(h==-1)throw new Error(`Slot not found: ${a}`);for(const m in r){const f=r[m];if(m=="attachment"){const d=new Vt(f.length);d.slotIndex=h;let g=0;for(let p=0;p<f.length;p++){const w=f[p];d.setFrame(g++,this.getValue(w,"time",0),w.name)}l.push(d),c=Math.max(c,d.frames[d.getFrameCount()-1])}else if(m=="color"){const d=new st(f.length);d.slotIndex=h;let g=0;for(let p=0;p<f.length;p++){const w=f[p],M=new u.Color;M.setFromString(w.color||"ffffffff"),d.setFrame(g,this.getValue(w,"time",0),M.r,M.g,M.b,M.a),this.readCurve(w,d,g),g++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*st.ENTRIES])}else if(m=="twoColor"){const d=new z(f.length);d.slotIndex=h;let g=0;for(let p=0;p<f.length;p++){const w=f[p],M=new u.Color,E=new u.Color;M.setFromString(w.light),E.setFromString(w.dark),d.setFrame(g,this.getValue(w,"time",0),M.r,M.g,M.b,M.a,E.r,E.g,E.b),this.readCurve(w,d,g),g++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*z.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${m} (${a})`)}}if(t.bones)for(const a in t.bones){const r=t.bones[a],h=n.findBoneIndex(a);if(h==-1)throw new Error(`Bone not found: ${a}`);for(const m in r){const f=r[m];if(m==="rotate"){const d=new tt(f.length);d.boneIndex=h;let g=0;for(let p=0;p<f.length;p++){const w=f[p];d.setFrame(g,this.getValue(w,"time",0),this.getValue(w,"angle",0)),this.readCurve(w,d,g),g++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*tt.ENTRIES])}else if(m==="translate"||m==="scale"||m==="shear"){let d=null,g=1,p=0;m==="scale"?(d=new ht(f.length),p=1):m==="shear"?d=new ct(f.length):(d=new mt(f.length),g=i),d.boneIndex=h;let w=0;for(let M=0;M<f.length;M++){const E=f[M],x=this.getValue(E,"x",p),S=this.getValue(E,"y",p);d.setFrame(w,this.getValue(E,"time",0),x*g,S*g),this.readCurve(E,d,w),w++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*mt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${m} (${a})`)}}if(t.ik)for(const a in t.ik){const r=t.ik[a],h=n.findIkConstraint(a),m=new et(r.length);m.ikConstraintIndex=n.ikConstraints.indexOf(h);let f=0;for(let d=0;d<r.length;d++){const g=r[d];m.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"mix",1),this.getValue(g,"softness",0)*i,this.getValue(g,"bendPositive",!0)?1:-1,this.getValue(g,"compress",!1),this.getValue(g,"stretch",!1)),this.readCurve(g,m,f),f++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*et.ENTRIES])}if(t.transform)for(const a in t.transform){const r=t.transform[a],h=n.findTransformConstraint(a),m=new at(r.length);m.transformConstraintIndex=n.transformConstraints.indexOf(h);let f=0;for(let d=0;d<r.length;d++){const g=r[d];m.setFrame(f,this.getValue(g,"time",0),this.getValue(g,"rotateMix",1),this.getValue(g,"translateMix",1),this.getValue(g,"scaleMix",1),this.getValue(g,"shearMix",1)),this.readCurve(g,m,f),f++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*at.ENTRIES])}if(t.path)for(const a in t.path){const r=t.path[a],h=n.findPathConstraintIndex(a);if(h==-1)throw new Error(`Path constraint not found: ${a}`);const m=n.pathConstraints[h];for(const f in r){const d=r[f];if(f==="position"||f==="spacing"){let g=null,p=1;f==="spacing"?(g=new Mt(d.length),(m.spacingMode==J.Length||m.spacingMode==J.Fixed)&&(p=i)):(g=new Et(d.length),m.positionMode==u.PositionMode.Fixed&&(p=i)),g.pathConstraintIndex=h;let w=0;for(let M=0;M<d.length;M++){const E=d[M];g.setFrame(w,this.getValue(E,"time",0),this.getValue(E,f,0)*p),this.readCurve(E,g,w),w++}l.push(g),c=Math.max(c,g.frames[(g.getFrameCount()-1)*Et.ENTRIES])}else if(f==="mix"){const g=new xt(d.length);g.pathConstraintIndex=h;let p=0;for(let w=0;w<d.length;w++){const M=d[w];g.setFrame(p,this.getValue(M,"time",0),this.getValue(M,"rotateMix",1),this.getValue(M,"translateMix",1)),this.readCurve(M,g,p),p++}l.push(g),c=Math.max(c,g.frames[(g.getFrameCount()-1)*xt.ENTRIES])}}}if(t.deform)for(const a in t.deform){const r=t.deform[a],h=n.findSkin(a);if(h==null){if(u.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${a}`);continue}for(const m in r){const f=r[m],d=n.findSlotIndex(m);if(d==-1)throw new Error(`Slot not found: ${f.name}`);for(const g in f){const p=f[g],w=h.getAttachment(d,g);if(w==null)throw new Error(`Deform attachment not found: ${p.name}`);const M=w.bones!=null,E=w.vertices,x=M?E.length/3*2:E.length,S=new Zt(p.length);S.slotIndex=d,S.attachment=w;let A=0;for(let I=0;I<p.length;I++){const T=p[I];let y;const R=this.getValue(T,"vertices",null);if(R==null)y=M?u.Utils.newFloatArray(x):E;else{y=u.Utils.newFloatArray(x);const k=this.getValue(T,"offset",0);if(u.Utils.arrayCopy(R,0,y,k,R.length),i!=1)for(let D=k,Y=D+R.length;D<Y;D++)y[D]*=i;if(!M)for(let D=0;D<x;D++)y[D]+=E[D]}S.setFrame(A,this.getValue(T,"time",0),y),this.readCurve(T,S,A),A++}l.push(S),c=Math.max(c,S.frames[S.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const a=new Bt(o.length),r=n.slots.length;let h=0;for(let m=0;m<o.length;m++){const f=o[m];let d=null;const g=this.getValue(f,"offsets",null);if(g!=null){d=u.Utils.newArray(r,-1);const p=u.Utils.newArray(r-g.length,0);let w=0,M=0;for(let E=0;E<g.length;E++){const x=g[E],S=n.findSlotIndex(x.slot);if(S==-1)throw new Error(`Slot not found: ${x.slot}`);for(;w!=S;)p[M++]=w++;d[w+x.offset]=w++}for(;w<r;)p[M++]=w++;for(let E=r-1;E>=0;E--)d[E]==-1&&(d[E]=p[--M])}a.setFrame(h++,this.getValue(f,"time",0),d)}l.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(t.events){const a=new Lt(t.events.length);let r=0;for(let h=0;h<t.events.length;h++){const m=t.events[h],f=n.findEvent(m.name);if(f==null)throw new Error(`Event not found: ${m.name}`);const d=new ne(u.Utils.toSinglePrecision(this.getValue(m,"time",0)),f);d.intValue=this.getValue(m,"int",f.intValue),d.floatValue=this.getValue(m,"float",f.floatValue),d.stringValue=this.getValue(m,"string",f.stringValue),d.data.audioPath!=null&&(d.volume=this.getValue(m,"volume",1),d.balance=this.getValue(m,"balance",0)),a.setFrame(r++,d)}l.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new j(s,l,c))}readCurve(t,s,n){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")s.setStepped(n);else{const i=t.curve;s.setCurve(n,i,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,s,n){return t[s]!==void 0?t[s]:n}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return wt.BLEND_MODES.NORMAL;if(t=="additive")return wt.BLEND_MODES.ADD;if(t=="multiply")return wt.BLEND_MODES.MULTIPLY;if(t=="screen")return wt.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return u.PositionMode.Fixed;if(t=="percent")return u.PositionMode.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return J.Length;if(t=="fixed")return J.Fixed;if(t=="percent")return J.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return u.RotateMode.Tangent;if(t=="chain")return u.RotateMode.Chain;if(t=="chainscale")return u.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return u.TransformMode.Normal;if(t=="onlytranslation")return u.TransformMode.OnlyTranslation;if(t=="norotationorreflection")return u.TransformMode.NoRotationOrReflection;if(t=="noscale")return u.TransformMode.NoScale;if(t=="noscaleorreflection")return u.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ne{constructor(t,s,n,i,l){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=i,this.inheritDeform=l}}class ve extends u.SpineBase{createSkeleton(t){this.skeleton=new re(t),this.skeleton.updateWorldTransform(),this.stateData=new Jt(t),this.state=new ft(this.stateData)}}return C.Animation=j,C.AnimationState=ft,C.AnimationStateAdapter=ke,C.AnimationStateData=Jt,C.AtlasAttachmentLoader=Ve,C.Attachment=Gt,C.AttachmentTimeline=Vt,C.Bone=te,C.BoneData=ee,C.BoundingBoxAttachment=Xt,C.ClippingAttachment=Ot,C.ColorTimeline=st,C.ConstraintData=bt,C.CurveTimeline=lt,C.DeformTimeline=Zt,C.DrawOrderTimeline=Bt,C.Event=ne,C.EventData=se,C.EventQueue=Qt,C.EventTimeline=Lt,C.EventType=dt,C.IkConstraint=xe,C.IkConstraintData=ae,C.IkConstraintTimeline=et,C.JitterEffect=Ce,C.MeshAttachment=Ct,C.PathAttachment=kt,C.PathConstraint=Nt,C.PathConstraintData=ie,C.PathConstraintMixTimeline=xt,C.PathConstraintPositionTimeline=Et,C.PathConstraintSpacingTimeline=Mt,C.PointAttachment=Yt,C.RegionAttachment=B,C.RotateTimeline=tt,C.ScaleTimeline=ht,C.ShearTimeline=ct,C.Skeleton=re,C.SkeletonBinary=Q,C.SkeletonBounds=Be,C.SkeletonData=oe,C.SkeletonJson=Ft,C.Skin=Wt,C.SkinEntry=ce,C.Slot=jt,C.SlotData=le,C.SpacingMode=J,C.Spine=ve,C.SwirlEffect=ge,C.TimelineType=pe,C.TrackEntry=_t,C.TransformConstraint=Ee,C.TransformConstraintData=he,C.TransformConstraintTimeline=at,C.TranslateTimeline=mt,C.TwoColorTimeline=z,C.VertexAttachment=At,C}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-3.8.js.map
