/*!
 * @pixi-spine/runtime-3.8 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:36 UTC
 *
 * @pixi-spine/runtime-3.8 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as V,AttachmentType as pt,Color as W,MathUtils as R,PowOut as Xe,MixBlend as A,MixDirection as xt,IntSet as Ye,Pool as Oe,settings as ne,TransformMode as z,RotateMode as Tt,PositionMode as Vt,Vector2 as De,BinaryInput as Be,SkeletonBoundsBase as Le,SpineBase as _e}from"@pixi-spine/base";import{Matrix as We,BLEND_MODES as Pt}from"@pixi/core";class se{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const Ve=class extends se{constructor(e){super(e),this.id=(Ve.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,s,n,r,l){s=r+(s>>1)*l;const c=e.bone.skeleton,o=e.deform;let a=this.vertices;const i=this.bones;if(i==null){o.length>0&&(a=o);const d=e.bone.matrix,m=d.tx,g=d.ty,w=d.a,p=d.c,E=d.b,x=d.d;for(let b=t,I=r;I<s;b+=2,I+=l){const S=a[b],M=a[b+1];n[I]=S*w+M*p+m,n[I+1]=S*E+M*x+g}return}let h=0,u=0;for(let d=0;d<t;d+=2){const m=i[h];h+=m+1,u+=m}const f=c.bones;if(o.length==0)for(let d=r,m=u*3;d<s;d+=l){let g=0,w=0,p=i[h++];for(p+=h;h<p;h++,m+=3){const E=f[i[h]].matrix,x=a[m],b=a[m+1],I=a[m+2];g+=(x*E.a+b*E.c+E.tx)*I,w+=(x*E.b+b*E.d+E.ty)*I}n[d]=g,n[d+1]=w}else{const d=o;for(let m=r,g=u*3,w=u<<1;m<s;m+=l){let p=0,E=0,x=i[h++];for(x+=h;h<x;h++,g+=3,w+=2){const b=f[i[h]].matrix,I=a[g]+d[w],S=a[g+1]+d[w+1],M=a[g+2];p+=(I*b.a+S*b.c+b.tx)*M,E+=(I*b.b+S*b.d+b.ty)*M}n[m]=p,n[m+1]=E}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),V.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=V.newFloatArray(this.vertices.length),V.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let Ft=Ve;Ft.nextID=0;class Qt extends Ft{constructor(t){super(t),this.type=pt.BoundingBox,this.color=new W(1,1,1,1)}copy(){const t=new Qt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Kt extends Ft{constructor(t){super(t),this.type=pt.Clipping,this.color=new W(.2275,.2275,.8078,1)}copy(){const t=new Kt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Dt extends Ft{constructor(t){super(t),this.type=pt.Mesh,this.color=new W(1,1,1,1),this.tempColor=new W(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Dt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),V.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),V.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),V.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Dt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class Yt extends Ft{constructor(t){super(t),this.type=pt.Path,this.closed=!1,this.constantSpeed=!1,this.color=new W(1,1,1,1)}copy(){const t=new Yt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),V.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Jt extends Ft{constructor(t){super(t),this.type=pt.Point,this.color=new W(.38,.94,0,1)}computeWorldPosition(t,s){const n=t.matrix;return s.x=this.x*n.a+this.y*n.c+t.worldX,s.y=this.x*n.b+this.y*n.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,n=R.cosDeg(this.rotation),r=R.sinDeg(this.rotation),l=n*s.a+r*s.c,c=n*s.b+r*s.d;return Math.atan2(c,l)*R.radDeg}copy(){const t=new Jt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class ae{constructor(t,s){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new W,this.darkColor=t.darkColor==null?null:new W,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const et=class extends se{constructor(e){super(e),this.type=pt.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new W(1,1,1,1),this.offset=V.newFloatArray(8),this.uvs=V.newFloatArray(8),this.tempColor=new W(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*e,n=-this.height/2*this.scaleY+this.region.offsetY*t,r=s+this.region.width*e,l=n+this.region.height*t,c=this.rotation*Math.PI/180,o=Math.cos(c),a=Math.sin(c),i=s*o+this.x,h=s*a,u=n*o+this.y,f=n*a,d=r*o+this.x,m=r*a,g=l*o+this.y,w=l*a,p=this.offset;p[et.OX1]=i-f,p[et.OY1]=u+h,p[et.OX2]=i-w,p[et.OY2]=g+h,p[et.OX3]=d-w,p[et.OY3]=g+m,p[et.OX4]=d-f,p[et.OY4]=u+m}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,s,n){const r=this.offset,l=e instanceof ae?e.bone.matrix:e.matrix,c=l.tx,o=l.ty,a=l.a,i=l.c,h=l.b,u=l.d;let f=0,d=0;f=r[et.OX1],d=r[et.OY1],t[s]=f*a+d*i+c,t[s+1]=f*h+d*u+o,s+=n,f=r[et.OX2],d=r[et.OY2],t[s]=f*a+d*i+c,t[s+1]=f*h+d*u+o,s+=n,f=r[et.OX3],d=r[et.OY3],t[s]=f*a+d*i+c,t[s+1]=f*h+d*u+o,s+=n,f=r[et.OX4],d=r[et.OY4],t[s]=f*a+d*i+c,t[s+1]=f*h+d*u+o}copy(){const e=new et(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,V.arrayCopy(this.uvs,0,e.uvs,0,8),V.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let N=et;N.OX1=0,N.OY1=1,N.OX2=2,N.OY2=3,N.OX3=4,N.OY3=5,N.OX4=6,N.OY4=7,N.X1=0,N.Y1=1,N.C1R=2,N.C1G=3,N.C1B=4,N.C1A=5,N.U1=6,N.V1=7,N.X2=8,N.Y2=9,N.C2R=10,N.C2G=11,N.C2B=12,N.C2A=13,N.U2=14,N.V2=15,N.X3=16,N.Y3=17,N.C3R=18,N.C3G=19,N.C3B=20,N.C3A=21,N.U3=22,N.V3=23,N.X4=24,N.Y4=25,N.C4R=26,N.C4G=27,N.C4B=28,N.C4A=29,N.U4=30,N.V4=31;class qe{constructor(t,s){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=s}begin(t){}transform(t,s,n,r){t.x+=R.randomTriangular(-this.jitterX,this.jitterY),t.y+=R.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Ce=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,s,n){const r=this.angle*R.degreesToRadians,l=e.x-this.worldX,c=e.y-this.worldY,o=Math.sqrt(l*l+c*c);if(o<this.radius){const a=Ce.interpolation.apply(0,r,(this.radius-o)/this.radius),i=Math.cos(a),h=Math.sin(a);e.x=i*l-h*c+this.worldX,e.y=h*l+i*c+this.worldY}}end(){}};let ke=Ce;ke.interpolation=new Xe(2);class Q{constructor(t,s,n){if(t==null)throw new Error("name cannot be null.");if(s==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=s,this.timelineIds=[];for(let r=0;r<s.length;r++)this.timelineIds[s[r].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,s,n,r,l,c,o,a){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(n%=this.duration,s>0&&(s%=this.duration));const i=this.timelines;for(let h=0,u=i.length;h<u;h++)i[h].apply(t,s,n,l,c,o,a)}static binarySearch(t,s,n=1){let r=0,l=t.length/n-2;if(l==0)return n;let c=l>>>1;for(;;){if(t[(c+1)*n]<=s?r=c+1:l=c,r==l)return(r+1)*n;c=r+l>>>1}}static linearSearch(t,s,n){for(let r=0,l=t.length-n;r<=l;r+=n)if(t[r]>s)return r;return-1}}var Pe=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Pe||{});const K=class{constructor(e){if(e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=V.newFloatArray((e-1)*K.BEZIER_SIZE)}getFrameCount(){return this.curves.length/K.BEZIER_SIZE+1}setLinear(e){this.curves[e*K.BEZIER_SIZE]=K.LINEAR}setStepped(e){this.curves[e*K.BEZIER_SIZE]=K.STEPPED}getCurveType(e){const t=e*K.BEZIER_SIZE;if(t==this.curves.length)return K.LINEAR;const s=this.curves[t];return s==K.LINEAR?K.LINEAR:s==K.STEPPED?K.STEPPED:K.BEZIER}setCurve(e,t,s,n,r){const l=(-t*2+n)*.03,c=(-s*2+r)*.03,o=((t-n)*3+1)*.006,a=((s-r)*3+1)*.006;let i=l*2+o,h=c*2+a,u=t*.3+l+o*.16666667,f=s*.3+c+a*.16666667,d=e*K.BEZIER_SIZE;const m=this.curves;m[d++]=K.BEZIER;let g=u,w=f;for(let p=d+K.BEZIER_SIZE-1;d<p;d+=2)m[d]=g,m[d+1]=w,u+=i,f+=h,i+=o,h+=a,g+=u,w+=f}getCurvePercent(e,t){t=R.clamp(t,0,1);const s=this.curves;let n=e*K.BEZIER_SIZE;const r=s[n];if(r==K.LINEAR)return t;if(r==K.STEPPED)return 0;n++;let l=0;for(let o=n,a=n+K.BEZIER_SIZE-1;n<a;n+=2)if(l=s[n],l>=t){let i,h;return n==o?(i=0,h=0):(i=s[n-2],h=s[n-1]),h+(s[n+1]-h)*(t-i)/(l-i)}const c=s[n-1];return c+(1-c)*(t-l)/(1-l)}};let ut=K;ut.LINEAR=0,ut.STEPPED=1,ut.BEZIER=2,ut.BEZIER_SIZE=10*2-1;const Nt=class extends ut{constructor(t){super(t),this.frames=V.newFloatArray(t<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(t,s,n){t<<=1,this.frames[t]=s,this.frames[t+Nt.ROTATION]=n}apply(t,s,n,r,l,c,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<a[0]){switch(c){case A.setup:i.rotation=i.data.rotation;return;case A.first:const g=i.data.rotation-i.rotation;i.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*l}return}if(n>=a[a.length-Nt.ENTRIES]){let g=a[a.length+Nt.PREV_ROTATION];switch(c){case A.setup:i.rotation=i.data.rotation+g*l;break;case A.first:case A.replace:g+=i.data.rotation-i.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case A.add:i.rotation+=g*l}return}const h=Q.binarySearch(a,n,Nt.ENTRIES),u=a[h+Nt.PREV_ROTATION],f=a[h],d=this.getCurvePercent((h>>1)-1,1-(n-f)/(a[h+Nt.PREV_TIME]-f));let m=a[h+Nt.ROTATION]-u;switch(m=u+(m-(16384-(16384.499999999996-m/360|0))*360)*d,c){case A.setup:i.rotation=i.data.rotation+(m-(16384-(16384.499999999996-m/360|0))*360)*l;break;case A.first:case A.replace:m+=i.data.rotation-i.rotation;case A.add:i.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*l}}};let st=Nt;st.ENTRIES=2,st.PREV_TIME=-2,st.PREV_ROTATION=-1,st.ROTATION=1;const ot=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*ot.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,s,n){e*=ot.ENTRIES,this.frames[e]=t,this.frames[e+ot.X]=s,this.frames[e+ot.Y]=n}apply(e,t,s,n,r,l,c){const o=this.frames,a=e.bones[this.boneIndex];if(!a.active)return;if(s<o[0]){switch(l){case A.setup:a.x=a.data.x,a.y=a.data.y;return;case A.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let i=0,h=0;if(s>=o[o.length-ot.ENTRIES])i=o[o.length+ot.PREV_X],h=o[o.length+ot.PREV_Y];else{const u=Q.binarySearch(o,s,ot.ENTRIES);i=o[u+ot.PREV_X],h=o[u+ot.PREV_Y];const f=o[u],d=this.getCurvePercent(u/ot.ENTRIES-1,1-(s-f)/(o[u+ot.PREV_TIME]-f));i+=(o[u+ot.X]-i)*d,h+=(o[u+ot.Y]-h)*d}switch(l){case A.setup:a.x=a.data.x+i*r,a.y=a.data.y+h*r;break;case A.first:case A.replace:a.x+=(a.data.x+i-a.x)*r,a.y+=(a.data.y+h-a.y)*r;break;case A.add:a.x+=i*r,a.y+=h*r}}};let Et=ot;Et.ENTRIES=3,Et.PREV_TIME=-3,Et.PREV_X=-2,Et.PREV_Y=-1,Et.X=1,Et.Y=2;class mt extends Et{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,s,n,r,l,c,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<a[0]){switch(c){case A.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case A.first:i.scaleX+=(i.data.scaleX-i.scaleX)*l,i.scaleY+=(i.data.scaleY-i.scaleY)*l}return}let h=0,u=0;if(n>=a[a.length-mt.ENTRIES])h=a[a.length+mt.PREV_X]*i.data.scaleX,u=a[a.length+mt.PREV_Y]*i.data.scaleY;else{const f=Q.binarySearch(a,n,mt.ENTRIES);h=a[f+mt.PREV_X],u=a[f+mt.PREV_Y];const d=a[f],m=this.getCurvePercent(f/mt.ENTRIES-1,1-(n-d)/(a[f+mt.PREV_TIME]-d));h=(h+(a[f+mt.X]-h)*m)*i.data.scaleX,u=(u+(a[f+mt.Y]-u)*m)*i.data.scaleY}if(l==1)c==A.add?(i.scaleX+=h-i.data.scaleX,i.scaleY+=u-i.data.scaleY):(i.scaleX=h,i.scaleY=u);else{let f=0,d=0;if(o==xt.mixOut)switch(c){case A.setup:f=i.data.scaleX,d=i.data.scaleY,i.scaleX=f+(Math.abs(h)*R.signum(f)-f)*l,i.scaleY=d+(Math.abs(u)*R.signum(d)-d)*l;break;case A.first:case A.replace:f=i.scaleX,d=i.scaleY,i.scaleX=f+(Math.abs(h)*R.signum(f)-f)*l,i.scaleY=d+(Math.abs(u)*R.signum(d)-d)*l;break;case A.add:f=i.scaleX,d=i.scaleY,i.scaleX=f+(Math.abs(h)*R.signum(f)-i.data.scaleX)*l,i.scaleY=d+(Math.abs(u)*R.signum(d)-i.data.scaleY)*l}else switch(c){case A.setup:f=Math.abs(i.data.scaleX)*R.signum(h),d=Math.abs(i.data.scaleY)*R.signum(u),i.scaleX=f+(h-f)*l,i.scaleY=d+(u-d)*l;break;case A.first:case A.replace:f=Math.abs(i.scaleX)*R.signum(h),d=Math.abs(i.scaleY)*R.signum(u),i.scaleX=f+(h-f)*l,i.scaleY=d+(u-d)*l;break;case A.add:f=R.signum(h),d=R.signum(u),i.scaleX=Math.abs(i.scaleX)*f+(h-Math.abs(i.data.scaleX)*f)*l,i.scaleY=Math.abs(i.scaleY)*d+(u-Math.abs(i.data.scaleY)*d)*l}}}}class gt extends Et{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,s,n,r,l,c,o){const a=this.frames,i=t.bones[this.boneIndex];if(!i.active)return;if(n<a[0]){switch(c){case A.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case A.first:i.shearX+=(i.data.shearX-i.shearX)*l,i.shearY+=(i.data.shearY-i.shearY)*l}return}let h=0,u=0;if(n>=a[a.length-gt.ENTRIES])h=a[a.length+gt.PREV_X],u=a[a.length+gt.PREV_Y];else{const f=Q.binarySearch(a,n,gt.ENTRIES);h=a[f+gt.PREV_X],u=a[f+gt.PREV_Y];const d=a[f],m=this.getCurvePercent(f/gt.ENTRIES-1,1-(n-d)/(a[f+gt.PREV_TIME]-d));h=h+(a[f+gt.X]-h)*m,u=u+(a[f+gt.Y]-u)*m}switch(c){case A.setup:i.shearX=i.data.shearX+h*l,i.shearY=i.data.shearY+u*l;break;case A.first:case A.replace:i.shearX+=(i.data.shearX+h-i.shearX)*l,i.shearY+=(i.data.shearY+u-i.shearY)*l;break;case A.add:i.shearX+=h*l,i.shearY+=u*l}}}const $=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*$.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,s,n,r,l){e*=$.ENTRIES,this.frames[e]=t,this.frames[e+$.R]=s,this.frames[e+$.G]=n,this.frames[e+$.B]=r,this.frames[e+$.A]=l}apply(e,t,s,n,r,l,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const a=this.frames;if(s<a[0]){switch(l){case A.setup:o.color.setFromColor(o.data.color);return;case A.first:const d=o.color,m=o.data.color;d.add((m.r-d.r)*r,(m.g-d.g)*r,(m.b-d.b)*r,(m.a-d.a)*r)}return}let i=0,h=0,u=0,f=0;if(s>=a[a.length-$.ENTRIES]){const d=a.length;i=a[d+$.PREV_R],h=a[d+$.PREV_G],u=a[d+$.PREV_B],f=a[d+$.PREV_A]}else{const d=Q.binarySearch(a,s,$.ENTRIES);i=a[d+$.PREV_R],h=a[d+$.PREV_G],u=a[d+$.PREV_B],f=a[d+$.PREV_A];const m=a[d],g=this.getCurvePercent(d/$.ENTRIES-1,1-(s-m)/(a[d+$.PREV_TIME]-m));i+=(a[d+$.R]-i)*g,h+=(a[d+$.G]-h)*g,u+=(a[d+$.B]-u)*g,f+=(a[d+$.A]-f)*g}if(r==1)o.color.set(i,h,u,f);else{const d=o.color;l==A.setup&&d.setFromColor(o.data.color),d.add((i-d.r)*r,(h-d.g)*r,(u-d.b)*r,(f-d.a)*r)}}};let lt=$;lt.ENTRIES=5,lt.PREV_TIME=-5,lt.PREV_R=-4,lt.PREV_G=-3,lt.PREV_B=-2,lt.PREV_A=-1,lt.R=1,lt.G=2,lt.B=3,lt.A=4;const D=class extends ut{constructor(t){super(t),this.frames=V.newFloatArray(t*D.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,s,n,r,l,c,o,a,i){t*=D.ENTRIES,this.frames[t]=s,this.frames[t+D.R]=n,this.frames[t+D.G]=r,this.frames[t+D.B]=l,this.frames[t+D.A]=c,this.frames[t+D.R2]=o,this.frames[t+D.G2]=a,this.frames[t+D.B2]=i}apply(t,s,n,r,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const i=this.frames;if(n<i[0]){switch(c){case A.setup:a.color.setFromColor(a.data.color),a.darkColor.setFromColor(a.data.darkColor);return;case A.first:const p=a.color,E=a.darkColor,x=a.data.color,b=a.data.darkColor;p.add((x.r-p.r)*l,(x.g-p.g)*l,(x.b-p.b)*l,(x.a-p.a)*l),E.add((b.r-E.r)*l,(b.g-E.g)*l,(b.b-E.b)*l,0)}return}let h=0,u=0,f=0,d=0,m=0,g=0,w=0;if(n>=i[i.length-D.ENTRIES]){const p=i.length;h=i[p+D.PREV_R],u=i[p+D.PREV_G],f=i[p+D.PREV_B],d=i[p+D.PREV_A],m=i[p+D.PREV_R2],g=i[p+D.PREV_G2],w=i[p+D.PREV_B2]}else{const p=Q.binarySearch(i,n,D.ENTRIES);h=i[p+D.PREV_R],u=i[p+D.PREV_G],f=i[p+D.PREV_B],d=i[p+D.PREV_A],m=i[p+D.PREV_R2],g=i[p+D.PREV_G2],w=i[p+D.PREV_B2];const E=i[p],x=this.getCurvePercent(p/D.ENTRIES-1,1-(n-E)/(i[p+D.PREV_TIME]-E));h+=(i[p+D.R]-h)*x,u+=(i[p+D.G]-u)*x,f+=(i[p+D.B]-f)*x,d+=(i[p+D.A]-d)*x,m+=(i[p+D.R2]-m)*x,g+=(i[p+D.G2]-g)*x,w+=(i[p+D.B2]-w)*x}if(l==1)a.color.set(h,u,f,d),a.darkColor.set(m,g,w,1);else{const p=a.color,E=a.darkColor;c==A.setup&&(p.setFromColor(a.data.color),E.setFromColor(a.data.darkColor)),p.add((h-p.r)*l,(u-p.g)*l,(f-p.b)*l,(d-p.a)*l),E.add((m-E.r)*l,(g-E.g)*l,(w-E.b)*l,0)}}};let J=D;J.ENTRIES=8,J.PREV_TIME=-8,J.PREV_R=-7,J.PREV_G=-6,J.PREV_B=-5,J.PREV_A=-4,J.PREV_R2=-3,J.PREV_G2=-2,J.PREV_B2=-1,J.R=1,J.G=2,J.B=3,J.A=4,J.R2=5,J.G2=6,J.B2=7;class vt{constructor(t){this.frames=V.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.frames[t]=s,this.attachmentNames[t]=n}apply(t,s,n,r,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;if(o==xt.mixOut){c==A.setup&&this.setAttachment(t,a,a.data.attachmentName);return}const i=this.frames;if(n<i[0]){(c==A.setup||c==A.first)&&this.setAttachment(t,a,a.data.attachmentName);return}let h=0;n>=i[i.length-1]?h=i.length-1:h=Q.binarySearch(i,n,1)-1;const u=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(u==null?null:t.getAttachment(this.slotIndex,u))}setAttachment(t,s,n){s.setAttachment(n==null?null:t.getAttachment(this.slotIndex,n))}}let Fe=null;class re extends ut{constructor(t){super(t),this.frames=V.newFloatArray(t),this.frameVertices=new Array(t),Fe==null&&(Fe=V.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,s,n){this.frames[t]=s,this.frameVertices[t]=n}apply(t,s,n,r,l,c,o){const a=t.slots[this.slotIndex];if(!a.bone.active)return;const i=a.getAttachment();if(!(i instanceof Ft)||i.deformAttachment!=this.attachment)return;const h=a.deform;h.length==0&&(c=A.setup);const u=this.frameVertices,f=u[0].length,d=this.frames;if(n<d[0]){const b=i;switch(c){case A.setup:h.length=0;return;case A.first:if(l==1){h.length=0;break}const I=V.setArraySize(h,f);if(b.bones==null){const S=b.vertices;for(let M=0;M<f;M++)I[M]+=(S[M]-I[M])*l}else{l=1-l;for(let S=0;S<f;S++)I[S]*=l}}return}const m=V.setArraySize(h,f);if(n>=d[d.length-1]){const b=u[d.length-1];if(l==1)if(c==A.add){const I=i;if(I.bones==null){const S=I.vertices;for(let M=0;M<f;M++)m[M]+=b[M]-S[M]}else for(let S=0;S<f;S++)m[S]+=b[S]}else V.arrayCopy(b,0,m,0,f);else switch(c){case A.setup:{const S=i;if(S.bones==null){const M=S.vertices;for(let T=0;T<f;T++){const y=M[T];m[T]=y+(b[T]-y)*l}}else for(let M=0;M<f;M++)m[M]=b[M]*l;break}case A.first:case A.replace:for(let S=0;S<f;S++)m[S]+=(b[S]-m[S])*l;break;case A.add:const I=i;if(I.bones==null){const S=I.vertices;for(let M=0;M<f;M++)m[M]+=(b[M]-S[M])*l}else for(let S=0;S<f;S++)m[S]+=b[S]*l}return}const g=Q.binarySearch(d,n),w=u[g-1],p=u[g],E=d[g],x=this.getCurvePercent(g-1,1-(n-E)/(d[g-1]-E));if(l==1)if(c==A.add){const b=i;if(b.bones==null){const I=b.vertices;for(let S=0;S<f;S++){const M=w[S];m[S]+=M+(p[S]-M)*x-I[S]}}else for(let I=0;I<f;I++){const S=w[I];m[I]+=S+(p[I]-S)*x}}else for(let b=0;b<f;b++){const I=w[b];m[b]=I+(p[b]-I)*x}else switch(c){case A.setup:{const I=i;if(I.bones==null){const S=I.vertices;for(let M=0;M<f;M++){const T=w[M],y=S[M];m[M]=y+(T+(p[M]-T)*x-y)*l}}else for(let S=0;S<f;S++){const M=w[S];m[S]=(M+(p[S]-M)*x)*l}break}case A.first:case A.replace:for(let I=0;I<f;I++){const S=w[I];m[I]+=(S+(p[I]-S)*x-m[I])*l}break;case A.add:const b=i;if(b.bones==null){const I=b.vertices;for(let S=0;S<f;S++){const M=w[S];m[S]+=(M+(p[S]-M)*x-I[S])*l}}else for(let I=0;I<f;I++){const S=w[I];m[I]+=(S+(p[I]-S)*x)*l}}}}class Gt{constructor(t){this.frames=V.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,s){this.frames[t]=s.time,this.events[t]=s}apply(t,s,n,r,l,c,o){if(r==null)return;const a=this.frames,i=this.frames.length;if(s>n)this.apply(t,s,Number.MAX_VALUE,r,l,c,o),s=-1;else if(s>=a[i-1])return;if(n<a[0])return;let h=0;if(s<a[0])h=0;else{h=Q.binarySearch(a,s);const u=a[h];for(;h>0&&a[h-1]==u;)h--}for(;h<i&&n>=a[h];h++)r.push(this.events[h])}}class _t{constructor(t){this.frames=V.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,s,n){this.frames[t]=s,this.drawOrders[t]=n}apply(t,s,n,r,l,c,o){const a=t.drawOrder,i=t.slots;if(o==xt.mixOut&&c==A.setup){V.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const h=this.frames;if(n<h[0]){(c==A.setup||c==A.first)&&V.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let u=0;n>=h[h.length-1]?u=h.length-1:u=Q.binarySearch(h,n)-1;const f=this.drawOrders[u];if(f==null)V.arrayCopy(i,0,a,0,i.length);else for(let d=0,m=f.length;d<m;d++)a[d]=i[f[d]]}}const B=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*B.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,s,n,r,l,c){e*=B.ENTRIES,this.frames[e]=t,this.frames[e+B.MIX]=s,this.frames[e+B.SOFTNESS]=n,this.frames[e+B.BEND_DIRECTION]=r,this.frames[e+B.COMPRESS]=l?1:0,this.frames[e+B.STRETCH]=c?1:0}apply(e,t,s,n,r,l,c){const o=this.frames,a=e.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case A.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case A.first:a.mix+=(a.data.mix-a.mix)*r,a.softness+=(a.data.softness-a.softness)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=o[o.length-B.ENTRIES]){l==A.setup?(a.mix=a.data.mix+(o[o.length+B.PREV_MIX]-a.data.mix)*r,a.softness=a.data.softness+(o[o.length+B.PREV_SOFTNESS]-a.data.softness)*r,c==xt.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[o.length+B.PREV_BEND_DIRECTION],a.compress=o[o.length+B.PREV_COMPRESS]!=0,a.stretch=o[o.length+B.PREV_STRETCH]!=0)):(a.mix+=(o[o.length+B.PREV_MIX]-a.mix)*r,a.softness+=(o[o.length+B.PREV_SOFTNESS]-a.softness)*r,c==xt.mixIn&&(a.bendDirection=o[o.length+B.PREV_BEND_DIRECTION],a.compress=o[o.length+B.PREV_COMPRESS]!=0,a.stretch=o[o.length+B.PREV_STRETCH]!=0));return}const i=Q.binarySearch(o,s,B.ENTRIES),h=o[i+B.PREV_MIX],u=o[i+B.PREV_SOFTNESS],f=o[i],d=this.getCurvePercent(i/B.ENTRIES-1,1-(s-f)/(o[i+B.PREV_TIME]-f));l==A.setup?(a.mix=a.data.mix+(h+(o[i+B.MIX]-h)*d-a.data.mix)*r,a.softness=a.data.softness+(u+(o[i+B.SOFTNESS]-u)*d-a.data.softness)*r,c==xt.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[i+B.PREV_BEND_DIRECTION],a.compress=o[i+B.PREV_COMPRESS]!=0,a.stretch=o[i+B.PREV_STRETCH]!=0)):(a.mix+=(h+(o[i+B.MIX]-h)*d-a.mix)*r,a.softness+=(u+(o[i+B.SOFTNESS]-u)*d-a.softness)*r,c==xt.mixIn&&(a.bendDirection=o[i+B.PREV_BEND_DIRECTION],a.compress=o[i+B.PREV_COMPRESS]!=0,a.stretch=o[i+B.PREV_STRETCH]!=0))}};let at=B;at.ENTRIES=6,at.PREV_TIME=-6,at.PREV_MIX=-5,at.PREV_SOFTNESS=-4,at.PREV_BEND_DIRECTION=-3,at.PREV_COMPRESS=-2,at.PREV_STRETCH=-1,at.MIX=1,at.SOFTNESS=2,at.BEND_DIRECTION=3,at.COMPRESS=4,at.STRETCH=5;const H=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*H.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,s,n,r,l){e*=H.ENTRIES,this.frames[e]=t,this.frames[e+H.ROTATE]=s,this.frames[e+H.TRANSLATE]=n,this.frames[e+H.SCALE]=r,this.frames[e+H.SHEAR]=l}apply(e,t,s,n,r,l,c){const o=this.frames,a=e.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(s<o[0]){const d=a.data;switch(l){case A.setup:a.rotateMix=d.rotateMix,a.translateMix=d.translateMix,a.scaleMix=d.scaleMix,a.shearMix=d.shearMix;return;case A.first:a.rotateMix+=(d.rotateMix-a.rotateMix)*r,a.translateMix+=(d.translateMix-a.translateMix)*r,a.scaleMix+=(d.scaleMix-a.scaleMix)*r,a.shearMix+=(d.shearMix-a.shearMix)*r}return}let i=0,h=0,u=0,f=0;if(s>=o[o.length-H.ENTRIES]){const d=o.length;i=o[d+H.PREV_ROTATE],h=o[d+H.PREV_TRANSLATE],u=o[d+H.PREV_SCALE],f=o[d+H.PREV_SHEAR]}else{const d=Q.binarySearch(o,s,H.ENTRIES);i=o[d+H.PREV_ROTATE],h=o[d+H.PREV_TRANSLATE],u=o[d+H.PREV_SCALE],f=o[d+H.PREV_SHEAR];const m=o[d],g=this.getCurvePercent(d/H.ENTRIES-1,1-(s-m)/(o[d+H.PREV_TIME]-m));i+=(o[d+H.ROTATE]-i)*g,h+=(o[d+H.TRANSLATE]-h)*g,u+=(o[d+H.SCALE]-u)*g,f+=(o[d+H.SHEAR]-f)*g}if(l==A.setup){const d=a.data;a.rotateMix=d.rotateMix+(i-d.rotateMix)*r,a.translateMix=d.translateMix+(h-d.translateMix)*r,a.scaleMix=d.scaleMix+(u-d.scaleMix)*r,a.shearMix=d.shearMix+(f-d.shearMix)*r}else a.rotateMix+=(i-a.rotateMix)*r,a.translateMix+=(h-a.translateMix)*r,a.scaleMix+=(u-a.scaleMix)*r,a.shearMix+=(f-a.shearMix)*r}};let ht=H;ht.ENTRIES=5,ht.PREV_TIME=-5,ht.PREV_ROTATE=-4,ht.PREV_TRANSLATE=-3,ht.PREV_SCALE=-2,ht.PREV_SHEAR=-1,ht.ROTATE=1,ht.TRANSLATE=2,ht.SCALE=3,ht.SHEAR=4;const St=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*St.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,s){e*=St.ENTRIES,this.frames[e]=t,this.frames[e+St.VALUE]=s}apply(e,t,s,n,r,l,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case A.setup:a.position=a.data.position;return;case A.first:a.position+=(a.data.position-a.position)*r}return}let i=0;if(s>=o[o.length-St.ENTRIES])i=o[o.length+St.PREV_VALUE];else{const h=Q.binarySearch(o,s,St.ENTRIES);i=o[h+St.PREV_VALUE];const u=o[h],f=this.getCurvePercent(h/St.ENTRIES-1,1-(s-u)/(o[h+St.PREV_TIME]-u));i+=(o[h+St.VALUE]-i)*f}l==A.setup?a.position=a.data.position+(i-a.data.position)*r:a.position+=(i-a.position)*r}};let Rt=St;Rt.ENTRIES=2,Rt.PREV_TIME=-2,Rt.PREV_VALUE=-1,Rt.VALUE=1;class It extends Rt{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,s,n,r,l,c,o){const a=this.frames,i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<a[0]){switch(c){case A.setup:i.spacing=i.data.spacing;return;case A.first:i.spacing+=(i.data.spacing-i.spacing)*l}return}let h=0;if(n>=a[a.length-It.ENTRIES])h=a[a.length+It.PREV_VALUE];else{const u=Q.binarySearch(a,n,It.ENTRIES);h=a[u+It.PREV_VALUE];const f=a[u],d=this.getCurvePercent(u/It.ENTRIES-1,1-(n-f)/(a[u+It.PREV_TIME]-f));h+=(a[u+It.VALUE]-h)*d}c==A.setup?i.spacing=i.data.spacing+(h-i.data.spacing)*l:i.spacing+=(h-i.spacing)*l}}const ct=class extends ut{constructor(e){super(e),this.frames=V.newFloatArray(e*ct.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,s,n){e*=ct.ENTRIES,this.frames[e]=t,this.frames[e+ct.ROTATE]=s,this.frames[e+ct.TRANSLATE]=n}apply(e,t,s,n,r,l,c){const o=this.frames,a=e.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<o[0]){switch(l){case A.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case A.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let i=0,h=0;if(s>=o[o.length-ct.ENTRIES])i=o[o.length+ct.PREV_ROTATE],h=o[o.length+ct.PREV_TRANSLATE];else{const u=Q.binarySearch(o,s,ct.ENTRIES);i=o[u+ct.PREV_ROTATE],h=o[u+ct.PREV_TRANSLATE];const f=o[u],d=this.getCurvePercent(u/ct.ENTRIES-1,1-(s-f)/(o[u+ct.PREV_TIME]-f));i+=(o[u+ct.ROTATE]-i)*d,h+=(o[u+ct.TRANSLATE]-h)*d}l==A.setup?(a.rotateMix=a.data.rotateMix+(i-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(h-a.data.translateMix)*r):(a.rotateMix+=(i-a.rotateMix)*r,a.translateMix+=(h-a.translateMix)*r)}};let Mt=ct;Mt.ENTRIES=3,Mt.PREV_TIME=-3,Mt.PREV_ROTATE=-2,Mt.PREV_TRANSLATE=-1,Mt.ROTATE=1,Mt.TRANSLATE=2;const G=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new oe(this),this.propertyIDs=new Ye,this.animationsChanged=!1,this.trackEntryPool=new Oe(()=>new jt),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=e*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let c=r.next;if(c!=null){const o=r.trackLast-c.delay;if(o>=0){for(c.delay=0,c.trackTime+=r.timeScale==0?0:(o/r.timeScale+e)*c.timeScale,r.trackTime+=l,this.setCurrent(s,c,!0);c.mixingFrom!=null;)c.mixTime+=e,c=c.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){t[s]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,e)){let o=r.mixingFrom;for(r.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(e,t){const s=e.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((s.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=e),e.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=t*s.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let n=!1;for(let c=0,o=s.length;c<o;c++){const a=s[c];if(a==null||a.delay>0)continue;n=!0;const i=c==0?A.first:a.mixBlend;let h=a.alpha;a.mixingFrom!=null?h*=this.applyMixingFrom(a,e,i):a.trackTime>=a.trackEnd&&a.next==null&&(h=0);const u=a.animationLast,f=a.getAnimationTime(),d=a.animation.timelines.length,m=a.animation.timelines;if(c==0&&h==1||i==A.add)for(let g=0;g<d;g++){V.webkit602BugfixHelper(h,i);const w=m[g];w instanceof vt?this.applyAttachmentTimeline(w,e,f,i,!0):w.apply(e,u,f,t,h,i,xt.mixIn)}else{const g=a.timelineMode,w=a.timelinesRotation.length==0;w&&V.setArraySize(a.timelinesRotation,d<<1,null);const p=a.timelinesRotation;for(let E=0;E<d;E++){const x=m[E],b=g[E]==G.SUBSEQUENT?i:A.setup;x instanceof st?this.applyRotateTimeline(x,e,f,h,b,p,E<<1,w):x instanceof vt?this.applyAttachmentTimeline(x,e,f,i,!0):(V.webkit602BugfixHelper(h,i),x.apply(e,u,f,t,h,b,xt.mixIn))}}this.queueEvents(a,f),t.length=0,a.nextAnimationLast=f,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+G.SETUP,l=e.slots;for(let c=0,o=e.slots.length;c<o;c++){const a=l[c];if(a.attachmentState==r){const i=a.data.attachmentName;a.setAttachment(i==null?null:e.getAttachment(a.data.index,i))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(e,t,s){const n=e.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,t,s);let r=0;e.mixDuration==0?(r=1,s==A.first&&(s=A.setup)):(r=e.mixTime/e.mixDuration,r>1&&(r=1),s!=A.first&&(s=n.mixBlend));const l=r<n.eventThreshold?this.events:null,c=r<n.attachmentThreshold,o=r<n.drawOrderThreshold,a=n.animationLast,i=n.getAnimationTime(),h=n.animation.timelines.length,u=n.animation.timelines,f=n.alpha*e.interruptAlpha,d=f*(1-r);if(s==A.add)for(let m=0;m<h;m++)u[m].apply(t,a,i,l,d,s,xt.mixOut);else{const m=n.timelineMode,g=n.timelineHoldMix,w=n.timelinesRotation.length==0;w&&V.setArraySize(n.timelinesRotation,h<<1,null);const p=n.timelinesRotation;n.totalAlpha=0;for(let E=0;E<h;E++){const x=u[E];let b=xt.mixOut,I,S=0;switch(m[E]){case G.SUBSEQUENT:if(!o&&x instanceof _t)continue;I=s,S=d;break;case G.FIRST:I=A.setup,S=d;break;case G.HOLD_SUBSEQUENT:I=s,S=f;break;case G.HOLD_FIRST:I=A.setup,S=f;break;default:I=A.setup;const M=g[E];S=f*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=S,x instanceof st?this.applyRotateTimeline(x,t,i,S,I,p,E<<1,w):x instanceof vt?this.applyAttachmentTimeline(x,t,i,I,c):(V.webkit602BugfixHelper(S,s),o&&x instanceof _t&&I==A.setup&&(b=xt.mixIn),x.apply(t,a,i,l,S,I,b))}}return e.mixDuration>0&&this.queueEvents(n,i),this.events.length=0,n.nextAnimationLast=i,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(e,t,s,n,r){const l=t.slots[e.slotIndex];if(!l.bone.active)return;const c=e.frames;if(s<c[0])(n==A.setup||n==A.first)&&this.setAttachment(t,l,l.data.attachmentName,r);else{let o;s>=c[c.length-1]?o=c.length-1:o=Q.binarySearch(c,s)-1,this.setAttachment(t,l,e.attachmentNames[o],r)}l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+G.SETUP)}setAttachment(e,t,s,n){t.setAttachment(s==null?null:e.getAttachment(t.data.index,s)),n&&(t.attachmentState=this.unkeyedState+G.CURRENT)}applyRotateTimeline(e,t,s,n,r,l,c,o){if(o&&(l[c]=0),n==1){e.apply(t,0,s,null,1,r,xt.mixIn);return}const a=e,i=a.frames,h=t.bones[a.boneIndex];if(!h.active)return;let u=0,f=0;if(s<i[0])switch(r){case A.setup:h.rotation=h.data.rotation;default:return;case A.first:u=h.rotation,f=h.data.rotation}else if(u=r==A.setup?h.data.rotation:h.rotation,s>=i[i.length-st.ENTRIES])f=h.data.rotation+i[i.length+st.PREV_ROTATION];else{const g=Q.binarySearch(i,s,st.ENTRIES),w=i[g+st.PREV_ROTATION],p=i[g],E=a.getCurvePercent((g>>1)-1,1-(s-p)/(i[g+st.PREV_TIME]-p));f=i[g+st.ROTATION]-w,f-=(16384-(16384.499999999996-f/360|0))*360,f=w+f*E+h.data.rotation,f-=(16384-(16384.499999999996-f/360|0))*360}let d=0,m=f-u;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)d=l[c];else{let g=0,w=0;o?(g=0,w=m):(g=l[c],w=l[c+1]);const p=m>0;let E=g>=0;R.signum(w)!=R.signum(m)&&Math.abs(w)<=90&&(Math.abs(g)>180&&(g+=360*R.signum(g)),E=p),d=m+g-g%360,E!=p&&(d+=360*R.signum(g)),l[c]=d}l[c+1]=m,u+=d*n,h.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(e,t){const s=e.animationStart,n=e.animationEnd,r=n-s,l=e.trackLast%r,c=this.events;let o=0;const a=c.length;for(;o<a;o++){const h=c[o];if(h.time<l)break;h.time>n||this.queue.event(e,h)}let i=!1;for(e.loop?i=r==0||l>e.trackTime%r:i=t>=n&&e.animationLast<n,i&&this.queue.complete(e);o<a;o++)c[o].time<s||this.queue.event(e,c[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let s=t;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,s){const n=this.expandToIndex(e);this.tracks[e]=t,n!=null&&(s&&this.queue.interrupt(n),t.mixingFrom=n,n.mixingTo=t,t.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(t.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,s){const n=this.data.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,n,s)}setAnimationWith(e,t,s){if(t==null)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(e);r!=null&&(r.nextTrackLast==-1?(this.tracks[e]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,n=!1):this.disposeNext(r));const l=this.trackEntry(e,t,s,r);return this.setCurrent(e,l,n),this.queue.drain(),l}addAnimation(e,t,s,n){const r=this.data.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,r,s,n)}addAnimationWith(e,t,s,n){if(t==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(e);if(r!=null)for(;r.next!=null;)r=r.next;const l=this.trackEntry(e,t,s,r);if(r==null)this.setCurrent(e,l,!0),this.queue.drain();else if(r.next=l,n<=0){const c=r.animationEnd-r.animationStart;c!=0?(r.loop?n+=c*(1+(r.trackTime/c|0)):n+=Math.max(c,r.trackTime),n-=this.data.getMix(r.animation,t)):n=r.trackTime}return l.delay=n,l}setEmptyAnimation(e,t){const s=this.setAnimationWith(e,G.emptyAnimation,!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(e,t,s){s<=0&&(s-=t);const n=this.addAnimationWith(e,G.emptyAnimation,!1,s);return n.mixDuration=t,n.trackEnd=t,n}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r!=null&&this.setEmptyAnimation(r.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(V.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,s,n){const r=this.trackEntryPool.obtain();return r.trackIndex=e,r.animation=t,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n==null?0:this.data.getMix(n.animation,t),r.mixBlend=A.replace,r}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let s=this.tracks[e];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=A.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(e){const t=e.mixingTo,s=e.animation.timelines,n=e.animation.timelines.length,r=V.setArraySize(e.timelineMode,n);e.timelineHoldMix.length=0;const l=V.setArraySize(e.timelineHoldMix,n),c=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<n;o++)r[o]=c.add(s[o].getPropertyId())?G.HOLD_FIRST:G.HOLD_SUBSEQUENT;return}t:for(let o=0;o<n;o++){const a=s[o],i=a.getPropertyId();if(!c.add(i))r[o]=G.SUBSEQUENT;else if(t==null||a instanceof vt||a instanceof _t||a instanceof Gt||!t.animation.hasTimeline(i))r[o]=G.FIRST;else{for(let h=t.mixingTo;h!=null;h=h.mixingTo)if(!h.animation.hasTimeline(i)){if(e.mixDuration>0){r[o]=G.HOLD_MIX,l[o]=h;continue t}break}r[o]=G.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,s){G.deprecatedWarning1||(G.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,s)}addAnimationByName(e,t,s,n){G.deprecatedWarning2||(G.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,s,n)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return G.deprecatedWarning3||(G.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let wt=G;wt.emptyAnimation=new Q("<empty>",[],0),wt.SUBSEQUENT=0,wt.FIRST=1,wt.HOLD_SUBSEQUENT=2,wt.HOLD_FIRST=3,wt.HOLD_MIX=4,wt.SETUP=1,wt.CURRENT=2,wt.deprecatedWarning1=!1,wt.deprecatedWarning2=!1,wt.deprecatedWarning3=!1;const Ct=class{constructor(){this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){Ct.deprecatedWarning1||(Ct.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return Ct.deprecatedWarning2||(Ct.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){Ct.deprecatedWarning2||(Ct.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let jt=Ct;jt.deprecatedWarning1=!1,jt.deprecatedWarning2=!1;const ie=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(ft.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(ft.interrupt),this.objects.push(e)}end(e){this.objects.push(ft.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(ft.dispose),this.objects.push(e)}complete(e){this.objects.push(ft.complete),this.objects.push(e)}event(e,t){this.objects.push(ft.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return ie.deprecatedWarning1||(ie.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let s=0;s<e.length;s+=2){const n=e[s],r=e[s+1];switch(n){case ft.start:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case ft.interrupt:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(r);break;case ft.end:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case ft.dispose:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(r);this.animState.trackEntryPool.free(r);break;case ft.complete:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(r);const l=R.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,l);break;case ft.event:const c=e[s+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,c);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(r,c);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,c),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,c);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let oe=ie;oe.deprecatedWarning1=!1;var ft=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(ft||{});class Ue{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const le=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,s){const n=this.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(n,r,s)}setMixByName(e,t,s){le.deprecatedWarning1||(le.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,s)}setMixWith(e,t,s){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const n=`${e.name}.${t.name}`;this.animationToMixTime[n]=s}getMix(e,t){const s=`${e.name}.${t.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};let he=le;he.deprecatedWarning1=!1;class $e{constructor(t){this.atlas=t}newRegionAttachment(t,s,n){const r=this.atlas.findRegion(n);if(r==null)throw new Error(`Region not found in atlas: ${n} (region attachment: ${s})`);const l=new N(s);return l.region=r,l}newMeshAttachment(t,s,n){const r=this.atlas.findRegion(n);if(r==null)throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${s})`);const l=new Dt(s);return l.region=r,l}newBoundingBoxAttachment(t,s){return new Qt(s)}newPathAttachment(t,s){return new Yt(s)}newPointAttachment(t,s){return new Jt(s)}newClippingAttachment(t,s){return new Kt(s)}}class ce{constructor(t,s,n){if(this.matrix=new We,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=n,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,n,r,l,c,o){this.ax=t,this.ay=s,this.arotation=n,this.ascaleX=r,this.ascaleY=l,this.ashearX=c,this.ashearY=o,this.appliedValid=!0;const a=this.parent,i=this.matrix,h=this.skeleton.scaleX,u=ne.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(a==null){const w=this.skeleton,p=n+90+o;i.a=R.cosDeg(n+c)*r*h,i.c=R.cosDeg(p)*l*h,i.b=R.sinDeg(n+c)*r*u,i.d=R.sinDeg(p)*l*u,i.tx=t*h+w.x,i.ty=s*u+w.y;return}let f=a.matrix.a,d=a.matrix.c,m=a.matrix.b,g=a.matrix.d;switch(i.tx=f*t+d*s+a.matrix.tx,i.ty=m*t+g*s+a.matrix.ty,this.data.transformMode){case z.Normal:{const w=n+90+o,p=R.cosDeg(n+c)*r,E=R.cosDeg(w)*l,x=R.sinDeg(n+c)*r,b=R.sinDeg(w)*l;i.a=f*p+d*x,i.c=f*E+d*b,i.b=m*p+g*x,i.d=m*E+g*b;return}case z.OnlyTranslation:{const w=n+90+o;i.a=R.cosDeg(n+c)*r,i.c=R.cosDeg(w)*l,i.b=R.sinDeg(n+c)*r,i.d=R.sinDeg(w)*l;break}case z.NoRotationOrReflection:{let w=f*f+m*m,p=0;w>1e-4?(w=Math.abs(f*g-d*m)/w,f/=this.skeleton.scaleX,m/=this.skeleton.scaleY,d=m*w,g=f*w,p=Math.atan2(m,f)*R.radDeg):(f=0,m=0,p=90-Math.atan2(g,d)*R.radDeg);const E=n+c-p,x=n+o-p+90,b=R.cosDeg(E)*r,I=R.cosDeg(x)*l,S=R.sinDeg(E)*r,M=R.sinDeg(x)*l;i.a=f*b-d*S,i.c=f*I-d*M,i.b=m*b+g*S,i.d=m*I+g*M;break}case z.NoScale:case z.NoScaleOrReflection:{const w=R.cosDeg(n),p=R.sinDeg(n);let E=(f*w+d*p)/h,x=(m*w+g*p)/u,b=Math.sqrt(E*E+x*x);b>1e-5&&(b=1/b),E*=b,x*=b,b=Math.sqrt(E*E+x*x),this.data.transformMode==z.NoScale&&f*g-d*m<0!=(ne.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(b=-b);const I=Math.PI/2+Math.atan2(x,E),S=Math.cos(I)*b,M=Math.sin(I)*b,T=R.cosDeg(c)*r,y=R.cosDeg(90+o)*l,C=R.sinDeg(c)*r,O=R.sinDeg(90+o)*l;i.a=E*T+S*C,i.c=E*y+S*O,i.b=x*T+M*C,i.d=x*y+M*O;break}}i.a*=h,i.c*=h,i.b*=u,i.d*=u}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*R.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*R.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,s=this.matrix;if(t==null){this.ax=s.tx,this.ay=s.ty,this.arotation=Math.atan2(s.b,s.a)*R.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*R.radDeg;return}const n=t.matrix,r=1/(n.a*n.d-n.b*n.c),l=s.tx-n.tx,c=s.ty-n.ty;this.ax=l*n.d*r-c*n.c*r,this.ay=c*n.a*r-l*n.b*r;const o=r*n.d,a=r*n.a,i=r*n.c,h=r*n.b,u=o*s.a-i*s.b,f=o*s.c-i*s.d,d=a*s.b-h*s.a,m=a*s.d-h*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(u*u+d*d),this.ascaleX>1e-4){const g=u*m-f*d;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(u*f+d*m,g)*R.radDeg,this.arotation=Math.atan2(d,u)*R.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,f)*R.radDeg}worldToLocal(t){const s=this.matrix,n=s.a,r=s.c,l=s.b,c=s.d,o=1/(n*c-r*l),a=t.x-s.tx,i=t.y-s.ty;return t.x=a*c*o-i*r*o,t.y=i*n*o-a*l*o,t}localToWorld(t){const s=this.matrix,n=t.x,r=t.y;return t.x=n*s.a+r*s.c+s.tx,t.y=n*s.b+r*s.d+s.ty,t}worldToLocalRotation(t){const s=R.sinDeg(t),n=R.cosDeg(t),r=this.matrix;return Math.atan2(r.a*s-r.b*n,r.d*n-r.c*s)*R.radDeg}localToWorldRotation(t){const s=R.sinDeg(t),n=R.cosDeg(t),r=this.matrix;return Math.atan2(n*r.b+s*r.d,n*r.a+s*r.c)*R.radDeg}rotateWorld(t){const s=this.matrix,n=s.a,r=s.c,l=s.b,c=s.d,o=R.cosDeg(t),a=R.sinDeg(t);s.a=o*n-a*l,s.c=o*r-a*c,s.b=a*n+o*l,s.d=a*r+o*c,this.appliedValid=!1}}class de{constructor(t,s,n){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,this.skinRequired=!1,this.color=new W,t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=n}}class Zt{constructor(t,s,n){this.name=t,this.order=s,this.skinRequired=n}}class ue{constructor(t,s){if(s==null)throw new Error("data cannot be null.");this.time=t,this.data=s}}class fe{constructor(t){this.name=t}}class Ne{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,s,n,r,l,c,o){t.appliedValid||t.updateAppliedTransform();const a=t.parent.matrix,i=a.a;let h=a.c;const u=a.b;let f=a.d,d=-t.ashearX-t.arotation,m=0,g=0;switch(t.data.transformMode){case z.OnlyTranslation:m=s-t.worldX,g=n-t.worldY;break;case z.NoRotationOrReflection:const E=Math.abs(i*f-h*u)/(i*i+u*u),x=i/t.skeleton.scaleX,b=u/t.skeleton.scaleY;h=-b*E*t.skeleton.scaleX,f=x*E*t.skeleton.scaleY,d+=Math.atan2(b,x)*R.radDeg;default:const I=s-a.tx,S=n-a.ty,M=i*f-h*u;m=(I*f-S*h)/M-t.ax,g=(S*i-I*u)/M-t.ay}d+=Math.atan2(g,m)*R.radDeg,t.ascaleX<0&&(d+=180),d>180?d-=360:d<-180&&(d+=360);let w=t.ascaleX,p=t.ascaleY;if(r||l){switch(t.data.transformMode){case z.NoScale:case z.NoScaleOrReflection:m=s-t.worldX,g=n-t.worldY}const E=t.data.length*w,x=Math.sqrt(m*m+g*g);if(r&&x<E||l&&x>E&&E>1e-4){const b=(x/E-1)*o+1;w*=b,c&&(p*=b)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+d*o,w,p,t.ashearX,t.ashearY)}apply2(t,s,n,r,l,c,o,a){if(a==0){s.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),s.appliedValid||s.updateAppliedTransform();const i=t.ax,h=t.ay;let u=t.ascaleX,f=u,d=t.ascaleY,m=s.ascaleX;const g=t.matrix;let w=0,p=0,E=0;u<0?(u=-u,w=180,E=-1):(w=0,E=1),d<0&&(d=-d,E=-E),m<0?(m=-m,p=180):p=0;const x=s.ax;let b=0,I=0,S=0,M=g.a,T=g.c,y=g.b,C=g.d;const O=Math.abs(u-d)<=1e-4;O?(b=s.ay,I=M*x+T*b+g.tx,S=y*x+C*b+g.ty):(b=0,I=M*x+g.tx,S=y*x+g.ty);const L=t.parent.matrix;M=L.a,T=L.c,y=L.b,C=L.d;const _=1/(M*C-T*y);let P=I-L.tx,F=S-L.ty;const rt=(P*C-F*T)*_-i,it=(F*M-P*y)*_-h,k=Math.sqrt(rt*rt+it*it);let X=s.data.length*m,Y,U;if(k<1e-4){this.apply1(t,n,r,!1,c,!1,a),s.updateWorldTransformWith(x,b,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}P=n-L.tx,F=r-L.ty;let j=(P*C-F*T)*_-i,q=(F*M-P*y)*_-h,v=j*j+q*q;if(o!=0){o*=u*(m+1)/2;const dt=Math.sqrt(v),At=dt-k-X*u+o;if(At>0){let yt=Math.min(1,At/(o*2))-1;yt=(At-o*(1-yt*yt))/dt,j-=yt*j,q-=yt*q,v=j*j+q*q}}t:if(O){X*=u;let dt=(v-k*k-X*X)/(2*k*X);dt<-1?dt=-1:dt>1&&(dt=1,c&&(f*=(Math.sqrt(v)/(k+X)-1)*a+1)),U=Math.acos(dt)*l,M=k+X*dt,T=X*Math.sin(U),Y=Math.atan2(q*M-j*T,j*M+q*T)}else{M=u*X,T=d*X;const dt=M*M,At=T*T,yt=Math.atan2(q,j);y=At*k*k+dt*v-dt*At;const Ut=-2*At*k,Se=At-dt;if(C=Ut*Ut-4*Se*y,C>=0){let Bt=Math.sqrt(C);Ut<0&&(Bt=-Bt),Bt=-(Ut+Bt)/2;const ye=Bt/Se,Te=y/Bt,Lt=Math.abs(ye)<Math.abs(Te)?ye:Te;if(Lt*Lt<=v){F=Math.sqrt(v-Lt*Lt)*l,Y=yt-Math.atan2(F,Lt),U=Math.atan2(F/d,(Lt-k)/u);break t}}let Me=R.PI,$t=k-M,te=$t*$t,Ie=0,Re=0,Ht=k+M,ee=Ht*Ht,Ae=0;y=-M*k/(dt-At),y>=-1&&y<=1&&(y=Math.acos(y),P=M*Math.cos(y)+k,F=T*Math.sin(y),C=P*P+F*F,C<te&&(Me=y,te=C,$t=P,Ie=F),C>ee&&(Re=y,ee=C,Ht=P,Ae=F)),v<=(te+ee)/2?(Y=yt-Math.atan2(Ie*l,$t),U=Me*l):(Y=yt-Math.atan2(Ae*l,Ht),U=Re*l)}const bt=Math.atan2(b,x)*E;let kt=t.arotation;Y=(Y-bt)*R.radDeg+w-kt,Y>180?Y-=360:Y<-180&&(Y+=360),t.updateWorldTransformWith(i,h,kt+Y*a,f,t.ascaleY,0,0),kt=s.arotation,U=((U+bt)*R.radDeg-s.ashearX)*E+p-kt,U>180?U-=360:U<-180&&(U+=360),s.updateWorldTransformWith(x,b,kt+U*a,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class me extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ge extends Zt{constructor(t){super(t,0,!1),this.bones=new Array}}var nt=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(nt||{});const Xt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let s=0,n=e.bones.length;s<n;s++)this.bones.push(t.findBone(e.bones[s].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof Yt))return;const t=this.rotateMix,s=this.translateMix,n=s>0,r=t>0;if(!n&&!r)return;const l=this.data,c=l.spacingMode,o=c==nt.Length,a=l.rotateMode,i=a==Tt.Tangent,h=a==Tt.ChainScale,u=this.bones.length,f=i?u:u+1,d=this.bones,m=V.setArraySize(this.spaces,f);let g=null;const w=this.spacing;if(h||o){h&&(g=V.setArraySize(this.lengths,u));for(let S=0,M=f-1;S<M;){const T=d[S],y=T.data.length;if(y<Xt.epsilon)h&&(g[S]=0),m[++S]=0;else{const C=y*T.matrix.a,O=y*T.matrix.b,L=Math.sqrt(C*C+O*O);h&&(g[S]=L),m[++S]=(o?y+w:w)*L/y}}}else for(let S=1;S<f;S++)m[S]=w;const p=this.computeWorldPositions(e,f,i,l.positionMode==Vt.Percent,c==nt.Percent);let E=p[0],x=p[1],b=l.offsetRotation,I=!1;if(b==0)I=a==Tt.Chain;else{I=!1;const S=this.target.bone.matrix;b*=S.a*S.d-S.b*S.c>0?R.degRad:-R.degRad}for(let S=0,M=3;S<u;S++,M+=3){const T=d[S],y=T.matrix;y.tx+=(E-y.tx)*s,y.ty+=(x-y.ty)*s;const C=p[M],O=p[M+1],L=C-E,_=O-x;if(h){const P=g[S];if(P!=0){const F=(Math.sqrt(L*L+_*_)/P-1)*t+1;y.a*=F,y.b*=F}}if(E=C,x=O,r){const P=y.a,F=y.c,rt=y.b,it=y.d;let k=0,X=0,Y=0;if(i&&(i?k=p[M-1]:m[S+1]==0?k=p[M+2]:k=Math.atan2(_,L)),k-=Math.atan2(rt,P),I){X=Math.cos(k),Y=Math.sin(k);const U=T.data.length;E+=(U*(X*P-Y*rt)-L)*t,x+=(U*(Y*P+X*rt)-_)*t}else k+=b;k>R.PI?k-=R.PI2:k<-R.PI&&(k+=R.PI2),k*=t,X=Math.cos(k),Y=Math.sin(k),y.a=X*P-Y*rt,y.c=X*F-Y*it,y.b=Y*P+X*rt,y.d=Y*F+X*it}T.appliedValid=!1}}computeWorldPositions(e,t,s,n,r){const l=this.target;let c=this.position;const o=this.spaces,a=V.setArraySize(this.positions,t*3+2);let i=null;const h=e.closed;let u=e.worldVerticesLength,f=u/6,d=Xt.NONE;if(!e.constantSpeed){const k=e.lengths;f-=h?1:2;const X=k[f];if(n&&(c*=X),r)for(let Y=0;Y<t;Y++)o[Y]*=X;i=V.setArraySize(this.world,8);for(let Y=0,U=0,j=0;Y<t;Y++,U+=3){const q=o[Y];c+=q;let v=c;if(h)v%=X,v<0&&(v+=X),j=0;else if(v<0){d!=Xt.BEFORE&&(d=Xt.BEFORE,e.computeWorldVertices(l,2,4,i,0,2)),this.addBeforePosition(v,i,0,a,U);continue}else if(v>X){d!=Xt.AFTER&&(d=Xt.AFTER,e.computeWorldVertices(l,u-6,4,i,0,2)),this.addAfterPosition(v-X,i,0,a,U);continue}for(;;j++){const bt=k[j];if(!(v>bt)){if(j==0)v/=bt;else{const kt=k[j-1];v=(v-kt)/(bt-kt)}break}}j!=d&&(d=j,h&&j==f?(e.computeWorldVertices(l,u-4,4,i,0,2),e.computeWorldVertices(l,0,4,i,4,2)):e.computeWorldVertices(l,j*6+2,8,i,0,2)),this.addCurvePosition(v,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],a,U,s||Y>0&&q==0)}return a}h?(u+=2,i=V.setArraySize(this.world,u),e.computeWorldVertices(l,2,u-4,i,0,2),e.computeWorldVertices(l,0,2,i,u-4,2),i[u-2]=i[0],i[u-1]=i[1]):(f--,u-=4,i=V.setArraySize(this.world,u),e.computeWorldVertices(l,2,u,i,0,2));const m=V.setArraySize(this.curves,f);let g=0,w=i[0],p=i[1],E=0,x=0,b=0,I=0,S=0,M=0,T=0,y=0,C=0,O=0,L=0,_=0,P=0,F=0;for(let k=0,X=2;k<f;k++,X+=6)E=i[X],x=i[X+1],b=i[X+2],I=i[X+3],S=i[X+4],M=i[X+5],T=(w-E*2+b)*.1875,y=(p-x*2+I)*.1875,C=((E-b)*3-w+S)*.09375,O=((x-I)*3-p+M)*.09375,L=T*2+C,_=y*2+O,P=(E-w)*.75+T+C*.16666667,F=(x-p)*.75+y+O*.16666667,g+=Math.sqrt(P*P+F*F),P+=L,F+=_,L+=C,_+=O,g+=Math.sqrt(P*P+F*F),P+=L,F+=_,g+=Math.sqrt(P*P+F*F),P+=L+C,F+=_+O,g+=Math.sqrt(P*P+F*F),m[k]=g,w=S,p=M;if(n&&(c*=g),r)for(let k=0;k<t;k++)o[k]*=g;const rt=this.segments;let it=0;for(let k=0,X=0,Y=0,U=0;k<t;k++,X+=3){const j=o[k];c+=j;let q=c;if(h)q%=g,q<0&&(q+=g),Y=0;else if(q<0){this.addBeforePosition(q,i,0,a,X);continue}else if(q>g){this.addAfterPosition(q-g,i,u-4,a,X);continue}for(;;Y++){const v=m[Y];if(!(q>v)){if(Y==0)q/=v;else{const bt=m[Y-1];q=(q-bt)/(v-bt)}break}}if(Y!=d){d=Y;let v=Y*6;for(w=i[v],p=i[v+1],E=i[v+2],x=i[v+3],b=i[v+4],I=i[v+5],S=i[v+6],M=i[v+7],T=(w-E*2+b)*.03,y=(p-x*2+I)*.03,C=((E-b)*3-w+S)*.006,O=((x-I)*3-p+M)*.006,L=T*2+C,_=y*2+O,P=(E-w)*.3+T+C*.16666667,F=(x-p)*.3+y+O*.16666667,it=Math.sqrt(P*P+F*F),rt[0]=it,v=1;v<8;v++)P+=L,F+=_,L+=C,_+=O,it+=Math.sqrt(P*P+F*F),rt[v]=it;P+=L,F+=_,it+=Math.sqrt(P*P+F*F),rt[8]=it,P+=L+C,F+=_+O,it+=Math.sqrt(P*P+F*F),rt[9]=it,U=0}for(q*=it;;U++){const v=rt[U];if(!(q>v)){if(U==0)q/=v;else{const bt=rt[U-1];q=U+(q-bt)/(v-bt)}break}}this.addCurvePosition(q*.1,w,p,E,x,b,I,S,M,a,X,s||k>0&&j==0)}return a}addBeforePosition(e,t,s,n,r){const l=t[s],c=t[s+1],o=t[s+2]-l,a=t[s+3]-c,i=Math.atan2(a,o);n[r]=l+e*Math.cos(i),n[r+1]=c+e*Math.sin(i),n[r+2]=i}addAfterPosition(e,t,s,n,r){const l=t[s+2],c=t[s+3],o=l-t[s],a=c-t[s+1],i=Math.atan2(a,o);n[r]=l+e*Math.cos(i),n[r+1]=c+e*Math.sin(i),n[r+2]=i}addCurvePosition(e,t,s,n,r,l,c,o,a,i,h,u){(e==0||isNaN(e))&&(e=1e-4);const f=e*e,d=f*e,m=1-e,g=m*m,w=g*m,p=m*e,E=p*3,x=m*E,b=E*e,I=t*w+n*x+l*b+o*d,S=s*w+r*x+c*b+a*d;i[h]=I,i[h+1]=S,u&&(i[h+2]=Math.atan2(S-(s*g+r*p*2+c*f),I-(t*g+n*p*2+l*f)))}};let Wt=Xt;Wt.NONE=-1,Wt.BEFORE=-2,Wt.AFTER=-3,Wt.epsilon=1e-5;class ve{constructor(t,s){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new De,this.active=!1,t==null)throw new Error("data cannot be null.");if(s==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(s.findBone(t.bones[n].name));this.target=s.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,r=this.shearMix,l=this.target,c=l.matrix,o=c.a,a=c.c,i=c.b,h=c.d,u=o*h-a*i>0?R.degRad:-R.degRad,f=this.data.offsetRotation*u,d=this.data.offsetShearY*u,m=this.bones;for(let g=0,w=m.length;g<w;g++){const p=m[g];let E=!1;const x=p.matrix;if(t!=0){const b=x.a,I=x.c,S=x.b,M=x.d;let T=Math.atan2(i,o)-Math.atan2(S,b)+f;T>R.PI?T-=R.PI2:T<-R.PI&&(T+=R.PI2),T*=t;const y=Math.cos(T),C=Math.sin(T);x.a=y*b-C*S,x.c=y*I-C*M,x.b=C*b+y*S,x.d=C*I+y*M,E=!0}if(s!=0){const b=this.temp;l.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=(b.x-x.tx)*s,x.ty+=(b.y-x.ty)*s,E=!0}if(n>0){let b=Math.sqrt(x.a*x.a+x.b*x.b),I=Math.sqrt(o*o+i*i);b>1e-5&&(b=(b+(I-b+this.data.offsetScaleX)*n)/b),x.a*=b,x.b*=b,b=Math.sqrt(x.c*x.c+x.d*x.d),I=Math.sqrt(a*a+h*h),b>1e-5&&(b=(b+(I-b+this.data.offsetScaleY)*n)/b),x.c*=b,x.d*=b,E=!0}if(r>0){const b=x.c,I=x.d,S=Math.atan2(I,b);let M=Math.atan2(h,a)-Math.atan2(i,o)-(S-Math.atan2(x.b,x.a));M>R.PI?M-=R.PI2:M<-R.PI&&(M+=R.PI2),M=S+(M+d)*r;const T=Math.sqrt(b*b+I*I);x.c=Math.cos(M)*T,x.d=Math.sin(M)*T,E=!0}E&&(p.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,r=this.shearMix,l=this.target,c=l.matrix,o=c.a,a=c.c,i=c.b,h=c.d,u=o*h-a*i>0?R.degRad:-R.degRad,f=this.data.offsetRotation*u,d=this.data.offsetShearY*u,m=this.bones;for(let g=0,w=m.length;g<w;g++){const p=m[g];let E=!1;const x=p.matrix;if(t!=0){const b=x.a,I=x.c,S=x.b,M=x.d;let T=Math.atan2(i,o)+f;T>R.PI?T-=R.PI2:T<-R.PI&&(T+=R.PI2),T*=t;const y=Math.cos(T),C=Math.sin(T);x.a=y*b-C*S,x.c=y*I-C*M,x.b=C*b+y*S,x.d=C*I+y*M,E=!0}if(s!=0){const b=this.temp;l.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=b.x*s,x.ty+=b.y*s,E=!0}if(n>0){let b=(Math.sqrt(o*o+i*i)-1+this.data.offsetScaleX)*n+1;x.a*=b,x.b*=b,b=(Math.sqrt(a*a+h*h)-1+this.data.offsetScaleY)*n+1,x.c*=b,x.d*=b,E=!0}if(r>0){let b=Math.atan2(h,a)-Math.atan2(i,o);b>R.PI?b-=R.PI2:b<-R.PI&&(b+=R.PI2);const I=x.c,S=x.d;b=Math.atan2(S,I)+(b-R.PI/2+d)*r;const M=Math.sqrt(I*I+S*S);x.c=Math.cos(b)*M,x.d=Math.sin(b)*M,E=!0}E&&(p.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,r=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const i=c[o];i.appliedValid||i.updateAppliedTransform();let h=i.arotation;if(t!=0){let w=l.arotation-h+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,h+=w*t}let u=i.ax,f=i.ay;s!=0&&(u+=(l.ax-u+this.data.offsetX)*s,f+=(l.ay-f+this.data.offsetY)*s);let d=i.ascaleX,m=i.ascaleY;n>0&&(d>1e-5&&(d=(d+(l.ascaleX-d+this.data.offsetScaleX)*n)/d),m>1e-5&&(m=(m+(l.ascaleY-m+this.data.offsetScaleY)*n)/m));const g=i.ashearY;if(r>0){let w=l.ashearY-g+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,i.shearY+=w*r}i.updateWorldTransformWith(u,f,h,d,m,i.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,s=this.translateMix,n=this.scaleMix,r=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,a=c.length;o<a;o++){const i=c[o];i.appliedValid||i.updateAppliedTransform();let h=i.arotation;t!=0&&(h+=(l.arotation+this.data.offsetRotation)*t);let u=i.ax,f=i.ay;s!=0&&(u+=(l.ax+this.data.offsetX)*s,f+=(l.ay+this.data.offsetY)*s);let d=i.ascaleX,m=i.ascaleY;n>0&&(d>1e-5&&(d*=(l.ascaleX-1+this.data.offsetScaleX)*n+1),m>1e-5&&(m*=(l.ascaleY-1+this.data.offsetScaleY)*n+1));let g=i.ashearY;r>0&&(g+=(l.ashearY+this.data.offsetShearY)*r),i.updateWorldTransformWith(u,f,h,d,m,i.ashearX,g)}}}const qt=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const s=e.bones[t];let n;if(s.parent==null)n=new ce(s,this,null);else{const r=this.bones[s.parent.index];n=new ce(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const s=e.slots[t],n=this.bones[s.boneData.index],r=new ae(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const s=e.ikConstraints[t];this.ikConstraints.push(new Ne(s,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const s=e.transformConstraints[t];this.transformConstraints.push(new ve(s,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const s=e.pathConstraints[t];this.pathConstraints.push(new Wt(s,this))}this.color=new W(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let i=0,h=t.length;i<h;i++){const u=t[i];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin!=null){const i=this.skin.bones;for(let h=0,u=this.skin.bones.length;h<u;h++){let f=this.bones[i[h].index];do f.sorted=!1,f.active=!0,f=f.parent;while(f!=null)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,c=n.length,o=r.length,a=l+c+o;t:for(let i=0;i<a;i++){for(let h=0;h<l;h++){const u=s[h];if(u.data.order==i){this.sortIkConstraint(u);continue t}}for(let h=0;h<c;h++){const u=n[h];if(u.data.order==i){this.sortTransformConstraint(u);continue t}}for(let h=0;h<o;h++){const u=r[h];if(u.data.order==i){this.sortPathConstraint(u);continue t}}}for(let i=0,h=t.length;i<h;i++)this.sortBone(t[i])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&V.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const s=e.bones,n=s[0];if(this.sortBone(n),s.length>1){const r=s[s.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(e),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&V.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,s=t.data.index,n=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let o=0,a=this.data.skins.length;o<a;o++)this.sortPathConstraintAttachment(this.data.skins[o],s,n);const r=t.getAttachment();r instanceof Yt&&this.sortPathConstraintAttachmentWith(r,n);const l=e.bones,c=l.length;for(let o=0;o<c;o++)this.sortBone(l[o]);this._updateCache.push(e);for(let o=0;o<c;o++)this.sortReset(l[o].children);for(let o=0;o<c;o++)l[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&V.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,s=t.length;if(e.data.local)for(let n=0;n<s;n++){const r=t[n];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let n=0;n<s;n++)this.sortBone(t[n]);this._updateCache.push(e);for(let n=0;n<s;n++)this.sortReset(t[n].children);for(let n=0;n<s;n++)t[n].sorted=!0}sortPathConstraintAttachment(e,t,s){const n=e.attachments[t];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof Yt))return;const s=e.bones;if(s==null)this.sortBone(t);else{const n=this.bones;let r=0;for(;r<s.length;){const l=s[r++];for(let c=r+l;r<c;r++){const o=s[r];this.sortBone(n[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,s=e.length;t<s;t++){const n=e[t];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let s=0,n=e.length;s<n;s++){const r=e[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const t=this._updateCache;for(let s=0,n=t.length;s<n;s++)t[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let r=0,l=e.length;r<l;r++)e[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,l=t.length;r<l;r++){const c=t[r];c.mix=c.data.mix,c.softness=c.data.softness,c.bendDirection=c.data.bendDirection,c.compress=c.data.compress,c.stretch=c.data.stretch}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const c=s[r],o=c.data;c.rotateMix=o.rotateMix,c.translateMix=o.translateMix,c.scaleMix=o.scaleMix,c.shearMix=o.shearMix}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const c=n[r],o=c.data;c.position=o.position,c.spacing=o.spacing,c.rotateMix=o.rotateMix,c.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;V.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,s=e.length;t<s;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r.data.name==e)return r}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r.data.name==e)return r}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,n=t.length;s<n;s++)if(t[s].data.name==e)return s;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,n=t.length;s<n;s++){const r=t[s],l=r.data.attachmentName;if(l!=null){const c=e.getAttachment(s,l);c!=null&&r.setAttachment(c)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(e,t);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==e){let c=null;if(t!=null&&(c=this.getAttachment(n,t),c==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);l.setAttachment(c);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r.data.name==e)return r}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r.data.name==e)return r}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,n=t.length;s<n;s++){const r=t[s];if(r.data.name==e)return r}return null}getBounds(e,t,s=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let a=0,i=n.length;a<i;a++){const h=n[a];if(!h.bone.active)continue;let u=0,f=null;const d=h.getAttachment();if(d instanceof N)u=8,f=V.setArraySize(s,u,0),d.computeWorldVertices(h.bone,f,0,2);else if(d instanceof Dt){const m=d;u=m.worldVerticesLength,f=V.setArraySize(s,u,0),m.computeWorldVertices(h,0,u,f,0,2)}if(f!=null)for(let m=0,g=f.length;m<g;m+=2){const w=f[m],p=f[m+1];r=Math.min(r,w),l=Math.min(l,p),c=Math.max(c,w),o=Math.max(o,p)}}e.set(r,l),t.set(c-r,o-l)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let pe=qt;pe.deprecatedWarning1=!1;class xe{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const s=this.bones;for(let n=0,r=s.length;n<r;n++)if(s[n].name==t)return n;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++)if(s[n].name==t)return n;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const s=this.skins;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const s=this.events;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const s=this.animations;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.name==t)return l}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let n=0,r=s.length;n<r;n++)if(s[n].name==t)return n;return-1}}class Ee{constructor(t,s,n){if(this.color=new W(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(s==null)throw new Error("name cannot be null.");if(n==null)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=n}}class we extends Zt{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class be{constructor(t,s,n){this.slotIndex=t,this.name=s,this.attachment=n}}class zt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,n){if(n==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][s]=n}addSkin(t){for(let n=0;n<t.bones.length;n++){const r=t.bones[n];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==r){l=!0;break}l||this.bones.push(r)}for(let n=0;n<t.constraints.length;n++){const r=t.constraints[n];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==r){l=!0;break}l||this.constraints.push(r)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const r=s[n];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){const r=t.bones[n];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==r){l=!0;break}l||this.bones.push(r)}for(let n=0;n<t.constraints.length;n++){const r=t.constraints[n];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==r){l=!0;break}l||this.constraints.push(r)}const s=t.getAttachments();for(let n=0;n<s.length;n++){const r=s[n];r.attachment!=null&&(r.attachment instanceof Dt?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,s){const n=this.attachments[t];return n?n[s]:null}removeAttachment(t,s){const n=this.attachments[t];n&&(n[s]=null)}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const n=this.attachments[s];if(n)for(const r in n){const l=n[r];l&&t.push(new be(s,r,l))}}return t}getAttachmentsForSlot(t,s){const n=this.attachments[t];if(n)for(const r in n){const l=n[r];l&&s.push(new be(t,r,l))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let n=0;for(let r=0;r<t.slots.length;r++){const l=t.slots[r],c=l.getAttachment();if(c&&n<s.attachments.length){const o=s.attachments[n];for(const a in o){const i=o[a];if(c==i){const h=this.getAttachment(n,a);h!=null&&l.setAttachment(h);break}}}n++}}}const Z=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,s=new xe;s.name="";const n=new Be(e);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const r=n.readBoolean();r&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let l=0;l=n.readInt(!0);for(let o=0;o<l;o++)n.strings.push(n.readString());l=n.readInt(!0);for(let o=0;o<l;o++){const a=n.readString(),i=o==0?null:s.bones[n.readInt(!0)],h=new de(o,a,i);h.rotation=n.readFloat(),h.x=n.readFloat()*t,h.y=n.readFloat()*t,h.scaleX=n.readFloat(),h.scaleY=n.readFloat(),h.shearX=n.readFloat(),h.shearY=n.readFloat(),h.length=n.readFloat()*t,h.transformMode=Z.TransformModeValues[n.readInt(!0)],h.skinRequired=n.readBoolean(),r&&W.rgba8888ToColor(h.color,n.readInt32()),s.bones.push(h)}l=n.readInt(!0);for(let o=0;o<l;o++){const a=n.readString(),i=s.bones[n.readInt(!0)],h=new Ee(o,a,i);W.rgba8888ToColor(h.color,n.readInt32());const u=n.readInt32();u!=-1&&W.rgb888ToColor(h.darkColor=new W,u),h.attachmentName=n.readStringRef(),h.blendMode=Z.BlendModeValues[n.readInt(!0)],s.slots.push(h)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const i=new me(n.readString());i.order=n.readInt(!0),i.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)i.bones.push(s.bones[n.readInt(!0)]);i.target=s.bones[n.readInt(!0)],i.mix=n.readFloat(),i.softness=n.readFloat()*t,i.bendDirection=n.readByte(),i.compress=n.readBoolean(),i.stretch=n.readBoolean(),i.uniform=n.readBoolean(),s.ikConstraints.push(i)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const i=new we(n.readString());i.order=n.readInt(!0),i.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)i.bones.push(s.bones[n.readInt(!0)]);i.target=s.bones[n.readInt(!0)],i.local=n.readBoolean(),i.relative=n.readBoolean(),i.offsetRotation=n.readFloat(),i.offsetX=n.readFloat()*t,i.offsetY=n.readFloat()*t,i.offsetScaleX=n.readFloat(),i.offsetScaleY=n.readFloat(),i.offsetShearY=n.readFloat(),i.rotateMix=n.readFloat(),i.translateMix=n.readFloat(),i.scaleMix=n.readFloat(),i.shearMix=n.readFloat(),s.transformConstraints.push(i)}l=n.readInt(!0);for(let o=0,a;o<l;o++){const i=new ge(n.readString());i.order=n.readInt(!0),i.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let h=0;h<a;h++)i.bones.push(s.bones[n.readInt(!0)]);i.target=s.slots[n.readInt(!0)],i.positionMode=Z.PositionModeValues[n.readInt(!0)],i.spacingMode=Z.SpacingModeValues[n.readInt(!0)],i.rotateMode=Z.RotateModeValues[n.readInt(!0)],i.offsetRotation=n.readFloat(),i.position=n.readFloat(),i.positionMode==Vt.Fixed&&(i.position*=t),i.spacing=n.readFloat(),(i.spacingMode==nt.Length||i.spacingMode==nt.Fixed)&&(i.spacing*=t),i.rotateMix=n.readFloat(),i.translateMix=n.readFloat(),s.pathConstraints.push(i)}const c=this.readSkin(n,s,!0,r);c!=null&&(s.defaultSkin=c,s.skins.push(c));{let o=s.skins.length;for(V.setArraySize(s.skins,l=o+n.readInt(!0));o<l;o++)s.skins[o]=this.readSkin(n,s,!1,r)}l=this.linkedMeshes.length;for(let o=0;o<l;o++){const a=this.linkedMeshes[o],i=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(i==null)throw new Error(`Skin not found: ${a.skin}`);const h=i.getAttachment(a.slotIndex,a.parent);if(h==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?h:a.mesh,a.mesh.setParentMesh(h)}this.linkedMeshes.length=0,l=n.readInt(!0);for(let o=0;o<l;o++){const a=new fe(n.readStringRef());a.intValue=n.readInt(!1),a.floatValue=n.readFloat(),a.stringValue=n.readString(),a.audioPath=n.readString(),a.audioPath!=null&&(a.volume=n.readFloat(),a.balance=n.readFloat()),s.events.push(a)}l=n.readInt(!0);for(let o=0;o<l;o++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(e,t,s,n){let r=null,l=0;if(s){if(l=e.readInt(!0),l==0)return null;r=new zt("default")}else{r=new zt(e.readStringRef()),r.bones.length=e.readInt(!0);for(let c=0,o=r.bones.length;c<o;c++)r.bones[c]=t.bones[e.readInt(!0)];for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.pathConstraints[e.readInt(!0)]);l=e.readInt(!0)}for(let c=0;c<l;c++){const o=e.readInt(!0);for(let a=0,i=e.readInt(!0);a<i;a++){const h=e.readStringRef(),u=this.readAttachment(e,t,r,o,h,n);u!=null&&r.setAttachment(o,h,u)}}return r}readAttachment(e,t,s,n,r,l){const c=this.scale;let o=e.readStringRef();o==null&&(o=r);const a=e.readByte();switch(Z.AttachmentTypeValues[a]){case pt.Region:{let i=e.readStringRef();const h=e.readFloat(),u=e.readFloat(),f=e.readFloat(),d=e.readFloat(),m=e.readFloat(),g=e.readFloat(),w=e.readFloat(),p=e.readInt32();i==null&&(i=o);const E=this.attachmentLoader.newRegionAttachment(s,o,i);return E==null?null:(E.path=i,E.x=u*c,E.y=f*c,E.scaleX=d,E.scaleY=m,E.rotation=h,E.width=g*c,E.height=w*c,W.rgba8888ToColor(E.color,p),E)}case pt.BoundingBox:{const i=e.readInt(!0),h=this.readVertices(e,i),u=l?e.readInt32():0,f=this.attachmentLoader.newBoundingBoxAttachment(s,o);return f==null?null:(f.worldVerticesLength=i<<1,f.vertices=h.vertices,f.bones=h.bones,l&&W.rgba8888ToColor(f.color,u),f)}case pt.Mesh:{let i=e.readStringRef();const h=e.readInt32(),u=e.readInt(!0),f=this.readFloatArray(e,u<<1,1),d=this.readShortArray(e),m=this.readVertices(e,u),g=e.readInt(!0);let w=null,p=0,E=0;l&&(w=this.readShortArray(e),p=e.readFloat(),E=e.readFloat()),i==null&&(i=o);const x=this.attachmentLoader.newMeshAttachment(s,o,i);return x==null?null:(x.path=i,W.rgba8888ToColor(x.color,h),x.bones=m.bones,x.vertices=m.vertices,x.worldVerticesLength=u<<1,x.triangles=d,x.regionUVs=new Float32Array(f),x.hullLength=g<<1,l&&(x.edges=w,x.width=p*c,x.height=E*c),x)}case pt.LinkedMesh:{let i=e.readStringRef();const h=e.readInt32(),u=e.readStringRef(),f=e.readStringRef(),d=e.readBoolean();let m=0,g=0;l&&(m=e.readFloat(),g=e.readFloat()),i==null&&(i=o);const w=this.attachmentLoader.newMeshAttachment(s,o,i);return w==null?null:(w.path=i,W.rgba8888ToColor(w.color,h),l&&(w.width=m*c,w.height=g*c),this.linkedMeshes.push(new He(w,u,n,f,d)),w)}case pt.Path:{const i=e.readBoolean(),h=e.readBoolean(),u=e.readInt(!0),f=this.readVertices(e,u),d=V.newArray(u/3,0);for(let w=0,p=d.length;w<p;w++)d[w]=e.readFloat()*c;const m=l?e.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,o);return g==null?null:(g.closed=i,g.constantSpeed=h,g.worldVerticesLength=u<<1,g.vertices=f.vertices,g.bones=f.bones,g.lengths=d,l&&W.rgba8888ToColor(g.color,m),g)}case pt.Point:{const i=e.readFloat(),h=e.readFloat(),u=e.readFloat(),f=l?e.readInt32():0,d=this.attachmentLoader.newPointAttachment(s,o);return d==null?null:(d.x=h*c,d.y=u*c,d.rotation=i,l&&W.rgba8888ToColor(d.color,f),d)}case pt.Clipping:{const i=e.readInt(!0),h=e.readInt(!0),u=this.readVertices(e,h),f=l?e.readInt32():0,d=this.attachmentLoader.newClippingAttachment(s,o);return d==null?null:(d.endSlot=t.slots[i],d.worldVerticesLength=h<<1,d.vertices=u.vertices,d.bones=u.bones,l&&W.rgba8888ToColor(d.color,f),d)}}return null}readVertices(e,t){const s=t<<1,n=new Ge,r=this.scale;if(!e.readBoolean())return n.vertices=this.readFloatArray(e,s,r),n;const l=new Array,c=new Array;for(let o=0;o<t;o++){const a=e.readInt(!0);c.push(a);for(let i=0;i<a;i++)c.push(e.readInt(!0)),l.push(e.readFloat()*r),l.push(e.readFloat()*r),l.push(e.readFloat())}return n.vertices=V.toFloatArray(l),n.bones=c,n}readFloatArray(e,t,s){const n=new Array(t);if(s==1)for(let r=0;r<t;r++)n[r]=e.readFloat();else for(let r=0;r<t;r++)n[r]=e.readFloat()*s;return n}readShortArray(e){const t=e.readInt(!0),s=new Array(t);for(let n=0;n<t;n++)s[n]=e.readShort();return s}readAnimation(e,t,s){const n=new Array,r=this.scale;let l=0;const c=new W,o=new W;for(let h=0,u=e.readInt(!0);h<u;h++){const f=e.readInt(!0);for(let d=0,m=e.readInt(!0);d<m;d++){const g=e.readByte(),w=e.readInt(!0);switch(g){case Z.SLOT_ATTACHMENT:{const p=new vt(w);p.slotIndex=f;for(let E=0;E<w;E++)p.setFrame(E,e.readFloat(),e.readStringRef());n.push(p),l=Math.max(l,p.frames[w-1]);break}case Z.SLOT_COLOR:{const p=new lt(w);p.slotIndex=f;for(let E=0;E<w;E++){const x=e.readFloat();W.rgba8888ToColor(c,e.readInt32()),p.setFrame(E,x,c.r,c.g,c.b,c.a),E<w-1&&this.readCurve(e,E,p)}n.push(p),l=Math.max(l,p.frames[(w-1)*lt.ENTRIES]);break}case Z.SLOT_TWO_COLOR:{const p=new J(w);p.slotIndex=f;for(let E=0;E<w;E++){const x=e.readFloat();W.rgba8888ToColor(c,e.readInt32()),W.rgb888ToColor(o,e.readInt32()),p.setFrame(E,x,c.r,c.g,c.b,c.a,o.r,o.g,o.b),E<w-1&&this.readCurve(e,E,p)}n.push(p),l=Math.max(l,p.frames[(w-1)*J.ENTRIES]);break}}}}for(let h=0,u=e.readInt(!0);h<u;h++){const f=e.readInt(!0);for(let d=0,m=e.readInt(!0);d<m;d++){const g=e.readByte(),w=e.readInt(!0);switch(g){case Z.BONE_ROTATE:{const p=new st(w);p.boneIndex=f;for(let E=0;E<w;E++)p.setFrame(E,e.readFloat(),e.readFloat()),E<w-1&&this.readCurve(e,E,p);n.push(p),l=Math.max(l,p.frames[(w-1)*st.ENTRIES]);break}case Z.BONE_TRANSLATE:case Z.BONE_SCALE:case Z.BONE_SHEAR:{let p,E=1;g==Z.BONE_SCALE?p=new mt(w):g==Z.BONE_SHEAR?p=new gt(w):(p=new Et(w),E=r),p.boneIndex=f;for(let x=0;x<w;x++)p.setFrame(x,e.readFloat(),e.readFloat()*E,e.readFloat()*E),x<w-1&&this.readCurve(e,x,p);n.push(p),l=Math.max(l,p.frames[(w-1)*Et.ENTRIES]);break}}}}for(let h=0,u=e.readInt(!0);h<u;h++){const f=e.readInt(!0),d=e.readInt(!0),m=new at(d);m.ikConstraintIndex=f;for(let g=0;g<d;g++)m.setFrame(g,e.readFloat(),e.readFloat(),e.readFloat()*r,e.readByte(),e.readBoolean(),e.readBoolean()),g<d-1&&this.readCurve(e,g,m);n.push(m),l=Math.max(l,m.frames[(d-1)*at.ENTRIES])}for(let h=0,u=e.readInt(!0);h<u;h++){const f=e.readInt(!0),d=e.readInt(!0),m=new ht(d);m.transformConstraintIndex=f;for(let g=0;g<d;g++)m.setFrame(g,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),g<d-1&&this.readCurve(e,g,m);n.push(m),l=Math.max(l,m.frames[(d-1)*ht.ENTRIES])}for(let h=0,u=e.readInt(!0);h<u;h++){const f=e.readInt(!0),d=s.pathConstraints[f];for(let m=0,g=e.readInt(!0);m<g;m++){const w=e.readByte(),p=e.readInt(!0);switch(w){case Z.PATH_POSITION:case Z.PATH_SPACING:{let E,x=1;w==Z.PATH_SPACING?(E=new It(p),(d.spacingMode==nt.Length||d.spacingMode==nt.Fixed)&&(x=r)):(E=new Rt(p),d.positionMode==Vt.Fixed&&(x=r)),E.pathConstraintIndex=f;for(let b=0;b<p;b++)E.setFrame(b,e.readFloat(),e.readFloat()*x),b<p-1&&this.readCurve(e,b,E);n.push(E),l=Math.max(l,E.frames[(p-1)*Rt.ENTRIES]);break}case Z.PATH_MIX:{const E=new Mt(p);E.pathConstraintIndex=f;for(let x=0;x<p;x++)E.setFrame(x,e.readFloat(),e.readFloat(),e.readFloat()),x<p-1&&this.readCurve(e,x,E);n.push(E),l=Math.max(l,E.frames[(p-1)*Mt.ENTRIES]);break}}}}for(let h=0,u=e.readInt(!0);h<u;h++){const f=s.skins[e.readInt(!0)];for(let d=0,m=e.readInt(!0);d<m;d++){const g=e.readInt(!0);for(let w=0,p=e.readInt(!0);w<p;w++){const E=f.getAttachment(g,e.readStringRef()),x=E.bones!=null,b=E.vertices,I=x?b.length/3*2:b.length,S=e.readInt(!0),M=new re(S);M.slotIndex=g,M.attachment=E;for(let T=0;T<S;T++){const y=e.readFloat();let C,O=e.readInt(!0);if(O==0)C=x?V.newFloatArray(I):b;else{C=V.newFloatArray(I);const L=e.readInt(!0);if(O+=L,r==1)for(let _=L;_<O;_++)C[_]=e.readFloat();else for(let _=L;_<O;_++)C[_]=e.readFloat()*r;if(!x)for(let _=0,P=C.length;_<P;_++)C[_]+=b[_]}M.setFrame(T,y,C),T<S-1&&this.readCurve(e,T,M)}n.push(M),l=Math.max(l,M.frames[S-1])}}}const a=e.readInt(!0);if(a>0){const h=new _t(a),u=s.slots.length;for(let f=0;f<a;f++){const d=e.readFloat(),m=e.readInt(!0),g=V.newArray(u,0);for(let x=u-1;x>=0;x--)g[x]=-1;const w=V.newArray(u-m,0);let p=0,E=0;for(let x=0;x<m;x++){const b=e.readInt(!0);for(;p!=b;)w[E++]=p++;g[p+e.readInt(!0)]=p++}for(;p<u;)w[E++]=p++;for(let x=u-1;x>=0;x--)g[x]==-1&&(g[x]=w[--E]);h.setFrame(f,d,g)}n.push(h),l=Math.max(l,h.frames[a-1])}const i=e.readInt(!0);if(i>0){const h=new Gt(i);for(let u=0;u<i;u++){const f=e.readFloat(),d=s.events[e.readInt(!0)],m=new ue(f,d);m.intValue=e.readInt(!1),m.floatValue=e.readFloat(),m.stringValue=e.readBoolean()?e.readString():d.stringValue,m.data.audioPath!=null&&(m.volume=e.readFloat(),m.balance=e.readFloat()),h.setFrame(u,m)}n.push(h),l=Math.max(l,h.frames[i-1])}return new Q(t,n,l)}readCurve(e,t,s){switch(e.readByte()){case Z.CURVE_STEPPED:s.setStepped(t);break;case Z.CURVE_BEZIER:this.setCurve(s,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,s,n,r,l){e.setCurve(t,s,n,r,l)}};let tt=Z;tt.AttachmentTypeValues=[0,1,2,3,4,5,6],tt.TransformModeValues=[z.Normal,z.OnlyTranslation,z.NoRotationOrReflection,z.NoScale,z.NoScaleOrReflection],tt.PositionModeValues=[Vt.Fixed,Vt.Percent],tt.SpacingModeValues=[nt.Length,nt.Fixed,nt.Percent],tt.RotateModeValues=[Tt.Tangent,Tt.Chain,Tt.ChainScale],tt.BlendModeValues=[Pt.NORMAL,Pt.ADD,Pt.MULTIPLY,Pt.SCREEN],tt.BONE_ROTATE=0,tt.BONE_TRANSLATE=1,tt.BONE_SCALE=2,tt.BONE_SHEAR=3,tt.SLOT_ATTACHMENT=0,tt.SLOT_COLOR=1,tt.SLOT_TWO_COLOR=2,tt.PATH_POSITION=0,tt.PATH_SPACING=1,tt.PATH_MIX=2,tt.CURVE_LINEAR=0,tt.CURVE_STEPPED=1,tt.CURVE_BEZIER=2;class He{constructor(t,s,n,r,l){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=r,this.inheritDeform=l}}class Ge{constructor(t=null,s=null){this.bones=t,this.vertices=s}}class je extends Le{}class Ot{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,n=new xe,r=typeof t=="string"?JSON.parse(t):t,l=r.skeleton;if(l!=null){if(n.hash=l.hash,n.version=l.spine,n.version.substr(0,3)!=="3.8"){const c=`Spine 3.8 loader cant load version ${l.spine}. Please configure your pixi-spine bundle`;console.error(c)}n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.x=l.x,n.y=l.y,n.width=l.width,n.height=l.height,n.fps=l.fps,n.imagesPath=l.images}if(r.bones)for(let c=0;c<r.bones.length;c++){const o=r.bones[c];let a=null;const i=this.getValue(o,"parent",null);if(i!=null&&(a=n.findBone(i),a==null))throw new Error(`Parent bone not found: ${i}`);const h=new de(n.bones.length,o.name,a);h.length=this.getValue(o,"length",0)*s,h.x=this.getValue(o,"x",0)*s,h.y=this.getValue(o,"y",0)*s,h.rotation=this.getValue(o,"rotation",0),h.scaleX=this.getValue(o,"scaleX",1),h.scaleY=this.getValue(o,"scaleY",1),h.shearX=this.getValue(o,"shearX",0),h.shearY=this.getValue(o,"shearY",0),h.transformMode=Ot.transformModeFromString(this.getValue(o,"transform","normal")),h.skinRequired=this.getValue(o,"skin",!1),n.bones.push(h)}if(r.slots)for(let c=0;c<r.slots.length;c++){const o=r.slots[c],a=o.name,i=o.bone,h=n.findBone(i);if(h==null)throw new Error(`Slot bone not found: ${i}`);const u=new Ee(n.slots.length,a,h),f=this.getValue(o,"color",null);f!=null&&u.color.setFromString(f);const d=this.getValue(o,"dark",null);d!=null&&(u.darkColor=new W(1,1,1,1),u.darkColor.setFromString(d)),u.attachmentName=this.getValue(o,"attachment",null),u.blendMode=Ot.blendModeFromString(this.getValue(o,"blend","normal")),n.slots.push(u)}if(r.ik)for(let c=0;c<r.ik.length;c++){const o=r.ik[c],a=new me(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],f=n.findBone(u);if(f==null)throw new Error(`IK bone not found: ${u}`);a.bones.push(f)}const i=o.target;if(a.target=n.findBone(i),a.target==null)throw new Error(`IK target bone not found: ${i}`);a.mix=this.getValue(o,"mix",1),a.softness=this.getValue(o,"softness",0)*s,a.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,a.compress=this.getValue(o,"compress",!1),a.stretch=this.getValue(o,"stretch",!1),a.uniform=this.getValue(o,"uniform",!1),n.ikConstraints.push(a)}if(r.transform)for(let c=0;c<r.transform.length;c++){const o=r.transform[c],a=new we(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],f=n.findBone(u);if(f==null)throw new Error(`Transform constraint bone not found: ${u}`);a.bones.push(f)}const i=o.target;if(a.target=n.findBone(i),a.target==null)throw new Error(`Transform constraint target bone not found: ${i}`);a.local=this.getValue(o,"local",!1),a.relative=this.getValue(o,"relative",!1),a.offsetRotation=this.getValue(o,"rotation",0),a.offsetX=this.getValue(o,"x",0)*s,a.offsetY=this.getValue(o,"y",0)*s,a.offsetScaleX=this.getValue(o,"scaleX",0),a.offsetScaleY=this.getValue(o,"scaleY",0),a.offsetShearY=this.getValue(o,"shearY",0),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),a.scaleMix=this.getValue(o,"scaleMix",1),a.shearMix=this.getValue(o,"shearMix",1),n.transformConstraints.push(a)}if(r.path)for(let c=0;c<r.path.length;c++){const o=r.path[c],a=new ge(o.name);a.order=this.getValue(o,"order",0),a.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const u=o.bones[h],f=n.findBone(u);if(f==null)throw new Error(`Transform constraint bone not found: ${u}`);a.bones.push(f)}const i=o.target;if(a.target=n.findSlot(i),a.target==null)throw new Error(`Path target slot not found: ${i}`);a.positionMode=Ot.positionModeFromString(this.getValue(o,"positionMode","percent")),a.spacingMode=Ot.spacingModeFromString(this.getValue(o,"spacingMode","length")),a.rotateMode=Ot.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),a.offsetRotation=this.getValue(o,"rotation",0),a.position=this.getValue(o,"position",0),a.positionMode==Vt.Fixed&&(a.position*=s),a.spacing=this.getValue(o,"spacing",0),(a.spacingMode==nt.Length||a.spacingMode==nt.Fixed)&&(a.spacing*=s),a.rotateMix=this.getValue(o,"rotateMix",1),a.translateMix=this.getValue(o,"translateMix",1),n.pathConstraints.push(a)}if(r.skins)for(let c=0;c<r.skins.length;c++){const o=r.skins[c],a=new zt(o.name);if(o.bones)for(let i=0;i<o.bones.length;i++){const h=n.findBone(o.bones[i]);if(h==null)throw new Error(`Skin bone not found: ${o.bones[c]}`);a.bones.push(h)}if(o.ik)for(let i=0;i<o.ik.length;i++){const h=n.findIkConstraint(o.ik[i]);if(h==null)throw new Error(`Skin IK constraint not found: ${o.ik[c]}`);a.constraints.push(h)}if(o.transform)for(let i=0;i<o.transform.length;i++){const h=n.findTransformConstraint(o.transform[i]);if(h==null)throw new Error(`Skin transform constraint not found: ${o.transform[c]}`);a.constraints.push(h)}if(o.path)for(let i=0;i<o.path.length;i++){const h=n.findPathConstraint(o.path[i]);if(h==null)throw new Error(`Skin path constraint not found: ${o.path[c]}`);a.constraints.push(h)}for(const i in o.attachments){const h=n.findSlot(i);if(h==null)throw new Error(`Slot not found: ${i}`);const u=o.attachments[i];for(const f in u){const d=this.readAttachment(u[f],a,h.index,f,n);d!=null&&a.setAttachment(h.index,f,d)}}n.skins.push(a),a.name=="default"&&(n.defaultSkin=a)}for(let c=0,o=this.linkedMeshes.length;c<o;c++){const a=this.linkedMeshes[c],i=a.skin==null?n.defaultSkin:n.findSkin(a.skin);if(i==null)throw new Error(`Skin not found: ${a.skin}`);const h=i.getAttachment(a.slotIndex,a.parent);if(h==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?h:a.mesh,a.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,r.events)for(const c in r.events){const o=r.events[c],a=new fe(c);a.intValue=this.getValue(o,"int",0),a.floatValue=this.getValue(o,"float",0),a.stringValue=this.getValue(o,"string",""),a.audioPath=this.getValue(o,"audio",null),a.audioPath!=null&&(a.volume=this.getValue(o,"volume",1),a.balance=this.getValue(o,"balance",0)),n.events.push(a)}if(r.animations)for(const c in r.animations){const o=r.animations[c];this.readAnimation(o,c,n)}return n}readAttachment(t,s,n,r,l){const c=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const o=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(s,r,o);if(a==null)return null;a.path=o,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const i=this.getValue(t,"color",null);return i!=null&&a.color.setFromString(i),a}case"boundingbox":{const o=this.attachmentLoader.newBoundingBoxAttachment(s,r);if(o==null)return null;this.readVertices(t,o,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"mesh":case"linkedmesh":{const o=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(s,r,o);if(a==null)return null;a.path=o;const i=this.getValue(t,"color",null);i!=null&&a.color.setFromString(i),a.width=this.getValue(t,"width",0)*c,a.height=this.getValue(t,"height",0)*c;const h=this.getValue(t,"parent",null);if(h!=null)return this.linkedMeshes.push(new Ze(a,this.getValue(t,"skin",null),n,h,this.getValue(t,"deform",!0))),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const o=this.attachmentLoader.newPathAttachment(s,r);if(o==null)return null;o.closed=this.getValue(t,"closed",!1),o.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,o,a<<1);const i=V.newArray(a/3,0);for(let u=0;u<t.lengths.length;u++)i[u]=t.lengths[u]*c;o.lengths=i;const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}case"point":{const o=this.attachmentLoader.newPointAttachment(s,r);if(o==null)return null;o.x=this.getValue(t,"x",0)*c,o.y=this.getValue(t,"y",0)*c,o.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&o.color.setFromString(a),o}case"clipping":{const o=this.attachmentLoader.newClippingAttachment(s,r);if(o==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const u=l.findSlot(a);if(u==null)throw new Error(`Clipping end slot not found: ${a}`);o.endSlot=u}const i=t.vertexCount;this.readVertices(t,o,i<<1);const h=this.getValue(t,"color",null);return h!=null&&o.color.setFromString(h),o}}return null}readVertices(t,s,n){const r=this.scale;s.worldVerticesLength=n;const l=t.vertices;if(n==l.length){const a=V.toFloatArray(l);if(r!=1)for(let i=0,h=l.length;i<h;i++)a[i]*=r;s.vertices=a;return}const c=new Array,o=new Array;for(let a=0,i=l.length;a<i;){const h=l[a++];o.push(h);for(let u=a+h*4;a<u;a+=4)o.push(l[a]),c.push(l[a+1]*r),c.push(l[a+2]*r),c.push(l[a+3])}s.bones=o,s.vertices=V.toFloatArray(c)}readAnimation(t,s,n){const r=this.scale,l=new Array;let c=0;if(t.slots)for(const a in t.slots){const i=t.slots[a],h=n.findSlotIndex(a);if(h==-1)throw new Error(`Slot not found: ${a}`);for(const u in i){const f=i[u];if(u=="attachment"){const d=new vt(f.length);d.slotIndex=h;let m=0;for(let g=0;g<f.length;g++){const w=f[g];d.setFrame(m++,this.getValue(w,"time",0),w.name)}l.push(d),c=Math.max(c,d.frames[d.getFrameCount()-1])}else if(u=="color"){const d=new lt(f.length);d.slotIndex=h;let m=0;for(let g=0;g<f.length;g++){const w=f[g],p=new W;p.setFromString(w.color||"ffffffff"),d.setFrame(m,this.getValue(w,"time",0),p.r,p.g,p.b,p.a),this.readCurve(w,d,m),m++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*lt.ENTRIES])}else if(u=="twoColor"){const d=new J(f.length);d.slotIndex=h;let m=0;for(let g=0;g<f.length;g++){const w=f[g],p=new W,E=new W;p.setFromString(w.light),E.setFromString(w.dark),d.setFrame(m,this.getValue(w,"time",0),p.r,p.g,p.b,p.a,E.r,E.g,E.b),this.readCurve(w,d,m),m++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*J.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${u} (${a})`)}}if(t.bones)for(const a in t.bones){const i=t.bones[a],h=n.findBoneIndex(a);if(h==-1)throw new Error(`Bone not found: ${a}`);for(const u in i){const f=i[u];if(u==="rotate"){const d=new st(f.length);d.boneIndex=h;let m=0;for(let g=0;g<f.length;g++){const w=f[g];d.setFrame(m,this.getValue(w,"time",0),this.getValue(w,"angle",0)),this.readCurve(w,d,m),m++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*st.ENTRIES])}else if(u==="translate"||u==="scale"||u==="shear"){let d=null,m=1,g=0;u==="scale"?(d=new mt(f.length),g=1):u==="shear"?d=new gt(f.length):(d=new Et(f.length),m=r),d.boneIndex=h;let w=0;for(let p=0;p<f.length;p++){const E=f[p],x=this.getValue(E,"x",g),b=this.getValue(E,"y",g);d.setFrame(w,this.getValue(E,"time",0),x*m,b*m),this.readCurve(E,d,w),w++}l.push(d),c=Math.max(c,d.frames[(d.getFrameCount()-1)*Et.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${u} (${a})`)}}if(t.ik)for(const a in t.ik){const i=t.ik[a],h=n.findIkConstraint(a),u=new at(i.length);u.ikConstraintIndex=n.ikConstraints.indexOf(h);let f=0;for(let d=0;d<i.length;d++){const m=i[d];u.setFrame(f,this.getValue(m,"time",0),this.getValue(m,"mix",1),this.getValue(m,"softness",0)*r,this.getValue(m,"bendPositive",!0)?1:-1,this.getValue(m,"compress",!1),this.getValue(m,"stretch",!1)),this.readCurve(m,u,f),f++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*at.ENTRIES])}if(t.transform)for(const a in t.transform){const i=t.transform[a],h=n.findTransformConstraint(a),u=new ht(i.length);u.transformConstraintIndex=n.transformConstraints.indexOf(h);let f=0;for(let d=0;d<i.length;d++){const m=i[d];u.setFrame(f,this.getValue(m,"time",0),this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,u,f),f++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*ht.ENTRIES])}if(t.path)for(const a in t.path){const i=t.path[a],h=n.findPathConstraintIndex(a);if(h==-1)throw new Error(`Path constraint not found: ${a}`);const u=n.pathConstraints[h];for(const f in i){const d=i[f];if(f==="position"||f==="spacing"){let m=null,g=1;f==="spacing"?(m=new It(d.length),(u.spacingMode==nt.Length||u.spacingMode==nt.Fixed)&&(g=r)):(m=new Rt(d.length),u.positionMode==Vt.Fixed&&(g=r)),m.pathConstraintIndex=h;let w=0;for(let p=0;p<d.length;p++){const E=d[p];m.setFrame(w,this.getValue(E,"time",0),this.getValue(E,f,0)*g),this.readCurve(E,m,w),w++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Rt.ENTRIES])}else if(f==="mix"){const m=new Mt(d.length);m.pathConstraintIndex=h;let g=0;for(let w=0;w<d.length;w++){const p=d[w];m.setFrame(g,this.getValue(p,"time",0),this.getValue(p,"rotateMix",1),this.getValue(p,"translateMix",1)),this.readCurve(p,m,g),g++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Mt.ENTRIES])}}}if(t.deform)for(const a in t.deform){const i=t.deform[a],h=n.findSkin(a);if(h==null){if(ne.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${a}`);continue}for(const u in i){const f=i[u],d=n.findSlotIndex(u);if(d==-1)throw new Error(`Slot not found: ${f.name}`);for(const m in f){const g=f[m],w=h.getAttachment(d,m);if(w==null)throw new Error(`Deform attachment not found: ${g.name}`);const p=w.bones!=null,E=w.vertices,x=p?E.length/3*2:E.length,b=new re(g.length);b.slotIndex=d,b.attachment=w;let I=0;for(let S=0;S<g.length;S++){const M=g[S];let T;const y=this.getValue(M,"vertices",null);if(y==null)T=p?V.newFloatArray(x):E;else{T=V.newFloatArray(x);const C=this.getValue(M,"offset",0);if(V.arrayCopy(y,0,T,C,y.length),r!=1)for(let O=C,L=O+y.length;O<L;O++)T[O]*=r;if(!p)for(let O=0;O<x;O++)T[O]+=E[O]}b.setFrame(I,this.getValue(M,"time",0),T),this.readCurve(M,b,I),I++}l.push(b),c=Math.max(c,b.frames[b.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const a=new _t(o.length),i=n.slots.length;let h=0;for(let u=0;u<o.length;u++){const f=o[u];let d=null;const m=this.getValue(f,"offsets",null);if(m!=null){d=V.newArray(i,-1);const g=V.newArray(i-m.length,0);let w=0,p=0;for(let E=0;E<m.length;E++){const x=m[E],b=n.findSlotIndex(x.slot);if(b==-1)throw new Error(`Slot not found: ${x.slot}`);for(;w!=b;)g[p++]=w++;d[w+x.offset]=w++}for(;w<i;)g[p++]=w++;for(let E=i-1;E>=0;E--)d[E]==-1&&(d[E]=g[--p])}a.setFrame(h++,this.getValue(f,"time",0),d)}l.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(t.events){const a=new Gt(t.events.length);let i=0;for(let h=0;h<t.events.length;h++){const u=t.events[h],f=n.findEvent(u.name);if(f==null)throw new Error(`Event not found: ${u.name}`);const d=new ue(V.toSinglePrecision(this.getValue(u,"time",0)),f);d.intValue=this.getValue(u,"int",f.intValue),d.floatValue=this.getValue(u,"float",f.floatValue),d.stringValue=this.getValue(u,"string",f.stringValue),d.data.audioPath!=null&&(d.volume=this.getValue(u,"volume",1),d.balance=this.getValue(u,"balance",0)),a.setFrame(i++,d)}l.push(a),c=Math.max(c,a.frames[a.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");n.animations.push(new Q(s,l,c))}readCurve(t,s,n){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")s.setStepped(n);else{const r=t.curve;s.setCurve(n,r,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,s,n){return t[s]!==void 0?t[s]:n}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Pt.NORMAL;if(t=="additive")return Pt.ADD;if(t=="multiply")return Pt.MULTIPLY;if(t=="screen")return Pt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Vt.Fixed;if(t=="percent")return Vt.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return nt.Length;if(t=="fixed")return nt.Fixed;if(t=="percent")return nt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Tt.Tangent;if(t=="chain")return Tt.Chain;if(t=="chainscale")return Tt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return z.Normal;if(t=="onlytranslation")return z.OnlyTranslation;if(t=="norotationorreflection")return z.NoRotationOrReflection;if(t=="noscale")return z.NoScale;if(t=="noscaleorreflection")return z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Ze{constructor(t,s,n,r,l){this.mesh=t,this.skin=s,this.slotIndex=n,this.parent=r,this.inheritDeform=l}}class ze extends _e{createSkeleton(t){this.skeleton=new pe(t),this.skeleton.updateWorldTransform(),this.stateData=new he(t),this.state=new wt(this.stateData)}}export{Q as Animation,wt as AnimationState,Ue as AnimationStateAdapter,he as AnimationStateData,$e as AtlasAttachmentLoader,se as Attachment,vt as AttachmentTimeline,ce as Bone,de as BoneData,Qt as BoundingBoxAttachment,Kt as ClippingAttachment,lt as ColorTimeline,Zt as ConstraintData,ut as CurveTimeline,re as DeformTimeline,_t as DrawOrderTimeline,ue as Event,fe as EventData,oe as EventQueue,Gt as EventTimeline,ft as EventType,Ne as IkConstraint,me as IkConstraintData,at as IkConstraintTimeline,qe as JitterEffect,Dt as MeshAttachment,Yt as PathAttachment,Wt as PathConstraint,ge as PathConstraintData,Mt as PathConstraintMixTimeline,Rt as PathConstraintPositionTimeline,It as PathConstraintSpacingTimeline,Jt as PointAttachment,N as RegionAttachment,st as RotateTimeline,mt as ScaleTimeline,gt as ShearTimeline,pe as Skeleton,tt as SkeletonBinary,je as SkeletonBounds,xe as SkeletonData,Ot as SkeletonJson,zt as Skin,be as SkinEntry,ae as Slot,Ee as SlotData,nt as SpacingMode,ze as Spine,ke as SwirlEffect,Pe as TimelineType,jt as TrackEntry,ve as TransformConstraint,we as TransformConstraintData,ht as TransformConstraintTimeline,Et as TranslateTimeline,J as TwoColorTimeline,Ft as VertexAttachment};
//# sourceMappingURL=runtime-3.8.mjs.map
