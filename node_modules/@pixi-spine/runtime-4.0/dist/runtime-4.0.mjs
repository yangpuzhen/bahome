/*!
 * @pixi-spine/runtime-4.0 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-4.0 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as B,AttachmentType as st,Color as $,MathUtils as M,PowOut as ss,StringSet as Ne,MixBlend as A,MixDirection as at,Pool as as,settings as Ct,TransformMode as nt,RotateMode as Pt,PositionMode as wt,Vector2 as _t,BinaryInput as ns,SkeletonBoundsBase as is,SpineBase as rs}from"@pixi-spine/base";import{Matrix as os,BLEND_MODES as xt}from"@pixi/core";class Gt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Oe=class extends Gt{constructor(a){super(a),this.id=Oe.nextID++,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(a,t){this.computeWorldVertices(a,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(a,t,n,e,r,o){n=r+(n>>1)*o;const d=a.bone.skeleton,l=a.deform;let s=this.vertices;const i=this.bones;if(!i){l.length>0&&(s=l);const u=a.bone.matrix,f=u.tx,p=u.ty,w=u.a,b=u.c,g=u.b,k=u.d;for(let y=t,x=r;x<n;y+=2,x+=o){const S=s[y],X=s[y+1];e[x]=S*w+X*b+f,e[x+1]=S*g+X*k+p}return}let h=0,c=0;for(let u=0;u<t;u+=2){const f=i[h];h+=f+1,c+=f}const m=d.bones;if(l.length==0)for(let u=r,f=c*3;u<n;u+=o){let p=0,w=0,b=i[h++];for(b+=h;h<b;h++,f+=3){const g=m[i[h]].matrix,k=s[f],y=s[f+1],x=s[f+2];p+=(k*g.a+y*g.c+g.tx)*x,w+=(k*g.b+y*g.d+g.ty)*x}e[u]=p,e[u+1]=w}else{const u=l;for(let f=r,p=c*3,w=c<<1;f<n;f+=o){let b=0,g=0,k=i[h++];for(k+=h;h<k;h++,p+=3,w+=2){const y=m[i[h]].matrix,x=s[p]+u[w],S=s[p+1]+u[w+1],X=s[p+2];b+=(x*y.a+S*y.c+y.tx)*X,g+=(x*y.b+S*y.d+y.ty)*X}e[f]=b,e[f+1]=g}}}copyTo(a){this.bones?(a.bones=new Array(this.bones.length),B.arrayCopy(this.bones,0,a.bones,0,this.bones.length)):a.bones=null,this.vertices?(a.vertices=B.newFloatArray(this.vertices.length),B.arrayCopy(this.vertices,0,a.vertices,0,this.vertices.length)):a.vertices=null,a.worldVerticesLength=this.worldVerticesLength,a.deformAttachment=this.deformAttachment}};let bt=Oe;bt.nextID=0;class Ot extends bt{constructor(t){super(t),this.type=st.BoundingBox,this.color=new $(1,1,1,1)}copy(){const t=new Ot(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class qt extends bt{constructor(t){super(t),this.type=st.Clipping,this.color=new $(.2275,.2275,.8078,1)}copy(){const t=new qt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Yt extends bt{constructor(t){super(t),this.type=st.Mesh,this.color=new $(1,1,1,1),this.tempColor=new $(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Yt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),B.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),B.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges&&(t.edges=new Array(this.edges.length),B.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Yt(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class St extends bt{constructor(t){super(t),this.type=st.Path,this.closed=!1,this.constantSpeed=!1,this.color=new $(1,1,1,1)}copy(){const t=new St(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),B.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class zt extends bt{constructor(t){super(t),this.type=st.Point,this.color=new $(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=M.cosDeg(this.rotation),r=M.sinDeg(this.rotation),o=e*n.a+r*n.c,d=e*n.b+r*n.d;return Math.atan2(d,o)*M.radDeg}copy(){const t=new zt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class Ht{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new $,this.darkColor=t.darkColor==null?null:new $,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const Z=class extends Gt{constructor(a){super(a),this.type=st.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new $(1,1,1,1),this.offset=B.newFloatArray(8),this.uvs=B.newFloatArray(8),this.tempColor=new $(1,1,1,1)}updateOffset(){const a=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*a,e=-this.height/2*this.scaleY+this.region.offsetY*t,r=n+this.region.width*a,o=e+this.region.height*t,d=this.rotation*Math.PI/180,l=Math.cos(d),s=Math.sin(d),i=n*l+this.x,h=n*s,c=e*l+this.y,m=e*s,u=r*l+this.x,f=r*s,p=o*l+this.y,w=o*s,b=this.offset;b[Z.OX1]=i-m,b[Z.OY1]=c+h,b[Z.OX2]=i-w,b[Z.OY2]=p+h,b[Z.OX3]=u-w,b[Z.OY3]=p+f,b[Z.OX4]=u-m,b[Z.OY4]=c+f}setRegion(a){this.region=a;const t=this.uvs;a.degrees==90?(t[2]=a.u,t[3]=a.v2,t[4]=a.u,t[5]=a.v,t[6]=a.u2,t[7]=a.v,t[0]=a.u2,t[1]=a.v2):(t[0]=a.u,t[1]=a.v2,t[2]=a.u,t[3]=a.v,t[4]=a.u2,t[5]=a.v,t[6]=a.u2,t[7]=a.v2)}computeWorldVertices(a,t,n,e){const r=this.offset,o=a instanceof Ht?a.bone.matrix:a.matrix,d=o.tx,l=o.ty,s=o.a,i=o.c,h=o.b,c=o.d;let m=0,u=0;m=r[Z.OX1],u=r[Z.OY1],t[n]=m*s+u*i+d,t[n+1]=m*h+u*c+l,n+=e,m=r[Z.OX2],u=r[Z.OY2],t[n]=m*s+u*i+d,t[n+1]=m*h+u*c+l,n+=e,m=r[Z.OX3],u=r[Z.OY3],t[n]=m*s+u*i+d,t[n+1]=m*h+u*c+l,n+=e,m=r[Z.OX4],u=r[Z.OY4],t[n]=m*s+u*i+d,t[n+1]=m*h+u*c+l}copy(){const a=new Z(this.name);return a.region=this.region,a.rendererObject=this.rendererObject,a.path=this.path,a.x=this.x,a.y=this.y,a.scaleX=this.scaleX,a.scaleY=this.scaleY,a.rotation=this.rotation,a.width=this.width,a.height=this.height,B.arrayCopy(this.uvs,0,a.uvs,0,8),B.arrayCopy(this.offset,0,a.offset,0,8),a.color.setFromColor(this.color),a}};let P=Z;P.OX1=0,P.OY1=1,P.OX2=2,P.OY2=3,P.OX3=4,P.OY3=5,P.OX4=6,P.OY4=7,P.X1=0,P.Y1=1,P.C1R=2,P.C1G=3,P.C1B=4,P.C1A=5,P.U1=6,P.V1=7,P.X2=8,P.Y2=9,P.C2R=10,P.C2G=11,P.C2B=12,P.C2A=13,P.U2=14,P.V2=15,P.X3=16,P.Y3=17,P.C3R=18,P.C3G=19,P.C3B=20,P.C3A=21,P.U3=22,P.V3=23,P.X4=24,P.Y4=25,P.C4R=26,P.C4G=27,P.C4B=28,P.C4A=29,P.U4=30,P.V4=31;class hs{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,e,r){t.x+=M.randomTriangular(-this.jitterX,this.jitterY),t.y+=M.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const qe=class{constructor(a){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=a}begin(a){this.worldX=a.x+this.centerX,this.worldY=a.y+this.centerY}transform(a,t,n,e){const r=this.angle*M.degreesToRadians,o=a.x-this.worldX,d=a.y-this.worldY,l=Math.sqrt(o*o+d*d);if(l<this.radius){const s=qe.interpolation.apply(0,r,(this.radius-l)/this.radius),i=Math.cos(s),h=Math.sin(s);a.x=i*o-h*d+this.worldX,a.y=h*o+i*d+this.worldY}}end(){}};let ze=qe;ze.interpolation=new ss(2);class Vt{constructor(t,n,e){if(this.timelines=null,this.timelineIds=null,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(n),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds=new Ne;for(let n=0;n<t.length;n++)this.timelineIds.addAll(t[n].getPropertyIds())}hasTimeline(t){for(let n=0;n<t.length;n++)if(this.timelineIds.contains(t[n]))return!0;return!1}apply(t,n,e,r,o,d,l,s){if(!t)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const i=this.timelines;for(let h=0,c=i.length;h<c;h++)i[h].apply(t,n,e,o,d,l,s)}}const z={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18};class G{constructor(t,n){this.propertyIds=null,this.frames=null,this.propertyIds=n,this.frames=B.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,n){const e=t.length;for(let r=1;r<e;r++)if(t[r]>n)return r-1;return e-1}static search(t,n,e){const r=t.length;for(let o=e;o<r;o+=e)if(t[o]>n)return o-e;return r-e}}class rt extends G{constructor(t,n,e){super(t,e),this.curves=null,this.curves=B.newFloatArray(t+n*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const n=this.getFrameCount()+t*18;if(this.curves.length>n){const e=B.newFloatArray(n);B.arrayCopy(this.curves,0,e,0,n),this.curves=e}}setBezier(t,n,e,r,o,d,l,s,i,h,c){const m=this.curves;let u=this.getFrameCount()+t*18;e==0&&(m[n]=2+u);const f=(r-d*2+s)*.03,p=(o-l*2+i)*.03,w=((d-s)*3-r+h)*.006,b=((l-i)*3-o+c)*.006;let g=f*2+w,k=p*2+b,y=(d-r)*.3+f+w*.16666667,x=(l-o)*.3+p+b*.16666667,S=r+y,X=o+x;for(let F=u+18;u<F;u+=2)m[u]=S,m[u+1]=X,y+=g,x+=k,g+=w,k+=b,S+=y,X+=x}getBezierValue(t,n,e,r){const o=this.curves;if(o[r]>t){const i=this.frames[n],h=this.frames[n+e];return h+(t-i)/(o[r]-i)*(o[r+1]-h)}const d=r+18;for(r+=2;r<d;r+=2)if(o[r]>=t){const i=o[r-2],h=o[r-1];return h+(t-i)/(o[r]-i)*(o[r+1]-h)}n+=this.getFrameEntries();const l=o[d-2],s=o[d-1];return s+(t-l)/(this.frames[n]-l)*(this.frames[n+e]-s)}}class ot extends rt{constructor(t,n,e){super(t,n,[e])}getFrameEntries(){return 2}setFrame(t,n,e){t<<=1,this.frames[t]=n,this.frames[t+1]=e}getCurveValue(t){const n=this.frames;let e=n.length-2;for(let o=2;o<=e;o+=2)if(n[o]>t){e=o-2;break}const r=this.curves[e>>1];switch(r){case 0:const o=n[e],d=n[e+1];return d+(t-o)/(n[e+2]-o)*(n[e+2+1]-d);case 1:return n[e+1]}return this.getBezierValue(t,e,1,r-2)}}class Lt extends rt{constructor(t,n,e,r){super(t,n,[e,r])}getFrameEntries(){return 3}setFrame(t,n,e,r){t*=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r}}class Mt extends ot{constructor(t,n,e){super(t,n,`${z.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.rotation=s.data.rotation;return;case A.first:s.rotation+=(s.data.rotation-s.rotation)*o}return}let h=this.getCurveValue(e);switch(d){case A.setup:s.rotation=s.data.rotation+h*o;break;case A.first:case A.replace:h+=s.data.rotation-s.rotation;case A.add:s.rotation+=h*o}}}class Jt extends Lt{constructor(t,n,e){super(t,n,`${z.x}|${e}`,`${z.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.x=s.data.x,s.y=s.data.y;return;case A.first:s.x+=(s.data.x-s.x)*o,s.y+=(s.data.y-s.y)*o}return}let h=0,c=0;const m=G.search(i,e,3),u=this.curves[m/3];switch(u){case 0:const f=i[m];h=i[m+1],c=i[m+2];const p=(e-f)/(i[m+3]-f);h+=(i[m+3+1]-h)*p,c+=(i[m+3+2]-c)*p;break;case 1:h=i[m+1],c=i[m+2];break;default:h=this.getBezierValue(e,m,1,u-2),c=this.getBezierValue(e,m,2,u+18-2)}switch(d){case A.setup:s.x=s.data.x+h*o,s.y=s.data.y+c*o;break;case A.first:case A.replace:s.x+=(s.data.x+h-s.x)*o,s.y+=(s.data.y+c-s.y)*o;break;case A.add:s.x+=h*o,s.y+=c*o}}}class Zt extends ot{constructor(t,n,e){super(t,n,`${z.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.x=s.data.x;return;case A.first:s.x+=(s.data.x-s.x)*o}return}const h=this.getCurveValue(e);switch(d){case A.setup:s.x=s.data.x+h*o;break;case A.first:case A.replace:s.x+=(s.data.x+h-s.x)*o;break;case A.add:s.x+=h*o}}}class Kt extends ot{constructor(t,n,e){super(t,n,`${z.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.y=s.data.y;return;case A.first:s.y+=(s.data.y-s.y)*o}return}const h=this.getCurveValue(e);switch(d){case A.setup:s.y=s.data.y+h*o;break;case A.first:case A.replace:s.y+=(s.data.y+h-s.y)*o;break;case A.add:s.y+=h*o}}}class Qt extends Lt{constructor(t,n,e){super(t,n,`${z.scaleX}|${e}`,`${z.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.scaleX=s.data.scaleX,s.scaleY=s.data.scaleY;return;case A.first:s.scaleX+=(s.data.scaleX-s.scaleX)*o,s.scaleY+=(s.data.scaleY-s.scaleY)*o}return}let h,c;const m=G.search(i,e,3),u=this.curves[m/3];switch(u){case 0:const f=i[m];h=i[m+1],c=i[m+2];const p=(e-f)/(i[m+3]-f);h+=(i[m+3+1]-h)*p,c+=(i[m+3+2]-c)*p;break;case 1:h=i[m+1],c=i[m+2];break;default:h=this.getBezierValue(e,m,1,u-2),c=this.getBezierValue(e,m,2,u+18-2)}if(h*=s.data.scaleX,c*=s.data.scaleY,o==1)d==A.add?(s.scaleX+=h-s.data.scaleX,s.scaleY+=c-s.data.scaleY):(s.scaleX=h,s.scaleY=c);else{let f=0,p=0;if(l==at.mixOut)switch(d){case A.setup:f=s.data.scaleX,p=s.data.scaleY,s.scaleX=f+(Math.abs(h)*M.signum(f)-f)*o,s.scaleY=p+(Math.abs(c)*M.signum(p)-p)*o;break;case A.first:case A.replace:f=s.scaleX,p=s.scaleY,s.scaleX=f+(Math.abs(h)*M.signum(f)-f)*o,s.scaleY=p+(Math.abs(c)*M.signum(p)-p)*o;break;case A.add:s.scaleX+=(h-s.data.scaleX)*o,s.scaleY+=(c-s.data.scaleY)*o}else switch(d){case A.setup:f=Math.abs(s.data.scaleX)*M.signum(h),p=Math.abs(s.data.scaleY)*M.signum(c),s.scaleX=f+(h-f)*o,s.scaleY=p+(c-p)*o;break;case A.first:case A.replace:f=Math.abs(s.scaleX)*M.signum(h),p=Math.abs(s.scaleY)*M.signum(c),s.scaleX=f+(h-f)*o,s.scaleY=p+(c-p)*o;break;case A.add:s.scaleX+=(h-s.data.scaleX)*o,s.scaleY+=(c-s.data.scaleY)*o}}}}class te extends ot{constructor(t,n,e){super(t,n,`${z.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.scaleX=s.data.scaleX;return;case A.first:s.scaleX+=(s.data.scaleX-s.scaleX)*o}return}const h=this.getCurveValue(e)*s.data.scaleX;if(o==1)d==A.add?s.scaleX+=h-s.data.scaleX:s.scaleX=h;else{let c=0;if(l==at.mixOut)switch(d){case A.setup:c=s.data.scaleX,s.scaleX=c+(Math.abs(h)*M.signum(c)-c)*o;break;case A.first:case A.replace:c=s.scaleX,s.scaleX=c+(Math.abs(h)*M.signum(c)-c)*o;break;case A.add:s.scaleX+=(h-s.data.scaleX)*o}else switch(d){case A.setup:c=Math.abs(s.data.scaleX)*M.signum(h),s.scaleX=c+(h-c)*o;break;case A.first:case A.replace:c=Math.abs(s.scaleX)*M.signum(h),s.scaleX=c+(h-c)*o;break;case A.add:s.scaleX+=(h-s.data.scaleX)*o}}}}class ee extends ot{constructor(t,n,e){super(t,n,`${z.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.scaleY=s.data.scaleY;return;case A.first:s.scaleY+=(s.data.scaleY-s.scaleY)*o}return}const h=this.getCurveValue(e)*s.data.scaleY;if(o==1)d==A.add?s.scaleY+=h-s.data.scaleY:s.scaleY=h;else{let c=0;if(l==at.mixOut)switch(d){case A.setup:c=s.data.scaleY,s.scaleY=c+(Math.abs(h)*M.signum(c)-c)*o;break;case A.first:case A.replace:c=s.scaleY,s.scaleY=c+(Math.abs(h)*M.signum(c)-c)*o;break;case A.add:s.scaleY+=(h-s.data.scaleY)*o}else switch(d){case A.setup:c=Math.abs(s.data.scaleY)*M.signum(h),s.scaleY=c+(h-c)*o;break;case A.first:case A.replace:c=Math.abs(s.scaleY)*M.signum(h),s.scaleY=c+(h-c)*o;break;case A.add:s.scaleY+=(h-s.data.scaleY)*o}}}}class se extends Lt{constructor(t,n,e){super(t,n,`${z.shearX}|${e}`,`${z.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.shearX=s.data.shearX,s.shearY=s.data.shearY;return;case A.first:s.shearX+=(s.data.shearX-s.shearX)*o,s.shearY+=(s.data.shearY-s.shearY)*o}return}let h=0,c=0;const m=G.search(i,e,3),u=this.curves[m/3];switch(u){case 0:const f=i[m];h=i[m+1],c=i[m+2];const p=(e-f)/(i[m+3]-f);h+=(i[m+3+1]-h)*p,c+=(i[m+3+2]-c)*p;break;case 1:h=i[m+1],c=i[m+2];break;default:h=this.getBezierValue(e,m,1,u-2),c=this.getBezierValue(e,m,2,u+18-2)}switch(d){case A.setup:s.shearX=s.data.shearX+h*o,s.shearY=s.data.shearY+c*o;break;case A.first:case A.replace:s.shearX+=(s.data.shearX+h-s.shearX)*o,s.shearY+=(s.data.shearY+c-s.shearY)*o;break;case A.add:s.shearX+=h*o,s.shearY+=c*o}}}class ae extends ot{constructor(t,n,e){super(t,n,`${z.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.shearX=s.data.shearX;return;case A.first:s.shearX+=(s.data.shearX-s.shearX)*o}return}const h=this.getCurveValue(e);switch(d){case A.setup:s.shearX=s.data.shearX+h*o;break;case A.first:case A.replace:s.shearX+=(s.data.shearX+h-s.shearX)*o;break;case A.add:s.shearX+=h*o}}}class ne extends ot{constructor(t,n,e){super(t,n,`${z.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,o,d,l){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.shearY=s.data.shearY;return;case A.first:s.shearY+=(s.data.shearY-s.shearY)*o}return}const h=this.getCurveValue(e);switch(d){case A.setup:s.shearY=s.data.shearY+h*o;break;case A.first:case A.replace:s.shearY+=(s.data.shearY+h-s.shearY)*o;break;case A.add:s.shearY+=h*o}}}class ie extends rt{constructor(t,n,e){super(t,n,[`${z.rgb}|${e}`,`${z.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,n,e,r,o,d){t*=5,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,h=s.color;if(e<i[0]){const b=s.data.color;switch(d){case A.setup:h.setFromColor(b);return;case A.first:h.add((b.r-h.r)*o,(b.g-h.g)*o,(b.b-h.b)*o,(b.a-h.a)*o)}return}let c=0,m=0,u=0,f=0;const p=G.search(i,e,5),w=this.curves[p/5];switch(w){case 0:const b=i[p];c=i[p+1],m=i[p+2],u=i[p+3],f=i[p+4];const g=(e-b)/(i[p+5]-b);c+=(i[p+5+1]-c)*g,m+=(i[p+5+2]-m)*g,u+=(i[p+5+3]-u)*g,f+=(i[p+5+4]-f)*g;break;case 1:c=i[p+1],m=i[p+2],u=i[p+3],f=i[p+4];break;default:c=this.getBezierValue(e,p,1,w-2),m=this.getBezierValue(e,p,2,w+18-2),u=this.getBezierValue(e,p,3,w+18*2-2),f=this.getBezierValue(e,p,4,w+18*3-2)}o==1?h.set(c,m,u,f):(d==A.setup&&h.setFromColor(s.data.color),h.add((c-h.r)*o,(m-h.g)*o,(u-h.b)*o,(f-h.a)*o))}}class re extends rt{constructor(t,n,e){super(t,n,[`${z.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,o){t<<=2,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,h=s.color;if(e<i[0]){const w=s.data.color;switch(d){case A.setup:h.r=w.r,h.g=w.g,h.b=w.b;return;case A.first:h.r+=(w.r-h.r)*o,h.g+=(w.g-h.g)*o,h.b+=(w.b-h.b)*o}return}let c=0,m=0,u=0;const f=G.search(i,e,4),p=this.curves[f>>2];switch(p){case 0:const w=i[f];c=i[f+1],m=i[f+2],u=i[f+3];const b=(e-w)/(i[f+4]-w);c+=(i[f+4+1]-c)*b,m+=(i[f+4+2]-m)*b,u+=(i[f+4+3]-u)*b;break;case 1:c=i[f+1],m=i[f+2],u=i[f+3];break;default:c=this.getBezierValue(e,f,1,p-2),m=this.getBezierValue(e,f,2,p+18-2),u=this.getBezierValue(e,f,3,p+18*2-2)}if(o==1)h.r=c,h.g=m,h.b=u;else{if(d==A.setup){const w=s.data.color;h.r=w.r,h.g=w.g,h.b=w.b}h.r+=(c-h.r)*o,h.g+=(m-h.g)*o,h.b+=(u-h.b)*o}}}class oe extends ot{constructor(t,n,e){super(t,n,`${z.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=s.color;if(e<this.frames[0]){const c=s.data.color;switch(d){case A.setup:i.a=c.a;return;case A.first:i.a+=(c.a-i.a)*o}return}const h=this.getCurveValue(e);o==1?i.a=h:(d==A.setup&&(i.a=s.data.color.a),i.a+=(h-i.a)*o)}}class he extends rt{constructor(t,n,e){super(t,n,[`${z.rgb}|${e}`,`${z.alpha}|${e}`,`${z.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,n,e,r,o,d,l,s,i){t<<=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=s,this.frames[t+7]=i}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,h=s.color,c=s.darkColor;if(e<i[0]){const x=s.data.color,S=s.data.darkColor;switch(d){case A.setup:h.setFromColor(x),c.r=S.r,c.g=S.g,c.b=S.b;return;case A.first:h.add((x.r-h.r)*o,(x.g-h.g)*o,(x.b-h.b)*o,(x.a-h.a)*o),c.r+=(S.r-c.r)*o,c.g+=(S.g-c.g)*o,c.b+=(S.b-c.b)*o}return}let m=0,u=0,f=0,p=0,w=0,b=0,g=0;const k=G.search(i,e,8),y=this.curves[k>>3];switch(y){case 0:const x=i[k];m=i[k+1],u=i[k+2],f=i[k+3],p=i[k+4],w=i[k+5],b=i[k+6],g=i[k+7];const S=(e-x)/(i[k+8]-x);m+=(i[k+8+1]-m)*S,u+=(i[k+8+2]-u)*S,f+=(i[k+8+3]-f)*S,p+=(i[k+8+4]-p)*S,w+=(i[k+8+5]-w)*S,b+=(i[k+8+6]-b)*S,g+=(i[k+8+7]-g)*S;break;case 1:m=i[k+1],u=i[k+2],f=i[k+3],p=i[k+4],w=i[k+5],b=i[k+6],g=i[k+7];break;default:m=this.getBezierValue(e,k,1,y-2),u=this.getBezierValue(e,k,2,y+18-2),f=this.getBezierValue(e,k,3,y+18*2-2),p=this.getBezierValue(e,k,4,y+18*3-2),w=this.getBezierValue(e,k,5,y+18*4-2),b=this.getBezierValue(e,k,6,y+18*5-2),g=this.getBezierValue(e,k,7,y+18*6-2)}if(o==1)h.set(m,u,f,p),c.r=w,c.g=b,c.b=g;else{if(d==A.setup){h.setFromColor(s.data.color);const x=s.data.darkColor;c.r=x.r,c.g=x.g,c.b=x.b}h.add((m-h.r)*o,(u-h.g)*o,(f-h.b)*o,(p-h.a)*o),c.r+=(w-c.r)*o,c.g+=(b-c.g)*o,c.b+=(g-c.b)*o}}}class le extends rt{constructor(t,n,e){super(t,n,[`${z.rgb}|${e}`,`${z.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,o,d,l,s){t*=7,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d,this.frames[t+5]=l,this.frames[t+6]=s}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,h=s.color,c=s.darkColor;if(e<i[0]){const y=s.data.color,x=s.data.darkColor;switch(d){case A.setup:h.r=y.r,h.g=y.g,h.b=y.b,c.r=x.r,c.g=x.g,c.b=x.b;return;case A.first:h.r+=(y.r-h.r)*o,h.g+=(y.g-h.g)*o,h.b+=(y.b-h.b)*o,c.r+=(x.r-c.r)*o,c.g+=(x.g-c.g)*o,c.b+=(x.b-c.b)*o}return}let m=0,u=0,f=0,p=0,w=0,b=0;const g=G.search(i,e,7),k=this.curves[g/7];switch(k){case 0:const y=i[g];m=i[g+1],u=i[g+2],f=i[g+3],p=i[g+4],w=i[g+5],b=i[g+6];const x=(e-y)/(i[g+7]-y);m+=(i[g+7+1]-m)*x,u+=(i[g+7+2]-u)*x,f+=(i[g+7+3]-f)*x,p+=(i[g+7+4]-p)*x,w+=(i[g+7+5]-w)*x,b+=(i[g+7+6]-b)*x;break;case 1:m=i[g+1],u=i[g+2],f=i[g+3],p=i[g+4],w=i[g+5],b=i[g+6];break;default:m=this.getBezierValue(e,g,1,k-2),u=this.getBezierValue(e,g,2,k+18-2),f=this.getBezierValue(e,g,3,k+18*2-2),p=this.getBezierValue(e,g,4,k+18*3-2),w=this.getBezierValue(e,g,5,k+18*4-2),b=this.getBezierValue(e,g,6,k+18*5-2)}if(o==1)h.r=m,h.g=u,h.b=f,c.r=p,c.g=w,c.b=b;else{if(d==A.setup){const y=s.data.color,x=s.data.darkColor;h.r=y.r,h.g=y.g,h.b=y.b,c.r=x.r,c.g=x.g,c.b=x.b}h.r+=(m-h.r)*o,h.g+=(u-h.g)*o,h.b+=(f-h.b)*o,c.r+=(p-c.r)*o,c.g+=(w-c.g)*o,c.b+=(b-c.b)*o}}}class yt extends G{constructor(t,n){super(t,[`${z.attachment}|${n}`]),this.slotIndex=0,this.slotIndex=n,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(s.bone.active){if(l==at.mixOut){d==A.setup&&this.setAttachment(t,s,s.data.attachmentName);return}if(e<this.frames[0]){(d==A.setup||d==A.first)&&this.setAttachment(t,s,s.data.attachmentName);return}this.setAttachment(t,s,this.attachmentNames[G.search1(this.frames,e)])}}setAttachment(t,n,e){n.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class ce extends rt{constructor(t,n,e,r){super(t,n,[`${z.deform}|${e}|${r.id}`]),this.slotIndex=0,this.attachment=null,this.vertices=null,this.slotIndex=e,this.attachment=r,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.vertices[t]=e}setBezier(t,n,e,r,o,d,l,s,i,h,c){const m=this.curves;let u=this.getFrameCount()+t*18;e==0&&(m[n]=2+u);const f=(r-d*2+s)*.03,p=i*.03-l*.06,w=((d-s)*3-r+h)*.006,b=(l-i+.33333333)*.018;let g=f*2+w,k=p*2+b,y=(d-r)*.3+f+w*.16666667,x=l*.3+p+b*.16666667,S=r+y,X=x;for(let F=u+18;u<F;u+=2)m[u]=S,m[u+1]=X,y+=g,x+=k,g+=w,k+=b,S+=y,X+=x}getCurvePercent(t,n){const e=this.curves;let r=e[n];switch(r){case 0:const s=this.frames[n];return(t-s)/(this.frames[n+this.getFrameEntries()]-s);case 1:return 0}if(r-=2,e[r]>t){const s=this.frames[n];return e[r+1]*(t-s)/(e[r]-s)}const o=r+18;for(r+=2;r<o;r+=2)if(e[r]>=t){const s=e[r-2],i=e[r-1];return i+(t-s)/(e[r]-s)*(e[r+1]-i)}const d=e[o-2],l=e[o-1];return l+(1-l)*(t-d)/(this.frames[n+this.getFrameEntries()]-d)}apply(t,n,e,r,o,d,l){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=s.getAttachment();if(!(i instanceof bt)||i.deformAttachment!=this.attachment)return;const h=s.deform;h.length==0&&(d=A.setup);const c=this.vertices,m=c[0].length,u=this.frames;if(e<u[0]){const g=i;switch(d){case A.setup:h.length=0;return;case A.first:if(o==1){h.length=0;return}if(h.length=m,g.bones){o=1-o;for(let k=0;k<m;k++)h[k]*=o}else{const k=g.vertices;for(let y=0;y<m;y++)h[y]+=(k[y]-h[y])*o}}return}if(h.length=m,e>=u[u.length-1]){const g=c[u.length-1];if(o==1)if(d==A.add){const k=i;if(k.bones)for(let y=0;y<m;y++)h[y]+=g[y];else{const y=k.vertices;for(let x=0;x<m;x++)h[x]+=g[x]-y[x]}}else B.arrayCopy(g,0,h,0,m);else switch(d){case A.setup:{const y=i;if(y.bones)for(let x=0;x<m;x++)h[x]=g[x]*o;else{const x=y.vertices;for(let S=0;S<m;S++){const X=x[S];h[S]=X+(g[S]-X)*o}}break}case A.first:case A.replace:for(let y=0;y<m;y++)h[y]+=(g[y]-h[y])*o;break;case A.add:const k=i;if(k.bones)for(let y=0;y<m;y++)h[y]+=g[y]*o;else{const y=k.vertices;for(let x=0;x<m;x++)h[x]+=(g[x]-y[x])*o}}return}const f=G.search1(u,e),p=this.getCurvePercent(e,f),w=c[f],b=c[f+1];if(o==1)if(d==A.add){const g=i;if(g.bones)for(let k=0;k<m;k++){const y=w[k];h[k]+=y+(b[k]-y)*p}else{const k=g.vertices;for(let y=0;y<m;y++){const x=w[y];h[y]+=x+(b[y]-x)*p-k[y]}}}else for(let g=0;g<m;g++){const k=w[g];h[g]=k+(b[g]-k)*p}else switch(d){case A.setup:{const k=i;if(k.bones)for(let y=0;y<m;y++){const x=w[y];h[y]=(x+(b[y]-x)*p)*o}else{const y=k.vertices;for(let x=0;x<m;x++){const S=w[x],X=y[x];h[x]=X+(S+(b[x]-S)*p-X)*o}}break}case A.first:case A.replace:for(let k=0;k<m;k++){const y=w[k];h[k]+=(y+(b[k]-y)*p-h[k])*o}break;case A.add:const g=i;if(g.bones)for(let k=0;k<m;k++){const y=w[k];h[k]+=(y+(b[k]-y)*p)*o}else{const k=g.vertices;for(let y=0;y<m;y++){const x=w[y];h[y]+=(x+(b[y]-x)*p-k[y])*o}}}}}const Ue=class extends G{constructor(a){super(a,Ue.propertyIds),this.events=null,this.events=new Array(a)}getFrameCount(){return this.frames.length}setFrame(a,t){this.frames[a]=t.time,this.events[a]=t}apply(a,t,n,e,r,o,d){if(!e)return;const l=this.frames,s=this.frames.length;if(t>n)this.apply(a,t,Number.MAX_VALUE,e,r,o,d),t=-1;else if(t>=l[s-1])return;if(n<l[0])return;let i=0;if(t<l[0])i=0;else{i=G.search1(l,t)+1;const h=l[i];for(;i>0&&l[i-1]==h;)i--}for(;i<s&&n>=l[i];i++)e.push(this.events[i])}};let vt=Ue;vt.propertyIds=[`${z.event}`];const je=class extends G{constructor(t){super(t,je.propertyIds),this.drawOrders=null,this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.drawOrders[t]=e}apply(t,n,e,r,o,d,l){if(l==at.mixOut){d==A.setup&&B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==A.setup||d==A.first)&&B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const s=this.drawOrders[G.search1(this.frames,e)];if(!s)B.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const i=t.drawOrder,h=t.slots;for(let c=0,m=s.length;c<m;c++)i[c]=h[s[c]]}}};let kt=je;kt.propertyIds=[`${z.drawOrder}`];class de extends rt{constructor(t,n,e){super(t,n,[`${z.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,n,e,r,o,d,l){t*=6,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d?1:0,this.frames[t+5]=l?1:0}apply(t,n,e,r,o,d,l){const s=t.ikConstraints[this.ikConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.mix=s.data.mix,s.softness=s.data.softness,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case A.first:s.mix+=(s.data.mix-s.mix)*o,s.softness+=(s.data.softness-s.softness)*o,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}let h=0,c=0;const m=G.search(i,e,6),u=this.curves[m/6];switch(u){case 0:const f=i[m];h=i[m+1],c=i[m+2];const p=(e-f)/(i[m+6]-f);h+=(i[m+6+1]-h)*p,c+=(i[m+6+2]-c)*p;break;case 1:h=i[m+1],c=i[m+2];break;default:h=this.getBezierValue(e,m,1,u-2),c=this.getBezierValue(e,m,2,u+18-2)}d==A.setup?(s.mix=s.data.mix+(h-s.data.mix)*o,s.softness=s.data.softness+(c-s.data.softness)*o,l==at.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=i[m+3],s.compress=i[m+4]!=0,s.stretch=i[m+5]!=0)):(s.mix+=(h-s.mix)*o,s.softness+=(c-s.softness)*o,l==at.mixIn&&(s.bendDirection=i[m+3],s.compress=i[m+4]!=0,s.stretch=i[m+5]!=0))}}class me extends rt{constructor(t,n,e){super(t,n,[`${z.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,o,d,l,s){const i=this.frames;t*=7,i[t]=n,i[t+1]=e,i[t+2]=r,i[t+3]=o,i[t+4]=d,i[t+5]=l,i[t+6]=s}apply(t,n,e,r,o,d,l){const s=t.transformConstraints[this.transformConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){const g=s.data;switch(d){case A.setup:s.mixRotate=g.mixRotate,s.mixX=g.mixX,s.mixY=g.mixY,s.mixScaleX=g.mixScaleX,s.mixScaleY=g.mixScaleY,s.mixShearY=g.mixShearY;return;case A.first:s.mixRotate+=(g.mixRotate-s.mixRotate)*o,s.mixX+=(g.mixX-s.mixX)*o,s.mixY+=(g.mixY-s.mixY)*o,s.mixScaleX+=(g.mixScaleX-s.mixScaleX)*o,s.mixScaleY+=(g.mixScaleY-s.mixScaleY)*o,s.mixShearY+=(g.mixShearY-s.mixShearY)*o}return}let h,c,m,u,f,p;const w=G.search(i,e,7),b=this.curves[w/7];switch(b){case 0:const g=i[w];h=i[w+1],c=i[w+2],m=i[w+3],u=i[w+4],f=i[w+5],p=i[w+6];const k=(e-g)/(i[w+7]-g);h+=(i[w+7+1]-h)*k,c+=(i[w+7+2]-c)*k,m+=(i[w+7+3]-m)*k,u+=(i[w+7+4]-u)*k,f+=(i[w+7+5]-f)*k,p+=(i[w+7+6]-p)*k;break;case 1:h=i[w+1],c=i[w+2],m=i[w+3],u=i[w+4],f=i[w+5],p=i[w+6];break;default:h=this.getBezierValue(e,w,1,b-2),c=this.getBezierValue(e,w,2,b+18-2),m=this.getBezierValue(e,w,3,b+18*2-2),u=this.getBezierValue(e,w,4,b+18*3-2),f=this.getBezierValue(e,w,5,b+18*4-2),p=this.getBezierValue(e,w,6,b+18*5-2)}if(d==A.setup){const g=s.data;s.mixRotate=g.mixRotate+(h-g.mixRotate)*o,s.mixX=g.mixX+(c-g.mixX)*o,s.mixY=g.mixY+(m-g.mixY)*o,s.mixScaleX=g.mixScaleX+(u-g.mixScaleX)*o,s.mixScaleY=g.mixScaleY+(f-g.mixScaleY)*o,s.mixShearY=g.mixShearY+(p-g.mixShearY)*o}else s.mixRotate+=(h-s.mixRotate)*o,s.mixX+=(c-s.mixX)*o,s.mixY+=(m-s.mixY)*o,s.mixScaleX+=(u-s.mixScaleX)*o,s.mixScaleY+=(f-s.mixScaleY)*o,s.mixShearY+=(p-s.mixShearY)*o}}class ue extends ot{constructor(t,n,e){super(t,n,`${z.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,o,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.position=s.data.position;return;case A.first:s.position+=(s.data.position-s.position)*o}return}const h=this.getCurveValue(e);d==A.setup?s.position=s.data.position+(h-s.data.position)*o:s.position+=(h-s.position)*o}}class fe extends ot{constructor(t,n,e){super(t,n,`${z.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,o,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.spacing=s.data.spacing;return;case A.first:s.spacing+=(s.data.spacing-s.spacing)*o}return}const h=this.getCurveValue(e);d==A.setup?s.spacing=s.data.spacing+(h-s.data.spacing)*o:s.spacing+=(h-s.spacing)*o}}class ge extends rt{constructor(t,n,e){super(t,n,[`${z.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,o){const d=this.frames;t<<=2,d[t]=n,d[t+1]=e,d[t+2]=r,d[t+3]=o}apply(t,n,e,r,o,d,l){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case A.setup:s.mixRotate=s.data.mixRotate,s.mixX=s.data.mixX,s.mixY=s.data.mixY;return;case A.first:s.mixRotate+=(s.data.mixRotate-s.mixRotate)*o,s.mixX+=(s.data.mixX-s.mixX)*o,s.mixY+=(s.data.mixY-s.mixY)*o}return}let h,c,m;const u=G.search(i,e,4),f=this.curves[u>>2];switch(f){case 0:const p=i[u];h=i[u+1],c=i[u+2],m=i[u+3];const w=(e-p)/(i[u+4]-p);h+=(i[u+4+1]-h)*w,c+=(i[u+4+2]-c)*w,m+=(i[u+4+3]-m)*w;break;case 1:h=i[u+1],c=i[u+2],m=i[u+3];break;default:h=this.getBezierValue(e,u,1,f-2),c=this.getBezierValue(e,u,2,f+18-2),m=this.getBezierValue(e,u,3,f+18*2-2)}if(d==A.setup){const p=s.data;s.mixRotate=p.mixRotate+(h-p.mixRotate)*o,s.mixX=p.mixX+(c-p.mixX)*o,s.mixY=p.mixY+(m-p.mixY)*o}else s.mixRotate+=(h-s.mixRotate)*o,s.mixX+=(c-s.mixX)*o,s.mixY+=(m-s.mixY)*o}}const ut=class{constructor(a){this.data=null,this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new _e(this),this.propertyIDs=new Ne,this.animationsChanged=!1,this.trackEntryPool=new as(()=>new Wt),this.data=a}static emptyAnimation(){return be||(be=new Vt("<empty>",[],0)),be}update(a){a*=this.timeScale;const t=this.tracks;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let o=a*r.timeScale;if(r.delay>0){if(r.delay-=o,r.delay>0)continue;o=-r.delay,r.delay=0}let d=r.next;if(d){const l=r.trackLast-d.delay;if(l>=0){for(d.delay=0,d.trackTime+=r.timeScale==0?0:(l/r.timeScale+a)*d.timeScale,r.trackTime+=o,this.setCurrent(n,d,!0);d.mixingFrom;)d.mixTime+=a,d=d.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){t[n]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,a)){let l=r.mixingFrom;for(r.mixingFrom=null,l&&(l.mixingTo=null);l;)this.queue.end(l),l=l.mixingFrom}r.trackTime+=o}this.queue.drain()}updateMixingFrom(a,t){const n=a.mixingFrom;if(!n)return!0;const e=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,a.mixTime>0&&a.mixTime>=a.mixDuration?((n.totalAlpha==0||a.mixDuration==0)&&(a.mixingFrom=n.mixingFrom,n.mixingFrom&&(n.mixingFrom.mixingTo=a),a.interruptAlpha=n.interruptAlpha,this.queue.end(n)),e):(n.trackTime+=t*n.timeScale,a.mixTime+=t,!1)}apply(a){if(!a)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let e=!1;for(let d=0,l=n.length;d<l;d++){const s=n[d];if(!s||s.delay>0)continue;e=!0;const i=d==0?A.first:s.mixBlend;let h=s.alpha;s.mixingFrom?h*=this.applyMixingFrom(s,a,i):s.trackTime>=s.trackEnd&&!s.next&&(h=0);const c=s.animationLast,m=s.getAnimationTime();let u=m,f=t;s.reverse&&(u=s.animation.duration-u,f=null);const p=s.animation.timelines,w=p.length;if(d==0&&h==1||i==A.add)for(let b=0;b<w;b++){B.webkit602BugfixHelper(h,i);const g=p[b];g instanceof yt?this.applyAttachmentTimeline(g,a,u,i,!0):g.apply(a,c,u,f,h,i,at.mixIn)}else{const b=s.timelineMode,g=s.timelinesRotation.length!=w<<1;g&&(s.timelinesRotation.length=w<<1);for(let k=0;k<w;k++){const y=p[k],x=b[k]==pe?i:A.setup;y instanceof Mt?this.applyRotateTimeline(y,a,u,h,x,s.timelinesRotation,k<<1,g):y instanceof yt?this.applyAttachmentTimeline(y,a,u,i,!0):(B.webkit602BugfixHelper(h,i),y.apply(a,c,u,f,h,x,at.mixIn))}}this.queueEvents(s,m),t.length=0,s.nextAnimationLast=m,s.nextTrackLast=s.trackTime}const r=this.unkeyedState+Je,o=a.slots;for(let d=0,l=a.slots.length;d<l;d++){const s=o[d];if(s.attachmentState==r){const i=s.data.attachmentName;s.setAttachment(i?a.getAttachment(s.data.index,i):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(a,t,n){const e=a.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,n);let r=0;a.mixDuration==0?(r=1,n==A.first&&(n=A.setup)):(r=a.mixTime/a.mixDuration,r>1&&(r=1),n!=A.first&&(n=e.mixBlend));const o=r<e.attachmentThreshold,d=r<e.drawOrderThreshold,l=e.animation.timelines,s=l.length,i=e.alpha*a.interruptAlpha,h=i*(1-r),c=e.animationLast,m=e.getAnimationTime();let u=m,f=null;if(e.reverse?u=e.animation.duration-u:r<e.eventThreshold&&(f=this.events),n==A.add)for(let p=0;p<s;p++)l[p].apply(t,c,u,f,h,n,at.mixOut);else{const p=e.timelineMode,w=e.timelineHoldMix,b=e.timelinesRotation.length!=s<<1;b&&(e.timelinesRotation.length=s<<1),e.totalAlpha=0;for(let g=0;g<s;g++){const k=l[g];let y=at.mixOut,x,S=0;switch(p[g]){case pe:if(!d&&k instanceof kt)continue;x=n,S=h;break;case Ge:x=A.setup,S=h;break;case He:x=n,S=i;break;case xe:x=A.setup,S=i;break;default:x=A.setup;const X=w[g];S=i*Math.max(0,1-X.mixTime/X.mixDuration);break}e.totalAlpha+=S,k instanceof Mt?this.applyRotateTimeline(k,t,u,S,x,e.timelinesRotation,g<<1,b):k instanceof yt?this.applyAttachmentTimeline(k,t,u,x,o):(B.webkit602BugfixHelper(S,n),d&&k instanceof kt&&x==A.setup&&(y=at.mixIn),k.apply(t,c,u,f,S,x,y))}}return a.mixDuration>0&&this.queueEvents(e,m),this.events.length=0,e.nextAnimationLast=m,e.nextTrackLast=e.trackTime,r}applyAttachmentTimeline(a,t,n,e,r){const o=t.slots[a.slotIndex];o.bone.active&&(n<a.frames[0]?(e==A.setup||e==A.first)&&this.setAttachment(t,o,o.data.attachmentName,r):this.setAttachment(t,o,a.attachmentNames[G.search1(a.frames,n)],r),o.attachmentState<=this.unkeyedState&&(o.attachmentState=this.unkeyedState+Je))}setAttachment(a,t,n,e){t.setAttachment(n?a.getAttachment(t.data.index,n):null),e&&(t.attachmentState=this.unkeyedState+ds)}applyRotateTimeline(a,t,n,e,r,o,d,l){if(l&&(o[d]=0),e==1){a.apply(t,0,n,null,1,r,at.mixIn);return}const s=t.bones[a.boneIndex];if(!s.active)return;const i=a.frames;let h=0,c=0;if(n<i[0])switch(r){case A.setup:s.rotation=s.data.rotation;default:return;case A.first:h=s.rotation,c=s.data.rotation}else h=r==A.setup?s.data.rotation:s.rotation,c=s.data.rotation+a.getCurveValue(n);let m=0,u=c-h;if(u-=(16384-(16384.499999999996-u/360|0))*360,u==0)m=o[d];else{let f=0,p=0;l?(f=0,p=u):(f=o[d],p=o[d+1]);const w=u>0;let b=f>=0;M.signum(p)!=M.signum(u)&&Math.abs(p)<=90&&(Math.abs(f)>180&&(f+=360*M.signum(f)),b=w),m=u+f-f%360,b!=w&&(m+=360*M.signum(f)),o[d]=m}o[d+1]=u,s.rotation=h+m*e}queueEvents(a,t){const n=a.animationStart,e=a.animationEnd,r=e-n,o=a.trackLast%r,d=this.events;let l=0;const s=d.length;for(;l<s;l++){const h=d[l];if(h.time<o)break;h.time>e||this.queue.event(a,h)}let i=!1;for(a.loop?i=r==0||o>a.trackTime%r:i=t>=e&&a.animationLast<e,i&&this.queue.complete(a);l<s;l++){const h=d[l];h.time<n||this.queue.event(a,h)}}clearTracks(){const a=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=a,this.queue.drain()}clearTrack(a){if(a>=this.tracks.length)return;const t=this.tracks[a];if(!t)return;this.queue.end(t),this.clearNext(t);let n=t;for(;;){const e=n.mixingFrom;if(!e)break;this.queue.end(e),n.mixingFrom=null,n.mixingTo=null,n=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(a,t,n){const e=this.expandToIndex(a);this.tracks[a]=t,t.previous=null,e&&(n&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(a,t,n=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(a,e,n)}setAnimationWith(a,t,n=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,r=this.expandToIndex(a);r&&(r.nextTrackLast==-1?(this.tracks[a]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,e=!1):this.clearNext(r));const o=this.trackEntry(a,t,n,r);return this.setCurrent(a,o,e),this.queue.drain(),o}addAnimation(a,t,n=!1,e=0){const r=this.data.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(a,r,n,e)}addAnimationWith(a,t,n=!1,e=0){if(!t)throw new Error("animation cannot be null.");let r=this.expandToIndex(a);if(r)for(;r.next;)r=r.next;const o=this.trackEntry(a,t,n,r);return r?(r.next=o,o.previous=r,e<=0&&(e+=r.getTrackComplete()-o.mixDuration)):(this.setCurrent(a,o,!0),this.queue.drain()),o.delay=e,o}setEmptyAnimation(a,t=0){const n=this.setAnimationWith(a,ut.emptyAnimation(),!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(a,t=0,n=0){const e=this.addAnimationWith(a,ut.emptyAnimation(),!1,n);return n<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(a=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++){const r=this.tracks[n];r&&this.setEmptyAnimation(r.trackIndex,a)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(a){return a<this.tracks.length?this.tracks[a]:(B.ensureArrayCapacity(this.tracks,a+1,null),this.tracks.length=a+1,null)}trackEntry(a,t,n,e){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=a,r.animation=t,r.loop=n,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=e?this.data.getMix(e.animation,t):0,r.mixBlend=A.replace,r}clearNext(a){let t=a.next;for(;t;)this.queue.dispose(t),t=t.next;a.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const a=this.tracks;for(let t=0,n=a.length;t<n;t++){let e=a[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=A.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(a){const t=a.mixingTo,n=a.animation.timelines,e=a.animation.timelines.length,r=a.timelineMode;r.length=e;const o=a.timelineHoldMix;o.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let l=0;l<e;l++)r[l]=d.addAll(n[l].getPropertyIds())?xe:He;return}t:for(let l=0;l<e;l++){const s=n[l],i=s.getPropertyIds();if(!d.addAll(i))r[l]=pe;else if(!t||s instanceof yt||s instanceof kt||s instanceof vt||!t.animation.hasTimeline(i))r[l]=Ge;else{for(let h=t.mixingTo;h;h=h.mixingTo)if(!h.animation.hasTimeline(i)){if(a.mixDuration>0){r[l]=cs,o[l]=h;continue t}break}r[l]=xe}}}getCurrent(a){return a>=this.tracks.length?null:this.tracks[a]}addListener(a){if(!a)throw new Error("listener cannot be null.");this.listeners.push(a)}removeListener(a){const t=this.listeners.indexOf(a);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(a,t,n){ut.deprecatedWarning1||(ut.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(a,t,n)}addAnimationByName(a,t,n,e){ut.deprecatedWarning2||(ut.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(a,t,n,e)}hasAnimation(a){return this.data.skeletonData.findAnimation(a)!==null}hasAnimationByName(a){return ut.deprecatedWarning3||(ut.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(a)}};let Tt=ut;Tt.deprecatedWarning1=!1,Tt.deprecatedWarning2=!1,Tt.deprecatedWarning3=!1;const ft=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=A.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return ft.deprecatedWarning1||(ft.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){ft.deprecatedWarning1||(ft.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return ft.deprecatedWarning2||(ft.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){ft.deprecatedWarning2||(ft.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Wt=ft;Wt.deprecatedWarning1=!1,Wt.deprecatedWarning2=!1;class _e{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=null,this.animState=t}start(t){this.objects.push(tt.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(tt.interrupt),this.objects.push(t)}end(t){this.objects.push(tt.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(tt.dispose),this.objects.push(t)}complete(t){this.objects.push(tt.complete),this.objects.push(t)}event(t,n){this.objects.push(tt.event),this.objects.push(t),this.objects.push(n)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],o=t[e+1];switch(r){case tt.start:o.listener&&o.listener.start&&o.listener.start(o);for(let l=0;l<n.length;l++)n[l].start&&n[l].start(o);break;case tt.interrupt:o.listener&&o.listener.interrupt&&o.listener.interrupt(o);for(let l=0;l<n.length;l++)n[l].interrupt&&n[l].interrupt(o);break;case tt.end:o.listener&&o.listener.end&&o.listener.end(o);for(let l=0;l<n.length;l++)n[l].end&&n[l].end(o);case tt.dispose:o.listener&&o.listener.dispose&&o.listener.dispose(o);for(let l=0;l<n.length;l++)n[l].dispose&&n[l].dispose(o);this.animState.trackEntryPool.free(o);break;case tt.complete:o.listener&&o.listener.complete&&o.listener.complete(o);for(let l=0;l<n.length;l++)n[l].complete&&n[l].complete(o);break;case tt.event:const d=t[e+++2];o.listener&&o.listener.event&&o.listener.event(o,d);for(let l=0;l<n.length;l++)n[l].event&&n[l].event(o,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var tt=(a=>(a[a.start=0]="start",a[a.interrupt=1]="interrupt",a[a.end=2]="end",a[a.dispose=3]="dispose",a[a.complete=4]="complete",a[a.event=5]="event",a))(tt||{});class ls{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const pe=0,Ge=1,He=2,xe=3,cs=4,Je=1,ds=2;let be=null;class Ze{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);const o=this.skeletonData.findAnimation(n);if(o==null)throw new Error(`Animation not found: ${n}`);this.setMixWith(r,o,e)}setMixWith(t,n,e){if(t==null)throw new Error("from cannot be null.");if(n==null)throw new Error("to cannot be null.");const r=`${t.name}.${n.name}`;this.animationToMixTime[r]=e}getMix(t,n){const e=`${t.name}.${n.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}}class ms{constructor(t){this.atlas=t}newRegionAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);const o=new P(n);return o.region=r,o}newMeshAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);const o=new Yt(n);return o.region=r,o}newBoundingBoxAttachment(t,n){return new Ot(n)}newPathAttachment(t,n){return new St(n)}newPointAttachment(t,n){return new zt(n)}newClippingAttachment(t,n){return new qt(n)}}class we{constructor(t,n,e){if(this.matrix=new os,this.data=null,this.skeleton=null,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,o,d,l){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=o,this.ashearX=d,this.ashearY=l;const s=this.parent,i=this.matrix,h=this.skeleton.scaleX,c=Ct.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!s){const w=this.skeleton,b=e+90+l;i.a=M.cosDeg(e+d)*r*h,i.c=M.cosDeg(b)*o*h,i.b=M.sinDeg(e+d)*r*c,i.d=M.sinDeg(b)*o*c,i.tx=t*h+w.x,i.ty=n*c+w.y;return}let m=s.matrix.a,u=s.matrix.c,f=s.matrix.b,p=s.matrix.d;switch(i.tx=m*t+u*n+s.matrix.tx,i.ty=f*t+p*n+s.matrix.ty,this.data.transformMode){case nt.Normal:{const w=e+90+l,b=M.cosDeg(e+d)*r,g=M.cosDeg(w)*o,k=M.sinDeg(e+d)*r,y=M.sinDeg(w)*o;i.a=m*b+u*k,i.c=m*g+u*y,i.b=f*b+p*k,i.d=f*g+p*y;return}case nt.OnlyTranslation:{const w=e+90+l;i.a=M.cosDeg(e+d)*r,i.c=M.cosDeg(w)*o,i.b=M.sinDeg(e+d)*r,i.d=M.sinDeg(w)*o;break}case nt.NoRotationOrReflection:{let w=m*m+f*f,b=0;w>1e-4?(w=Math.abs(m*p-u*f)/w,m/=h,f/=c,u=f*w,p=m*w,b=Math.atan2(f,m)*M.radDeg):(m=0,f=0,b=90-Math.atan2(p,u)*M.radDeg);const g=e+d-b,k=e+l-b+90,y=M.cosDeg(g)*r,x=M.cosDeg(k)*o,S=M.sinDeg(g)*r,X=M.sinDeg(k)*o;i.a=m*y-u*S,i.c=m*x-u*X,i.b=f*y+p*S,i.d=f*x+p*X;break}case nt.NoScale:case nt.NoScaleOrReflection:{const w=M.cosDeg(e),b=M.sinDeg(e);let g=(m*w+u*b)/h,k=(f*w+p*b)/c,y=Math.sqrt(g*g+k*k);y>1e-5&&(y=1/y),g*=y,k*=y,y=Math.sqrt(g*g+k*k),this.data.transformMode==nt.NoScale&&m*p-u*f<0!=(h<0!=c<0)&&(y=-y);const x=Math.PI/2+Math.atan2(k,g),S=Math.cos(x)*y,X=Math.sin(x)*y,F=M.cosDeg(d)*r,I=M.cosDeg(90+l)*o,C=M.sinDeg(d)*r,v=M.sinDeg(90+l)*o;i.a=g*F+S*C,i.c=g*I+S*v,i.b=k*F+X*C,i.d=k*I+X*v;break}}i.a*=h,i.c*=h,i.b*=c,i.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*M.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*M.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,n=this.matrix;if(!t){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*M.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*M.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),o=n.tx-e.tx,d=n.ty-e.ty;this.ax=o*e.d*r-d*e.c*r,this.ay=d*e.a*r-o*e.b*r;const l=r*e.d,s=r*e.a,i=r*e.c,h=r*e.b,c=l*n.a-i*n.b,m=l*n.c-i*n.d,u=s*n.b-h*n.a,f=s*n.d-h*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+u*u),this.ascaleX>1e-4){const p=c*f-m*u;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(c*m+u*f,p)*M.radDeg,this.arotation=Math.atan2(u,c)*M.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,m)*M.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,o=n.b,d=n.d,l=1/(e*d-r*o),s=t.x-n.tx,i=t.y-n.ty;return t.x=s*d*l-i*r*l,t.y=i*e*l-s*o*l,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=M.sinDeg(t),e=M.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*M.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const n=M.sinDeg(t),e=M.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*M.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,o=n.b,d=n.d,l=M.cosDeg(t),s=M.sinDeg(t);n.a=l*e-s*o,n.c=l*r-s*d,n.b=s*e+l*o,n.d=s*r+l*d}}class ye{constructor(t,n,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=nt.Normal,this.skinRequired=!1,this.color=new $,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}}class $t{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}}class ke{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class Se{constructor(t){this.name=t}}class Ke{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,n,e,r,o,d,l){const s=t.parent.matrix,i=s.a;let h=s.c;const c=s.b;let m=s.d,u=-t.ashearX-t.arotation,f=0,p=0;const w=t.skeleton.scaleX,b=Ct.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case nt.OnlyTranslation:f=n-t.worldX,p=e-t.worldY,Ct.yDown&&(p=-p);break;case nt.NoRotationOrReflection:const y=Math.abs(i*m-h*c)/(i*i+c*c),x=i/w,S=c/b;h=-S*y*w,m=x*y*b,u+=Math.atan2(S,x)*M.radDeg;default:const X=n-s.tx,F=e-s.ty,I=i*m-h*c;f=(X*m-F*h)/I-t.ax,p=(F*i-X*c)/I-t.ay}u+=Math.atan2(p,f)*M.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let g=t.ascaleX,k=t.ascaleY;if(r||o){switch(t.data.transformMode){case nt.NoScale:case nt.NoScaleOrReflection:f=n-t.worldX,p=e-t.worldY}const y=t.data.length*g,x=Math.sqrt(f*f+p*p);if(r&&x<y||o&&x>y&&y>1e-4){const S=(x/y-1)*l+1;g*=S,d&&(k*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*l,g,k,t.ashearX,t.ashearY)}apply2(t,n,e,r,o,d,l,s,i){const h=t.ax,c=t.ay;let m=t.ascaleX,u=t.ascaleY,f=m,p=u,w=n.ascaleX;const b=t.matrix;let g=0,k=0,y=0;m<0?(m=-m,g=180,y=-1):(g=0,y=1),u<0&&(u=-u,y=-y),w<0?(w=-w,k=180):k=0;const x=n.ax;let S=0,X=0,F=0,I=b.a,C=b.c,v=b.b,T=b.d;const R=Math.abs(m-u)<=1e-4;!R||d?(S=0,X=I*x+b.tx,F=v*x+b.ty):(S=n.ay,X=I*x+C*S+b.tx,F=v*x+T*S+b.ty);const E=t.parent.matrix;I=E.a,C=E.c,v=E.b,T=E.d;const q=1/(I*T-C*v);let D=X-E.tx,W=F-E.ty;const _=(D*T-W*C)*q-h,H=(W*I-D*v)*q-c,j=Math.sqrt(_*_+H*H);let J=n.data.length*w,V,L;if(j<1e-4){this.apply1(t,e,r,!1,d,!1,i),n.updateWorldTransformWith(x,S,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}D=e-E.tx,W=r-E.ty;let U=(D*T-W*C)*q-h,et=(W*I-D*v)*q-c,it=U*U+et*et;if(s!=0){s*=m*(w+1)*.5;const Q=Math.sqrt(it),dt=Q-j-J*m+s;if(dt>0){let mt=Math.min(1,dt/(s*2))-1;mt=(dt-s*(1-mt*mt))/Q,U-=mt*U,et-=mt*et,it=U*U+et*et}}t:if(R){J*=m;let Q=(it-j*j-J*J)/(2*j*J);Q<-1?(Q=-1,L=Math.PI*o):Q>1?(Q=1,L=0,d&&(I=(Math.sqrt(it)/(j+J)-1)*i+1,f*=I,l&&(p*=I))):L=Math.acos(Q)*o,I=j+J*Q,C=J*Math.sin(L),V=Math.atan2(et*I-U*C,U*I+et*C)}else{I=m*J,C=u*J;const Q=I*I,dt=C*C,mt=Math.atan2(et,U);v=dt*j*j+Q*it-Q*dt;const Et=-2*dt*j,Re=dt-Q;if(T=Et*Et-4*Re*v,T>=0){let At=Math.sqrt(T);Et<0&&(At=-At),At=-(Et+At)*.5;const We=At/Re,$e=v/At,Xt=Math.abs(We)<Math.abs($e)?We:$e;if(Xt*Xt<=it){W=Math.sqrt(it-Xt*Xt)*o,V=mt-Math.atan2(W,Xt),L=Math.atan2(W/u,(Xt-j)/m);break t}}let De=M.PI,Rt=j-I,Ut=Rt*Rt,Pe=0,Ve=0,Dt=j+I,jt=Dt*Dt,Le=0;v=-I*j/(Q-dt),v>=-1&&v<=1&&(v=Math.acos(v),D=I*Math.cos(v)+j,W=C*Math.sin(v),T=D*D+W*W,T<Ut&&(De=v,Ut=T,Rt=D,Pe=W),T>jt&&(Ve=v,jt=T,Dt=D,Le=W)),it<=(Ut+jt)*.5?(V=mt-Math.atan2(Pe*o,Rt),L=De*o):(V=mt-Math.atan2(Le*o,Dt),L=Ve*o)}const Ee=Math.atan2(S,x)*y;let Ft=t.arotation;V=(V-Ee)*M.radDeg+g-Ft,V>180?V-=360:V<-180&&(V+=360),t.updateWorldTransformWith(h,c,Ft+V*i,f,p,0,0),Ft=n.arotation,L=((L+Ee)*M.radDeg-n.ashearX)*y+k-Ft,L>180?L-=360:L<-180&&(L+=360),n.updateWorldTransformWith(x,S,Ft+L*i,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class Ye extends $t{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class Ae extends $t{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0}}var K=(a=>(a[a.Length=0]="Length",a[a.Fixed=1]="Fixed",a[a.Percent=2]="Percent",a[a.Proportional=3]="Proportional",a))(K||{});const gt=class{constructor(a,t){if(this.data=null,this.bones=null,this.target=null,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!a)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=a,this.bones=new Array;for(let n=0,e=a.bones.length;n<e;n++)this.bones.push(t.findBone(a.bones[n].name));this.target=t.findSlot(a.target.name),this.position=a.position,this.spacing=a.spacing,this.mixRotate=a.mixRotate,this.mixX=a.mixX,this.mixY=a.mixY}isActive(){return this.active}update(){const a=this.target.getAttachment();if(!(a instanceof St))return;const t=this.mixRotate,n=this.mixX,e=this.mixY;if(t==0&&n==0&&e==0)return;const r=this.data,o=r.rotateMode==Pt.Tangent,d=r.rotateMode==Pt.ChainScale,l=this.bones,s=l.length,i=o?s:s+1,h=B.setArraySize(this.spaces,i),c=d?this.lengths=B.setArraySize(this.lengths,s):null,m=this.spacing;switch(r.spacingMode){case K.Percent:if(d)for(let y=0,x=i-1;y<x;y++){const S=l[y],X=S.data.length;if(X<gt.epsilon)c[y]=0;else{const F=X*S.matrix.a,I=X*S.matrix.b;c[y]=Math.sqrt(F*F+I*I)}}B.arrayFill(h,1,i,m);break;case K.Proportional:let g=0;for(let y=0,x=i-1;y<x;){const S=l[y],X=S.data.length;if(X<gt.epsilon)d&&(c[y]=0),h[++y]=m;else{const F=X*S.matrix.a,I=X*S.matrix.b,C=Math.sqrt(F*F+I*I);d&&(c[y]=C),h[++y]=C,g+=C}}if(g>0){g=i/g*m;for(let y=1;y<i;y++)h[y]*=g}break;default:const k=r.spacingMode==K.Length;for(let y=0,x=i-1;y<x;){const S=l[y],X=S.data.length;if(X<gt.epsilon)d&&(c[y]=0),h[++y]=m;else{const F=X*S.matrix.a,I=X*S.matrix.b,C=Math.sqrt(F*F+I*I);d&&(c[y]=C),h[++y]=(k?X+m:m)*C/X}}}const u=this.computeWorldPositions(a,i,o);let f=u[0],p=u[1],w=r.offsetRotation,b=!1;if(w==0)b=r.rotateMode==Pt.Chain;else{b=!1;const g=this.target.bone.matrix;w*=g.a*g.d-g.b*g.c>0?M.degRad:-M.degRad}for(let g=0,k=3;g<s;g++,k+=3){const y=l[g],x=y.matrix;x.tx+=(f-x.tx)*n,x.ty+=(p-x.ty)*e;const S=u[k],X=u[k+1],F=S-f,I=X-p;if(d){const C=c[g];if(C!=0){const v=(Math.sqrt(F*F+I*I)/C-1)*t+1;x.a*=v,x.b*=v}}if(f=S,p=X,t>0){const C=x.a,v=x.c,T=x.b,R=x.d;let E=0,q=0,D=0;if(o&&(o?E=u[k-1]:h[g+1]==0?E=u[k+2]:E=Math.atan2(I,F)),E-=Math.atan2(T,C),b){q=Math.cos(E),D=Math.sin(E);const W=y.data.length;f+=(W*(q*C-D*T)-F)*t,p+=(W*(D*C+q*T)-I)*t}else E+=w;E>M.PI?E-=M.PI2:E<-M.PI&&(E+=M.PI2),E*=t,q=Math.cos(E),D=Math.sin(E),x.a=q*C-D*T,x.c=q*v-D*R,x.b=D*C+q*T,x.d=D*v+q*R}y.updateAppliedTransform()}}computeWorldPositions(a,t,n){const e=this.target;let r=this.position;const o=this.spaces,d=B.setArraySize(this.positions,t*3+2);let l=null;const s=a.closed;let i=a.worldVerticesLength,h=i/6,c=gt.NONE;if(!a.constantSpeed){const W=a.lengths;h-=s?1:2;const _=W[h];this.data.positionMode==wt.Percent&&(r*=_);let H;switch(this.data.spacingMode){case K.Percent:H=_;break;case K.Proportional:H=_/t;break;default:H=1}l=B.setArraySize(this.world,8);for(let j=0,J=0,V=0;j<t;j++,J+=3){const L=o[j]*H;r+=L;let U=r;if(s)U%=_,U<0&&(U+=_),V=0;else if(U<0){c!=gt.BEFORE&&(c=gt.BEFORE,a.computeWorldVertices(e,2,4,l,0,2)),this.addBeforePosition(U,l,0,d,J);continue}else if(U>_){c!=gt.AFTER&&(c=gt.AFTER,a.computeWorldVertices(e,i-6,4,l,0,2)),this.addAfterPosition(U-_,l,0,d,J);continue}for(;;V++){const et=W[V];if(!(U>et)){if(V==0)U/=et;else{const it=W[V-1];U=(U-it)/(et-it)}break}}V!=c&&(c=V,s&&V==h?(a.computeWorldVertices(e,i-4,4,l,0,2),a.computeWorldVertices(e,0,4,l,4,2)):a.computeWorldVertices(e,V*6+2,8,l,0,2)),this.addCurvePosition(U,l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],d,J,n||j>0&&L==0)}return d}s?(i+=2,l=B.setArraySize(this.world,i),a.computeWorldVertices(e,2,i-4,l,0,2),a.computeWorldVertices(e,0,2,l,i-4,2),l[i-2]=l[0],l[i-1]=l[1]):(h--,i-=4,l=B.setArraySize(this.world,i),a.computeWorldVertices(e,2,i,l,0,2));const m=B.setArraySize(this.curves,h);let u=0,f=l[0],p=l[1],w=0,b=0,g=0,k=0,y=0,x=0,S=0,X=0,F=0,I=0,C=0,v=0,T=0,R=0;for(let W=0,_=2;W<h;W++,_+=6)w=l[_],b=l[_+1],g=l[_+2],k=l[_+3],y=l[_+4],x=l[_+5],S=(f-w*2+g)*.1875,X=(p-b*2+k)*.1875,F=((w-g)*3-f+y)*.09375,I=((b-k)*3-p+x)*.09375,C=S*2+F,v=X*2+I,T=(w-f)*.75+S+F*.16666667,R=(b-p)*.75+X+I*.16666667,u+=Math.sqrt(T*T+R*R),T+=C,R+=v,C+=F,v+=I,u+=Math.sqrt(T*T+R*R),T+=C,R+=v,u+=Math.sqrt(T*T+R*R),T+=C+F,R+=v+I,u+=Math.sqrt(T*T+R*R),m[W]=u,f=y,p=x;this.data.positionMode==wt.Percent&&(r*=u);let E;switch(this.data.spacingMode){case K.Percent:E=u;break;case K.Proportional:E=u/t;break;default:E=1}const q=this.segments;let D=0;for(let W=0,_=0,H=0,j=0;W<t;W++,_+=3){const J=o[W]*E;r+=J;let V=r;if(s)V%=u,V<0&&(V+=u),H=0;else if(V<0){this.addBeforePosition(V,l,0,d,_);continue}else if(V>u){this.addAfterPosition(V-u,l,i-4,d,_);continue}for(;;H++){const L=m[H];if(!(V>L)){if(H==0)V/=L;else{const U=m[H-1];V=(V-U)/(L-U)}break}}if(H!=c){c=H;let L=H*6;for(f=l[L],p=l[L+1],w=l[L+2],b=l[L+3],g=l[L+4],k=l[L+5],y=l[L+6],x=l[L+7],S=(f-w*2+g)*.03,X=(p-b*2+k)*.03,F=((w-g)*3-f+y)*.006,I=((b-k)*3-p+x)*.006,C=S*2+F,v=X*2+I,T=(w-f)*.3+S+F*.16666667,R=(b-p)*.3+X+I*.16666667,D=Math.sqrt(T*T+R*R),q[0]=D,L=1;L<8;L++)T+=C,R+=v,C+=F,v+=I,D+=Math.sqrt(T*T+R*R),q[L]=D;T+=C,R+=v,D+=Math.sqrt(T*T+R*R),q[8]=D,T+=C+F,R+=v+I,D+=Math.sqrt(T*T+R*R),q[9]=D,j=0}for(V*=D;;j++){const L=q[j];if(!(V>L)){if(j==0)V/=L;else{const U=q[j-1];V=j+(V-U)/(L-U)}break}}this.addCurvePosition(V*.1,f,p,w,b,g,k,y,x,d,_,n||W>0&&J==0)}return d}addBeforePosition(a,t,n,e,r){const o=t[n],d=t[n+1],l=t[n+2]-o,s=t[n+3]-d,i=Math.atan2(s,l);e[r]=o+a*Math.cos(i),e[r+1]=d+a*Math.sin(i),e[r+2]=i}addAfterPosition(a,t,n,e,r){const o=t[n+2],d=t[n+3],l=o-t[n],s=d-t[n+1],i=Math.atan2(s,l);e[r]=o+a*Math.cos(i),e[r+1]=d+a*Math.sin(i),e[r+2]=i}addCurvePosition(a,t,n,e,r,o,d,l,s,i,h,c){if(a==0||isNaN(a)){i[h]=t,i[h+1]=n,i[h+2]=Math.atan2(r-n,e-t);return}const m=a*a,u=m*a,f=1-a,p=f*f,w=p*f,b=f*a,g=b*3,k=f*g,y=g*a,x=t*w+e*k+o*y+l*u,S=n*w+r*k+d*y+s*u;i[h]=x,i[h+1]=S,c&&(a<.001?i[h+2]=Math.atan2(r-n,e-t):i[h+2]=Math.atan2(S-(n*p+r*b*2+d*m),x-(t*p+e*b*2+o*m)))}};let It=gt;It.NONE=-1,It.BEFORE=-2,It.AFTER=-3,It.epsilon=1e-5;class Qe{constructor(t,n){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new _t,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,l=n!=0||e!=0,s=this.target,i=s.matrix,h=i.a,c=i.c,m=i.b,u=i.d,f=h*u-c*m>0?M.degRad:-M.degRad,p=this.data.offsetRotation*f,w=this.data.offsetShearY*f,b=this.bones;for(let g=0,k=b.length;g<k;g++){const y=b[g],x=y.matrix;if(t!=0){const S=x.a,X=x.c,F=x.b,I=x.d;let C=Math.atan2(m,h)-Math.atan2(F,S)+p;C>M.PI?C-=M.PI2:C<-M.PI&&(C+=M.PI2),C*=t;const v=Math.cos(C),T=Math.sin(C);x.a=v*S-T*F,x.c=v*X-T*I,x.b=T*S+v*F,x.d=T*X+v*I}if(l){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),x.tx+=(S.x-x.tx)*n,x.ty+=(S.y-x.ty)*e}if(r!=0){let S=Math.sqrt(x.a*x.a+x.b*x.b);S!=0&&(S=(S+(Math.sqrt(h*h+m*m)-S+this.data.offsetScaleX)*r)/S),x.a*=S,x.b*=S}if(o!=0){let S=Math.sqrt(x.c*x.c+x.d*x.d);S!=0&&(S=(S+(Math.sqrt(c*c+u*u)-S+this.data.offsetScaleY)*o)/S),x.c*=S,x.d*=S}if(d>0){const S=x.c,X=x.d,F=Math.atan2(X,S);let I=Math.atan2(u,c)-Math.atan2(m,h)-(F-Math.atan2(x.b,x.a));I>M.PI?I-=M.PI2:I<-M.PI&&(I+=M.PI2),I=F+(I+w)*d;const C=Math.sqrt(S*S+X*X);x.c=Math.cos(I)*C,x.d=Math.sin(I)*C}y.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,l=n!=0||e!=0,s=this.target,i=s.matrix,h=i.a,c=i.c,m=i.b,u=i.d,f=h*u-c*m>0?M.degRad:-M.degRad,p=this.data.offsetRotation*f,w=this.data.offsetShearY*f,b=this.bones;for(let g=0,k=b.length;g<k;g++){const y=b[g],x=y.matrix;if(t!=0){const S=x.a,X=x.c,F=x.b,I=x.d;let C=Math.atan2(m,h)+p;C>M.PI?C-=M.PI2:C<-M.PI&&(C+=M.PI2),C*=t;const v=Math.cos(C),T=Math.sin(C);x.a=v*S-T*F,x.c=v*X-T*I,x.b=T*S+v*F,x.d=T*X+v*I}if(l){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),x.tx+=S.x*n,x.ty+=S.y*e}if(r!=0){const S=(Math.sqrt(h*h+m*m)-1+this.data.offsetScaleX)*r+1;x.a*=S,x.b*=S}if(o!=0){const S=(Math.sqrt(c*c+u*u)-1+this.data.offsetScaleY)*o+1;x.c*=S,x.d*=S}if(d>0){let S=Math.atan2(u,c)-Math.atan2(m,h);S>M.PI?S-=M.PI2:S<-M.PI&&(S+=M.PI2);const X=x.c,F=x.d;S=Math.atan2(F,X)+(S-M.PI/2+w)*d;const I=Math.sqrt(X*X+F*F);x.c=Math.cos(S)*I,x.d=Math.sin(S)*I}y.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,l=this.target,s=this.bones;for(let i=0,h=s.length;i<h;i++){const c=s[i];let m=c.arotation;if(t!=0){let g=l.arotation-m+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,m+=g*t}let u=c.ax,f=c.ay;u+=(l.ax-u+this.data.offsetX)*n,f+=(l.ay-f+this.data.offsetY)*e;let p=c.ascaleX,w=c.ascaleY;r!=0&&p!=0&&(p=(p+(l.ascaleX-p+this.data.offsetScaleX)*r)/p),o!=0&&w!=0&&(w=(w+(l.ascaleY-w+this.data.offsetScaleY)*o)/w);let b=c.ashearY;if(d!=0){let g=l.ashearY-b+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,b+=g*d}c.updateWorldTransformWith(u,f,m,p,w,c.ashearX,b)}}applyRelativeLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,l=this.target,s=this.bones;for(let i=0,h=s.length;i<h;i++){const c=s[i],m=c.arotation+(l.arotation+this.data.offsetRotation)*t,u=c.ax+(l.ax+this.data.offsetX)*n,f=c.ay+(l.ay+this.data.offsetY)*e,p=c.ascaleX*((l.ascaleX-1+this.data.offsetScaleX)*r+1),w=c.ascaleY*((l.ascaleY-1+this.data.offsetScaleY)*o+1),b=c.ashearY+(l.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(u,f,m,p,w,c.ashearX,b)}}}const Bt=class{constructor(a){if(this.data=null,this.bones=null,this.slots=null,this.drawOrder=null,this.ikConstraints=null,this.transformConstraints=null,this.pathConstraints=null,this._updateCache=new Array,this.skin=null,this.color=null,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!a)throw new Error("data cannot be null.");this.data=a,this.bones=new Array;for(let t=0;t<a.bones.length;t++){const n=a.bones[t];let e;if(!n.parent)e=new we(n,this,null);else{const r=this.bones[n.parent.index];e=new we(n,this,r),r.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<a.slots.length;t++){const n=a.slots[t],e=this.bones[n.boneData.index],r=new Ht(n,e);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<a.ikConstraints.length;t++){const n=a.ikConstraints[t];this.ikConstraints.push(new Ke(n,this))}this.transformConstraints=new Array;for(let t=0;t<a.transformConstraints.length;t++){const n=a.transformConstraints[t];this.transformConstraints.push(new Qe(n,this))}this.pathConstraints=new Array;for(let t=0;t<a.pathConstraints.length;t++){const n=a.pathConstraints[t];this.pathConstraints.push(new It(n,this))}this.color=new $(1,1,1,1),this.updateCache()}updateCache(){const a=this._updateCache;a.length=0;const t=this.bones;for(let i=0,h=t.length;i<h;i++){const c=t[i];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const i=this.skin.bones;for(let h=0,c=this.skin.bones.length;h<c;h++){let m=this.bones[i[h].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const n=this.ikConstraints,e=this.transformConstraints,r=this.pathConstraints,o=n.length,d=e.length,l=r.length,s=o+d+l;t:for(let i=0;i<s;i++){for(let h=0;h<o;h++){const c=n[h];if(c.data.order==i){this.sortIkConstraint(c);continue t}}for(let h=0;h<d;h++){const c=e[h];if(c.data.order==i){this.sortTransformConstraint(c);continue t}}for(let h=0;h<l;h++){const c=r[h];if(c.data.order==i){this.sortPathConstraint(c);continue t}}}for(let i=0,h=t.length;i<h;i++)this.sortBone(t[i])}sortIkConstraint(a){if(a.active=a.target.isActive()&&(!a.data.skinRequired||this.skin&&B.contains(this.skin.constraints,a.data,!0)),!a.active)return;const t=a.target;this.sortBone(t);const n=a.bones,e=n[0];if(this.sortBone(e),n.length==1)this._updateCache.push(a),this.sortReset(e.children);else{const r=n[n.length-1];this.sortBone(r),this._updateCache.push(a),this.sortReset(e.children),r.sorted=!0}}sortPathConstraint(a){if(a.active=a.target.bone.isActive()&&(!a.data.skinRequired||this.skin&&B.contains(this.skin.constraints,a.data,!0)),!a.active)return;const t=a.target,n=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,n,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,e);for(let l=0,s=this.data.skins.length;l<s;l++)this.sortPathConstraintAttachment(this.data.skins[l],n,e);const r=t.getAttachment();r instanceof St&&this.sortPathConstraintAttachmentWith(r,e);const o=a.bones,d=o.length;for(let l=0;l<d;l++)this.sortBone(o[l]);this._updateCache.push(a);for(let l=0;l<d;l++)this.sortReset(o[l].children);for(let l=0;l<d;l++)o[l].sorted=!0}sortTransformConstraint(a){if(a.active=a.target.isActive()&&(!a.data.skinRequired||this.skin&&B.contains(this.skin.constraints,a.data,!0)),!a.active)return;this.sortBone(a.target);const t=a.bones,n=t.length;if(a.data.local)for(let e=0;e<n;e++){const r=t[e];this.sortBone(r.parent),this.sortBone(r)}else for(let e=0;e<n;e++)this.sortBone(t[e]);this._updateCache.push(a);for(let e=0;e<n;e++)this.sortReset(t[e].children);for(let e=0;e<n;e++)t[e].sorted=!0}sortPathConstraintAttachment(a,t,n){const e=a.attachments[t];if(e)for(const r in e)this.sortPathConstraintAttachmentWith(e[r],n)}sortPathConstraintAttachmentWith(a,t){if(!(a instanceof St))return;const n=a.bones;if(!n)this.sortBone(t);else{const e=this.bones;for(let r=0,o=n.length;r<o;){let d=n[r++];for(d+=r;r<d;)this.sortBone(e[n[r++]])}}}sortBone(a){if(a.sorted)return;const t=a.parent;t&&this.sortBone(t),a.sorted=!0,this._updateCache.push(a)}sortReset(a){for(let t=0,n=a.length;t<n;t++){const e=a[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const a=this.bones;for(let n=0,e=a.length;n<e;n++){const r=a[n];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const t=this._updateCache;for(let n=0,e=t.length;n<e;n++)t[n].update()}updateWorldTransformWith(a){const t=this.getRootBone(),n=a.matrix.a,e=a.matrix.c,r=a.matrix.b,o=a.matrix.d;t.matrix.tx=n*this.x+e*this.y+a.worldX,t.matrix.ty=r*this.x+o*this.y+a.worldY;const d=t.rotation+90+t.shearY,l=M.cosDeg(t.rotation+t.shearX)*t.scaleX,s=M.cosDeg(d)*t.scaleY,i=M.sinDeg(t.rotation+t.shearX)*t.scaleX,h=M.sinDeg(d)*t.scaleY,c=this.scaleX,m=Ct.yDown?-this.scaleY:this.scaleY;t.matrix.a=(n*l+e*i)*c,t.matrix.c=(n*s+e*h)*c,t.matrix.b=(r*l+o*i)*m,t.matrix.d=(r*s+o*h)*m;const u=this._updateCache;for(let f=0,p=u.length;f<p;f++){const w=u[f];w!=t&&w.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const a=this.bones;for(let r=0,o=a.length;r<o;r++)a[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,o=t.length;r<o;r++){const d=t[r];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let r=0,o=n.length;r<o;r++){const d=n[r],l=d.data;d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY,d.mixScaleX=l.mixScaleX,d.mixScaleY=l.mixScaleY,d.mixShearY=l.mixShearY}const e=this.pathConstraints;for(let r=0,o=e.length;r<o;r++){const d=e[r],l=d.data;d.position=l.position,d.spacing=l.spacing,d.mixRotate=l.mixRotate,d.mixX=l.mixX,d.mixY=l.mixY}}setSlotsToSetupPose(){const a=this.slots;B.arrayCopy(a,0,this.drawOrder,0,a.length);for(let t=0,n=a.length;t<n;t++)a[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(a){if(!a)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==a)return r}return null}findBoneIndex(a){if(!a)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==a)return n;return-1}findSlot(a){if(!a)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==a)return r}return null}findSlotIndex(a){if(!a)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==a)return n;return-1}setSkinByName(a){const t=this.data.findSkin(a);if(!t)throw new Error(`Skin not found: ${a}`);this.setSkin(t)}setSkin(a){if(a!=this.skin){if(a)if(this.skin)a.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n],o=r.data.attachmentName;if(o){const d=a.getAttachment(n,o);d&&r.setAttachment(d)}}}this.skin=a,this.updateCache()}}getAttachmentByName(a,t){return this.getAttachment(this.data.findSlot(a).index,t)}getAttachment(a,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const n=this.skin.getAttachment(a,t);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(a,t):null}setAttachment(a,t){if(!a)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.data.name==a){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${a}`);o.setAttachment(d);return}}throw new Error(`Slot not found: ${a}`)}findIkConstraint(a){if(!a)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==a)return r}return null}findTransformConstraint(a){if(!a)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==a)return r}return null}findPathConstraint(a){if(!a)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==a)return r}return null}getBoundsRect(){const a=new _t,t=new _t;return this.getBounds(a,t),{x:a.x,y:a.y,width:t.x,height:t.y}}getBounds(a,t,n=new Array(2)){if(!a)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let r=Number.POSITIVE_INFINITY,o=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,l=Number.NEGATIVE_INFINITY;for(let s=0,i=e.length;s<i;s++){const h=e[s];if(!h.bone.active)continue;let c=0,m=null;const u=h.getAttachment();if(u instanceof P)c=8,m=B.setArraySize(n,c,0),u.computeWorldVertices(h.bone,m,0,2);else if(u instanceof Yt){const f=u;c=f.worldVerticesLength,m=B.setArraySize(n,c,0),f.computeWorldVertices(h,0,c,m,0,2)}if(m)for(let f=0,p=m.length;f<p;f+=2){const w=m[f],b=m[f+1];r=Math.min(r,w),o=Math.min(o,b),d=Math.max(d,w),l=Math.max(l,b)}}a.set(r,o),t.set(d-r,l-o)}update(a){this.time+=a}get flipX(){return this.scaleX==-1}set flipX(a){Bt.deprecatedWarning1||(Bt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=a?1:-1}get flipY(){return this.scaleY==-1}set flipY(a){Bt.deprecatedWarning1||(Bt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=a?1:-1}};let Xe=Bt;Xe.deprecatedWarning1=!1;class Ie{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const o=n[e];if(o.name==t)return o}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}}class Fe{constructor(t,n,e){if(this.color=new $(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}}class Ce extends $t{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class Me{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}}class Nt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(!e)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let o=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){o=!0;break}o||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let o=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){o=!0;break}o||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let o=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){o=!0;break}o||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let o=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){o=!0;break}o||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];r.attachment&&(r.attachment instanceof Yt?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&(e[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const r in e){const o=e[r];o&&t.push(new Me(n,r,o))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const r in e){const o=e[r];o&&n.push(new Me(t,r,o))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const o=t.slots[r],d=o.getAttachment();if(d&&e<n.attachments.length){const l=n.attachments[e];for(const s in l){const i=l[s];if(d==i){const h=this.getAttachment(e,s);h&&o.setAttachment(h);break}}}e++}}}const ts=class{constructor(a){this.scale=1,this.attachmentLoader=null,this.linkedMeshes=new Array,this.attachmentLoader=a}readSkeletonData(a){const t=this.scale,n=new Ie;n.name="";const e=new ns(a),r=e.readInt32(),o=e.readInt32();if(n.hash=o==0&&r==0?null:o.toString(16)+r.toString(16),n.version=e.readString(),n.version.substr(0,3)!=="4.0"){const i=`Spine 4.0 loader cant load version ${n.version}. Please configure your pixi-spine bundle`;console.error(i)}n.x=e.readFloat(),n.y=e.readFloat(),n.width=e.readFloat(),n.height=e.readFloat();const d=e.readBoolean();d&&(n.fps=e.readFloat(),n.imagesPath=e.readString(),n.audioPath=e.readString());let l=0;l=e.readInt(!0);for(let i=0;i<l;i++)e.strings.push(e.readString());l=e.readInt(!0);for(let i=0;i<l;i++){const h=e.readString(),c=i==0?null:n.bones[e.readInt(!0)],m=new ye(i,h,c);m.rotation=e.readFloat(),m.x=e.readFloat()*t,m.y=e.readFloat()*t,m.scaleX=e.readFloat(),m.scaleY=e.readFloat(),m.shearX=e.readFloat(),m.shearY=e.readFloat(),m.length=e.readFloat()*t,m.transformMode=e.readInt(!0),m.skinRequired=e.readBoolean(),d&&$.rgba8888ToColor(m.color,e.readInt32()),n.bones.push(m)}l=e.readInt(!0);for(let i=0;i<l;i++){const h=e.readString(),c=n.bones[e.readInt(!0)],m=new Fe(i,h,c);$.rgba8888ToColor(m.color,e.readInt32());const u=e.readInt32();u!=-1&&$.rgb888ToColor(m.darkColor=new $,u),m.attachmentName=e.readStringRef(),m.blendMode=ts.BlendModeValues[e.readInt(!0)],n.slots.push(m)}l=e.readInt(!0);for(let i=0,h;i<l;i++){const c=new Ye(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),h=e.readInt(!0);for(let m=0;m<h;m++)c.bones.push(n.bones[e.readInt(!0)]);c.target=n.bones[e.readInt(!0)],c.mix=e.readFloat(),c.softness=e.readFloat()*t,c.bendDirection=e.readByte(),c.compress=e.readBoolean(),c.stretch=e.readBoolean(),c.uniform=e.readBoolean(),n.ikConstraints.push(c)}l=e.readInt(!0);for(let i=0,h;i<l;i++){const c=new Ce(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),h=e.readInt(!0);for(let m=0;m<h;m++)c.bones.push(n.bones[e.readInt(!0)]);c.target=n.bones[e.readInt(!0)],c.local=e.readBoolean(),c.relative=e.readBoolean(),c.offsetRotation=e.readFloat(),c.offsetX=e.readFloat()*t,c.offsetY=e.readFloat()*t,c.offsetScaleX=e.readFloat(),c.offsetScaleY=e.readFloat(),c.offsetShearY=e.readFloat(),c.mixRotate=e.readFloat(),c.mixX=e.readFloat(),c.mixY=e.readFloat(),c.mixScaleX=e.readFloat(),c.mixScaleY=e.readFloat(),c.mixShearY=e.readFloat(),n.transformConstraints.push(c)}l=e.readInt(!0);for(let i=0,h;i<l;i++){const c=new Ae(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),h=e.readInt(!0);for(let m=0;m<h;m++)c.bones.push(n.bones[e.readInt(!0)]);c.target=n.slots[e.readInt(!0)],c.positionMode=e.readInt(!0),c.spacingMode=e.readInt(!0),c.rotateMode=e.readInt(!0),c.offsetRotation=e.readFloat(),c.position=e.readFloat(),c.positionMode==wt.Fixed&&(c.position*=t),c.spacing=e.readFloat(),(c.spacingMode==K.Length||c.spacingMode==K.Fixed)&&(c.spacing*=t),c.mixRotate=e.readFloat(),c.mixX=e.readFloat(),c.mixY=e.readFloat(),n.pathConstraints.push(c)}const s=this.readSkin(e,n,!0,d);s&&(n.defaultSkin=s,n.skins.push(s));{let i=n.skins.length;for(B.setArraySize(n.skins,l=i+e.readInt(!0));i<l;i++)n.skins[i]=this.readSkin(e,n,!1,d)}l=this.linkedMeshes.length;for(let i=0;i<l;i++){const h=this.linkedMeshes[i],c=(h.skin?n.findSkin(h.skin):n.defaultSkin).getAttachment(h.slotIndex,h.parent);h.mesh.deformAttachment=h.inheritDeform?c:h.mesh,h.mesh.setParentMesh(c)}this.linkedMeshes.length=0,l=e.readInt(!0);for(let i=0;i<l;i++){const h=new Se(e.readStringRef());h.intValue=e.readInt(!1),h.floatValue=e.readFloat(),h.stringValue=e.readString(),h.audioPath=e.readString(),h.audioPath&&(h.volume=e.readFloat(),h.balance=e.readFloat()),n.events.push(h)}l=e.readInt(!0);for(let i=0;i<l;i++)n.animations.push(this.readAnimation(e,e.readString(),n));return n}readSkin(a,t,n,e){let r=null,o=0;if(n){if(o=a.readInt(!0),o==0)return null;r=new Nt("default")}else{r=new Nt(a.readStringRef()),r.bones.length=a.readInt(!0);for(let d=0,l=r.bones.length;d<l;d++)r.bones[d]=t.bones[a.readInt(!0)];for(let d=0,l=a.readInt(!0);d<l;d++)r.constraints.push(t.ikConstraints[a.readInt(!0)]);for(let d=0,l=a.readInt(!0);d<l;d++)r.constraints.push(t.transformConstraints[a.readInt(!0)]);for(let d=0,l=a.readInt(!0);d<l;d++)r.constraints.push(t.pathConstraints[a.readInt(!0)]);o=a.readInt(!0)}for(let d=0;d<o;d++){const l=a.readInt(!0);for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readStringRef(),c=this.readAttachment(a,t,r,l,h,e);c&&r.setAttachment(l,h,c)}}return r}readAttachment(a,t,n,e,r,o){const d=this.scale;let l=a.readStringRef();switch(l||(l=r),a.readByte()){case st.Region:{let s=a.readStringRef();const i=a.readFloat(),h=a.readFloat(),c=a.readFloat(),m=a.readFloat(),u=a.readFloat(),f=a.readFloat(),p=a.readFloat(),w=a.readInt32();s||(s=l);const b=this.attachmentLoader.newRegionAttachment(n,l,s);return b?(b.path=s,b.x=h*d,b.y=c*d,b.scaleX=m,b.scaleY=u,b.rotation=i,b.width=f*d,b.height=p*d,$.rgba8888ToColor(b.color,w),b):null}case st.BoundingBox:{const s=a.readInt(!0),i=this.readVertices(a,s),h=o?a.readInt32():0,c=this.attachmentLoader.newBoundingBoxAttachment(n,l);return c?(c.worldVerticesLength=s<<1,c.vertices=i.vertices,c.bones=i.bones,o&&$.rgba8888ToColor(c.color,h),c):null}case st.Mesh:{let s=a.readStringRef();const i=a.readInt32(),h=a.readInt(!0),c=this.readFloatArray(a,h<<1,1),m=this.readShortArray(a),u=this.readVertices(a,h),f=a.readInt(!0);let p=null,w=0,b=0;o&&(p=this.readShortArray(a),w=a.readFloat(),b=a.readFloat()),s||(s=l);const g=this.attachmentLoader.newMeshAttachment(n,l,s);return g?(g.path=s,$.rgba8888ToColor(g.color,i),g.bones=u.bones,g.vertices=u.vertices,g.worldVerticesLength=h<<1,g.triangles=m,g.regionUVs=new Float32Array(c),g.hullLength=f<<1,o&&(g.edges=p,g.width=w*d,g.height=b*d),g):null}case st.LinkedMesh:{let s=a.readStringRef();const i=a.readInt32(),h=a.readStringRef(),c=a.readStringRef(),m=a.readBoolean();let u=0,f=0;o&&(u=a.readFloat(),f=a.readFloat()),s||(s=l);const p=this.attachmentLoader.newMeshAttachment(n,l,s);return p?(p.path=s,$.rgba8888ToColor(p.color,i),o&&(p.width=u*d,p.height=f*d),this.linkedMeshes.push(new us(p,h,e,c,m)),p):null}case st.Path:{const s=a.readBoolean(),i=a.readBoolean(),h=a.readInt(!0),c=this.readVertices(a,h),m=B.newArray(h/3,0);for(let p=0,w=m.length;p<w;p++)m[p]=a.readFloat()*d;const u=o?a.readInt32():0,f=this.attachmentLoader.newPathAttachment(n,l);return f?(f.closed=s,f.constantSpeed=i,f.worldVerticesLength=h<<1,f.vertices=c.vertices,f.bones=c.bones,f.lengths=m,o&&$.rgba8888ToColor(f.color,u),f):null}case st.Point:{const s=a.readFloat(),i=a.readFloat(),h=a.readFloat(),c=o?a.readInt32():0,m=this.attachmentLoader.newPointAttachment(n,l);return m?(m.x=i*d,m.y=h*d,m.rotation=s,o&&$.rgba8888ToColor(m.color,c),m):null}case st.Clipping:{const s=a.readInt(!0),i=a.readInt(!0),h=this.readVertices(a,i),c=o?a.readInt32():0,m=this.attachmentLoader.newClippingAttachment(n,l);return m?(m.endSlot=t.slots[s],m.worldVerticesLength=i<<1,m.vertices=h.vertices,m.bones=h.bones,o&&$.rgba8888ToColor(m.color,c),m):null}}return null}readVertices(a,t){const n=this.scale,e=t<<1,r=new fs;if(!a.readBoolean())return r.vertices=this.readFloatArray(a,e,n),r;const o=new Array,d=new Array;for(let l=0;l<t;l++){const s=a.readInt(!0);d.push(s);for(let i=0;i<s;i++)d.push(a.readInt(!0)),o.push(a.readFloat()*n),o.push(a.readFloat()*n),o.push(a.readFloat())}return r.vertices=B.toFloatArray(o),r.bones=d,r}readFloatArray(a,t,n){const e=new Array(t);if(n==1)for(let r=0;r<t;r++)e[r]=a.readFloat();else for(let r=0;r<t;r++)e[r]=a.readFloat()*n;return e}readShortArray(a){const t=a.readInt(!0),n=new Array(t);for(let e=0;e<t;e++)n[e]=a.readShort();return n}readAnimation(a,t,n){a.readInt(!0);const e=new Array,r=this.scale;for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readInt(!0);for(let c=0,m=a.readInt(!0);c<m;c++){const u=a.readByte(),f=a.readInt(!0),p=f-1;switch(u){case Xs:{const w=new yt(f,h);for(let b=0;b<f;b++)w.setFrame(b,a.readFloat(),a.readStringRef());e.push(w);break}case Is:{const w=a.readInt(!0),b=new ie(f,w,h);let g=a.readFloat(),k=a.readUnsignedByte()/255,y=a.readUnsignedByte()/255,x=a.readUnsignedByte()/255,S=a.readUnsignedByte()/255;for(let X=0,F=0;b.setFrame(X,g,k,y,x,S),X!=p;X++){const I=a.readFloat(),C=a.readUnsignedByte()/255,v=a.readUnsignedByte()/255,T=a.readUnsignedByte()/255,R=a.readUnsignedByte()/255;switch(a.readByte()){case ht:b.setStepped(X);break;case lt:N(a,b,F++,X,0,g,I,k,C,1),N(a,b,F++,X,1,g,I,y,v,1),N(a,b,F++,X,2,g,I,x,T,1),N(a,b,F++,X,3,g,I,S,R,1)}g=I,k=C,y=v,x=T,S=R}e.push(b);break}case Fs:{const w=a.readInt(!0),b=new re(f,w,h);let g=a.readFloat(),k=a.readUnsignedByte()/255,y=a.readUnsignedByte()/255,x=a.readUnsignedByte()/255;for(let S=0,X=0;b.setFrame(S,g,k,y,x),S!=p;S++){const F=a.readFloat(),I=a.readUnsignedByte()/255,C=a.readUnsignedByte()/255,v=a.readUnsignedByte()/255;switch(a.readByte()){case ht:b.setStepped(S);break;case lt:N(a,b,X++,S,0,g,F,k,I,1),N(a,b,X++,S,1,g,F,y,C,1),N(a,b,X++,S,2,g,F,x,v,1)}g=F,k=I,y=C,x=v}e.push(b);break}case Cs:{const w=a.readInt(!0),b=new he(f,w,h);let g=a.readFloat(),k=a.readUnsignedByte()/255,y=a.readUnsignedByte()/255,x=a.readUnsignedByte()/255,S=a.readUnsignedByte()/255,X=a.readUnsignedByte()/255,F=a.readUnsignedByte()/255,I=a.readUnsignedByte()/255;for(let C=0,v=0;b.setFrame(C,g,k,y,x,S,X,F,I),C!=p;C++){const T=a.readFloat(),R=a.readUnsignedByte()/255,E=a.readUnsignedByte()/255,q=a.readUnsignedByte()/255,D=a.readUnsignedByte()/255,W=a.readUnsignedByte()/255,_=a.readUnsignedByte()/255,H=a.readUnsignedByte()/255;switch(a.readByte()){case ht:b.setStepped(C);break;case lt:N(a,b,v++,C,0,g,T,k,R,1),N(a,b,v++,C,1,g,T,y,E,1),N(a,b,v++,C,2,g,T,x,q,1),N(a,b,v++,C,3,g,T,S,D,1),N(a,b,v++,C,4,g,T,X,W,1),N(a,b,v++,C,5,g,T,F,_,1),N(a,b,v++,C,6,g,T,I,H,1)}g=T,k=R,y=E,x=q,S=D,X=W,F=_,I=H}e.push(b);break}case Ms:{const w=a.readInt(!0),b=new le(f,w,h);let g=a.readFloat(),k=a.readUnsignedByte()/255,y=a.readUnsignedByte()/255,x=a.readUnsignedByte()/255,S=a.readUnsignedByte()/255,X=a.readUnsignedByte()/255,F=a.readUnsignedByte()/255;for(let I=0,C=0;b.setFrame(I,g,k,y,x,S,X,F),I!=p;I++){const v=a.readFloat(),T=a.readUnsignedByte()/255,R=a.readUnsignedByte()/255,E=a.readUnsignedByte()/255,q=a.readUnsignedByte()/255,D=a.readUnsignedByte()/255,W=a.readUnsignedByte()/255;switch(a.readByte()){case ht:b.setStepped(I);break;case lt:N(a,b,C++,I,0,g,v,k,T,1),N(a,b,C++,I,1,g,v,y,R,1),N(a,b,C++,I,2,g,v,x,E,1),N(a,b,C++,I,3,g,v,S,q,1),N(a,b,C++,I,4,g,v,X,D,1),N(a,b,C++,I,5,g,v,F,W,1)}g=v,k=T,y=R,x=E,S=q,X=D,F=W}e.push(b);break}case vs:{const w=new oe(f,a.readInt(!0),h);let b=a.readFloat(),g=a.readUnsignedByte()/255;for(let k=0,y=0;w.setFrame(k,b,g),k!=p;k++){const x=a.readFloat(),S=a.readUnsignedByte()/255;switch(a.readByte()){case ht:w.setStepped(k);break;case lt:N(a,w,y++,k,0,b,x,g,S,1)}b=x,g=S}e.push(w);break}}}}for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readInt(!0);for(let c=0,m=a.readInt(!0);c<m;c++){const u=a.readByte(),f=a.readInt(!0),p=a.readInt(!0);switch(u){case gs:e.push(pt(a,new Mt(f,p,h),1));break;case ps:e.push(ve(a,new Jt(f,p,h),r));break;case xs:e.push(pt(a,new Zt(f,p,h),r));break;case bs:e.push(pt(a,new Kt(f,p,h),r));break;case ws:e.push(ve(a,new Qt(f,p,h),1));break;case ys:e.push(pt(a,new te(f,p,h),1));break;case ks:e.push(pt(a,new ee(f,p,h),1));break;case Ss:e.push(ve(a,new se(f,p,h),1));break;case Ys:e.push(pt(a,new ae(f,p,h),1));break;case As:e.push(pt(a,new ne(f,p,h),1))}}}for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readInt(!0),c=a.readInt(!0),m=c-1,u=new de(c,a.readInt(!0),h);let f=a.readFloat(),p=a.readFloat(),w=a.readFloat()*r;for(let b=0,g=0;u.setFrame(b,f,p,w,a.readByte(),a.readBoolean(),a.readBoolean()),b!=m;b++){const k=a.readFloat(),y=a.readFloat(),x=a.readFloat()*r;switch(a.readByte()){case ht:u.setStepped(b);break;case lt:N(a,u,g++,b,0,f,k,p,y,1),N(a,u,g++,b,1,f,k,w,x,r)}f=k,p=y,w=x}e.push(u)}for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readInt(!0),c=a.readInt(!0),m=c-1,u=new me(c,a.readInt(!0),h);let f=a.readFloat(),p=a.readFloat(),w=a.readFloat(),b=a.readFloat(),g=a.readFloat(),k=a.readFloat(),y=a.readFloat();for(let x=0,S=0;u.setFrame(x,f,p,w,b,g,k,y),x!=m;x++){const X=a.readFloat(),F=a.readFloat(),I=a.readFloat(),C=a.readFloat(),v=a.readFloat(),T=a.readFloat(),R=a.readFloat();switch(a.readByte()){case ht:u.setStepped(x);break;case lt:N(a,u,S++,x,0,f,X,p,F,1),N(a,u,S++,x,1,f,X,w,I,1),N(a,u,S++,x,2,f,X,b,C,1),N(a,u,S++,x,3,f,X,g,v,1),N(a,u,S++,x,4,f,X,k,T,1),N(a,u,S++,x,5,f,X,y,R,1)}f=X,p=F,w=I,b=C,g=v,k=T,y=R}e.push(u)}for(let s=0,i=a.readInt(!0);s<i;s++){const h=a.readInt(!0),c=n.pathConstraints[h];for(let m=0,u=a.readInt(!0);m<u;m++)switch(a.readByte()){case Ts:e.push(pt(a,new ue(a.readInt(!0),a.readInt(!0),h),c.positionMode==wt.Fixed?r:1));break;case Bs:e.push(pt(a,new fe(a.readInt(!0),a.readInt(!0),h),c.spacingMode==K.Length||c.spacingMode==K.Fixed?r:1));break;case Es:const f=new ge(a.readInt(!0),a.readInt(!0),h);let p=a.readFloat(),w=a.readFloat(),b=a.readFloat(),g=a.readFloat();for(let k=0,y=0,x=f.getFrameCount()-1;f.setFrame(k,p,w,b,g),k!=x;k++){const S=a.readFloat(),X=a.readFloat(),F=a.readFloat(),I=a.readFloat();switch(a.readByte()){case ht:f.setStepped(k);break;case lt:N(a,f,y++,k,0,p,S,w,X,1),N(a,f,y++,k,1,p,S,b,F,1),N(a,f,y++,k,2,p,S,g,I,1)}p=S,w=X,b=F,g=I}e.push(f)}}for(let s=0,i=a.readInt(!0);s<i;s++){const h=n.skins[a.readInt(!0)];for(let c=0,m=a.readInt(!0);c<m;c++){const u=a.readInt(!0);for(let f=0,p=a.readInt(!0);f<p;f++){const w=a.readStringRef(),b=h.getAttachment(u,w),g=b.bones,k=b.vertices,y=g?k.length/3*2:k.length,x=a.readInt(!0),S=x-1,X=a.readInt(!0),F=new ce(x,X,u,b);let I=a.readFloat();for(let C=0,v=0;;C++){let T,R=a.readInt(!0);if(R==0)T=g?B.newFloatArray(y):k;else{T=B.newFloatArray(y);const q=a.readInt(!0);if(R+=q,r==1)for(let D=q;D<R;D++)T[D]=a.readFloat();else for(let D=q;D<R;D++)T[D]=a.readFloat()*r;if(!g)for(let D=0,W=T.length;D<W;D++)T[D]+=k[D]}if(F.setFrame(C,I,T),C==S)break;const E=a.readFloat();switch(a.readByte()){case ht:F.setStepped(C);break;case lt:N(a,F,v++,C,0,I,E,0,1,1)}I=E}e.push(F)}}}const o=a.readInt(!0);if(o>0){const s=new kt(o),i=n.slots.length;for(let h=0;h<o;h++){const c=a.readFloat(),m=a.readInt(!0),u=B.newArray(i,0);for(let b=i-1;b>=0;b--)u[b]=-1;const f=B.newArray(i-m,0);let p=0,w=0;for(let b=0;b<m;b++){const g=a.readInt(!0);for(;p!=g;)f[w++]=p++;u[p+a.readInt(!0)]=p++}for(;p<i;)f[w++]=p++;for(let b=i-1;b>=0;b--)u[b]==-1&&(u[b]=f[--w]);s.setFrame(h,c,u)}e.push(s)}const d=a.readInt(!0);if(d>0){const s=new vt(d);for(let i=0;i<d;i++){const h=a.readFloat(),c=n.events[a.readInt(!0)],m=new ke(h,c);m.intValue=a.readInt(!1),m.floatValue=a.readFloat(),m.stringValue=a.readBoolean()?a.readString():c.stringValue,m.data.audioPath&&(m.volume=a.readFloat(),m.balance=a.readFloat()),s.setFrame(i,m)}e.push(s)}let l=0;for(let s=0,i=e.length;s<i;s++)l=Math.max(l,e[s].getDuration());return new Vt(t,e,l)}};let es=ts;es.BlendModeValues=[xt.NORMAL,xt.ADD,xt.MULTIPLY,xt.SCREEN];class us{constructor(t,n,e,r,o){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=o}}class fs{constructor(t=null,n=null){this.bones=t,this.vertices=n}}function pt(a,t,n){let e=a.readFloat(),r=a.readFloat()*n;for(let o=0,d=0,l=t.getFrameCount()-1;t.setFrame(o,e,r),o!=l;o++){const s=a.readFloat(),i=a.readFloat()*n;switch(a.readByte()){case ht:t.setStepped(o);break;case lt:N(a,t,d++,o,0,e,s,r,i,n)}e=s,r=i}return t}function ve(a,t,n){let e=a.readFloat(),r=a.readFloat()*n,o=a.readFloat()*n;for(let d=0,l=0,s=t.getFrameCount()-1;t.setFrame(d,e,r,o),d!=s;d++){const i=a.readFloat(),h=a.readFloat()*n,c=a.readFloat()*n;switch(a.readByte()){case ht:t.setStepped(d);break;case lt:N(a,t,l++,d,0,e,i,r,h,n),N(a,t,l++,d,1,e,i,o,c,n)}e=i,r=h,o=c}return t}function N(a,t,n,e,r,o,d,l,s,i){t.setBezier(n,e,r,o,l,a.readFloat(),a.readFloat()*i,a.readFloat(),a.readFloat()*i,d,s)}const gs=0,ps=1,xs=2,bs=3,ws=4,ys=5,ks=6,Ss=7,Ys=8,As=9,Xs=0,Is=1,Fs=2,Cs=3,Ms=4,vs=5,Ts=0,Bs=1,Es=2,Ns=0,ht=1,lt=2;class Rs extends is{}class Be{constructor(t){this.attachmentLoader=null,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Ie,r=typeof t=="string"?JSON.parse(t):t,o=r.skeleton;if(o){if(e.hash=o.hash,e.version=o.spine,e.version.substr(0,3)!=="4.0"){const d=`Spine 4.0 loader cant load version ${o.spine}. Please configure your pixi-spine bundle`;console.error(d)}e.x=o.x,e.y=o.y,e.width=o.width,e.height=o.height,e.fps=o.fps,e.imagesPath=o.images}if(r.bones)for(let d=0;d<r.bones.length;d++){const l=r.bones[d];let s=null;const i=Y(l,"parent",null);if(i!=null&&(s=e.findBone(i),s==null))throw new Error(`Parent bone not found: ${i}`);const h=new ye(e.bones.length,l.name,s);h.length=Y(l,"length",0)*n,h.x=Y(l,"x",0)*n,h.y=Y(l,"y",0)*n,h.rotation=Y(l,"rotation",0),h.scaleX=Y(l,"scaleX",1),h.scaleY=Y(l,"scaleY",1),h.shearX=Y(l,"shearX",0),h.shearY=Y(l,"shearY",0),h.transformMode=B.enumValue(nt,Y(l,"transform","Normal")),h.skinRequired=Y(l,"skin",!1);const c=Y(l,"color",null);c&&h.color.setFromString(c),e.bones.push(h)}if(r.slots)for(let d=0;d<r.slots.length;d++){const l=r.slots[d],s=e.findBone(l.bone),i=new Fe(e.slots.length,l.name,s),h=Y(l,"color",null);h&&i.color.setFromString(h);const c=Y(l,"dark",null);c&&(i.darkColor=$.fromString(c)),i.attachmentName=Y(l,"attachment",null),i.blendMode=Be.blendModeFromString(Y(l,"blend","normal")),e.slots.push(i)}if(r.ik)for(let d=0;d<r.ik.length;d++){const l=r.ik[d],s=new Ye(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let i=0;i<l.bones.length;i++){const h=l.bones[i],c=e.findBone(h);if(c==null)throw new Error(`IK bone not found: ${h}`);s.bones.push(c)}s.target=e.findBone(l.target),s.mix=Y(l,"mix",1),s.softness=Y(l,"softness",0)*n,s.bendDirection=Y(l,"bendPositive",!0)?1:-1,s.compress=Y(l,"compress",!1),s.stretch=Y(l,"stretch",!1),s.uniform=Y(l,"uniform",!1),e.ikConstraints.push(s)}if(r.transform)for(let d=0;d<r.transform.length;d++){const l=r.transform[d],s=new Ce(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let h=0;h<l.bones.length;h++){const c=l.bones[h],m=e.findBone(c);if(m==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(m)}const i=l.target;if(s.target=e.findBone(i),s.target==null)throw new Error(`Transform constraint target bone not found: ${i}`);s.local=Y(l,"local",!1),s.relative=Y(l,"relative",!1),s.offsetRotation=Y(l,"rotation",0),s.offsetX=Y(l,"x",0)*n,s.offsetY=Y(l,"y",0)*n,s.offsetScaleX=Y(l,"scaleX",0),s.offsetScaleY=Y(l,"scaleY",0),s.offsetShearY=Y(l,"shearY",0),s.mixRotate=Y(l,"mixRotate",1),s.mixX=Y(l,"mixX",1),s.mixY=Y(l,"mixY",s.mixX),s.mixScaleX=Y(l,"mixScaleX",1),s.mixScaleY=Y(l,"mixScaleY",s.mixScaleX),s.mixShearY=Y(l,"mixShearY",1),e.transformConstraints.push(s)}if(r.path)for(let d=0;d<r.path.length;d++){const l=r.path[d],s=new Ae(l.name);s.order=Y(l,"order",0),s.skinRequired=Y(l,"skin",!1);for(let h=0;h<l.bones.length;h++){const c=l.bones[h],m=e.findBone(c);if(m==null)throw new Error(`Transform constraint bone not found: ${c}`);s.bones.push(m)}const i=l.target;if(s.target=e.findSlot(i),s.target==null)throw new Error(`Path target slot not found: ${i}`);s.positionMode=B.enumValue(wt,Y(l,"positionMode","Percent")),s.spacingMode=B.enumValue(K,Y(l,"spacingMode","Length")),s.rotateMode=B.enumValue(Pt,Y(l,"rotateMode","Tangent")),s.offsetRotation=Y(l,"rotation",0),s.position=Y(l,"position",0),s.positionMode==wt.Fixed&&(s.position*=n),s.spacing=Y(l,"spacing",0),(s.spacingMode==K.Length||s.spacingMode==K.Fixed)&&(s.spacing*=n),s.mixRotate=Y(l,"mixRotate",1),s.mixX=Y(l,"mixX",1),s.mixY=Y(l,"mixY",s.mixX),e.pathConstraints.push(s)}if(r.skins)for(let d=0;d<r.skins.length;d++){const l=r.skins[d],s=new Nt(l.name);if(l.bones)for(let i=0;i<l.bones.length;i++){const h=e.findBone(l.bones[i]);if(h==null)throw new Error(`Skin bone not found: ${l.bones[d]}`);s.bones.push(h)}if(l.ik)for(let i=0;i<l.ik.length;i++){const h=e.findIkConstraint(l.ik[i]);if(h==null)throw new Error(`Skin IK constraint not found: ${l.ik[d]}`);s.constraints.push(h)}if(l.transform)for(let i=0;i<l.transform.length;i++){const h=e.findTransformConstraint(l.transform[i]);if(h==null)throw new Error(`Skin transform constraint not found: ${l.transform[d]}`);s.constraints.push(h)}if(l.path)for(let i=0;i<l.path.length;i++){const h=e.findPathConstraint(l.path[i]);if(h==null)throw new Error(`Skin path constraint not found: ${l.path[d]}`);s.constraints.push(h)}for(const i in l.attachments){const h=e.findSlot(i);if(h==null)throw new Error(`Slot not found: ${i}`);const c=l.attachments[i];for(const m in c){const u=this.readAttachment(c[m],s,h.index,m,e);u&&s.setAttachment(h.index,m,u)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let d=0,l=this.linkedMeshes.length;d<l;d++){const s=this.linkedMeshes[d],i=(s.skin?e.findSkin(s.skin):e.defaultSkin).getAttachment(s.slotIndex,s.parent);s.mesh.deformAttachment=s.inheritDeform?i:s.mesh,s.mesh.setParentMesh(i)}if(this.linkedMeshes.length=0,r.events)for(const d in r.events){const l=r.events[d],s=new Se(d);s.intValue=Y(l,"int",0),s.floatValue=Y(l,"float",0),s.stringValue=Y(l,"string",""),s.audioPath=Y(l,"audio",null),s.audioPath&&(s.volume=Y(l,"volume",1),s.balance=Y(l,"balance",0)),e.events.push(s)}if(r.animations)for(const d in r.animations){const l=r.animations[d];this.readAnimation(l,d,e)}return e}readAttachment(t,n,e,r,o){const d=this.scale;switch(r=Y(t,"name",r),Y(t,"type","region")){case"region":{const l=Y(t,"path",r),s=this.attachmentLoader.newRegionAttachment(n,r,l);if(!s)return null;s.path=l,s.x=Y(t,"x",0)*d,s.y=Y(t,"y",0)*d,s.scaleX=Y(t,"scaleX",1),s.scaleY=Y(t,"scaleY",1),s.rotation=Y(t,"rotation",0),s.width=t.width*d,s.height=t.height*d;const i=Y(t,"color",null);return i&&s.color.setFromString(i),s}case"boundingbox":{const l=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(!l)return null;this.readVertices(t,l,t.vertexCount<<1);const s=Y(t,"color",null);return s&&l.color.setFromString(s),l}case"mesh":case"linkedmesh":{const l=Y(t,"path",r),s=this.attachmentLoader.newMeshAttachment(n,r,l);if(!s)return null;s.path=l;const i=Y(t,"color",null);i&&s.color.setFromString(i),s.width=Y(t,"width",0)*d,s.height=Y(t,"height",0)*d;const h=Y(t,"parent",null);if(h)return this.linkedMeshes.push(new Ds(s,Y(t,"skin",null),e,h,Y(t,"deform",!0))),s;const c=t.uvs;return this.readVertices(t,s,c.length),s.triangles=t.triangles,s.regionUVs=new Float32Array(c),s.edges=Y(t,"edges",null),s.hullLength=Y(t,"hull",0)*2,s}case"path":{const l=this.attachmentLoader.newPathAttachment(n,r);if(!l)return null;l.closed=Y(t,"closed",!1),l.constantSpeed=Y(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,l,s<<1);const i=B.newArray(s/3,0);for(let c=0;c<t.lengths.length;c++)i[c]=t.lengths[c]*d;l.lengths=i;const h=Y(t,"color",null);return h&&l.color.setFromString(h),l}case"point":{const l=this.attachmentLoader.newPointAttachment(n,r);if(!l)return null;l.x=Y(t,"x",0)*d,l.y=Y(t,"y",0)*d,l.rotation=Y(t,"rotation",0);const s=Y(t,"color",null);return s&&l.color.setFromString(s),l}case"clipping":{const l=this.attachmentLoader.newClippingAttachment(n,r);if(!l)return null;const s=Y(t,"end",null);if(s!=null){const c=o.findSlot(s);if(c==null)throw new Error(`Clipping end slot not found: ${s}`);l.endSlot=c}const i=t.vertexCount;this.readVertices(t,l,i<<1);const h=Y(t,"color",null);return h&&l.color.setFromString(h),l}}return null}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const o=t.vertices;if(e==o.length){const s=B.toFloatArray(o);if(r!=1)for(let i=0,h=o.length;i<h;i++)s[i]*=r;n.vertices=s;return}const d=new Array,l=new Array;for(let s=0,i=o.length;s<i;){const h=o[s++];l.push(h);for(let c=s+h*4;s<c;s+=4)l.push(o[s]),d.push(o[s+1]*r),d.push(o[s+2]*r),d.push(o[s+3])}n.bones=l,n.vertices=B.toFloatArray(d)}readAnimation(t,n,e){const r=this.scale,o=new Array;if(t.slots)for(const l in t.slots){const s=t.slots[l],i=e.findSlot(l).index;if(i==-1)throw new Error(`Slot not found: ${l}`);for(const h in s){const c=s[h];if(!c)continue;const m=c.length;if(h=="attachment"){const u=new yt(m,i);for(let f=0;f<m;f++){const p=c[f];u.setFrame(f,Y(p,"time",0),p.name)}o.push(u)}else if(h=="rgba"){const u=new ie(m,m<<2,i);let f=c[0],p=Y(f,"time",0),w=$.fromString(f.color);for(let b=0,g=0;;b++){u.setFrame(b,p,w.r,w.g,w.b,w.a);const k=c[b+1];if(!k){u.shrink(g);break}const y=Y(k,"time",0),x=$.fromString(k.color),S=f.curve;S&&(g=O(S,u,g,b,0,p,y,w.r,x.r,1),g=O(S,u,g,b,1,p,y,w.g,x.g,1),g=O(S,u,g,b,2,p,y,w.b,x.b,1),g=O(S,u,g,b,3,p,y,w.a,x.a,1)),p=y,w=x,f=k}o.push(u)}else if(h=="rgb"){const u=new re(m,m*3,i);let f=c[0],p=Y(f,"time",0),w=$.fromString(f.color);for(let b=0,g=0;;b++){u.setFrame(b,p,w.r,w.g,w.b);const k=c[b+1];if(!k){u.shrink(g);break}const y=Y(k,"time",0),x=$.fromString(k.color),S=f.curve;S&&(g=O(S,u,g,b,0,p,y,w.r,x.r,1),g=O(S,u,g,b,1,p,y,w.g,x.g,1),g=O(S,u,g,b,2,p,y,w.b,x.b,1)),p=y,w=x,f=k}o.push(u)}else if(h=="alpha")o.push(ct(c,new oe(m,m,i),0,1));else if(h=="rgba2"){const u=new he(m,m*7,i);let f=c[0],p=Y(f,"time",0),w=$.fromString(f.light),b=$.fromString(f.dark);for(let g=0,k=0;;g++){u.setFrame(g,p,w.r,w.g,w.b,w.a,b.r,b.g,b.b);const y=c[g+1];if(!y){u.shrink(k);break}const x=Y(y,"time",0),S=$.fromString(y.light),X=$.fromString(y.dark),F=f.curve;F&&(k=O(F,u,k,g,0,p,x,w.r,S.r,1),k=O(F,u,k,g,1,p,x,w.g,S.g,1),k=O(F,u,k,g,2,p,x,w.b,S.b,1),k=O(F,u,k,g,3,p,x,w.a,S.a,1),k=O(F,u,k,g,4,p,x,b.r,X.r,1),k=O(F,u,k,g,5,p,x,b.g,X.g,1),k=O(F,u,k,g,6,p,x,b.b,X.b,1)),p=x,w=S,b=X,f=y}o.push(u)}else if(h=="rgb2"){const u=new le(m,m*6,i);let f=c[0],p=Y(f,"time",0),w=$.fromString(f.light),b=$.fromString(f.dark);for(let g=0,k=0;;g++){u.setFrame(g,p,w.r,w.g,w.b,b.r,b.g,b.b);const y=c[g+1];if(!y){u.shrink(k);break}const x=Y(y,"time",0),S=$.fromString(y.light),X=$.fromString(y.dark),F=f.curve;F&&(k=O(F,u,k,g,0,p,x,w.r,S.r,1),k=O(F,u,k,g,1,p,x,w.g,S.g,1),k=O(F,u,k,g,2,p,x,w.b,S.b,1),k=O(F,u,k,g,3,p,x,b.r,X.r,1),k=O(F,u,k,g,4,p,x,b.g,X.g,1),k=O(F,u,k,g,5,p,x,b.b,X.b,1)),p=x,w=S,b=X,f=y}o.push(u)}else throw new Error(`Invalid timeline type for a slot: ${h} (${l})`)}}if(t.bones)for(const l in t.bones){const s=t.bones[l],i=e.findBone(l).index;if(i==-1)throw new Error(`Bone not found: ${l}`);for(const h in s){const c=s[h],m=c.length;if(m!=0){if(h==="rotate")o.push(ct(c,new Mt(m,m,i),0,1));else if(h==="translate"){const u=new Jt(m,m<<1,i);o.push(Te(c,u,"x","y",0,r))}else if(h==="translatex"){const u=new Zt(m,m,i);o.push(ct(c,u,0,r))}else if(h==="translatey"){const u=new Kt(m,m,i);o.push(ct(c,u,0,r))}else if(h==="scale"){const u=new Qt(m,m<<1,i);o.push(Te(c,u,"x","y",1,1))}else if(h==="scalex"){const u=new te(m,m,i);o.push(ct(c,u,1,1))}else if(h==="scaley"){const u=new ee(m,m,i);o.push(ct(c,u,1,1))}else if(h==="shear"){const u=new se(m,m<<1,i);o.push(Te(c,u,"x","y",0,1))}else if(h==="shearx"){const u=new ae(m,m,i);o.push(ct(c,u,0,1))}else if(h==="sheary"){const u=new ne(m,m,i);o.push(ct(c,u,0,1))}}}}if(t.ik)for(const l in t.ik){const s=t.ik[l];let i=s[0];if(!i)continue;const h=e.findIkConstraint(l),c=e.ikConstraints.indexOf(h),m=new de(s.length,s.length<<1,c);let u=Y(i,"time",0),f=Y(i,"mix",1),p=Y(i,"softness",0)*r;for(let w=0,b=0;;w++){m.setFrame(w,u,f,p,Y(i,"bendPositive",!0)?1:-1,Y(i,"compress",!1),Y(i,"stretch",!1));const g=s[w+1];if(!g){m.shrink(b);break}const k=Y(g,"time",0),y=Y(g,"mix",1),x=Y(g,"softness",0)*r,S=i.curve;S&&(b=O(S,m,b,w,0,u,k,f,y,1),b=O(S,m,b,w,1,u,k,p,x,r)),u=k,f=y,p=x,i=g}o.push(m)}if(t.transform)for(const l in t.transform){const s=t.transform[l];let i=s[0];if(!i)continue;const h=e.findTransformConstraint(l),c=e.transformConstraints.indexOf(h),m=new me(s.length,s.length*6,c);let u=Y(i,"time",0),f=Y(i,"mixRotate",1),p=Y(i,"mixX",1),w=Y(i,"mixY",p),b=Y(i,"mixScaleX",1),g=Y(i,"mixScaleY",b);const k=Y(i,"mixShearY",1);for(let y=0,x=0;;y++){m.setFrame(y,u,f,p,w,b,g,k);const S=s[y+1];if(!S){m.shrink(x);break}const X=Y(S,"time",0),F=Y(S,"mixRotate",1),I=Y(S,"mixX",1),C=Y(S,"mixY",I),v=Y(S,"mixScaleX",1),T=Y(S,"mixScaleY",v),R=Y(S,"mixShearY",1),E=i.curve;E&&(x=O(E,m,x,y,0,u,X,f,F,1),x=O(E,m,x,y,1,u,X,p,I,1),x=O(E,m,x,y,2,u,X,w,C,1),x=O(E,m,x,y,3,u,X,b,v,1),x=O(E,m,x,y,4,u,X,g,T,1),x=O(E,m,x,y,5,u,X,k,R,1)),u=X,f=F,p=I,w=C,b=v,g=T,b=v,i=S}o.push(m)}if(t.path)for(const l in t.path){const s=t.path[l],i=e.findPathConstraintIndex(l);if(i==-1)throw new Error(`Path constraint not found: ${l}`);const h=e.pathConstraints[i];for(const c in s){const m=s[c];let u=m[0];if(!u)continue;const f=m.length;if(c==="position"){const p=new ue(f,f,i);o.push(ct(m,p,0,h.positionMode==wt.Fixed?r:1))}else if(c==="spacing"){const p=new fe(f,f,i);o.push(ct(m,p,0,h.spacingMode==K.Length||h.spacingMode==K.Fixed?r:1))}else if(c==="mix"){const p=new ge(f,f*3,i);let w=Y(u,"time",0),b=Y(u,"mixRotate",1),g=Y(u,"mixX",1),k=Y(u,"mixY",g);for(let y=0,x=0;;y++){p.setFrame(y,w,b,g,k);const S=m[y+1];if(!S){p.shrink(x);break}const X=Y(S,"time",0),F=Y(S,"mixRotate",1),I=Y(S,"mixX",1),C=Y(S,"mixY",I),v=u.curve;v&&(x=O(v,p,x,y,0,w,X,b,F,1),x=O(v,p,x,y,1,w,X,g,I,1),x=O(v,p,x,y,2,w,X,k,C,1)),w=X,b=F,g=I,k=C,u=S}o.push(p)}}}if(t.deform)for(const l in t.deform){const s=t.deform[l],i=e.findSkin(l);if(i==null){if(Ct.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${l}`);continue}for(const h in s){const c=s[h],m=e.findSlot(h).index;for(const u in c){const f=c[u];let p=f[0];if(!p)continue;const w=i.getAttachment(m,u),b=w.bones,g=w.vertices,k=b?g.length/3*2:g.length,y=new ce(f.length,f.length,m,w);let x=Y(p,"time",0);for(let S=0,X=0;;S++){let F;const I=Y(p,"vertices",null);if(!I)F=b?B.newFloatArray(k):g;else{F=B.newFloatArray(k);const R=Y(p,"offset",0);if(B.arrayCopy(I,0,F,R,I.length),r!=1)for(let E=R,q=E+I.length;E<q;E++)F[E]*=r;if(!b)for(let E=0;E<k;E++)F[E]+=g[E]}y.setFrame(S,x,F);const C=f[S+1];if(!C){y.shrink(X);break}const v=Y(C,"time",0),T=p.curve;T&&(X=O(T,y,X,S,0,x,v,0,1,1)),x=v,p=C}o.push(y)}}}if(t.drawOrder){const l=new kt(t.drawOrder.length),s=e.slots.length;let i=0;for(let h=0;h<t.drawOrder.length;h++,i++){const c=t.drawOrder[h];let m=null;const u=Y(c,"offsets",null);if(u){m=B.newArray(s,-1);const f=B.newArray(s-u.length,0);let p=0,w=0;for(let b=0;b<u.length;b++){const g=u[b],k=e.findSlot(g.slot).index;for(;p!=k;)f[w++]=p++;m[p+g.offset]=p++}for(;p<s;)f[w++]=p++;for(let b=s-1;b>=0;b--)m[b]==-1&&(m[b]=f[--w])}l.setFrame(i,Y(c,"time",0),m)}o.push(l)}if(t.events){const l=new vt(t.events.length);let s=0;for(let i=0;i<t.events.length;i++,s++){const h=t.events[i],c=e.findEvent(h.name),m=new ke(B.toSinglePrecision(Y(h,"time",0)),c);m.intValue=Y(h,"int",c.intValue),m.floatValue=Y(h,"float",c.floatValue),m.stringValue=Y(h,"string",c.stringValue),m.data.audioPath&&(m.volume=Y(h,"volume",1),m.balance=Y(h,"balance",0)),l.setFrame(s,m)}o.push(l)}let d=0;for(let l=0,s=o.length;l<s;l++)d=Math.max(d,o[l].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Vt(n,o,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return xt.NORMAL;if(t=="additive")return xt.ADD;if(t=="multiply")return xt.MULTIPLY;if(t=="screen")return xt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class Ds{constructor(t,n,e,r,o){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=o}}function ct(a,t,n,e){let r=a[0],o=Y(r,"time",0),d=Y(r,"value",n)*e,l=0;for(let s=0;;s++){t.setFrame(s,o,d);const i=a[s+1];if(!i)return t.shrink(l),t;const h=Y(i,"time",0),c=Y(i,"value",n)*e;r.curve&&(l=O(r.curve,t,l,s,0,o,h,d,c,e)),o=h,d=c,r=i}}function Te(a,t,n,e,r,o){let d=a[0],l=Y(d,"time",0),s=Y(d,n,r)*o,i=Y(d,e,r)*o,h=0;for(let c=0;;c++){t.setFrame(c,l,s,i);const m=a[c+1];if(!m)return t.shrink(h),t;const u=Y(m,"time",0),f=Y(m,n,r)*o,p=Y(m,e,r)*o,w=d.curve;w&&(h=O(w,t,h,c,0,l,u,s,f,o),h=O(w,t,h,c,1,l,u,i,p,o)),l=u,s=f,i=p,d=m}}function O(a,t,n,e,r,o,d,l,s,i){if(a=="stepped")return t.setStepped(e),n;const h=r<<2,c=a[h],m=a[h+1]*i,u=a[h+2],f=a[h+3]*i;return t.setBezier(n,e,r,o,l,c,m,u,f,d,s),n+1}function Y(a,t,n){return a[t]!==void 0?a[t]:n}class Ps extends rs{createSkeleton(t){this.skeleton=new Xe(t),this.skeleton.updateWorldTransform(),this.stateData=new Ze(t),this.state=new Tt(this.stateData)}}export{oe as AlphaTimeline,Vt as Animation,Tt as AnimationState,ls as AnimationStateAdapter,Ze as AnimationStateData,ms as AtlasAttachmentLoader,Gt as Attachment,yt as AttachmentTimeline,we as Bone,ye as BoneData,Ot as BoundingBoxAttachment,qt as ClippingAttachment,$t as ConstraintData,rt as CurveTimeline,ot as CurveTimeline1,Lt as CurveTimeline2,ce as DeformTimeline,kt as DrawOrderTimeline,ke as Event,Se as EventData,_e as EventQueue,vt as EventTimeline,tt as EventType,Ke as IkConstraint,Ye as IkConstraintData,de as IkConstraintTimeline,hs as JitterEffect,Yt as MeshAttachment,St as PathAttachment,It as PathConstraint,Ae as PathConstraintData,ge as PathConstraintMixTimeline,ue as PathConstraintPositionTimeline,fe as PathConstraintSpacingTimeline,zt as PointAttachment,le as RGB2Timeline,he as RGBA2Timeline,ie as RGBATimeline,re as RGBTimeline,P as RegionAttachment,Mt as RotateTimeline,Qt as ScaleTimeline,te as ScaleXTimeline,ee as ScaleYTimeline,se as ShearTimeline,ae as ShearXTimeline,ne as ShearYTimeline,Xe as Skeleton,es as SkeletonBinary,Rs as SkeletonBounds,Ie as SkeletonData,Be as SkeletonJson,Nt as Skin,Me as SkinEntry,Ht as Slot,Fe as SlotData,K as SpacingMode,Ps as Spine,ze as SwirlEffect,G as Timeline,Wt as TrackEntry,Qe as TransformConstraint,Ce as TransformConstraintData,me as TransformConstraintTimeline,Jt as TranslateTimeline,Zt as TranslateXTimeline,Kt as TranslateYTimeline,bt as VertexAttachment};
//# sourceMappingURL=runtime-4.0.mjs.map
