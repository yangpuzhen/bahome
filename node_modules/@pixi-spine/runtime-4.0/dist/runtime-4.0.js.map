{"version":3,"file":"runtime-4.0.js","sources":["../src/core/attachments/Attachment.ts","../src/core/attachments/BoundingBoxAttachment.ts","../src/core/attachments/ClippingAttachment.ts","../src/core/attachments/MeshAttachment.ts","../src/core/attachments/PathAttachment.ts","../src/core/attachments/PointAttachment.ts","../src/core/Slot.ts","../src/core/attachments/RegionAttachment.ts","../src/core/vertexeffects/JitterEffect.ts","../src/core/vertexeffects/SwirlEffect.ts","../src/core/Animation.ts","../src/core/AnimationState.ts","../src/core/AnimationStateData.ts","../src/core/AtlasAttachmentLoader.ts","../src/core/Bone.ts","../src/core/BoneData.ts","../src/core/ConstraintData.ts","../src/core/Event.ts","../src/core/EventData.ts","../src/core/IkConstraint.ts","../src/core/IkConstraintData.ts","../src/core/PathConstraintData.ts","../src/core/PathConstraint.ts","../src/core/TransformConstraint.ts","../src/core/Skeleton.ts","../src/core/SkeletonData.ts","../src/core/SlotData.ts","../src/core/TransformConstraintData.ts","../src/core/Skin.ts","../src/core/SkeletonBinary.ts","../src/core/SkeletonBounds.ts","../src/core/SkeletonJson.ts","../src/Spine.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\nimport type { IAttachment, ArrayLike } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * The base class for all attachments.\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    abstract copy(): Attachment;\n}\n\n/**\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}.\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    /** The unique ID for this attachment. */\n    id = VertexAttachment.nextID++;\n\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    bones: Array<number>;\n\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    vertices: ArrayLike<number>;\n\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    worldVerticesLength = 0;\n\n    /** Deform keys for the deform attachment are also applied to this attachment. May be null if no deform keys should be applied. */\n    deformAttachment: VertexAttachment = this;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n     * not empty, it is used to deform the vertices.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide.\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n     *           `stride` / 2.\n     * @param offset The `worldVertices` index to begin writing values.\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.deform;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (!bones) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Does not copy id (generated) or name (set on construction). **/\n    copyTo(attachment: VertexAttachment) {\n        if (this.bones) {\n            attachment.bones = new Array<number>(this.bones.length);\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n        } else attachment.bones = null;\n\n        if (this.vertices) {\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n        } else attachment.vertices = null;\n\n        attachment.worldVerticesLength = this.worldVerticesLength;\n        attachment.deformAttachment = this.deformAttachment;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new BoundingBoxAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    endSlot: SlotData;\n\n    // Nonessential.\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n     * are not usually rendered at runtime. */\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new ClippingAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.endSlot = this.endSlot;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion;\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    /** The UV pair for each vertex, normalized within the texture region. */\n    regionUVs: Float32Array;\n\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    triangles: Array<number>;\n\n    /** The color to tint the mesh. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    width: number;\n\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    height: number;\n\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    hullLength: number;\n\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    edges: Array<number>;\n\n    private parentMesh: MeshAttachment;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        // Nonessential.\n        if (this.edges) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n        copy.deformAttachment = this.deformAttachment;\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n        // copy.updateUVs();\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n    lengths: Array<number>;\n\n    /** If true, the start and end knots are connected. */\n    closed = false;\n\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\n     * calculations are performed but calculating positions along the path is less accurate. */\n    constantSpeed = false;\n\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\n     * rendered at runtime. */\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new PathAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.lengths = new Array<number>(this.lengths.length);\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n        copy.closed = closed;\n        copy.constantSpeed = this.constantSpeed;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n\n    x: number;\n    y: number;\n    rotation: number;\n\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n     * are not usually rendered at runtime. */\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n\n    copy(): Attachment {\n        const copy = new PointAttachment(this.name);\n\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.rotation = this.rotation;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import { Color, ISlot } from '@pixi-spine/base';\n\nimport type { Attachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\nimport type { Skeleton } from './Skeleton';\n\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\n * across multiple skeletons.\n * @public\n * */\nexport class Slot implements ISlot {\n    // this is canon\n    blendMode: number;\n    /** The slot's setup pose data. */\n    data: SlotData;\n\n    /** The bone this slot belongs to. */\n    bone: Bone;\n\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    color: Color;\n\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    darkColor: Color;\n\n    attachment: Attachment;\n\n    private attachmentTime: number;\n\n    attachmentState: number;\n\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n     *\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n    deform = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (bone == null) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = data.darkColor == null ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** The skeleton this slot belongs to. */\n    getSkeleton(): Skeleton {\n        return this.bone.skeleton;\n    }\n\n    /** The current attachment for the slot, or null if the slot has no attachment. */\n    getAttachment(): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #attachmentTime} and clears {@link #deform}.\n     * @param attachment May be null. */\n    setAttachment(attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.deform.length = 0;\n    }\n\n    setAttachmentTime(time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** The time that has elapsed since the last time the attachment was set or cleared. Relies on Skeleton\n     * {@link Skeleton#time}. */\n    getAttachmentTime(): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    /** Sets this slot to the setup pose. */\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n","import { Attachment } from './Attachment';\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\n\nimport type { Bone } from '../Bone';\nimport { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\n    type = AttachmentType.Region;\n\n    static OX1 = 0;\n    static OY1 = 1;\n    static OX2 = 2;\n    static OY2 = 3;\n    static OX3 = 4;\n    static OY3 = 5;\n    static OX4 = 6;\n    static OY4 = 7;\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local scaleX. */\n    scaleX = 1;\n\n    /** The local scaleY. */\n    scaleY = 1;\n\n    /** The local rotation. */\n    rotation = 0;\n\n    /** The width of the region attachment in Spine. */\n    width = 0;\n\n    /** The height of the region attachment in Spine. */\n    height = 0;\n\n    /** The color to tint the region attachment. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    rendererObject: any;\n    region: TextureRegion;\n\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\n     *\n     * See {@link #updateOffset()}. */\n    offset = Utils.newFloatArray(8);\n\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n    updateOffset(): void {\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const localXCos = localX * cos + this.x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + this.y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + this.x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + this.y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n    }\n\n    setRegion(region: TextureRegion): void {\n        this.region = region;\n        const uvs = this.uvs;\n\n        if (region.degrees == 90) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    /** Transforms the attachment's four vertices to world coordinates.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide.\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + 8.\n     * @param offset The `worldVertices` index to begin writing values.\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        const vertexOffset = this.offset;\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n\n    copy(): Attachment {\n        const copy = new RegionAttachment(this.name);\n\n        copy.region = this.region;\n        copy.rendererObject = this.rendererObject;\n        copy.path = this.path;\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.scaleX = this.scaleX;\n        copy.scaleY = this.scaleY;\n        copy.rotation = this.rotation;\n        copy.width = this.width;\n        copy.height = this.height;\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class JitterEffect implements VertexEffect {\n    jitterX = 0;\n    jitterY = 0;\n\n    constructor(jitterX: number, jitterY: number) {\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n    }\n\n    // @ts-ignore\n    begin(skeleton: Skeleton): void {}\n\n    // @ts-ignore\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    }\n\n    end(): void {}\n}\n","import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SwirlEffect implements VertexEffect {\n    static interpolation = new PowOut(2);\n    centerX = 0;\n    centerY = 0;\n    radius = 0;\n    angle = 0;\n    private worldX = 0;\n    private worldY = 0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    begin(skeleton: Skeleton): void {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n    }\n\n    // @ts-ignore\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        const radAngle = this.angle * MathUtils.degreesToRadians;\n        const x = position.x - this.worldX;\n        const y = position.y - this.worldY;\n        const dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n            const cos = Math.cos(theta);\n            const sin = Math.sin(theta);\n\n            position.x = cos * x - sin * y + this.worldX;\n            position.y = sin * x + cos * y + this.worldY;\n        }\n    }\n\n    end(): void {}\n}\n","import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { NumberArrayLike, IAnimation, ITimeline, MathUtils, MixBlend, StringSet, Utils, MixDirection } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\n/**\n * A simple container for a list of timelines and a name.\n * @public\n * */\nexport class Animation implements IAnimation<Timeline> {\n    /** The animation's name, which is unique across all animations in the skeleton. */\n    name: string;\n    timelines: Array<Timeline> = null;\n    timelineIds: StringSet = null;\n\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n        this.setTimelines(timelines);\n        this.duration = duration;\n    }\n\n    setTimelines(timelines: Array<Timeline>) {\n        if (!timelines) throw new Error('timelines cannot be null.');\n        this.timelines = timelines;\n        this.timelineIds = new StringSet();\n        for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n    }\n\n    hasTimeline(ids: string[]): boolean {\n        for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n\n        return false;\n    }\n\n    /** Applies all the animation's timelines to the specified skeleton.\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\n     * @param events May be null to ignore fired events. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n}\n\nconst Property = {\n    rotate: 0,\n    x: 1,\n    y: 2,\n    scaleX: 3,\n    scaleY: 4,\n    shearX: 5,\n    shearY: 6,\n\n    rgb: 7,\n    alpha: 8,\n    rgb2: 9,\n\n    attachment: 10,\n    deform: 11,\n\n    event: 12,\n    drawOrder: 13,\n\n    ikConstraint: 14,\n    transformConstraint: 15,\n\n    pathConstraintPosition: 16,\n    pathConstraintSpacing: 17,\n    pathConstraintMix: 18,\n};\n\n/** The interface for all timelines.\n * @public\n * */\nexport abstract class Timeline implements ITimeline {\n    propertyIds: string[] = null;\n    frames: NumberArrayLike = null;\n\n    constructor(frameCount: number, propertyIds: string[]) {\n        this.propertyIds = propertyIds;\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n    }\n\n    getPropertyIds() {\n        return this.propertyIds;\n    }\n\n    getFrameEntries(): number {\n        return 1;\n    }\n\n    getFrameCount() {\n        return this.frames.length / this.getFrameEntries();\n    }\n\n    getDuration(): number {\n        return this.frames[this.frames.length - this.getFrameEntries()];\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n    static search1(frames: NumberArrayLike, time: number) {\n        const n = frames.length;\n\n        for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n\n        return n - 1;\n    }\n\n    static search(frames: NumberArrayLike, time: number, step: number) {\n        const n = frames.length;\n\n        for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n\n        return n - step;\n    }\n}\n\n/**\n * @public\n */\nexport interface BoneTimeline {\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n    boneIndex: number;\n}\n\n/**\n * @public\n */\nexport interface SlotTimeline {\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n    slotIndex: number;\n}\n\n/** The base class for timelines that use interpolation between key frame values.\n * @public\n * */\nexport abstract class CurveTimeline extends Timeline {\n    protected curves: NumberArrayLike = null; // type, x, y, ...\n\n    constructor(frameCount: number, bezierCount: number, propertyIds: string[]) {\n        super(frameCount, propertyIds);\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18 /* BEZIER_SIZE*/);\n        this.curves[frameCount - 1] = 1 /* STEPPED*/;\n    }\n\n    /** Sets the specified key frame to linear interpolation. */\n    setLinear(frame: number) {\n        this.curves[frame] = 0 /* LINEAR*/;\n    }\n\n    /** Sets the specified key frame to stepped interpolation. */\n    setStepped(frame: number) {\n        this.curves[frame] = 1 /* STEPPED*/;\n    }\n\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n     * than the actual number of Bezier curves. */\n    shrink(bezierCount: number) {\n        const size = this.getFrameCount() + bezierCount * 18; /* BEZIER_SIZE*/\n\n        if (this.curves.length > size) {\n            const newCurves = Utils.newFloatArray(size);\n\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n            this.curves = newCurves;\n        }\n    }\n\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n     * one curve per frame.\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n     *           in the constructor), inclusive.\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n     * @param value The index of the value for this frame that this curve is used for.\n     * @param time1 The time for the first key.\n     * @param value1 The value for the first key.\n     * @param cx1 The time for the first Bezier handle.\n     * @param cy1 The value for the first Bezier handle.\n     * @param cx2 The time of the second Bezier handle.\n     * @param cy2 The value for the second Bezier handle.\n     * @param time2 The time for the second key.\n     * @param value2 The value for the second key. */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = value1 + dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    /** Returns the Bezier interpolated value for the specified time.\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n    getBezierValue(time: number, frameIndex: number, valueOffset: number, i: number) {\n        const curves = this.curves;\n\n        if (curves[i] > time) {\n            const x = this.frames[frameIndex];\n            const y = this.frames[frameIndex + valueOffset];\n\n            return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        frameIndex += this.getFrameEntries();\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((time - x) / (this.frames[frameIndex] - x)) * (this.frames[frameIndex + valueOffset] - y);\n    }\n}\n/**\n * @public\n */\nexport abstract class CurveTimeline1 extends CurveTimeline {\n    constructor(frameCount: number, bezierCount: number, propertyId: string) {\n        super(frameCount, bezierCount, [propertyId]);\n    }\n\n    getFrameEntries() {\n        return 2 /* ENTRIES*/;\n    }\n\n    /** Sets the time and value for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value: number) {\n        frame <<= 1;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE*/] = value;\n    }\n\n    /** Returns the interpolated value for the specified time. */\n    getCurveValue(time: number) {\n        const frames = this.frames;\n        let i = frames.length - 2;\n\n        for (let ii = 2; ii <= i; ii += 2) {\n            if (frames[ii] > time) {\n                i = ii - 2;\n                break;\n            }\n        }\n\n        const curveType = this.curves[i >> 1];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n                const value = frames[i + 1 /* VALUE*/];\n\n                return value + ((time - before) / (frames[i + 2 /* ENTRIES*/] - before)) * (frames[i + 2 /* ENTRIES*/ + 1 /* VALUE*/] - value);\n            case 1 /* STEPPED*/:\n                return frames[i + 1 /* VALUE*/];\n        }\n\n        return this.getBezierValue(time, i, 1 /* VALUE*/, curveType - 2 /* BEZIER*/);\n    }\n}\n\n/** The base class for a {@link CurveTimeline} which sets two properties.\n * @public\n * */\nexport abstract class CurveTimeline2 extends CurveTimeline {\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n    constructor(frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\n        super(frameCount, bezierCount, [propertyId1, propertyId2]);\n    }\n\n    getFrameEntries() {\n        return 3 /* ENTRIES*/;\n    }\n\n    /** Sets the time and values for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value1: number, value2: number) {\n        frame *= 3 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE1*/] = value1;\n        this.frames[frame + 2 /* VALUE2*/] = value2;\n    }\n}\n\n/** Changes a bone's local {@link Bone#rotation}.\n * @public\n * */\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n            }\n\n            return;\n        }\n\n        let r = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + r * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += r * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\n * @public\n * */\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n        x *= bone.data.scaleX;\n        y *= bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time) * bone.data.scaleX;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;\n            else bone.scaleX = x;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let bx = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time) * bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;\n            else bone.scaleY = y;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = bone.data.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = bone.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 5 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number) {\n        frame *= 5 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.setFromColor(setup);\n\n                    return;\n                case MixBlend.first:\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        const i = Timeline.search(frames, time, 5 /* ENTRIES*/);\n        const curveType = this.curves[i / 5 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                const t = (time - before) / (frames[i + 5 /* ENTRIES*/] - before);\n\n                r += (frames[i + 5 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 5 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 5 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 5 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) color.set(r, g, b, a);\n        else {\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number) {\n        frame <<= 2;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.r = setup.r;\n                    color.g = setup.g;\n                    color.b = setup.b;\n\n                    return;\n                case MixBlend.first:\n                    color.r += (setup.r - color.r) * alpha;\n                    color.g += (setup.g - color.g) * alpha;\n                    color.b += (setup.b - color.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                r += (frames[i + 4 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 4 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 4 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) {\n            color.r = r;\n            color.g = g;\n            color.b = b;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setup = slot.data.color;\n\n                color.r = setup.r;\n                color.g = setup.g;\n                color.b = setup.b;\n            }\n            color.r += (r - color.r) * alpha;\n            color.g += (g - color.g) * alpha;\n            color.b += (b - color.b) * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\n        this.slotIndex = slotIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const color = slot.color;\n\n        if (time < this.frames[0]) {\n            // Time is before first frame.\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.a = setup.a;\n\n                    return;\n                case MixBlend.first:\n                    color.a += (setup.a - color.a) * alpha;\n            }\n\n            return;\n        }\n\n        const a = this.getCurveValue(time);\n\n        if (alpha == 1) color.a = a;\n        else {\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\n            color.a += (a - color.a) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 8 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frame <<= 3;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n        this.frames[frame + 5 /* R2*/] = r2;\n        this.frames[frame + 6 /* G2*/] = g2;\n        this.frames[frame + 7 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.setFromColor(setupLight);\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 8 /* ENTRIES*/);\n        const curveType = this.curves[i >> 3];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                const t = (time - before) / (frames[i + 8 /* ENTRIES*/] - before);\n\n                r += (frames[i + 8 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 8 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 8 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 8 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                r2 += (frames[i + 8 /* ENTRIES*/ + 5 /* R2*/] - r2) * t;\n                g2 += (frames[i + 8 /* ENTRIES*/ + 6 /* G2*/] - g2) * t;\n                b2 += (frames[i + 8 /* ENTRIES*/ + 7 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 5 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 6 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 7 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 6 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.set(r, g, b, a);\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                const setupDark = slot.data.darkColor;\n\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\n        frame *= 7 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* R2*/] = r2;\n        this.frames[frame + 5 /* G2*/] = g2;\n        this.frames[frame + 6 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.r = setupLight.r;\n                    light.g = setupLight.g;\n                    light.b = setupLight.b;\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.r += (setupLight.r - light.r) * alpha;\n                    light.g += (setupLight.g - light.g) * alpha;\n                    light.b += (setupLight.b - light.b) * alpha;\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                r += (frames[i + 7 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 7 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 7 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                r2 += (frames[i + 7 /* ENTRIES*/ + 4 /* R2*/] - r2) * t;\n                g2 += (frames[i + 7 /* ENTRIES*/ + 5 /* G2*/] - g2) * t;\n                b2 += (frames[i + 7 /* ENTRIES*/ + 6 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 4 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 5 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 6 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.r = r;\n            light.g = g;\n            light.b = b;\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setupLight = slot.data.color;\n                const setupDark = slot.data.darkColor;\n\n                light.r = setupLight.r;\n                light.g = setupLight.g;\n                light.b = setupLight.b;\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.r += (r - light.r) * alpha;\n            light.g += (g - light.g) * alpha;\n            light.b += (b - light.b) * alpha;\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#attachment}.\n * @public\n * */\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\n    attachmentNames: Array<string>;\n\n    constructor(frameCount: number, slotIndex: number) {\n        super(frameCount, [`${Property.attachment}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\n    setFrame(frame: number, time: number, attachmentName: string) {\n        this.frames[frame] = time;\n        this.attachmentNames[frame] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\n * @public\n * */\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment that will be deformed. */\n    attachment: VertexAttachment = null;\n\n    /** The vertices for each key frame. */\n    vertices: Array<NumberArrayLike> = null;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\n        super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\n        this.slotIndex = slotIndex;\n        this.attachment = attachment;\n        this.vertices = new Array<NumberArrayLike>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the vertices for the specified key frame.\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n    setFrame(frame: number, time: number, vertices: NumberArrayLike) {\n        this.frames[frame] = time;\n        this.vertices[frame] = vertices;\n    }\n\n    /** @param value1 Ignored (0 is used for a deform timeline).\n     * @param value2 Ignored (1 is used for a deform timeline). */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = cy2 * 0.03 - cy1 * 0.06;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    getCurvePercent(time: number, frame: number) {\n        const curves = this.curves;\n        let i = curves[frame];\n\n        switch (i) {\n            case 0 /* LINEAR*/:\n                const x = this.frames[frame];\n\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n            case 1 /* STEPPED*/:\n                return 0;\n        }\n        i -= 2 /* BEZIER*/;\n        if (curves[i] > time) {\n            const x = this.frames[frame];\n\n            return (curves[i + 1] * (time - x)) / (curves[i] - x);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((1 - y) * (time - x)) / (this.frames[frame + this.getFrameEntries()] - x);\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment: Attachment = slot.getAttachment();\n\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).deformAttachment != this.attachment) return;\n\n        const deform: Array<number> = slot.deform;\n\n        if (deform.length == 0) blend = MixBlend.setup;\n\n        const vertices = this.vertices;\n        const vertexCount = vertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const vertexAttachment = <VertexAttachment>slotAttachment;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    deform.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        deform.length = 0;\n\n                        return;\n                    }\n                    deform.length = vertexCount;\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        deform.length = vertexCount;\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = vertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n                    }\n                } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n                        break;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Timeline.search1(frames, time);\n        const percent = this.getCurvePercent(time, frame);\n        const prevVertices = vertices[frame];\n        const nextVertices = vertices[frame + 1];\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (!vertexAttachment.bones) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/** Fires an {@link Event} when specific animation times are reached.\n * @public\n * */\nexport class EventTimeline extends Timeline {\n    static propertyIds = [`${Property.event}`];\n\n    /** The event for each key frame. */\n    events: Array<Event> = null;\n\n    constructor(frameCount: number) {\n        super(frameCount, EventTimeline.propertyIds);\n\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the event for the specified key frame. */\n    setFrame(frame: number, event: Event) {\n        this.frames[frame] = event.time;\n        this.events[frame] = event;\n    }\n\n    /** Fires events for frames > `lastTime` and <= `time`. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!firedEvents) return;\n\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let i = 0;\n\n        if (lastTime < frames[0]) i = 0;\n        else {\n            i = Timeline.search1(frames, lastTime) + 1;\n            const frameTime = frames[i];\n\n            while (i > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[i - 1] != frameTime) break;\n                i--;\n            }\n        }\n        for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n    }\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\n * @public\n * */\nexport class DrawOrderTimeline extends Timeline {\n    static propertyIds = [`${Property.drawOrder}`];\n\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n    drawOrders: Array<Array<number>> = null;\n\n    constructor(frameCount: number) {\n        super(frameCount, DrawOrderTimeline.propertyIds);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the draw order for the specified key frame.\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n     *           draw order. */\n    setFrame(frame: number, time: number, drawOrder: Array<number>) {\n        this.frames[frame] = time;\n        this.drawOrders[frame] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const drawOrderToSetupIndex = this.drawOrders[Timeline.search1(this.frames, time)];\n\n        if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n        else {\n            const drawOrder: Array<Slot> = skeleton.drawOrder;\n            const slots: Array<Slot> = skeleton.slots;\n\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\n * @public\n * */\nexport class IkConstraintTimeline extends CurveTimeline {\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    ikConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, ikConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\n        this.ikConstraintIndex = ikConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 6 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n    setFrame(frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frame *= 6 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* MIX*/] = mix;\n        this.frames[frame + 2 /* SOFTNESS*/] = softness;\n        this.frames[frame + 3 /* BEND_DIRECTION*/] = bendDirection;\n        this.frames[frame + 4 /* COMPRESS*/] = compress ? 1 : 0;\n        this.frames[frame + 5 /* STRETCH*/] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.softness = constraint.data.softness;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        let mix = 0;\n        let softness = 0;\n        const i = Timeline.search(frames, time, 6 /* ENTRIES*/);\n        const curveType = this.curves[i / 6 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                const t = (time - before) / (frames[i + 6 /* ENTRIES*/] - before);\n\n                mix += (frames[i + 6 /* ENTRIES*/ + 1 /* MIX*/] - mix) * t;\n                softness += (frames[i + 6 /* ENTRIES*/ + 2 /* SOFTNESS*/] - softness) * t;\n                break;\n            case 1 /* STEPPED*/:\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                break;\n            default:\n                mix = this.getBezierValue(time, i, 1 /* MIX*/, curveType - 2 /* BEZIER*/);\n                softness = this.getBezierValue(time, i, 2 /* SOFTNESS*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        } else {\n            constraint.mix += (mix - constraint.mix) * alpha;\n            constraint.softness += (softness - constraint.softness) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        }\n    }\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\n * @public\n * */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    transformConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, transformConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\n        this.transformConstraintIndex = transformConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number, mixShearY: number) {\n        const frames = this.frames;\n\n        frame *= 7 /* ENTRIES*/;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n        frames[frame + 4 /* SCALEX*/] = mixScaleX;\n        frames[frame + 5 /* SCALEY*/] = mixScaleY;\n        frames[frame + 6 /* SHEARY*/] = mixShearY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = data.mixRotate;\n                    constraint.mixX = data.mixX;\n                    constraint.mixY = data.mixY;\n                    constraint.mixScaleX = data.mixScaleX;\n                    constraint.mixScaleY = data.mixScaleY;\n                    constraint.mixShearY = data.mixShearY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        let scaleX;\n        let scaleY;\n        let shearY;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 7 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 7 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 7 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                scaleX += (frames[i + 7 /* ENTRIES*/ + 4 /* SCALEX*/] - scaleX) * t;\n                scaleY += (frames[i + 7 /* ENTRIES*/ + 5 /* SCALEY*/] - scaleY) * t;\n                shearY += (frames[i + 7 /* ENTRIES*/ + 6 /* SHEARY*/] - shearY) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                scaleX = this.getBezierValue(time, i, 4 /* SCALEX*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                scaleY = this.getBezierValue(time, i, 5 /* SCALEY*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                shearY = this.getBezierValue(time, i, 6 /* SHEARY*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n        }\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}.\n * @public\n * */\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        const position = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}.\n * @public\n * */\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        const spacing = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\n * {@link PathConstraint#getMixY()}.\n * @public\n * */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\n        const frames = this.frames;\n\n        frame <<= 2;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = constraint.data.mixRotate;\n                    constraint.mixX = constraint.data.mixX;\n                    constraint.mixY = constraint.data.mixY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 4 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 4 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 4 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n        }\n    }\n}\n","import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, StringSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport type { Slot } from './Slot';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\n * @public\n * */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    private static emptyAnimation(): Animation {\n        if (!_emptyAnimation) _emptyAnimation = new Animation('<empty>', [], 0);\n\n        return _emptyAnimation;\n    }\n\n    /** The AnimationStateData to look up mix durations. */\n    data: AnimationStateData = null;\n\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    tracks = new Array<TrackEntry>();\n\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    timeScale = 1;\n    unkeyedState = 0;\n\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new StringSet();\n    animationsChanged = false;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.clearNext(current);\n                continue;\n            }\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from) from.mixingTo = null;\n                while (from) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    /** Returns true when all mixing from entries are complete. */\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (!from) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n     * animation state can be applied to multiple skeletons to pose them identically.\n     * @returns True if any animations were applied. */\n    apply(skeleton: Skeleton): boolean {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            let applyTime = animationTime;\n            let applyEvents = events;\n\n            if (current.reverse) {\n                applyTime = current.animation.duration - applyTime;\n                applyEvents = null;\n            }\n            const timelines = current.animation.timelines;\n            const timelineCount = timelines.length;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    const timeline = timelines[ii];\n\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const firstFrame = current.timelinesRotation.length != timelineCount << 1;\n\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n                    } else if (timeline instanceof AttachmentTimeline) {\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n        // the time is before the first key).\n        const setupState = this.unkeyedState + SETUP;\n        const slots = skeleton.slots;\n\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.attachmentState == setupState) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n            }\n        }\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const timelines = from.animation.timelines;\n        const timelineCount = timelines.length;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        let applyTime = animationTime;\n        let events = null;\n\n        if (from.reverse) applyTime = from.animation.duration - applyTime;\n        else if (mix < from.eventThreshold) events = this.events;\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const firstFrame = from.timelinesRotation.length != timelineCount << 1;\n\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case SUBSEQUENT:\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case HOLD_SUBSEQUENT:\n                        timelineBlend = blend;\n                        alpha = alphaHold;\n                        break;\n                    case HOLD_FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n        const slot = skeleton.slots[timeline.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (time < timeline.frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n        } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n    }\n\n    applyRotateTimeline(\n        timeline: RotateTimeline,\n        skeleton: Skeleton,\n        time: number,\n        alpha: number,\n        blend: MixBlend,\n        timelinesRotation: Array<number>,\n        i: number,\n        firstFrame: boolean\n    ) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const bone = skeleton.bones[timeline.boneIndex];\n\n        if (!bone.active) return;\n        const frames = timeline.frames;\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        bone.rotation = r1 + total * alpha;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n    }\n\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    /** Removes all animations from the track, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (!current) return;\n\n        this.queue.end(current);\n\n        this.clearNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (!from) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n        current.previous = null;\n\n        if (from) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    /** Sets an animation by name.\n     *\n     * See {@link #setAnimationWith()}. */\n    setAnimation(trackIndex: number, animationName: string, loop = false) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n     * applied to a skeleton, it is replaced (not mixed from).\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    setAnimationWith(trackIndex: number, animation: Animation, loop = false) {\n        if (!animation) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.clearNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.clearNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    /** Queues an animation by name.\n     *\n     * See {@link #addAnimationWith()}. */\n    addAnimation(trackIndex: number, animationName: string, loop = false, delay = 0) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n     * equivalent to calling {@link #setAnimationWith()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n     *           previous entry is looping, its next loop completion is used instead of its duration.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addAnimationWith(trackIndex: number, animation: Animation, loop = false, delay = 0) {\n        if (!animation) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last) {\n            while (last.next) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (!last) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            entry.previous = last;\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n     *\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n     * 0 still mixes out over one frame.\n     *\n     * Mixing in is done by first setting an empty animation, then adding an animation using\n     * {@link #addAnimation()} and on the returned track entry, set the\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n    setEmptyAnimation(trackIndex: number, mixDuration = 0) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n     * {@link #setEmptyAnimation()}.\n     *\n     * See {@link #setEmptyAnimation()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n     *           loop completion is used instead of its duration.\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addEmptyAnimation(trackIndex: number, mixDuration = 0, delay = 0) {\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\n\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n     * duration. */\n    setEmptyAnimations(mixDuration = 0) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    /** @param last May be null. */\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.reset();\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n        entry.mixBlend = MixBlend.replace;\n\n        return entry;\n    }\n\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n    clearNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            let entry = tracks[i];\n\n            if (!entry) continue;\n            while (entry.mixingFrom) entry = entry.mixingFrom;\n            do {\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                entry = entry.mixingTo;\n            } while (entry);\n        }\n    }\n\n    computeHold(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = entry.timelineMode;\n\n        timelineMode.length = timelinesCount;\n        const timelineHoldMix = entry.timelineHoldMix;\n\n        timelineHoldMix.length = 0;\n        const propertyIDs = this.propertyIDs;\n\n        if (to && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const timeline = timelines[i];\n            const ids = timeline.getPropertyIds();\n\n            if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\n            else if (\n                !to ||\n                timeline instanceof AttachmentTimeline ||\n                timeline instanceof DrawOrderTimeline ||\n                timeline instanceof EventTimeline ||\n                !to.animation.hasTimeline(ids)\n            ) {\n                timelineMode[i] = FIRST;\n            } else {\n                for (let next = to.mixingTo; next; next = next.mixingTo) {\n                    if (next.animation.hasTimeline(ids)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = HOLD_MIX;\n                        timelineHoldMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = HOLD_FIRST;\n            }\n        }\n    }\n\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all track entries. */\n    addListener(listener: AnimationStateListener) {\n        if (!listener) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener()}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    /** Removes all listeners added with {@link #addListener()}. */\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n     * are not wanted because new animations are being set. */\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\n * @public\n * */\nexport class TrackEntry implements ITrackEntry {\n    /** The animation to apply for this track entry. */\n    animation: Animation = null;\n\n    previous: TrackEntry = null;\n\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    next: TrackEntry = null;\n\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    mixingFrom: TrackEntry = null;\n\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    mixingTo: TrackEntry = null;\n\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    listener: AnimationStateListener = null;\n\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    trackIndex = 0;\n\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    loop = false;\n\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    holdPrevious = false;\n\n    reverse = false;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    eventThreshold = 0;\n\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    attachmentThreshold = 0;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    drawOrderThreshold = 0;\n\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    animationStart = 0;\n\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    animationEnd = 0;\n\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    animationLast = 0;\n\n    nextAnimationLast = 0;\n\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    delay = 0;\n\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    trackTime = 0;\n\n    trackLast = 0;\n    nextTrackLast = 0;\n\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    trackEnd = 0;\n\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    timeScale = 0;\n\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    alpha = 0;\n\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    mixTime = 0;\n\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    mixDuration = 0;\n    interruptAlpha = 0;\n    totalAlpha = 0;\n\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.previous = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n     * `animationStart` time. */\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    /** Returns true if at least one loop has been completed.\n     *\n     * See {@link AnimationStateListener#complete()}. */\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n     * long way around when using {@link #alpha} and starting animations on other tracks.\n     *\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    getTrackComplete() {\n        const duration = this.animationEnd - this.animationStart;\n\n        if (duration != 0) {\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\n            if (this.trackTime < duration) return duration; // Before duration.\n        }\n\n        return this.trackTime; // Next update.\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: Boolean = false;\n    private static deprecatedWarning2: Boolean = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState = null;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                    break;\n                case EventType.end:\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\n * events.\n *\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\n * {@link AnimationState#addListener()}.\n * @public\n * */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?(entry: TrackEntry): void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?(entry: TrackEntry): void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?(entry: TrackEntry): void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?(entry: TrackEntry): void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?(entry: TrackEntry): void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?(entry: TrackEntry, event: Event): void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nconst SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nconst FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nconst HOLD_MIX = 4;\n\nconst SETUP = 1;\nconst CURRENT = 2;\n\nlet _emptyAnimation: Animation = null;\n","import type { SkeletonData } from './SkeletonData';\nimport type { IAnimationStateData, Map } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\n * @public\n * */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    /** The SkeletonData to look up animations when they are specified by name. */\n    skeletonData: SkeletonData;\n\n    animationToMixTime: Map<number> = {};\n\n    /** The mix duration to use when no mix duration has been defined between two animations. */\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    /** Sets a mix duration by animation name.\n     *\n     * See {@link #setMixWith()}. */\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    /** Sets the mix duration when changing from the specified animation to the other.\n     *\n     * See {@link TrackEntry#mixDuration}. */\n    setMixWith(from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error('from cannot be null.');\n        if (to == null) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\n     * no mix duration has been set. */\n    getMix(from: Animation, to: Animation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    // @ts-ignore\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n        const attachment = new RegionAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    // @ts-ignore\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n        const attachment = new MeshAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    // @ts-ignore\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    // @ts-ignore\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    // @ts-ignore\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    // @ts-ignore\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n","import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/** Stores a bone's current pose.\n *\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\n * constraint or application code modifies the world transform after it was computed from the local transform.\n * @public\n * */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    /** The bone's setup pose data. */\n    data: BoneData = null;\n\n    /** The skeleton this bone belongs to. */\n    skeleton: Skeleton = null;\n\n    /** The parent bone, or null if this is the root bone. */\n    parent: Bone = null;\n\n    /** The immediate children of this bone. */\n    children = new Array<Bone>();\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local rotation in degrees, counter clockwise. */\n    rotation = 0;\n\n    /** The local scaleX. */\n    scaleX = 0;\n\n    /** The local scaleY. */\n    scaleY = 0;\n\n    /** The local shearX. */\n    shearX = 0;\n\n    /** The local shearY. */\n    shearY = 0;\n\n    /** The applied local x translation. */\n    ax = 0;\n\n    /** The applied local y translation. */\n    ay = 0;\n\n    /** The applied local rotation in degrees, counter clockwise. */\n    arotation = 0;\n\n    /** The applied local scaleX. */\n    ascaleX = 0;\n\n    /** The applied local scaleY. */\n    ascaleY = 0;\n\n    /** The applied local shearX. */\n    ashearX = 0;\n\n    /** The applied local shearY. */\n    ashearY = 0;\n\n    sorted = false;\n    active = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n    isActive() {\n        return this.active;\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\n    update() {\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform.\n     *\n     * See {@link #updateWorldTransformWith()}. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n     * specified local transform. Child bones are not updated.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (!parent) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pa /= sx;\n                    pc /= sy;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0)) s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    /** Sets this bone's local transform to the setup pose. */\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.b * m.b);\n    }\n\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.c * m.c + m.d * m.d);\n    }\n\n    /** Computes the applied transform values from the world transform.\n     *\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n     * constraints).\n     *\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n    updateAppliedTransform() {\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (!parent) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    /** Transforms a world rotation to a local rotation. */\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    /** Transforms a local rotation to a world rotation. */\n    localToWorldRotation(localRotation: number) {\n        localRotation -= this.rotation - this.shearX;\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    /** Rotates the world transform the specified amount.\n     * <p>\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n     * need to be called on any child bones, recursively. */\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n    }\n}\n","import { Color, TransformMode } from '@pixi-spine/base';\n\n/** Stores the setup pose for a {@link Bone}.\n * @public\n * */\nexport class BoneData {\n    /** The index of the bone in {@link Skeleton#getBones()}. */\n    index: number;\n\n    /** The name of the bone, which is unique across all bones in the skeleton. */\n    name: string;\n\n    /** @returns May be null. */\n    parent: BoneData;\n\n    /** The bone's length. */\n    length: number;\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local rotation. */\n    rotation = 0;\n\n    /** The local scaleX. */\n    scaleX = 1;\n\n    /** The local scaleY. */\n    scaleY = 1;\n\n    /** The local shearX. */\n    shearX = 0;\n\n    /** The local shearX. */\n    shearY = 0;\n\n    /** The transform mode for how parent world transforms affect this bone. */\n    transformMode = TransformMode.Normal;\n\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\n     * bone.\n     * @see Skin#bones */\n    skinRequired = false;\n\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\n     * rendered at runtime. */\n    color = new Color();\n\n    constructor(index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n","/** The base class for all constraint datas.\n * @public\n * */\nexport abstract class ConstraintData {\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\n}\n","import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/** Stores the current pose values for an {@link Event}.\n *\n * See Timeline {@link Timeline#apply()},\n * AnimationStateListener {@link AnimationStateListener#event()}, and\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\n * @public\n * */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n    volume: number;\n    balance: number;\n\n    constructor(time: number, data: EventData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n","import type { IEventData } from '@pixi-spine/base';\n\n/** Stores the setup pose values for an {@link Event}.\n *\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\n * @public\n * */\nexport class EventData implements IEventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    audioPath: string;\n    volume: number;\n    balance: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n","import type { Updatable } from './Updatable';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, settings, TransformMode } from '@pixi-spine/base';\n\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\n * the last bone is as close to the target bone as possible.\n *\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\n * @public\n * */\nexport class IkConstraint implements Updatable {\n    /** The IK constraint's setup pose data. */\n    data: IkConstraintData;\n\n    /** The bones that will be modified by this IK constraint. */\n    bones: Array<Bone>;\n\n    /** The bone that is the IK target. */\n    target: Bone;\n\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    bendDirection = 0;\n\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    compress = false;\n\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    stretch = false;\n\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    mix = 1;\n\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    softness = 0;\n    active = false;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.softness = data.softness;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        if (this.mix == 0) return;\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n                break;\n        }\n    }\n\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        const p = bone.parent.matrix;\n\n        const pa = p.a;\n        let pb = p.c;\n        const pc = p.b;\n        let pd = p.d;\n        let rotationIK = -bone.ashearX - bone.arotation;\n        let tx = 0;\n        let ty = 0;\n\n        const skelX = bone.skeleton.scaleX;\n        const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\n\n        switch (bone.data.transformMode) {\n            case TransformMode.OnlyTranslation:\n                tx = targetX - bone.worldX;\n                ty = targetY - bone.worldY;\n                // TODO: possible bug in spine-ts runtime!\n                if (settings.yDown) {\n                    ty = -ty;\n                }\n                break;\n            case TransformMode.NoRotationOrReflection:\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                const sa = pa / skelX;\n                const sc = pc / skelY;\n\n                pb = -sc * s * skelX;\n                pd = sa * s * skelY;\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n            // Fall through\n            default:\n                const x = targetX - p.tx;\n                const y = targetY - p.ty;\n                const d = pa * pd - pb * pc;\n\n                tx = (x * pd - y * pb) / d - bone.ax;\n                ty = (y * pa - x * pc) / d - bone.ay;\n        }\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            switch (bone.data.transformMode) {\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n            }\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let psy = parent.ascaleY;\n        let sx = psx;\n        let sy = psy;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u || stretch) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = cwx - pp.tx;\n        let y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1;\n        let a2;\n\n        if (l1 < 0.0001) {\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\n            return;\n        }\n        x = targetX - pp.tx;\n        y = targetY - pp.ty;\n        let tx = (x * d - y * b) * id - px;\n        let ty = (y * a - x * c) * id - py;\n        let dd = tx * tx + ty * ty;\n\n        if (softness != 0) {\n            softness *= psx * (csx + 1) * 0.5;\n            const td = Math.sqrt(dd);\n            const sd = td - l1 - l2 * psx + softness;\n\n            if (sd > 0) {\n                let p = Math.min(1, sd / (softness * 2)) - 1;\n\n                p = (sd - softness * (1 - p * p)) / td;\n                tx -= p * tx;\n                ty -= p * ty;\n                dd = tx * tx + ty * ty;\n            }\n        }\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) {\n                cos = -1;\n                a2 = Math.PI * bendDir;\n            } else if (cos > 1) {\n                cos = 1;\n                a2 = 0;\n                if (stretch) {\n                    a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n                    sx *= a;\n                    if (uniform) sy *= a;\n                }\n            } else a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) * 0.5;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) * 0.5) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180)\n            //\n            a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180)\n            //\n            a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n","import { ConstraintData } from './ConstraintData';\nimport type { BoneData } from './BoneData';\n\n/** Stores the setup pose for an {@link IkConstraint}.\n * <p>\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\n * @public\n * */\nexport class IkConstraintData extends ConstraintData {\n    /** The bones that are constrained by this IK constraint. */\n    bones = new Array<BoneData>();\n\n    /** The bone that is the IK target. */\n    target: BoneData;\n\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    bendDirection = 1;\n\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    compress = false;\n\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    stretch = false;\n\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\n     * is scaled on both the X and Y axes. */\n    uniform = false;\n\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    mix = 1;\n\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    softness = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n","import { ConstraintData } from './ConstraintData';\nimport type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport type { PositionMode, RotateMode } from '@pixi-spine/base';\n\n/** Stores the setup pose for a {@link PathConstraint}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\n * @public\n * */\nexport class PathConstraintData extends ConstraintData {\n    /** The bones that will be modified by this path constraint. */\n    bones = new Array<BoneData>();\n\n    /** The slot whose path attachment will be used to constrained the bones. */\n    target: SlotData;\n\n    /** The mode for positioning the first bone on the path. */\n    positionMode: PositionMode;\n\n    /** The mode for positioning the bones after the first bone on the path. */\n    spacingMode: SpacingMode;\n\n    /** The mode for adjusting the rotation of the bones. */\n    rotateMode: RotateMode;\n\n    /** An offset added to the constrained bone rotation. */\n    offsetRotation: number;\n\n    /** The position along the path. */\n    position: number;\n\n    /** The spacing between bones. */\n    spacing: number;\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n\n/** Controls how bones after the first bone are positioned along the path.\n *\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\n * @public\n * */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n    Proportional,\n}\n","import { PathAttachment } from './attachments';\nimport type { Updatable } from './Updatable';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\n * constrained bones so they follow a {@link PathAttachment}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\n * @public\n * */\nexport class PathConstraint implements Updatable {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    /** The path constraint's setup pose data. */\n    data: PathConstraintData = null;\n\n    /** The bones that will be modified by this path constraint. */\n    bones: Array<Bone> = null;\n\n    /** The slot whose path attachment will be used to constrained the bones. */\n    target: Slot = null;\n\n    /** The position along the path. */\n    position = 0;\n\n    /** The spacing between bones. */\n    spacing = 0;\n\n    mixRotate = 0;\n\n    mixX = 0;\n\n    mixY = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    active = false;\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n\n        const data = this.data;\n        const tangents = data.rotateMode == RotateMode.Tangent;\n        const scale = data.rotateMode == RotateMode.ChainScale;\n\n        const bones = this.bones;\n        const boneCount = bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        const lengths: Array<number> = scale ? (this.lengths = Utils.setArraySize(this.lengths, boneCount)) : null;\n        const spacing = this.spacing;\n\n        switch (data.spacingMode) {\n            case SpacingMode.Percent:\n                if (scale) {\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\n                        const bone = bones[i];\n                        const setupLength = bone.data.length;\n\n                        if (setupLength < PathConstraint.epsilon) lengths[i] = 0;\n                        else {\n                            const x = setupLength * bone.matrix.a;\n                            const y = setupLength * bone.matrix.b;\n\n                            lengths[i] = Math.sqrt(x * x + y * y);\n                        }\n                    }\n                }\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\n                break;\n            case SpacingMode.Proportional:\n                let sum = 0;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = length;\n                        sum += length;\n                    }\n                }\n                if (sum > 0) {\n                    sum = (spacesCount / sum) * spacing;\n                    for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n                }\n                break;\n            default:\n                const lengthSpacing = data.spacingMode == SpacingMode.Length;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                    }\n                }\n        }\n\n        const positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * mixX;\n            mat.ty += (boneY - mat.ty) * mixY;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (mixRotate > 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents)\n                    if (tangents) r = positions[p - 1];\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\n                    else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.updateAppliedTransform();\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = null;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n            let multiplier;\n\n            switch (this.data.spacingMode) {\n                case SpacingMode.Percent:\n                    multiplier = pathLength;\n                    break;\n                case SpacingMode.Proportional:\n                    multiplier = pathLength / spacesCount;\n                    break;\n                default:\n                    multiplier = 1;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i] * multiplier;\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n        let multiplier;\n\n        switch (this.data.spacingMode) {\n            case SpacingMode.Percent:\n                multiplier = pathLength;\n                break;\n            case SpacingMode.Proportional:\n                multiplier = pathLength / spacesCount;\n                break;\n            default:\n                multiplier = 1;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i] * multiplier;\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) {\n            out[o] = x1;\n            out[o + 1] = y1;\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\n            return;\n        }\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) {\n            if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n            else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n        }\n    }\n}\n","import type { Updatable } from './Updatable';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\nexport class TransformConstraint implements Updatable {\n    /** The transform constraint's setup pose data. */\n    data: TransformConstraintData;\n\n    /** The bones that will be modified by this transform constraint. */\n    bones: Array<Bone>;\n\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    target: Bone;\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n    mixScaleX = 0;\n    mixScaleY = 0;\n    mixShearY = 0;\n\n    temp = new Vector2();\n    active = false;\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n        this.mixScaleX = data.mixScaleX;\n        this.mixScaleY = data.mixScaleY;\n        this.mixShearY = data.mixShearY;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleY == 0 && this.mixShearY == 0) return;\n\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n        const translate = mixX != 0 || mixY != 0;\n\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * mixX;\n                mat.ty += (temp.y - mat.ty) * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n\n                if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n\n                if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n                mat.c *= s;\n                mat.d *= s;\n            }\n\n            if (mixShearY > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * mixShearY;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyRelativeWorld() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n        const translate = mixX != 0 || mixY != 0;\n\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * mixX;\n                mat.ty += temp.y * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n\n                mat.c *= s;\n                mat.d *= s;\n            }\n\n            if (mixShearY > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n\n        const target = this.target;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            let rotation = bone.arotation;\n\n            if (mixRotate != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * mixRotate;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            x += (target.ax - x + this.data.offsetX) * mixX;\n            y += (target.ay - y + this.data.offsetY) * mixY;\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (mixScaleX != 0 && scaleX != 0) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n            if (mixScaleY != 0 && scaleY != 0) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n\n            let shearY = bone.ashearY;\n\n            if (mixShearY != 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                shearY += r * mixShearY;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n\n        const target = this.target;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n            const x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n            const y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n            const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);\n            const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);\n            const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n}\n","import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, MathUtils, NumberArrayLike, settings, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    /** The skeleton's setup pose data. */\n    data: SkeletonData = null;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones: Array<Bone> = null;\n\n    /** The skeleton's slots. */\n    slots: Array<Slot> = null;\n\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n    drawOrder: Array<Slot> = null;\n\n    /** The skeleton's IK constraints. */\n    ikConstraints: Array<IkConstraint> = null;\n\n    /** The skeleton's transform constraints. */\n    transformConstraints: Array<TransformConstraint> = null;\n\n    /** The skeleton's path constraints. */\n    pathConstraints: Array<PathConstraint> = null;\n\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    _updateCache = new Array<Updatable>();\n\n    /** The skeleton's current skin. May be null. */\n    skin: Skin = null;\n\n    /** The color to tint all the skeleton's attachments. */\n    color: Color = null;\n\n    /** Returns the skeleton's time. This can be used for tracking, such as with Slot {@link Slot#attachmentTime}.\n     * <p>\n     * See {@link #update()}. */\n    time = 0;\n\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleX = 1;\n\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleY = 1;\n\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    x = 0;\n\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (!data) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (!boneData.parent) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n     * constraints, or weighted path attachments are added or removed. */\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin) {\n            const skinBones = this.skin.bones;\n\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone = this.bones[skinBones[i].index];\n\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length == 1) {\n            this._updateCache.push(constraint);\n            this.sortReset(parent.children);\n        } else {\n            const child = constrained[constrained.length - 1];\n\n            this.sortBone(child);\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            child.sorted = true;\n        }\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                this.sortBone(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (!pathBones) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n\n            for (let i = 0, n = pathBones.length; i < n; ) {\n                let nn = pathBones[i++];\n\n                nn += i;\n                while (i < nn) this.sortBone(bones[pathBones[i++]]);\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies all constraints.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransform() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n        }\n\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    updateWorldTransformWith(parent: Bone) {\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n        const rootBone = this.getRootBone();\n        const pa = parent.matrix.a;\n        const pb = parent.matrix.c;\n        const pc = parent.matrix.b;\n        const pd = parent.matrix.d;\n\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n\n        const rotationY = rootBone.rotation + 90 + rootBone.shearY;\n        const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n        const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n\n        const sx = this.scaleX;\n        const sy = settings.yDown ? -this.scaleY : this.scaleY;\n\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n\n        // Update everything except root bone.\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) {\n            const updatable = updateCache[i];\n\n            if (updatable != rootBone) updatable.update();\n        }\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n            constraint.mixScaleX = data.mixScaleX;\n            constraint.mixScaleY = data.mixScaleY;\n            constraint.mixShearY = data.mixShearY;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n        }\n    }\n\n    /** Sets the slots and draw order to their setup pose values. */\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @returns May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @returns May be null. */\n    findBone(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * repeatedly.\n     * @returns May be null. */\n    findSlot(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     *\n     * See {@link #setSkin()}. */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (!skin) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n     * skin is changed, {@link #updateCache()} is called.\n     *\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     *\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin) {\n            if (this.skin) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name) {\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n     * name.\n     *\n     * See {@link #getAttachment()}.\n     * @returns May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlot(slotName).index, attachmentName);\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n     *\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n     * @returns May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\n        if (!attachmentName) throw new Error('attachmentName cannot be null.');\n        if (this.skin) {\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n     * @param attachmentName May be null to clear the slot's attachment. */\n    setAttachment(slotName: string, attachmentName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (!attachment) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it repeatedly.\n     * @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n    getBoundsRect() {\n        const offset = new Vector2();\n        const size = new Vector2();\n\n        this.getBounds(offset, size);\n\n        return { x: offset.x, y: offset.y, width: size.x, height: size.y };\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size An output value, the width and height of the AABB.\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (!offset) throw new Error('offset cannot be null.');\n        if (!size) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: NumberArrayLike = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    /** Increments the skeleton's {@link #time}. */\n    update(delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n","import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/** Stores the setup pose and all of the stateless data for a skeleton.\n *\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\n * Guide.\n * @public\n * */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n    name: string = null;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones = new Array<BoneData>(); // Ordered parents first.\n\n    /** The skeleton's slots. */\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\n     *\n     * See {@link Skeleton#getAttachmentByName()}.\n     * May be null. */\n    defaultSkin: Skin = null;\n\n    /** The skeleton's events. */\n    events = new Array<EventData>();\n\n    /** The skeleton's animations. */\n    animations = new Array<Animation>();\n\n    /** The skeleton's IK constraints. */\n    ikConstraints = new Array<IkConstraintData>();\n\n    /** The skeleton's transform constraints. */\n    transformConstraints = new Array<TransformConstraintData>();\n\n    /** The skeleton's path constraints. */\n    pathConstraints = new Array<PathConstraintData>();\n\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    x = 0;\n\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    y = 0;\n\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\n    width = 0;\n\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\n    height = 0;\n\n    /** The Spine version used to export the skeleton data, or null. */\n    version: string = null;\n\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n    hash: string = null;\n\n    // Nonessential\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n    fps = 0;\n\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    imagesPath: string = null;\n\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    audioPath: string = null;\n\n    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findBone(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/\n    findBoneIndex(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findSlot(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/\n    findSlotIndex(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findSkin(skinName: string) {\n        if (!skinName) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findEvent(eventDataName: string) {\n        if (!eventDataName) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\n     * call it multiple times.\n     * @returns May be null. */\n    findAnimation(animationName: string) {\n        if (!animationName) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it multiple times.\n     * @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it multiple times.\n     * @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it multiple times.\n     * @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/ findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n","import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport type { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/** Stores the setup pose for a {@link Slot}.\n * @public\n * */\nexport class SlotData implements ISlotData {\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\n    index: number;\n\n    /** The name of the slot, which is unique across all slots in the skeleton. */\n    name: string;\n\n    /** The bone this slot belongs to. */\n    boneData: BoneData;\n\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    darkColor: Color;\n\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n    attachmentName: string;\n\n    /** The blend mode for drawing the slot's attachment. */\n    blendMode: BLEND_MODES;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (!name) throw new Error('name cannot be null.');\n        if (!boneData) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n","import type { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\n\n/** Stores the setup pose for a {@link TransformConstraint}.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\nexport class TransformConstraintData extends ConstraintData {\n    /** The bones that will be modified by this transform constraint. */\n    bones = new Array<BoneData>();\n\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    target: BoneData;\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n    mixScaleX = 0;\n    mixScaleY = 0;\n    mixShearY = 0;\n\n    /** An offset added to the constrained bone rotation. */\n    offsetRotation = 0;\n\n    /** An offset added to the constrained bone X translation. */\n    offsetX = 0;\n\n    /** An offset added to the constrained bone Y translation. */\n    offsetY = 0;\n\n    /** An offset added to the constrained bone scaleX. */\n    offsetScaleX = 0;\n\n    /** An offset added to the constrained bone scaleY. */\n    offsetScaleY = 0;\n\n    /** An offset added to the constrained bone shearY. */\n    offsetShearY = 0;\n\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n","import { Attachment, MeshAttachment } from './attachments';\nimport type { BoneData } from './BoneData';\nimport type { ConstraintData } from './ConstraintData';\nimport type { Skeleton } from './Skeleton';\n\nimport type { Map, ISkin } from '@pixi-spine/base';\n\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\n * @public\n * **/\nexport class SkinEntry {\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\n}\n\n/** Stores attachments by slot index and attachment name.\n *\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skin implements ISkin {\n    /** The skin's name, which is unique across all skins in the skeleton. */\n    name: string;\n\n    attachments = new Array<Map<Attachment>>();\n    bones = Array<BoneData>();\n    constraints = new Array<ConstraintData>();\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    /** Adds an attachment to the skin for the specified slot index and name. */\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (!attachment) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n    addSkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n        }\n    }\n\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n    copySkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            if (!attachment.attachment) continue;\n            if (attachment.attachment instanceof MeshAttachment) {\n                attachment.attachment = attachment.attachment.newLinkedMesh();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            } else {\n                attachment.attachment = attachment.attachment.copy();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            }\n        }\n    }\n\n    /** Returns the attachment for the specified slot index and name, or null. */\n    getAttachment(slotIndex: number, name: string): Attachment {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\n    removeAttachment(slotIndex: number, name: string) {\n        const dictionary = this.attachments[slotIndex];\n\n        if (dictionary) dictionary[name] = null;\n    }\n\n    /** Returns all attachments in this skin. */\n    getAttachments(): Array<SkinEntry> {\n        const entries = new Array<SkinEntry>();\n\n        for (let i = 0; i < this.attachments.length; i++) {\n            const slotAttachments = this.attachments[i];\n\n            if (slotAttachments) {\n                for (const name in slotAttachments) {\n                    const attachment = slotAttachments[name];\n\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\n                }\n            }\n        }\n\n        return entries;\n    }\n\n    /** Returns all attachments in this skin for the specified slot index. */\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n        const slotAttachments = this.attachments[slotIndex];\n\n        if (slotAttachments) {\n            for (const name in slotAttachments) {\n                const attachment = slotAttachments[name];\n\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n            }\n        }\n    }\n\n    /** Clears all attachments, bones, and constraints. */\n    clear() {\n        this.attachments.length = 0;\n        this.bones.length = 0;\n        this.constraints.length = 0;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { AttachmentType, BinaryInput, Color, PositionMode, Utils } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonBinary {\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n\n    attachmentLoader: AttachmentLoader = null;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(binary: Uint8Array): SkeletonData {\n        const scale = this.scale;\n\n        const skeletonData = new SkeletonData();\n\n        skeletonData.name = ''; // BOZO\n\n        const input = new BinaryInput(binary);\n\n        const lowHash = input.readInt32();\n        const highHash = input.readInt32();\n\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n        skeletonData.version = input.readString();\n        if (skeletonData.version.substr(0, 3) !== '4.0') {\n            const error = `Spine 4.0 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n\n            console.error(error);\n        }\n        skeletonData.x = input.readFloat();\n        skeletonData.y = input.readFloat();\n        skeletonData.width = input.readFloat();\n        skeletonData.height = input.readFloat();\n\n        const nonessential = input.readBoolean();\n\n        if (nonessential) {\n            skeletonData.fps = input.readFloat();\n\n            skeletonData.imagesPath = input.readString();\n            skeletonData.audioPath = input.readString();\n        }\n\n        let n = 0;\n        // Strings.\n\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) input.strings.push(input.readString());\n\n        // Bones.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const name = input.readString();\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n            const data = new BoneData(i, name, parent);\n\n            data.rotation = input.readFloat();\n            data.x = input.readFloat() * scale;\n            data.y = input.readFloat() * scale;\n            data.scaleX = input.readFloat();\n            data.scaleY = input.readFloat();\n            data.shearX = input.readFloat();\n            data.shearY = input.readFloat();\n            data.length = input.readFloat() * scale;\n            data.transformMode = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n            skeletonData.bones.push(data);\n        }\n\n        // Slots.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const slotName = input.readString();\n            const boneData = skeletonData.bones[input.readInt(true)];\n            const data = new SlotData(i, slotName, boneData);\n\n            Color.rgba8888ToColor(data.color, input.readInt32());\n\n            const darkColor = input.readInt32();\n\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\n\n            data.attachmentName = input.readStringRef();\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\n            skeletonData.slots.push(data);\n        }\n\n        // IK constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new IkConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.mix = input.readFloat();\n            data.softness = input.readFloat() * scale;\n            data.bendDirection = input.readByte();\n            data.compress = input.readBoolean();\n            data.stretch = input.readBoolean();\n            data.uniform = input.readBoolean();\n            skeletonData.ikConstraints.push(data);\n        }\n\n        // Transform constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new TransformConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.local = input.readBoolean();\n            data.relative = input.readBoolean();\n            data.offsetRotation = input.readFloat();\n            data.offsetX = input.readFloat() * scale;\n            data.offsetY = input.readFloat() * scale;\n            data.offsetScaleX = input.readFloat();\n            data.offsetScaleY = input.readFloat();\n            data.offsetShearY = input.readFloat();\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            data.mixScaleX = input.readFloat();\n            data.mixScaleY = input.readFloat();\n            data.mixShearY = input.readFloat();\n            skeletonData.transformConstraints.push(data);\n        }\n\n        // Path constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new PathConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.slots[input.readInt(true)];\n            data.positionMode = input.readInt(true);\n            data.spacingMode = input.readInt(true);\n            data.rotateMode = input.readInt(true);\n            data.offsetRotation = input.readFloat();\n            data.position = input.readFloat();\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n            data.spacing = input.readFloat();\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            skeletonData.pathConstraints.push(data);\n        }\n\n        // Default skin.\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\n        if (defaultSkin) {\n            skeletonData.defaultSkin = defaultSkin;\n            skeletonData.skins.push(defaultSkin);\n        }\n\n        // Skins.\n        {\n            let i = skeletonData.skins.length;\n\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\n            for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n        }\n\n        // Linked meshes.\n        n = this.linkedMeshes.length;\n        for (let i = 0; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? (parent as VertexAttachment) : linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const data = new EventData(input.readStringRef());\n\n            data.intValue = input.readInt(false);\n            data.floatValue = input.readFloat();\n            data.stringValue = input.readString();\n            data.audioPath = input.readString();\n            if (data.audioPath) {\n                data.volume = input.readFloat();\n                data.balance = input.readFloat();\n            }\n            skeletonData.events.push(data);\n        }\n\n        // Animations.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n\n        return skeletonData;\n    }\n\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\n        let skin = null;\n        let slotCount = 0;\n\n        if (defaultSkin) {\n            slotCount = input.readInt(true);\n            if (slotCount == 0) return null;\n            skin = new Skin('default');\n        } else {\n            skin = new Skin(input.readStringRef());\n            skin.bones.length = input.readInt(true);\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n            slotCount = input.readInt(true);\n        }\n\n        for (let i = 0; i < slotCount; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const name = input.readStringRef();\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\n            }\n        }\n\n        return skin;\n    }\n\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\n        const scale = this.scale;\n\n        let name = input.readStringRef();\n\n        if (!name) name = attachmentName;\n\n        switch (input.readByte()) {\n            case AttachmentType.Region: {\n                let path = input.readStringRef();\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const scaleX = input.readFloat();\n                const scaleY = input.readFloat();\n                const width = input.readFloat();\n                const height = input.readFloat();\n                const color = input.readInt32();\n\n                if (!path) path = name;\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = x * scale;\n                region.y = y * scale;\n                region.scaleX = scaleX;\n                region.scaleY = scaleY;\n                region.rotation = rotation;\n                region.width = width * scale;\n                region.height = height * scale;\n                Color.rgba8888ToColor(region.color, color);\n                // region.updateOffset();\n\n                return region;\n            }\n            case AttachmentType.BoundingBox: {\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                box.worldVerticesLength = vertexCount << 1;\n                box.vertices = vertices.vertices;\n                box.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\n\n                return box;\n            }\n            case AttachmentType.Mesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const vertexCount = input.readInt(true);\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n                const triangles = this.readShortArray(input);\n                const vertices = this.readVertices(input, vertexCount);\n                const hullLength = input.readInt(true);\n                let edges = null;\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    edges = this.readShortArray(input);\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.bones = vertices.bones;\n                mesh.vertices = vertices.vertices;\n                mesh.worldVerticesLength = vertexCount << 1;\n                mesh.triangles = triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n                mesh.hullLength = hullLength << 1;\n                if (nonessential) {\n                    mesh.edges = edges;\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n\n                return mesh;\n            }\n            case AttachmentType.LinkedMesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const skinName = input.readStringRef();\n                const parent = input.readStringRef();\n                const inheritDeform = input.readBoolean();\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                if (nonessential) {\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n\n                return mesh;\n            }\n            case AttachmentType.Path: {\n                const closed = input.readBoolean();\n                const constantSpeed = input.readBoolean();\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const lengths = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n                const color = nonessential ? input.readInt32() : 0;\n\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = closed;\n                path.constantSpeed = constantSpeed;\n                path.worldVerticesLength = vertexCount << 1;\n                path.vertices = vertices.vertices;\n                path.bones = vertices.bones;\n                path.lengths = lengths;\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\n\n                return path;\n            }\n            case AttachmentType.Point: {\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const color = nonessential ? input.readInt32() : 0;\n\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = x * scale;\n                point.y = y * scale;\n                point.rotation = rotation;\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\n\n                return point;\n            }\n            case AttachmentType.Clipping: {\n                const endSlotIndex = input.readInt(true);\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n                clip.endSlot = skeletonData.slots[endSlotIndex];\n                clip.worldVerticesLength = vertexCount << 1;\n                clip.vertices = vertices.vertices;\n                clip.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\n        const scale = this.scale;\n        const verticesLength = vertexCount << 1;\n        const vertices = new Vertices();\n\n        if (!input.readBoolean()) {\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\n            return vertices;\n        }\n        const weights = new Array<number>();\n        const bonesArray = new Array<number>();\n\n        for (let i = 0; i < vertexCount; i++) {\n            const boneCount = input.readInt(true);\n\n            bonesArray.push(boneCount);\n            for (let ii = 0; ii < boneCount; ii++) {\n                bonesArray.push(input.readInt(true));\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat());\n            }\n        }\n        vertices.vertices = Utils.toFloatArray(weights);\n        vertices.bones = bonesArray;\n\n        return vertices;\n    }\n\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\n        const array = new Array<number>(n);\n\n        if (scale == 1) {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\n        } else {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n        }\n\n        return array;\n    }\n\n    private readShortArray(input: BinaryInput): number[] {\n        const n = input.readInt(true);\n        const array = new Array<number>(n);\n\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\n\n        return array;\n    }\n\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n        input.readInt(true); // Number of timelines.\n        const timelines = new Array<Timeline>();\n        const scale = this.scale;\n\n        // Slot timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n                const frameLast = frameCount - 1;\n\n                switch (timelineType) {\n                    case SLOT_ATTACHMENT: {\n                        const timeline = new AttachmentTimeline(frameCount, slotIndex);\n\n                        for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n                            const a2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const na = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            a = na;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_ALPHA: {\n                        const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n                        let time = input.readFloat();\n                        let a = input.readUnsignedByte() / 255;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, a);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const a2 = input.readUnsignedByte() / 255;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const boneIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const type = input.readByte();\n                const frameCount = input.readInt(true);\n                const bezierCount = input.readInt(true);\n\n                switch (type) {\n                    case BONE_ROTATE:\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_TRANSLATE:\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEX:\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEY:\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_SCALE:\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEX:\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEY:\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEAR:\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARX:\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARY:\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mix = input.readFloat();\n            let softness = input.readFloat() * scale;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mix2 = input.readFloat();\n                const softness2 = input.readFloat() * scale;\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n                }\n                time = time2;\n                mix = mix2;\n                softness = softness2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Transform constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            let mixScaleX = input.readFloat();\n            let mixScaleY = input.readFloat();\n            let mixShearY = input.readFloat();\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mixRotate2 = input.readFloat();\n                const mixX2 = input.readFloat();\n                const mixY2 = input.readFloat();\n                const mixScaleX2 = input.readFloat();\n                const mixScaleY2 = input.readFloat();\n                const mixShearY2 = input.readFloat();\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                }\n                time = time2;\n                mixRotate = mixRotate2;\n                mixX = mixX2;\n                mixY = mixY2;\n                mixScaleX = mixScaleX2;\n                mixScaleY = mixScaleY2;\n                mixShearY = mixShearY2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Path constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const data = skeletonData.pathConstraints[index];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                switch (input.readByte()) {\n                    case PATH_POSITION:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                                data.positionMode == PositionMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_SPACING:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_MIX:\n                        const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n                        let time = input.readFloat();\n                        let mixRotate = input.readFloat();\n                        let mixX = input.readFloat();\n                        let mixY = input.readFloat();\n\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const mixRotate2 = input.readFloat();\n                            const mixX2 = input.readFloat();\n                            const mixY2 = input.readFloat();\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                        }\n                        timelines.push(timeline);\n                }\n            }\n        }\n\n        // Deform timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const skin = skeletonData.skins[input.readInt(true)];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const slotIndex = input.readInt(true);\n\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n                    const attachmentName = input.readStringRef();\n                    const attachment = skin.getAttachment(slotIndex, attachmentName) as VertexAttachment;\n                    const weighted = attachment.bones;\n                    const vertices = attachment.vertices;\n                    const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                    const frameCount = input.readInt(true);\n                    const frameLast = frameCount - 1;\n                    const bezierCount = input.readInt(true);\n                    const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, attachment);\n\n                    let time = input.readFloat();\n\n                    for (let frame = 0, bezier = 0; ; frame++) {\n                        let deform;\n                        let end = input.readInt(true);\n\n                        if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                        else {\n                            deform = Utils.newFloatArray(deformLength);\n                            const start = input.readInt(true);\n\n                            end += start;\n                            if (scale == 1) {\n                                // eslint-disable-next-line max-depth\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                            } else {\n                                // eslint-disable-next-line max-depth\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                            }\n                            if (!weighted) {\n                                // eslint-disable-next-line max-depth\n                                for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                            }\n                        }\n\n                        timeline.setFrame(frame, time, deform);\n                        if (frame == frameLast) break;\n                        const time2 = input.readFloat();\n\n                        switch (input.readByte()) {\n                            case CURVE_STEPPED:\n                                timeline.setStepped(frame);\n                                break;\n                            case CURVE_BEZIER:\n                                setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                        }\n                        time = time2;\n                    }\n                    timelines.push(timeline);\n                }\n            }\n        }\n\n        // Draw order timeline.\n        const drawOrderCount = input.readInt(true);\n\n        if (drawOrderCount > 0) {\n            const timeline = new DrawOrderTimeline(drawOrderCount);\n            const slotCount = skeletonData.slots.length;\n\n            for (let i = 0; i < drawOrderCount; i++) {\n                const time = input.readFloat();\n                const offsetCount = input.readInt(true);\n                const drawOrder = Utils.newArray(slotCount, 0);\n\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n                let originalIndex = 0;\n                let unchangedIndex = 0;\n\n                for (let ii = 0; ii < offsetCount; ii++) {\n                    const slotIndex = input.readInt(true);\n                    // Collect unchanged items.\n\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                    // Set changed items.\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n                }\n                // Collect remaining unchanged items.\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                // Fill in unchanged items.\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                timeline.setFrame(i, time, drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timeline.\n        const eventCount = input.readInt(true);\n\n        if (eventCount > 0) {\n            const timeline = new EventTimeline(eventCount);\n\n            for (let i = 0; i < eventCount; i++) {\n                const time = input.readFloat();\n                const eventData = skeletonData.events[input.readInt(true)];\n                const event = new Event(time, eventData);\n\n                event.intValue = input.readInt(false);\n                event.floatValue = input.readFloat();\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n                if (event.data.audioPath) {\n                    event.volume = input.readFloat();\n                    event.balance = input.readFloat();\n                }\n                timeline.setFrame(i, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n\n        return new Animation(name, timelines, duration);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n\nclass Vertices {\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) {}\n}\n\nfunction readTimeline1(input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\n    let time = input.readFloat();\n    let value = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const value2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n        }\n        time = time2;\n        value = value2;\n    }\n\n    return timeline;\n}\n\nfunction readTimeline2(input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\n    let time = input.readFloat();\n    let value1 = input.readFloat() * scale;\n    let value2 = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const nvalue1 = input.readFloat() * scale;\n        const nvalue2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n    }\n\n    return timeline;\n}\n\nfunction setBezier(\n    input: BinaryInput,\n    timeline: CurveTimeline,\n    bezier: number,\n    frame: number,\n    value: number,\n    time1: number,\n    time2: number,\n    value1: number,\n    value2: number,\n    scale: number\n) {\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\n\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\n\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\n\n// @ts-ignore\nconst CURVE_LINEAR = 0;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n","import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n","import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { NumberArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader = null;\n\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            if (skeletonData.version.substr(0, 3) !== '4.0') {\n                const error = `Spine 4.0 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = getValue(boneMap, 'length', 0) * scale;\n                data.x = getValue(boneMap, 'x', 0) * scale;\n                data.y = getValue(boneMap, 'y', 0) * scale;\n                data.rotation = getValue(boneMap, 'rotation', 0);\n                data.scaleX = getValue(boneMap, 'scaleX', 1);\n                data.scaleY = getValue(boneMap, 'scaleY', 1);\n                data.shearX = getValue(boneMap, 'shearX', 0);\n                data.shearY = getValue(boneMap, 'shearY', 0);\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\n                data.skinRequired = getValue(boneMap, 'skin', false);\n\n                const color = getValue(boneMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const boneData = skeletonData.findBone(slotMap.bone);\n                const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n\n                const color: string = getValue(slotMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                const dark: string = getValue(slotMap, 'dark', null);\n\n                if (dark) data.darkColor = Color.fromString(dark);\n\n                data.attachmentName = getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                data.target = skeletonData.findBone(constraintMap.target);\n\n                data.mix = getValue(constraintMap, 'mix', 1);\n                data.softness = getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = getValue(constraintMap, 'compress', false);\n                data.stretch = getValue(constraintMap, 'stretch', false);\n                data.uniform = getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = getValue(constraintMap, 'local', false);\n                data.relative = getValue(constraintMap, 'relative', false);\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.offsetX = getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = getValue(constraintMap, 'shearY', 0);\n\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n                data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\n                data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\n                data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.position = getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\n\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = getValue(eventMap, 'int', 0);\n                data.floatValue = getValue(eventMap, 'float', 0);\n                data.stringValue = getValue(eventMap, 'string', '');\n                data.audioPath = getValue(eventMap, 'audio', null);\n                if (data.audioPath) {\n                    data.volume = getValue(eventMap, 'volume', 1);\n                    data.balance = getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = getValue(map, 'name', name);\n\n        switch (getValue(map, 'type', 'region')) {\n            case 'region': {\n                const path = getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = getValue(map, 'x', 0) * scale;\n                region.y = getValue(map, 'y', 0) * scale;\n                region.scaleX = getValue(map, 'scaleX', 1);\n                region.scaleY = getValue(map, 'scaleY', 1);\n                region.rotation = getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = getValue(map, 'color', null);\n\n                if (color) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (!mesh) return null;\n                mesh.path = path;\n\n                const color = getValue(map, 'color', null);\n\n                if (color) mesh.color.setFromString(color);\n\n                mesh.width = getValue(map, 'width', 0) * scale;\n                mesh.height = getValue(map, 'height', 0) * scale;\n\n                const parent: string = getValue(map, 'parent', null);\n\n                if (parent) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, 'skin', null), slotIndex, parent, getValue(map, 'deform', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.edges = getValue(map, 'edges', null);\n                mesh.hullLength = getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = getValue(map, 'closed', false);\n                path.constantSpeed = getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = getValue(map, 'x', 0) * scale;\n                point.y = getValue(map, 'y', 0) * scale;\n                point.rotation = getValue(map, 'rotation', 0);\n\n                const color = getValue(map, 'color', null);\n\n                if (color) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n\n                const end = getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlot(slotName).index;\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (!timelineMap) continue;\n                    const frames = timelineMap.length;\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(frames, slotIndex);\n\n                        for (let frame = 0; frame < frames; frame++) {\n                            const keyMap = timelineMap[frame];\n\n                            timeline.setFrame(frame, getValue(keyMap, 'time', 0), keyMap.name);\n                        }\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgba') {\n                        const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb') {\n                        const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'alpha') {\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n                    } else if (timelineName == 'rgba2') {\n                        const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb2') {\n                        const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBone(boneName).index;\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n                    const frames = timelineMap.length;\n\n                    if (frames == 0) continue;\n\n                    if (timelineName === 'rotate') {\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n                    } else if (timelineName === 'translate') {\n                        const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\n                    } else if (timelineName === 'translatex') {\n                        const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'translatey') {\n                        const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'scale') {\n                        const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\n                    } else if (timelineName === 'scalex') {\n                        const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'scaley') {\n                        const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'shear') {\n                        const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\n                    } else if (timelineName === 'shearx') {\n                        const timeline = new ShearXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    } else if (timelineName === 'sheary') {\n                        const timeline = new ShearYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    }\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                let keyMap = constraintMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mix = getValue(keyMap, 'mix', 1);\n                let softness = getValue(keyMap, 'softness', 0) * scale;\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(\n                        frame,\n                        time,\n                        mix,\n                        softness,\n                        getValue(keyMap, 'bendPositive', true) ? 1 : -1,\n                        getValue(keyMap, 'compress', false),\n                        getValue(keyMap, 'stretch', false)\n                    );\n                    const nextMap = constraintMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mix2 = getValue(nextMap, 'mix', 1);\n                    const softness2 = getValue(nextMap, 'softness', 0) * scale;\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n                    }\n\n                    time = time2;\n                    mix = mix2;\n                    softness = softness2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const timelineMap = map.transform[constraintName];\n                let keyMap = timelineMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                let mixX = getValue(keyMap, 'mixX', 1);\n                let mixY = getValue(keyMap, 'mixY', mixX);\n                let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\n                let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\n                const mixShearY = getValue(keyMap, 'mixShearY', 1);\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                    const nextMap = timelineMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                    const mixX2 = getValue(nextMap, 'mixX', 1);\n                    const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                    const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\n                    const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\n                    const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                    }\n\n                    time = time2;\n                    mixRotate = mixRotate2;\n                    mixX = mixX2;\n                    mixY = mixY2;\n                    mixScaleX = mixScaleX2;\n                    mixScaleY = mixScaleY2;\n                    mixScaleX = mixScaleX2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const constraintIndex = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (constraintIndex == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const constraint = skeletonData.pathConstraints[constraintIndex];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n                    let keyMap = timelineMap[0];\n\n                    if (!keyMap) continue;\n\n                    const frames = timelineMap.length;\n\n                    if (timelineName === 'position') {\n                        const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n                    } else if (timelineName === 'spacing') {\n                        const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(\n                            readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\n                        );\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n                        let time = getValue(keyMap, 'time', 0);\n                        let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                        let mixX = getValue(keyMap, 'mixX', 1);\n                        let mixY = getValue(keyMap, 'mixY', mixX);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                            const mixX2 = getValue(nextMap, 'mixX', 1);\n                            const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlot(slotName).index;\n\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        let keyMap = timelineMap[0];\n\n                        if (!keyMap) continue;\n\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                        const weighted = attachment.bones;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                        let time = getValue(keyMap, 'time', 0);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            let deform: NumberArrayLike;\n                            const verticesValue: Array<Number> = getValue(keyMap, 'vertices', null);\n\n                            if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>getValue(keyMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frame, time, deform);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const curve = keyMap.curve;\n\n                            if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                            time = time2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Draw order timelines.\n        if (map.drawOrder) {\n            const timeline = new DrawOrderTimeline(map.drawOrder.length);\n            const slotCount = skeletonData.slots.length;\n            let frame = 0;\n\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n                const drawOrderMap = map.drawOrder[i];\n                let drawOrder: Array<number> = null;\n                const offsets = getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let ii = 0; ii < offsets.length; ii++) {\n                        const offsetMap = offsets[ii];\n                        const slotIndex = skeletonData.findSlot(offsetMap.slot).index;\n                        // Collect unchanged items.\n\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timelines.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frame = 0;\n\n            for (let i = 0; i < map.events.length; i++, frame++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n                const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath) {\n                    event.volume = getValue(eventMap, 'volume', 1);\n                    event.balance = getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frame, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value = getValue(keyMap, 'value', defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const value2 = getValue(nextMap, 'value', defaultValue) * scale;\n\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n        time = time2;\n        value = value2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readTimeline2(keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n        const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n        const curve = keyMap.curve;\n\n        if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readCurve(curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number, value1: number, value2: number, scale: number) {\n    if (curve == 'stepped') {\n        timeline.setStepped(frame);\n\n        return bezier;\n    }\n    const i = value << 2;\n    const cx1 = curve[i];\n    const cy1 = curve[i + 1] * scale;\n    const cx2 = curve[i + 2];\n    const cy2 = curve[i + 3] * scale;\n\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n\n    return bezier + 1;\n}\n\nfunction getValue(map: any, property: string, defaultValue: any) {\n    return map[property] !== undefined ? map[property] : defaultValue;\n}\n","import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n"],"names":["Attachment","name","_VertexAttachment","slot","worldVertices","start","count","offset","stride","skeleton","deformArray","vertices","bones","mat","x","y","a","b","c","d","v","w","vx","vy","skip","i","n","skeletonBones","wx","wy","weight","deform","f","attachment","Utils","VertexAttachment","BoundingBoxAttachment","AttachmentType","Color","copy","ClippingAttachment","MeshAttachment","parentMesh","PathAttachment","PointAttachment","bone","point","cos","MathUtils","sin","Slot","data","time","_RegionAttachment","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","region","uvs","vertexOffset","offsetX","offsetY","RegionAttachment","JitterEffect","jitterX","jitterY","position","uv","light","dark","_SwirlEffect","radius","radAngle","dist","theta","SwirlEffect","PowOut","Animation","timelines","duration","StringSet","ids","lastTime","loop","events","alpha","blend","direction","Property","Timeline","frameCount","propertyIds","frames","step","CurveTimeline","bezierCount","frame","size","newCurves","bezier","value","time1","value1","cx1","cy1","cx2","cy2","time2","value2","curves","tmpx","tmpy","dddx","dddy","ddx","ddy","dx","dy","frameIndex","valueOffset","CurveTimeline1","propertyId","ii","curveType","before","CurveTimeline2","propertyId1","propertyId2","RotateTimeline","boneIndex","MixBlend","r","TranslateTimeline","t","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","bx","by","MixDirection","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","RGBATimeline","slotIndex","g","color","setup","RGBTimeline","AlphaTimeline","RGBA2Timeline","r2","g2","b2","setupLight","setupDark","RGB2Timeline","AttachmentTimeline","attachmentName","DeformTimeline","firedEvents","slotAttachment","vertexCount","vertexAttachment","setupVertices","lastVertices","percent","prevVertices","nextVertices","prev","_EventTimeline","event","frameTime","EventTimeline","_DrawOrderTimeline","drawOrder","drawOrderToSetupIndex","slots","DrawOrderTimeline","IkConstraintTimeline","ikConstraintIndex","mix","softness","bendDirection","compress","stretch","constraint","TransformConstraintTimeline","transformConstraintIndex","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","rotate","scaleX","scaleY","shearY","PathConstraintPositionTimeline","pathConstraintIndex","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","_AnimationState","EventQueue","Pool","TrackEntry","_emptyAnimation","delta","tracks","current","currentDelta","next","nextTime","from","to","finished","applied","animationLast","animationTime","applyTime","applyEvents","timelineCount","timeline","timelineMode","firstFrame","timelineBlend","SUBSEQUENT","setupState","SETUP","attachments","alphaHold","alphaMix","timelineHoldMix","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","CURRENT","timelinesRotation","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","oldDrainDisabled","trackIndex","index","interrupt","animationName","animation","delay","last","mixDuration","timelinesCount","propertyIDs","outer","HOLD_MIX","listener","AnimationState","_TrackEntry","animState","EventType","objects","listeners","type","AnimationStateAdapter","AnimationStateData","skeletonData","fromName","toName","key","AtlasAttachmentLoader","atlas","skin","path","Bone","parent","Matrix","rotation","shearX","m","sx","sy","settings","rotationY","pa","pb","pc","pd","TransformMode","la","lb","lc","ld","s","prx","rx","ry","za","zc","zb","zd","pm","pid","ia","id","ib","ic","ra","rb","rc","rd","det","world","invDet","local","worldRotation","localRotation","degrees","BoneData","ConstraintData","order","skinRequired","Event","EventData","IkConstraint","target","targetX","targetY","uniform","p","rotationIK","tx","ty","skelX","skelY","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","l1","l2","a1","a2","td","sd","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraintData","SpacingMode","_PathConstraint","tangents","RotateMode","scale","boneCount","spacesCount","spaces","lengths","setupLength","sum","length","lengthSpacing","positions","boneX","boneY","offsetRotation","tip","out","closed","verticesLength","curveCount","prevCurve","pathLength","PositionMode","multiplier","o","curve","space","x1","y1","x2","y2","dddfx","dddfy","ddfx","ddfy","dfx","dfy","segments","curveLength","segment","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraint","TransformConstraint","Vector2","translate","targetMat","tb","tc","degRadReflect","offsetShearY","_Skeleton","boneData","slotData","ikConstraintData","transformConstraintData","pathConstraintData","updateCache","skinBones","ikConstraints","transformConstraints","pathConstraints","ikCount","transformCount","pathCount","constraintCount","constrained","slotBone","pathBones","nn","rootBone","updatable","boneName","slotName","skinName","newSkin","constraintName","ikConstraint","mesh","Skeleton","SkeletonData","skins","eventDataName","animations","pathConstraintName","SlotData","TransformConstraintData","SkinEntry","Skin","contained","dictionary","entries","slotAttachments","oldSkin","skinAttachment","_SkeletonBinary","attachmentLoader","binary","input","BinaryInput","lowHash","highHash","error","nonessential","darkColor","defaultSkin","linkedMesh","slotCount","width","height","box","triangles","hullLength","edges","inheritDeform","LinkedMesh","constantSpeed","endSlotIndex","clip","Vertices","weights","bonesArray","array","timelineType","frameLast","SLOT_ATTACHMENT","SLOT_RGBA","CURVE_STEPPED","CURVE_BEZIER","setBezier","SLOT_RGB","SLOT_RGBA2","nr","ng","nb","na","nr2","ng2","nb2","SLOT_RGB2","SLOT_ALPHA","BONE_ROTATE","readTimeline1","BONE_TRANSLATE","readTimeline2","BONE_TRANSLATEX","BONE_TRANSLATEY","BONE_SCALE","BONE_SCALEX","BONE_SCALEY","BONE_SHEAR","BONE_SHEARX","BONE_SHEARY","mix2","softness2","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PATH_POSITION","PATH_SPACING","PATH_MIX","iii","nnn","weighted","deformLength","end","vn","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","SkeletonBinary","BLEND_MODES","nvalue1","nvalue2","CURVE_LINEAR","SkeletonBounds","SkeletonBoundsBase","SkeletonJson","json","root","skeletonMap","boneMap","parentName","getValue","slotMap","constraintMap","targetName","skinMap","entryName","eventName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","keyMap","nextMap","newColor","readCurve","color2","newColor2","constraintIndex","deformName","deformMap","verticesValue","drawOrderMap","offsets","offsetMap","str","keys","defaultValue","name1","name2","property","Spine","SpineBase","spineData"],"mappings":"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"}