/*!
 * @pixi-spine/runtime-4.0 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-4.0 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine40=function(F,u,rt){"use strict";class Pt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Ae=class extends Pt{constructor(s){super(s),this.id=Ae.nextID++,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(s,t){this.computeWorldVertices(s,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(s,t,i,e,r,o){i=r+(i>>1)*o;const d=s.bone.skeleton,h=s.deform;let n=this.vertices;const a=this.bones;if(!a){h.length>0&&(n=h);const f=s.bone.matrix,g=f.tx,x=f.ty,y=f.a,M=f.c,p=f.b,S=f.d;for(let k=t,w=r;w<i;k+=2,w+=o){const B=n[k],Y=n[k+1];e[w]=B*y+Y*M+g,e[w+1]=B*p+Y*S+x}return}let l=0,c=0;for(let f=0;f<t;f+=2){const g=a[l];l+=g+1,c+=g}const m=d.bones;if(h.length==0)for(let f=r,g=c*3;f<i;f+=o){let x=0,y=0,M=a[l++];for(M+=l;l<M;l++,g+=3){const p=m[a[l]].matrix,S=n[g],k=n[g+1],w=n[g+2];x+=(S*p.a+k*p.c+p.tx)*w,y+=(S*p.b+k*p.d+p.ty)*w}e[f]=x,e[f+1]=y}else{const f=h;for(let g=r,x=c*3,y=c<<1;g<i;g+=o){let M=0,p=0,S=a[l++];for(S+=l;l<S;l++,x+=3,y+=2){const k=m[a[l]].matrix,w=n[x]+f[y],B=n[x+1]+f[y+1],Y=n[x+2];M+=(w*k.a+B*k.c+k.tx)*Y,p+=(w*k.b+B*k.d+k.ty)*Y}e[g]=M,e[g+1]=p}}}copyTo(s){this.bones?(s.bones=new Array(this.bones.length),u.Utils.arrayCopy(this.bones,0,s.bones,0,this.bones.length)):s.bones=null,this.vertices?(s.vertices=u.Utils.newFloatArray(this.vertices.length),u.Utils.arrayCopy(this.vertices,0,s.vertices,0,this.vertices.length)):s.vertices=null,s.worldVerticesLength=this.worldVerticesLength,s.deformAttachment=this.deformAttachment}};let ut=Ae;ut.nextID=0;class It extends ut{constructor(t){super(t),this.type=u.AttachmentType.BoundingBox,this.color=new u.Color(1,1,1,1)}copy(){const t=new It(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Xt extends ut{constructor(t){super(t),this.type=u.AttachmentType.Clipping,this.color=new u.Color(.2275,.2275,.8078,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class ft extends ut{constructor(t){super(t),this.type=u.AttachmentType.Mesh,this.color=new u.Color(1,1,1,1),this.tempColor=new u.Color(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new ft(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),u.Utils.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),u.Utils.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges&&(t.edges=new Array(this.edges.length),u.Utils.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new ft(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class gt extends ut{constructor(t){super(t),this.type=u.AttachmentType.Path,this.closed=!1,this.constantSpeed=!1,this.color=new u.Color(1,1,1,1)}copy(){const t=new gt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),u.Utils.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Ct extends ut{constructor(t){super(t),this.type=u.AttachmentType.Point,this.color=new u.Color(.38,.94,0,1)}computeWorldPosition(t,i){const e=t.matrix;return i.x=this.x*e.a+this.y*e.c+t.worldX,i.y=this.x*e.b+this.y*e.d+t.worldY,i}computeWorldRotation(t){const i=t.matrix,e=u.MathUtils.cosDeg(this.rotation),r=u.MathUtils.sinDeg(this.rotation),o=e*i.a+r*i.c,d=e*i.b+r*i.d;return Math.atan2(d,o)*u.MathUtils.radDeg}copy(){const t=new Ct(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class Vt{constructor(t,i){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(i==null)throw new Error("bone cannot be null.");this.data=t,this.bone=i,this.color=new u.Color,this.darkColor=t.darkColor==null?null:new u.Color,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const G=class extends Pt{constructor(s){super(s),this.type=u.AttachmentType.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new u.Color(1,1,1,1),this.offset=u.Utils.newFloatArray(8),this.uvs=u.Utils.newFloatArray(8),this.tempColor=new u.Color(1,1,1,1)}updateOffset(){const s=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,i=-this.width/2*this.scaleX+this.region.offsetX*s,e=-this.height/2*this.scaleY+this.region.offsetY*t,r=i+this.region.width*s,o=e+this.region.height*t,d=this.rotation*Math.PI/180,h=Math.cos(d),n=Math.sin(d),a=i*h+this.x,l=i*n,c=e*h+this.y,m=e*n,f=r*h+this.x,g=r*n,x=o*h+this.y,y=o*n,M=this.offset;M[G.OX1]=a-m,M[G.OY1]=c+l,M[G.OX2]=a-y,M[G.OY2]=x+l,M[G.OX3]=f-y,M[G.OY3]=x+g,M[G.OX4]=f-m,M[G.OY4]=c+g}setRegion(s){this.region=s;const t=this.uvs;s.degrees==90?(t[2]=s.u,t[3]=s.v2,t[4]=s.u,t[5]=s.v,t[6]=s.u2,t[7]=s.v,t[0]=s.u2,t[1]=s.v2):(t[0]=s.u,t[1]=s.v2,t[2]=s.u,t[3]=s.v,t[4]=s.u2,t[5]=s.v,t[6]=s.u2,t[7]=s.v2)}computeWorldVertices(s,t,i,e){const r=this.offset,o=s instanceof Vt?s.bone.matrix:s.matrix,d=o.tx,h=o.ty,n=o.a,a=o.c,l=o.b,c=o.d;let m=0,f=0;m=r[G.OX1],f=r[G.OY1],t[i]=m*n+f*a+d,t[i+1]=m*l+f*c+h,i+=e,m=r[G.OX2],f=r[G.OY2],t[i]=m*n+f*a+d,t[i+1]=m*l+f*c+h,i+=e,m=r[G.OX3],f=r[G.OY3],t[i]=m*n+f*a+d,t[i+1]=m*l+f*c+h,i+=e,m=r[G.OX4],f=r[G.OY4],t[i]=m*n+f*a+d,t[i+1]=m*l+f*c+h}copy(){const s=new G(this.name);return s.region=this.region,s.rendererObject=this.rendererObject,s.path=this.path,s.x=this.x,s.y=this.y,s.scaleX=this.scaleX,s.scaleY=this.scaleY,s.rotation=this.rotation,s.width=this.width,s.height=this.height,u.Utils.arrayCopy(this.uvs,0,s.uvs,0,8),u.Utils.arrayCopy(this.offset,0,s.offset,0,8),s.color.setFromColor(this.color),s}};let D=G;D.OX1=0,D.OY1=1,D.OX2=2,D.OY2=3,D.OX3=4,D.OY3=5,D.OX4=6,D.OY4=7,D.X1=0,D.Y1=1,D.C1R=2,D.C1G=3,D.C1B=4,D.C1A=5,D.U1=6,D.V1=7,D.X2=8,D.Y2=9,D.C2R=10,D.C2G=11,D.C2B=12,D.C2A=13,D.U2=14,D.V2=15,D.X3=16,D.Y3=17,D.C3R=18,D.C3G=19,D.C3B=20,D.C3A=21,D.U3=22,D.V3=23,D.X4=24,D.Y4=25,D.C4R=26,D.C4G=27,D.C4B=28,D.C4A=29,D.U4=30,D.V4=31;class je{constructor(t,i){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=i}begin(t){}transform(t,i,e,r){t.x+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY),t.y+=u.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Ye=class{constructor(s){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=s}begin(s){this.worldX=s.x+this.centerX,this.worldY=s.y+this.centerY}transform(s,t,i,e){const r=this.angle*u.MathUtils.degreesToRadians,o=s.x-this.worldX,d=s.y-this.worldY,h=Math.sqrt(o*o+d*d);if(h<this.radius){const n=Ye.interpolation.apply(0,r,(this.radius-h)/this.radius),a=Math.cos(n),l=Math.sin(n);s.x=a*o-l*d+this.worldX,s.y=l*o+a*d+this.worldY}}end(){}};let Ie=Ye;Ie.interpolation=new u.PowOut(2);class Tt{constructor(t,i,e){if(this.timelines=null,this.timelineIds=null,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(i),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds=new u.StringSet;for(let i=0;i<t.length;i++)this.timelineIds.addAll(t[i].getPropertyIds())}hasTimeline(t){for(let i=0;i<t.length;i++)if(this.timelineIds.contains(t[i]))return!0;return!1}apply(t,i,e,r,o,d,h,n){if(!t)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,i>0&&(i%=this.duration));const a=this.timelines;for(let l=0,c=a.length;l<c;l++)a[l].apply(t,i,e,o,d,h,n)}}const $={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18};class j{constructor(t,i){this.propertyIds=null,this.frames=null,this.propertyIds=i,this.frames=u.Utils.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,i){const e=t.length;for(let r=1;r<e;r++)if(t[r]>i)return r-1;return e-1}static search(t,i,e){const r=t.length;for(let o=e;o<r;o+=e)if(t[o]>i)return o-e;return r-e}}class tt extends j{constructor(t,i,e){super(t,e),this.curves=null,this.curves=u.Utils.newFloatArray(t+i*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const i=this.getFrameCount()+t*18;if(this.curves.length>i){const e=u.Utils.newFloatArray(i);u.Utils.arrayCopy(this.curves,0,e,0,i),this.curves=e}}setBezier(t,i,e,r,o,d,h,n,a,l,c){const m=this.curves;let f=this.getFrameCount()+t*18;e==0&&(m[i]=2+f);const g=(r-d*2+n)*.03,x=(o-h*2+a)*.03,y=((d-n)*3-r+l)*.006,M=((h-a)*3-o+c)*.006;let p=g*2+y,S=x*2+M,k=(d-r)*.3+g+y*.16666667,w=(h-o)*.3+x+M*.16666667,B=r+k,Y=o+w;for(let X=f+18;f<X;f+=2)m[f]=B,m[f+1]=Y,k+=p,w+=S,p+=y,S+=M,B+=k,Y+=w}getBezierValue(t,i,e,r){const o=this.curves;if(o[r]>t){const a=this.frames[i],l=this.frames[i+e];return l+(t-a)/(o[r]-a)*(o[r+1]-l)}const d=r+18;for(r+=2;r<d;r+=2)if(o[r]>=t){const a=o[r-2],l=o[r-1];return l+(t-a)/(o[r]-a)*(o[r+1]-l)}i+=this.getFrameEntries();const h=o[d-2],n=o[d-1];return n+(t-h)/(this.frames[i]-h)*(this.frames[i+e]-n)}}class et extends tt{constructor(t,i,e){super(t,i,[e])}getFrameEntries(){return 2}setFrame(t,i,e){t<<=1,this.frames[t]=i,this.frames[t+1]=e}getCurveValue(t){const i=this.frames;let e=i.length-2;for(let o=2;o<=e;o+=2)if(i[o]>t){e=o-2;break}const r=this.curves[e>>1];switch(r){case 0:const o=i[e],d=i[e+1];return d+(t-o)/(i[e+2]-o)*(i[e+2+1]-d);case 1:return i[e+1]}return this.getBezierValue(t,e,1,r-2)}}class bt extends tt{constructor(t,i,e,r){super(t,i,[e,r])}getFrameEntries(){return 3}setFrame(t,i,e,r){t*=3,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r}}class kt extends et{constructor(t,i,e){super(t,i,`${$.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.rotation=n.data.rotation;return;case u.MixBlend.first:n.rotation+=(n.data.rotation-n.rotation)*o}return}let l=this.getCurveValue(e);switch(d){case u.MixBlend.setup:n.rotation=n.data.rotation+l*o;break;case u.MixBlend.first:case u.MixBlend.replace:l+=n.data.rotation-n.rotation;case u.MixBlend.add:n.rotation+=l*o}}}class Lt extends bt{constructor(t,i,e){super(t,i,`${$.x}|${e}`,`${$.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.x=n.data.x,n.y=n.data.y;return;case u.MixBlend.first:n.x+=(n.data.x-n.x)*o,n.y+=(n.data.y-n.y)*o}return}let l=0,c=0;const m=j.search(a,e,3),f=this.curves[m/3];switch(f){case 0:const g=a[m];l=a[m+1],c=a[m+2];const x=(e-g)/(a[m+3]-g);l+=(a[m+3+1]-l)*x,c+=(a[m+3+2]-c)*x;break;case 1:l=a[m+1],c=a[m+2];break;default:l=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}switch(d){case u.MixBlend.setup:n.x=n.data.x+l*o,n.y=n.data.y+c*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.x+=(n.data.x+l-n.x)*o,n.y+=(n.data.y+c-n.y)*o;break;case u.MixBlend.add:n.x+=l*o,n.y+=c*o}}}class Nt extends et{constructor(t,i,e){super(t,i,`${$.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.x=n.data.x;return;case u.MixBlend.first:n.x+=(n.data.x-n.x)*o}return}const l=this.getCurveValue(e);switch(d){case u.MixBlend.setup:n.x=n.data.x+l*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.x+=(n.data.x+l-n.x)*o;break;case u.MixBlend.add:n.x+=l*o}}}class Wt extends et{constructor(t,i,e){super(t,i,`${$.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.y=n.data.y;return;case u.MixBlend.first:n.y+=(n.data.y-n.y)*o}return}const l=this.getCurveValue(e);switch(d){case u.MixBlend.setup:n.y=n.data.y+l*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.y+=(n.data.y+l-n.y)*o;break;case u.MixBlend.add:n.y+=l*o}}}class $t extends bt{constructor(t,i,e){super(t,i,`${$.scaleX}|${e}`,`${$.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case u.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*o,n.scaleY+=(n.data.scaleY-n.scaleY)*o}return}let l,c;const m=j.search(a,e,3),f=this.curves[m/3];switch(f){case 0:const g=a[m];l=a[m+1],c=a[m+2];const x=(e-g)/(a[m+3]-g);l+=(a[m+3+1]-l)*x,c+=(a[m+3+2]-c)*x;break;case 1:l=a[m+1],c=a[m+2];break;default:l=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}if(l*=n.data.scaleX,c*=n.data.scaleY,o==1)d==u.MixBlend.add?(n.scaleX+=l-n.data.scaleX,n.scaleY+=c-n.data.scaleY):(n.scaleX=l,n.scaleY=c);else{let g=0,x=0;if(h==u.MixDirection.mixOut)switch(d){case u.MixBlend.setup:g=n.data.scaleX,x=n.data.scaleY,n.scaleX=g+(Math.abs(l)*u.MathUtils.signum(g)-g)*o,n.scaleY=x+(Math.abs(c)*u.MathUtils.signum(x)-x)*o;break;case u.MixBlend.first:case u.MixBlend.replace:g=n.scaleX,x=n.scaleY,n.scaleX=g+(Math.abs(l)*u.MathUtils.signum(g)-g)*o,n.scaleY=x+(Math.abs(c)*u.MathUtils.signum(x)-x)*o;break;case u.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*o,n.scaleY+=(c-n.data.scaleY)*o}else switch(d){case u.MixBlend.setup:g=Math.abs(n.data.scaleX)*u.MathUtils.signum(l),x=Math.abs(n.data.scaleY)*u.MathUtils.signum(c),n.scaleX=g+(l-g)*o,n.scaleY=x+(c-x)*o;break;case u.MixBlend.first:case u.MixBlend.replace:g=Math.abs(n.scaleX)*u.MathUtils.signum(l),x=Math.abs(n.scaleY)*u.MathUtils.signum(c),n.scaleX=g+(l-g)*o,n.scaleY=x+(c-x)*o;break;case u.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*o,n.scaleY+=(c-n.data.scaleY)*o}}}}class Ot extends et{constructor(t,i,e){super(t,i,`${$.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.scaleX=n.data.scaleX;return;case u.MixBlend.first:n.scaleX+=(n.data.scaleX-n.scaleX)*o}return}const l=this.getCurveValue(e)*n.data.scaleX;if(o==1)d==u.MixBlend.add?n.scaleX+=l-n.data.scaleX:n.scaleX=l;else{let c=0;if(h==u.MixDirection.mixOut)switch(d){case u.MixBlend.setup:c=n.data.scaleX,n.scaleX=c+(Math.abs(l)*u.MathUtils.signum(c)-c)*o;break;case u.MixBlend.first:case u.MixBlend.replace:c=n.scaleX,n.scaleX=c+(Math.abs(l)*u.MathUtils.signum(c)-c)*o;break;case u.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*o}else switch(d){case u.MixBlend.setup:c=Math.abs(n.data.scaleX)*u.MathUtils.signum(l),n.scaleX=c+(l-c)*o;break;case u.MixBlend.first:case u.MixBlend.replace:c=Math.abs(n.scaleX)*u.MathUtils.signum(l),n.scaleX=c+(l-c)*o;break;case u.MixBlend.add:n.scaleX+=(l-n.data.scaleX)*o}}}}class qt extends et{constructor(t,i,e){super(t,i,`${$.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.scaleY=n.data.scaleY;return;case u.MixBlend.first:n.scaleY+=(n.data.scaleY-n.scaleY)*o}return}const l=this.getCurveValue(e)*n.data.scaleY;if(o==1)d==u.MixBlend.add?n.scaleY+=l-n.data.scaleY:n.scaleY=l;else{let c=0;if(h==u.MixDirection.mixOut)switch(d){case u.MixBlend.setup:c=n.data.scaleY,n.scaleY=c+(Math.abs(l)*u.MathUtils.signum(c)-c)*o;break;case u.MixBlend.first:case u.MixBlend.replace:c=n.scaleY,n.scaleY=c+(Math.abs(l)*u.MathUtils.signum(c)-c)*o;break;case u.MixBlend.add:n.scaleY+=(l-n.data.scaleY)*o}else switch(d){case u.MixBlend.setup:c=Math.abs(n.data.scaleY)*u.MathUtils.signum(l),n.scaleY=c+(l-c)*o;break;case u.MixBlend.first:case u.MixBlend.replace:c=Math.abs(n.scaleY)*u.MathUtils.signum(l),n.scaleY=c+(l-c)*o;break;case u.MixBlend.add:n.scaleY+=(l-n.data.scaleY)*o}}}}class zt extends bt{constructor(t,i,e){super(t,i,`${$.shearX}|${e}`,`${$.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case u.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*o,n.shearY+=(n.data.shearY-n.shearY)*o}return}let l=0,c=0;const m=j.search(a,e,3),f=this.curves[m/3];switch(f){case 0:const g=a[m];l=a[m+1],c=a[m+2];const x=(e-g)/(a[m+3]-g);l+=(a[m+3+1]-l)*x,c+=(a[m+3+2]-c)*x;break;case 1:l=a[m+1],c=a[m+2];break;default:l=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}switch(d){case u.MixBlend.setup:n.shearX=n.data.shearX+l*o,n.shearY=n.data.shearY+c*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.shearX+=(n.data.shearX+l-n.shearX)*o,n.shearY+=(n.data.shearY+c-n.shearY)*o;break;case u.MixBlend.add:n.shearX+=l*o,n.shearY+=c*o}}}class jt extends et{constructor(t,i,e){super(t,i,`${$.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.shearX=n.data.shearX;return;case u.MixBlend.first:n.shearX+=(n.data.shearX-n.shearX)*o}return}const l=this.getCurveValue(e);switch(d){case u.MixBlend.setup:n.shearX=n.data.shearX+l*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.shearX+=(n.data.shearX+l-n.shearX)*o;break;case u.MixBlend.add:n.shearX+=l*o}}}class _t extends et{constructor(t,i,e){super(t,i,`${$.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,i,e,r,o,d,h){const n=t.bones[this.boneIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.shearY=n.data.shearY;return;case u.MixBlend.first:n.shearY+=(n.data.shearY-n.shearY)*o}return}const l=this.getCurveValue(e);switch(d){case u.MixBlend.setup:n.shearY=n.data.shearY+l*o;break;case u.MixBlend.first:case u.MixBlend.replace:n.shearY+=(n.data.shearY+l-n.shearY)*o;break;case u.MixBlend.add:n.shearY+=l*o}}}class Gt extends tt{constructor(t,i,e){super(t,i,[`${$.rgb}|${e}`,`${$.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,i,e,r,o,d){t*=5,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,l=n.color;if(e<a[0]){const M=n.data.color;switch(d){case u.MixBlend.setup:l.setFromColor(M);return;case u.MixBlend.first:l.add((M.r-l.r)*o,(M.g-l.g)*o,(M.b-l.b)*o,(M.a-l.a)*o)}return}let c=0,m=0,f=0,g=0;const x=j.search(a,e,5),y=this.curves[x/5];switch(y){case 0:const M=a[x];c=a[x+1],m=a[x+2],f=a[x+3],g=a[x+4];const p=(e-M)/(a[x+5]-M);c+=(a[x+5+1]-c)*p,m+=(a[x+5+2]-m)*p,f+=(a[x+5+3]-f)*p,g+=(a[x+5+4]-g)*p;break;case 1:c=a[x+1],m=a[x+2],f=a[x+3],g=a[x+4];break;default:c=this.getBezierValue(e,x,1,y-2),m=this.getBezierValue(e,x,2,y+18-2),f=this.getBezierValue(e,x,3,y+18*2-2),g=this.getBezierValue(e,x,4,y+18*3-2)}o==1?l.set(c,m,f,g):(d==u.MixBlend.setup&&l.setFromColor(n.data.color),l.add((c-l.r)*o,(m-l.g)*o,(f-l.b)*o,(g-l.a)*o))}}class Ht extends tt{constructor(t,i,e){super(t,i,[`${$.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,i,e,r,o){t<<=2,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,l=n.color;if(e<a[0]){const y=n.data.color;switch(d){case u.MixBlend.setup:l.r=y.r,l.g=y.g,l.b=y.b;return;case u.MixBlend.first:l.r+=(y.r-l.r)*o,l.g+=(y.g-l.g)*o,l.b+=(y.b-l.b)*o}return}let c=0,m=0,f=0;const g=j.search(a,e,4),x=this.curves[g>>2];switch(x){case 0:const y=a[g];c=a[g+1],m=a[g+2],f=a[g+3];const M=(e-y)/(a[g+4]-y);c+=(a[g+4+1]-c)*M,m+=(a[g+4+2]-m)*M,f+=(a[g+4+3]-f)*M;break;case 1:c=a[g+1],m=a[g+2],f=a[g+3];break;default:c=this.getBezierValue(e,g,1,x-2),m=this.getBezierValue(e,g,2,x+18-2),f=this.getBezierValue(e,g,3,x+18*2-2)}if(o==1)l.r=c,l.g=m,l.b=f;else{if(d==u.MixBlend.setup){const y=n.data.color;l.r=y.r,l.g=y.g,l.b=y.b}l.r+=(c-l.r)*o,l.g+=(m-l.g)*o,l.b+=(f-l.b)*o}}}class Jt extends et{constructor(t,i,e){super(t,i,`${$.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=n.color;if(e<this.frames[0]){const c=n.data.color;switch(d){case u.MixBlend.setup:a.a=c.a;return;case u.MixBlend.first:a.a+=(c.a-a.a)*o}return}const l=this.getCurveValue(e);o==1?a.a=l:(d==u.MixBlend.setup&&(a.a=n.data.color.a),a.a+=(l-a.a)*o)}}class Zt extends tt{constructor(t,i,e){super(t,i,[`${$.rgb}|${e}`,`${$.alpha}|${e}`,`${$.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,i,e,r,o,d,h,n,a){t<<=3,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=n,this.frames[t+7]=a}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,l=n.color,c=n.darkColor;if(e<a[0]){const w=n.data.color,B=n.data.darkColor;switch(d){case u.MixBlend.setup:l.setFromColor(w),c.r=B.r,c.g=B.g,c.b=B.b;return;case u.MixBlend.first:l.add((w.r-l.r)*o,(w.g-l.g)*o,(w.b-l.b)*o,(w.a-l.a)*o),c.r+=(B.r-c.r)*o,c.g+=(B.g-c.g)*o,c.b+=(B.b-c.b)*o}return}let m=0,f=0,g=0,x=0,y=0,M=0,p=0;const S=j.search(a,e,8),k=this.curves[S>>3];switch(k){case 0:const w=a[S];m=a[S+1],f=a[S+2],g=a[S+3],x=a[S+4],y=a[S+5],M=a[S+6],p=a[S+7];const B=(e-w)/(a[S+8]-w);m+=(a[S+8+1]-m)*B,f+=(a[S+8+2]-f)*B,g+=(a[S+8+3]-g)*B,x+=(a[S+8+4]-x)*B,y+=(a[S+8+5]-y)*B,M+=(a[S+8+6]-M)*B,p+=(a[S+8+7]-p)*B;break;case 1:m=a[S+1],f=a[S+2],g=a[S+3],x=a[S+4],y=a[S+5],M=a[S+6],p=a[S+7];break;default:m=this.getBezierValue(e,S,1,k-2),f=this.getBezierValue(e,S,2,k+18-2),g=this.getBezierValue(e,S,3,k+18*2-2),x=this.getBezierValue(e,S,4,k+18*3-2),y=this.getBezierValue(e,S,5,k+18*4-2),M=this.getBezierValue(e,S,6,k+18*5-2),p=this.getBezierValue(e,S,7,k+18*6-2)}if(o==1)l.set(m,f,g,x),c.r=y,c.g=M,c.b=p;else{if(d==u.MixBlend.setup){l.setFromColor(n.data.color);const w=n.data.darkColor;c.r=w.r,c.g=w.g,c.b=w.b}l.add((m-l.r)*o,(f-l.g)*o,(g-l.b)*o,(x-l.a)*o),c.r+=(y-c.r)*o,c.g+=(M-c.g)*o,c.b+=(p-c.b)*o}}}class Kt extends tt{constructor(t,i,e){super(t,i,[`${$.rgb}|${e}`,`${$.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,i,e,r,o,d,h,n){t*=7,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=n}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=this.frames,l=n.color,c=n.darkColor;if(e<a[0]){const k=n.data.color,w=n.data.darkColor;switch(d){case u.MixBlend.setup:l.r=k.r,l.g=k.g,l.b=k.b,c.r=w.r,c.g=w.g,c.b=w.b;return;case u.MixBlend.first:l.r+=(k.r-l.r)*o,l.g+=(k.g-l.g)*o,l.b+=(k.b-l.b)*o,c.r+=(w.r-c.r)*o,c.g+=(w.g-c.g)*o,c.b+=(w.b-c.b)*o}return}let m=0,f=0,g=0,x=0,y=0,M=0;const p=j.search(a,e,7),S=this.curves[p/7];switch(S){case 0:const k=a[p];m=a[p+1],f=a[p+2],g=a[p+3],x=a[p+4],y=a[p+5],M=a[p+6];const w=(e-k)/(a[p+7]-k);m+=(a[p+7+1]-m)*w,f+=(a[p+7+2]-f)*w,g+=(a[p+7+3]-g)*w,x+=(a[p+7+4]-x)*w,y+=(a[p+7+5]-y)*w,M+=(a[p+7+6]-M)*w;break;case 1:m=a[p+1],f=a[p+2],g=a[p+3],x=a[p+4],y=a[p+5],M=a[p+6];break;default:m=this.getBezierValue(e,p,1,S-2),f=this.getBezierValue(e,p,2,S+18-2),g=this.getBezierValue(e,p,3,S+18*2-2),x=this.getBezierValue(e,p,4,S+18*3-2),y=this.getBezierValue(e,p,5,S+18*4-2),M=this.getBezierValue(e,p,6,S+18*5-2)}if(o==1)l.r=m,l.g=f,l.b=g,c.r=x,c.g=y,c.b=M;else{if(d==u.MixBlend.setup){const k=n.data.color,w=n.data.darkColor;l.r=k.r,l.g=k.g,l.b=k.b,c.r=w.r,c.g=w.g,c.b=w.b}l.r+=(m-l.r)*o,l.g+=(f-l.g)*o,l.b+=(g-l.b)*o,c.r+=(x-c.r)*o,c.g+=(y-c.g)*o,c.b+=(M-c.b)*o}}}class pt extends j{constructor(t,i){super(t,[`${$.attachment}|${i}`]),this.slotIndex=0,this.slotIndex=i,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.attachmentNames[t]=e}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(n.bone.active){if(h==u.MixDirection.mixOut){d==u.MixBlend.setup&&this.setAttachment(t,n,n.data.attachmentName);return}if(e<this.frames[0]){(d==u.MixBlend.setup||d==u.MixBlend.first)&&this.setAttachment(t,n,n.data.attachmentName);return}this.setAttachment(t,n,this.attachmentNames[j.search1(this.frames,e)])}}setAttachment(t,i,e){i.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class Qt extends tt{constructor(t,i,e,r){super(t,i,[`${$.deform}|${e}|${r.id}`]),this.slotIndex=0,this.attachment=null,this.vertices=null,this.slotIndex=e,this.attachment=r,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.vertices[t]=e}setBezier(t,i,e,r,o,d,h,n,a,l,c){const m=this.curves;let f=this.getFrameCount()+t*18;e==0&&(m[i]=2+f);const g=(r-d*2+n)*.03,x=a*.03-h*.06,y=((d-n)*3-r+l)*.006,M=(h-a+.33333333)*.018;let p=g*2+y,S=x*2+M,k=(d-r)*.3+g+y*.16666667,w=h*.3+x+M*.16666667,B=r+k,Y=w;for(let X=f+18;f<X;f+=2)m[f]=B,m[f+1]=Y,k+=p,w+=S,p+=y,S+=M,B+=k,Y+=w}getCurvePercent(t,i){const e=this.curves;let r=e[i];switch(r){case 0:const n=this.frames[i];return(t-n)/(this.frames[i+this.getFrameEntries()]-n);case 1:return 0}if(r-=2,e[r]>t){const n=this.frames[i];return e[r+1]*(t-n)/(e[r]-n)}const o=r+18;for(r+=2;r<o;r+=2)if(e[r]>=t){const n=e[r-2],a=e[r-1];return a+(t-n)/(e[r]-n)*(e[r+1]-a)}const d=e[o-2],h=e[o-1];return h+(1-h)*(t-d)/(this.frames[i+this.getFrameEntries()]-d)}apply(t,i,e,r,o,d,h){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const a=n.getAttachment();if(!(a instanceof ut)||a.deformAttachment!=this.attachment)return;const l=n.deform;l.length==0&&(d=u.MixBlend.setup);const c=this.vertices,m=c[0].length,f=this.frames;if(e<f[0]){const p=a;switch(d){case u.MixBlend.setup:l.length=0;return;case u.MixBlend.first:if(o==1){l.length=0;return}if(l.length=m,p.bones){o=1-o;for(let S=0;S<m;S++)l[S]*=o}else{const S=p.vertices;for(let k=0;k<m;k++)l[k]+=(S[k]-l[k])*o}}return}if(l.length=m,e>=f[f.length-1]){const p=c[f.length-1];if(o==1)if(d==u.MixBlend.add){const S=a;if(S.bones)for(let k=0;k<m;k++)l[k]+=p[k];else{const k=S.vertices;for(let w=0;w<m;w++)l[w]+=p[w]-k[w]}}else u.Utils.arrayCopy(p,0,l,0,m);else switch(d){case u.MixBlend.setup:{const k=a;if(k.bones)for(let w=0;w<m;w++)l[w]=p[w]*o;else{const w=k.vertices;for(let B=0;B<m;B++){const Y=w[B];l[B]=Y+(p[B]-Y)*o}}break}case u.MixBlend.first:case u.MixBlend.replace:for(let k=0;k<m;k++)l[k]+=(p[k]-l[k])*o;break;case u.MixBlend.add:const S=a;if(S.bones)for(let k=0;k<m;k++)l[k]+=p[k]*o;else{const k=S.vertices;for(let w=0;w<m;w++)l[w]+=(p[w]-k[w])*o}}return}const g=j.search1(f,e),x=this.getCurvePercent(e,g),y=c[g],M=c[g+1];if(o==1)if(d==u.MixBlend.add){const p=a;if(p.bones)for(let S=0;S<m;S++){const k=y[S];l[S]+=k+(M[S]-k)*x}else{const S=p.vertices;for(let k=0;k<m;k++){const w=y[k];l[k]+=w+(M[k]-w)*x-S[k]}}}else for(let p=0;p<m;p++){const S=y[p];l[p]=S+(M[p]-S)*x}else switch(d){case u.MixBlend.setup:{const S=a;if(S.bones)for(let k=0;k<m;k++){const w=y[k];l[k]=(w+(M[k]-w)*x)*o}else{const k=S.vertices;for(let w=0;w<m;w++){const B=y[w],Y=k[w];l[w]=Y+(B+(M[w]-B)*x-Y)*o}}break}case u.MixBlend.first:case u.MixBlend.replace:for(let S=0;S<m;S++){const k=y[S];l[S]+=(k+(M[S]-k)*x-l[S])*o}break;case u.MixBlend.add:const p=a;if(p.bones)for(let S=0;S<m;S++){const k=y[S];l[S]+=(k+(M[S]-k)*x)*o}else{const S=p.vertices;for(let k=0;k<m;k++){const w=y[k];l[k]+=(w+(M[k]-w)*x-S[k])*o}}}}}const Xe=class extends j{constructor(s){super(s,Xe.propertyIds),this.events=null,this.events=new Array(s)}getFrameCount(){return this.frames.length}setFrame(s,t){this.frames[s]=t.time,this.events[s]=t}apply(s,t,i,e,r,o,d){if(!e)return;const h=this.frames,n=this.frames.length;if(t>i)this.apply(s,t,Number.MAX_VALUE,e,r,o,d),t=-1;else if(t>=h[n-1])return;if(i<h[0])return;let a=0;if(t<h[0])a=0;else{a=j.search1(h,t)+1;const l=h[a];for(;a>0&&h[a-1]==l;)a--}for(;a<n&&i>=h[a];a++)e.push(this.events[a])}};let St=Xe;St.propertyIds=[`${$.event}`];const Ce=class extends j{constructor(t){super(t,Ce.propertyIds),this.drawOrders=null,this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,i,e){this.frames[t]=i,this.drawOrders[t]=e}apply(t,i,e,r,o,d,h){if(h==u.MixDirection.mixOut){d==u.MixBlend.setup&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==u.MixBlend.setup||d==u.MixBlend.first)&&u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const n=this.drawOrders[j.search1(this.frames,e)];if(!n)u.Utils.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const a=t.drawOrder,l=t.slots;for(let c=0,m=n.length;c<m;c++)a[c]=l[n[c]]}}};let xt=Ce;xt.propertyIds=[`${$.drawOrder}`];class te extends tt{constructor(t,i,e){super(t,i,[`${$.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,i,e,r,o,d,h){t*=6,this.frames[t]=i,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=o,this.frames[t+4]=d?1:0,this.frames[t+5]=h?1:0}apply(t,i,e,r,o,d,h){const n=t.ikConstraints[this.ikConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch;return;case u.MixBlend.first:n.mix+=(n.data.mix-n.mix)*o,n.softness+=(n.data.softness-n.softness)*o,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}return}let l=0,c=0;const m=j.search(a,e,6),f=this.curves[m/6];switch(f){case 0:const g=a[m];l=a[m+1],c=a[m+2];const x=(e-g)/(a[m+6]-g);l+=(a[m+6+1]-l)*x,c+=(a[m+6+2]-c)*x;break;case 1:l=a[m+1],c=a[m+2];break;default:l=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}d==u.MixBlend.setup?(n.mix=n.data.mix+(l-n.data.mix)*o,n.softness=n.data.softness+(c-n.data.softness)*o,h==u.MixDirection.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=a[m+3],n.compress=a[m+4]!=0,n.stretch=a[m+5]!=0)):(n.mix+=(l-n.mix)*o,n.softness+=(c-n.softness)*o,h==u.MixDirection.mixIn&&(n.bendDirection=a[m+3],n.compress=a[m+4]!=0,n.stretch=a[m+5]!=0))}}class ee extends tt{constructor(t,i,e){super(t,i,[`${$.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,i,e,r,o,d,h,n){const a=this.frames;t*=7,a[t]=i,a[t+1]=e,a[t+2]=r,a[t+3]=o,a[t+4]=d,a[t+5]=h,a[t+6]=n}apply(t,i,e,r,o,d,h){const n=t.transformConstraints[this.transformConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){const p=n.data;switch(d){case u.MixBlend.setup:n.mixRotate=p.mixRotate,n.mixX=p.mixX,n.mixY=p.mixY,n.mixScaleX=p.mixScaleX,n.mixScaleY=p.mixScaleY,n.mixShearY=p.mixShearY;return;case u.MixBlend.first:n.mixRotate+=(p.mixRotate-n.mixRotate)*o,n.mixX+=(p.mixX-n.mixX)*o,n.mixY+=(p.mixY-n.mixY)*o,n.mixScaleX+=(p.mixScaleX-n.mixScaleX)*o,n.mixScaleY+=(p.mixScaleY-n.mixScaleY)*o,n.mixShearY+=(p.mixShearY-n.mixShearY)*o}return}let l,c,m,f,g,x;const y=j.search(a,e,7),M=this.curves[y/7];switch(M){case 0:const p=a[y];l=a[y+1],c=a[y+2],m=a[y+3],f=a[y+4],g=a[y+5],x=a[y+6];const S=(e-p)/(a[y+7]-p);l+=(a[y+7+1]-l)*S,c+=(a[y+7+2]-c)*S,m+=(a[y+7+3]-m)*S,f+=(a[y+7+4]-f)*S,g+=(a[y+7+5]-g)*S,x+=(a[y+7+6]-x)*S;break;case 1:l=a[y+1],c=a[y+2],m=a[y+3],f=a[y+4],g=a[y+5],x=a[y+6];break;default:l=this.getBezierValue(e,y,1,M-2),c=this.getBezierValue(e,y,2,M+18-2),m=this.getBezierValue(e,y,3,M+18*2-2),f=this.getBezierValue(e,y,4,M+18*3-2),g=this.getBezierValue(e,y,5,M+18*4-2),x=this.getBezierValue(e,y,6,M+18*5-2)}if(d==u.MixBlend.setup){const p=n.data;n.mixRotate=p.mixRotate+(l-p.mixRotate)*o,n.mixX=p.mixX+(c-p.mixX)*o,n.mixY=p.mixY+(m-p.mixY)*o,n.mixScaleX=p.mixScaleX+(f-p.mixScaleX)*o,n.mixScaleY=p.mixScaleY+(g-p.mixScaleY)*o,n.mixShearY=p.mixShearY+(x-p.mixShearY)*o}else n.mixRotate+=(l-n.mixRotate)*o,n.mixX+=(c-n.mixX)*o,n.mixY+=(m-n.mixY)*o,n.mixScaleX+=(f-n.mixScaleX)*o,n.mixScaleY+=(g-n.mixScaleY)*o,n.mixShearY+=(x-n.mixShearY)*o}}class ne extends et{constructor(t,i,e){super(t,i,`${$.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,i,e,r,o,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.position=n.data.position;return;case u.MixBlend.first:n.position+=(n.data.position-n.position)*o}return}const l=this.getCurveValue(e);d==u.MixBlend.setup?n.position=n.data.position+(l-n.data.position)*o:n.position+=(l-n.position)*o}}class se extends et{constructor(t,i,e){super(t,i,`${$.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,i,e,r,o,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.spacing=n.data.spacing;return;case u.MixBlend.first:n.spacing+=(n.data.spacing-n.spacing)*o}return}const l=this.getCurveValue(e);d==u.MixBlend.setup?n.spacing=n.data.spacing+(l-n.data.spacing)*o:n.spacing+=(l-n.spacing)*o}}class ie extends tt{constructor(t,i,e){super(t,i,[`${$.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,i,e,r,o){const d=this.frames;t<<=2,d[t]=i,d[t+1]=e,d[t+2]=r,d[t+3]=o}apply(t,i,e,r,o,d,h){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const a=this.frames;if(e<a[0]){switch(d){case u.MixBlend.setup:n.mixRotate=n.data.mixRotate,n.mixX=n.data.mixX,n.mixY=n.data.mixY;return;case u.MixBlend.first:n.mixRotate+=(n.data.mixRotate-n.mixRotate)*o,n.mixX+=(n.data.mixX-n.mixX)*o,n.mixY+=(n.data.mixY-n.mixY)*o}return}let l,c,m;const f=j.search(a,e,4),g=this.curves[f>>2];switch(g){case 0:const x=a[f];l=a[f+1],c=a[f+2],m=a[f+3];const y=(e-x)/(a[f+4]-x);l+=(a[f+4+1]-l)*y,c+=(a[f+4+2]-c)*y,m+=(a[f+4+3]-m)*y;break;case 1:l=a[f+1],c=a[f+2],m=a[f+3];break;default:l=this.getBezierValue(e,f,1,g-2),c=this.getBezierValue(e,f,2,g+18-2),m=this.getBezierValue(e,f,3,g+18*2-2)}if(d==u.MixBlend.setup){const x=n.data;n.mixRotate=x.mixRotate+(l-x.mixRotate)*o,n.mixX=x.mixX+(c-x.mixX)*o,n.mixY=x.mixY+(m-x.mixY)*o}else n.mixRotate+=(l-n.mixRotate)*o,n.mixX+=(c-n.mixX)*o,n.mixY+=(m-n.mixY)*o}}const ot=class{constructor(s){this.data=null,this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new Te(this),this.propertyIDs=new u.StringSet,this.animationsChanged=!1,this.trackEntryPool=new u.Pool(()=>new Ft),this.data=s}static emptyAnimation(){return oe||(oe=new Tt("<empty>",[],0)),oe}update(s){s*=this.timeScale;const t=this.tracks;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let o=s*r.timeScale;if(r.delay>0){if(r.delay-=o,r.delay>0)continue;o=-r.delay,r.delay=0}let d=r.next;if(d){const h=r.trackLast-d.delay;if(h>=0){for(d.delay=0,d.trackTime+=r.timeScale==0?0:(h/r.timeScale+s)*d.timeScale,r.trackTime+=o,this.setCurrent(i,d,!0);d.mixingFrom;)d.mixTime+=s,d=d.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){t[i]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,s)){let h=r.mixingFrom;for(r.mixingFrom=null,h&&(h.mixingTo=null);h;)this.queue.end(h),h=h.mixingFrom}r.trackTime+=o}this.queue.drain()}updateMixingFrom(s,t){const i=s.mixingFrom;if(!i)return!0;const e=this.updateMixingFrom(i,t);return i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast,s.mixTime>0&&s.mixTime>=s.mixDuration?((i.totalAlpha==0||s.mixDuration==0)&&(s.mixingFrom=i.mixingFrom,i.mixingFrom&&(i.mixingFrom.mixingTo=s),s.interruptAlpha=i.interruptAlpha,this.queue.end(i)),e):(i.trackTime+=t*i.timeScale,s.mixTime+=t,!1)}apply(s){if(!s)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,i=this.tracks;let e=!1;for(let d=0,h=i.length;d<h;d++){const n=i[d];if(!n||n.delay>0)continue;e=!0;const a=d==0?u.MixBlend.first:n.mixBlend;let l=n.alpha;n.mixingFrom?l*=this.applyMixingFrom(n,s,a):n.trackTime>=n.trackEnd&&!n.next&&(l=0);const c=n.animationLast,m=n.getAnimationTime();let f=m,g=t;n.reverse&&(f=n.animation.duration-f,g=null);const x=n.animation.timelines,y=x.length;if(d==0&&l==1||a==u.MixBlend.add)for(let M=0;M<y;M++){u.Utils.webkit602BugfixHelper(l,a);const p=x[M];p instanceof pt?this.applyAttachmentTimeline(p,s,f,a,!0):p.apply(s,c,f,g,l,a,u.MixDirection.mixIn)}else{const M=n.timelineMode,p=n.timelinesRotation.length!=y<<1;p&&(n.timelinesRotation.length=y<<1);for(let S=0;S<y;S++){const k=x[S],w=M[S]==ae?a:u.MixBlend.setup;k instanceof kt?this.applyRotateTimeline(k,s,f,l,w,n.timelinesRotation,S<<1,p):k instanceof pt?this.applyAttachmentTimeline(k,s,f,a,!0):(u.Utils.webkit602BugfixHelper(l,a),k.apply(s,c,f,g,l,w,u.MixDirection.mixIn))}}this.queueEvents(n,m),t.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime}const r=this.unkeyedState+ve,o=s.slots;for(let d=0,h=s.slots.length;d<h;d++){const n=o[d];if(n.attachmentState==r){const a=n.data.attachmentName;n.setAttachment(a?s.getAttachment(n.data.index,a):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(s,t,i){const e=s.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,i);let r=0;s.mixDuration==0?(r=1,i==u.MixBlend.first&&(i=u.MixBlend.setup)):(r=s.mixTime/s.mixDuration,r>1&&(r=1),i!=u.MixBlend.first&&(i=e.mixBlend));const o=r<e.attachmentThreshold,d=r<e.drawOrderThreshold,h=e.animation.timelines,n=h.length,a=e.alpha*s.interruptAlpha,l=a*(1-r),c=e.animationLast,m=e.getAnimationTime();let f=m,g=null;if(e.reverse?f=e.animation.duration-f:r<e.eventThreshold&&(g=this.events),i==u.MixBlend.add)for(let x=0;x<n;x++)h[x].apply(t,c,f,g,l,i,u.MixDirection.mixOut);else{const x=e.timelineMode,y=e.timelineHoldMix,M=e.timelinesRotation.length!=n<<1;M&&(e.timelinesRotation.length=n<<1),e.totalAlpha=0;for(let p=0;p<n;p++){const S=h[p];let k=u.MixDirection.mixOut,w,B=0;switch(x[p]){case ae:if(!d&&S instanceof xt)continue;w=i,B=l;break;case be:w=u.MixBlend.setup,B=l;break;case Fe:w=i,B=a;break;case re:w=u.MixBlend.setup,B=a;break;default:w=u.MixBlend.setup;const Y=y[p];B=a*Math.max(0,1-Y.mixTime/Y.mixDuration);break}e.totalAlpha+=B,S instanceof kt?this.applyRotateTimeline(S,t,f,B,w,e.timelinesRotation,p<<1,M):S instanceof pt?this.applyAttachmentTimeline(S,t,f,w,o):(u.Utils.webkit602BugfixHelper(B,i),d&&S instanceof xt&&w==u.MixBlend.setup&&(k=u.MixDirection.mixIn),S.apply(t,c,f,g,B,w,k))}}return s.mixDuration>0&&this.queueEvents(e,m),this.events.length=0,e.nextAnimationLast=m,e.nextTrackLast=e.trackTime,r}applyAttachmentTimeline(s,t,i,e,r){const o=t.slots[s.slotIndex];o.bone.active&&(i<s.frames[0]?(e==u.MixBlend.setup||e==u.MixBlend.first)&&this.setAttachment(t,o,o.data.attachmentName,r):this.setAttachment(t,o,s.attachmentNames[j.search1(s.frames,i)],r),o.attachmentState<=this.unkeyedState&&(o.attachmentState=this.unkeyedState+ve))}setAttachment(s,t,i,e){t.setAttachment(i?s.getAttachment(t.data.index,i):null),e&&(t.attachmentState=this.unkeyedState+He)}applyRotateTimeline(s,t,i,e,r,o,d,h){if(h&&(o[d]=0),e==1){s.apply(t,0,i,null,1,r,u.MixDirection.mixIn);return}const n=t.bones[s.boneIndex];if(!n.active)return;const a=s.frames;let l=0,c=0;if(i<a[0])switch(r){case u.MixBlend.setup:n.rotation=n.data.rotation;default:return;case u.MixBlend.first:l=n.rotation,c=n.data.rotation}else l=r==u.MixBlend.setup?n.data.rotation:n.rotation,c=n.data.rotation+s.getCurveValue(i);let m=0,f=c-l;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)m=o[d];else{let g=0,x=0;h?(g=0,x=f):(g=o[d],x=o[d+1]);const y=f>0;let M=g>=0;u.MathUtils.signum(x)!=u.MathUtils.signum(f)&&Math.abs(x)<=90&&(Math.abs(g)>180&&(g+=360*u.MathUtils.signum(g)),M=y),m=f+g-g%360,M!=y&&(m+=360*u.MathUtils.signum(g)),o[d]=m}o[d+1]=f,n.rotation=l+m*e}queueEvents(s,t){const i=s.animationStart,e=s.animationEnd,r=e-i,o=s.trackLast%r,d=this.events;let h=0;const n=d.length;for(;h<n;h++){const l=d[h];if(l.time<o)break;l.time>e||this.queue.event(s,l)}let a=!1;for(s.loop?a=r==0||o>s.trackTime%r:a=t>=e&&s.animationLast<e,a&&this.queue.complete(s);h<n;h++){const l=d[h];l.time<i||this.queue.event(s,l)}}clearTracks(){const s=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,i=this.tracks.length;t<i;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=s,this.queue.drain()}clearTrack(s){if(s>=this.tracks.length)return;const t=this.tracks[s];if(!t)return;this.queue.end(t),this.clearNext(t);let i=t;for(;;){const e=i.mixingFrom;if(!e)break;this.queue.end(e),i.mixingFrom=null,i.mixingTo=null,i=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(s,t,i){const e=this.expandToIndex(s);this.tracks[s]=t,t.previous=null,e&&(i&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(s,t,i=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(s,e,i)}setAnimationWith(s,t,i=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,r=this.expandToIndex(s);r&&(r.nextTrackLast==-1?(this.tracks[s]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,e=!1):this.clearNext(r));const o=this.trackEntry(s,t,i,r);return this.setCurrent(s,o,e),this.queue.drain(),o}addAnimation(s,t,i=!1,e=0){const r=this.data.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(s,r,i,e)}addAnimationWith(s,t,i=!1,e=0){if(!t)throw new Error("animation cannot be null.");let r=this.expandToIndex(s);if(r)for(;r.next;)r=r.next;const o=this.trackEntry(s,t,i,r);return r?(r.next=o,o.previous=r,e<=0&&(e+=r.getTrackComplete()-o.mixDuration)):(this.setCurrent(s,o,!0),this.queue.drain()),o.delay=e,o}setEmptyAnimation(s,t=0){const i=this.setAnimationWith(s,ot.emptyAnimation(),!1);return i.mixDuration=t,i.trackEnd=t,i}addEmptyAnimation(s,t=0,i=0){const e=this.addAnimationWith(s,ot.emptyAnimation(),!1,i);return i<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(s=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let i=0,e=this.tracks.length;i<e;i++){const r=this.tracks[i];r&&this.setEmptyAnimation(r.trackIndex,s)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(s){return s<this.tracks.length?this.tracks[s]:(u.Utils.ensureArrayCapacity(this.tracks,s+1,null),this.tracks.length=s+1,null)}trackEntry(s,t,i,e){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=s,r.animation=t,r.loop=i,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=e?this.data.getMix(e.animation,t):0,r.mixBlend=u.MixBlend.replace,r}clearNext(s){let t=s.next;for(;t;)this.queue.dispose(t),t=t.next;s.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const s=this.tracks;for(let t=0,i=s.length;t<i;t++){let e=s[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=u.MixBlend.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(s){const t=s.mixingTo,i=s.animation.timelines,e=s.animation.timelines.length,r=s.timelineMode;r.length=e;const o=s.timelineHoldMix;o.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let h=0;h<e;h++)r[h]=d.addAll(i[h].getPropertyIds())?re:Fe;return}t:for(let h=0;h<e;h++){const n=i[h],a=n.getPropertyIds();if(!d.addAll(a))r[h]=ae;else if(!t||n instanceof pt||n instanceof xt||n instanceof St||!t.animation.hasTimeline(a))r[h]=be;else{for(let l=t.mixingTo;l;l=l.mixingTo)if(!l.animation.hasTimeline(a)){if(s.mixDuration>0){r[h]=Ge,o[h]=l;continue t}break}r[h]=re}}}getCurrent(s){return s>=this.tracks.length?null:this.tracks[s]}addListener(s){if(!s)throw new Error("listener cannot be null.");this.listeners.push(s)}removeListener(s){const t=this.listeners.indexOf(s);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(s,t,i){ot.deprecatedWarning1||(ot.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(s,t,i)}addAnimationByName(s,t,i,e){ot.deprecatedWarning2||(ot.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(s,t,i,e)}hasAnimation(s){return this.data.skeletonData.findAnimation(s)!==null}hasAnimationByName(s){return ot.deprecatedWarning3||(ot.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(s)}};let Bt=ot;Bt.deprecatedWarning1=!1,Bt.deprecatedWarning2=!1,Bt.deprecatedWarning3=!1;const lt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=u.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return lt.deprecatedWarning1||(lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){lt.deprecatedWarning1||(lt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return lt.deprecatedWarning2||(lt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){lt.deprecatedWarning2||(lt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ft=lt;Ft.deprecatedWarning1=!1,Ft.deprecatedWarning2=!1;class Te{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=null,this.animState=t}start(t){this.objects.push(Z.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Z.interrupt),this.objects.push(t)}end(t){this.objects.push(Z.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Z.dispose),this.objects.push(t)}complete(t){this.objects.push(Z.complete),this.objects.push(t)}event(t,i){this.objects.push(Z.event),this.objects.push(t),this.objects.push(i)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,i=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],o=t[e+1];switch(r){case Z.start:o.listener&&o.listener.start&&o.listener.start(o);for(let h=0;h<i.length;h++)i[h].start&&i[h].start(o);break;case Z.interrupt:o.listener&&o.listener.interrupt&&o.listener.interrupt(o);for(let h=0;h<i.length;h++)i[h].interrupt&&i[h].interrupt(o);break;case Z.end:o.listener&&o.listener.end&&o.listener.end(o);for(let h=0;h<i.length;h++)i[h].end&&i[h].end(o);case Z.dispose:o.listener&&o.listener.dispose&&o.listener.dispose(o);for(let h=0;h<i.length;h++)i[h].dispose&&i[h].dispose(o);this.animState.trackEntryPool.free(o);break;case Z.complete:o.listener&&o.listener.complete&&o.listener.complete(o);for(let h=0;h<i.length;h++)i[h].complete&&i[h].complete(o);break;case Z.event:const d=t[e+++2];o.listener&&o.listener.event&&o.listener.event(o,d);for(let h=0;h<i.length;h++)i[h].event&&i[h].event(o,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var Z=(s=>(s[s.start=0]="start",s[s.interrupt=1]="interrupt",s[s.end=2]="end",s[s.dispose=3]="dispose",s[s.complete=4]="complete",s[s.event=5]="event",s))(Z||{});class _e{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,i){}}const ae=0,be=1,Fe=2,re=3,Ge=4,ve=1,He=2;let oe=null;class Ee{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,i,e){const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);const o=this.skeletonData.findAnimation(i);if(o==null)throw new Error(`Animation not found: ${i}`);this.setMixWith(r,o,e)}setMixWith(t,i,e){if(t==null)throw new Error("from cannot be null.");if(i==null)throw new Error("to cannot be null.");const r=`${t.name}.${i.name}`;this.animationToMixTime[r]=e}getMix(t,i){const e=`${t.name}.${i.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}}class Je{constructor(t){this.atlas=t}newRegionAttachment(t,i,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${i})`);const o=new D(i);return o.region=r,o}newMeshAttachment(t,i,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${i})`);const o=new ft(i);return o.region=r,o}newBoundingBoxAttachment(t,i){return new It(i)}newPathAttachment(t,i){return new gt(i)}newPointAttachment(t,i){return new Ct(i)}newClippingAttachment(t,i){return new Xt(i)}}class le{constructor(t,i,e){if(this.matrix=new rt.Matrix,this.data=null,this.skeleton=null,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=i,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,i,e,r,o,d,h){this.ax=t,this.ay=i,this.arotation=e,this.ascaleX=r,this.ascaleY=o,this.ashearX=d,this.ashearY=h;const n=this.parent,a=this.matrix,l=this.skeleton.scaleX,c=u.settings.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!n){const y=this.skeleton,M=e+90+h;a.a=u.MathUtils.cosDeg(e+d)*r*l,a.c=u.MathUtils.cosDeg(M)*o*l,a.b=u.MathUtils.sinDeg(e+d)*r*c,a.d=u.MathUtils.sinDeg(M)*o*c,a.tx=t*l+y.x,a.ty=i*c+y.y;return}let m=n.matrix.a,f=n.matrix.c,g=n.matrix.b,x=n.matrix.d;switch(a.tx=m*t+f*i+n.matrix.tx,a.ty=g*t+x*i+n.matrix.ty,this.data.transformMode){case u.TransformMode.Normal:{const y=e+90+h,M=u.MathUtils.cosDeg(e+d)*r,p=u.MathUtils.cosDeg(y)*o,S=u.MathUtils.sinDeg(e+d)*r,k=u.MathUtils.sinDeg(y)*o;a.a=m*M+f*S,a.c=m*p+f*k,a.b=g*M+x*S,a.d=g*p+x*k;return}case u.TransformMode.OnlyTranslation:{const y=e+90+h;a.a=u.MathUtils.cosDeg(e+d)*r,a.c=u.MathUtils.cosDeg(y)*o,a.b=u.MathUtils.sinDeg(e+d)*r,a.d=u.MathUtils.sinDeg(y)*o;break}case u.TransformMode.NoRotationOrReflection:{let y=m*m+g*g,M=0;y>1e-4?(y=Math.abs(m*x-f*g)/y,m/=l,g/=c,f=g*y,x=m*y,M=Math.atan2(g,m)*u.MathUtils.radDeg):(m=0,g=0,M=90-Math.atan2(x,f)*u.MathUtils.radDeg);const p=e+d-M,S=e+h-M+90,k=u.MathUtils.cosDeg(p)*r,w=u.MathUtils.cosDeg(S)*o,B=u.MathUtils.sinDeg(p)*r,Y=u.MathUtils.sinDeg(S)*o;a.a=m*k-f*B,a.c=m*w-f*Y,a.b=g*k+x*B,a.d=g*w+x*Y;break}case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:{const y=u.MathUtils.cosDeg(e),M=u.MathUtils.sinDeg(e);let p=(m*y+f*M)/l,S=(g*y+x*M)/c,k=Math.sqrt(p*p+S*S);k>1e-5&&(k=1/k),p*=k,S*=k,k=Math.sqrt(p*p+S*S),this.data.transformMode==u.TransformMode.NoScale&&m*x-f*g<0!=(l<0!=c<0)&&(k=-k);const w=Math.PI/2+Math.atan2(S,p),B=Math.cos(w)*k,Y=Math.sin(w)*k,X=u.MathUtils.cosDeg(d)*r,I=u.MathUtils.cosDeg(90+h)*o,C=u.MathUtils.sinDeg(d)*r,T=u.MathUtils.sinDeg(90+h)*o;a.a=p*X+B*C,a.c=p*I+B*T,a.b=S*X+Y*C,a.d=S*I+Y*T;break}}a.a*=l,a.c*=l,a.b*=c,a.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*u.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*u.MathUtils.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,i=this.matrix;if(!t){this.ax=i.tx,this.ay=i.ty,this.arotation=Math.atan2(i.b,i.a)*u.MathUtils.radDeg,this.ascaleX=Math.sqrt(i.a*i.a+i.b*i.b),this.ascaleY=Math.sqrt(i.c*i.c+i.d*i.d),this.ashearX=0,this.ashearY=Math.atan2(i.a*i.c+i.b*i.d,i.a*i.d-i.b*i.c)*u.MathUtils.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),o=i.tx-e.tx,d=i.ty-e.ty;this.ax=o*e.d*r-d*e.c*r,this.ay=d*e.a*r-o*e.b*r;const h=r*e.d,n=r*e.a,a=r*e.c,l=r*e.b,c=h*i.a-a*i.b,m=h*i.c-a*i.d,f=n*i.b-l*i.a,g=n*i.d-l*i.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+f*f),this.ascaleX>1e-4){const x=c*g-m*f;this.ascaleY=x/this.ascaleX,this.ashearY=Math.atan2(c*m+f*g,x)*u.MathUtils.radDeg,this.arotation=Math.atan2(f,c)*u.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+g*g),this.ashearY=0,this.arotation=90-Math.atan2(g,m)*u.MathUtils.radDeg}worldToLocal(t){const i=this.matrix,e=i.a,r=i.c,o=i.b,d=i.d,h=1/(e*d-r*o),n=t.x-i.tx,a=t.y-i.ty;return t.x=n*d*h-a*r*h,t.y=a*e*h-n*o*h,t}localToWorld(t){const i=this.matrix,e=t.x,r=t.y;return t.x=e*i.a+r*i.c+i.tx,t.y=e*i.b+r*i.d+i.ty,t}worldToLocalRotation(t){const i=u.MathUtils.sinDeg(t),e=u.MathUtils.cosDeg(t),r=this.matrix;return Math.atan2(r.a*i-r.b*e,r.d*e-r.c*i)*u.MathUtils.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const i=u.MathUtils.sinDeg(t),e=u.MathUtils.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+i*r.d,e*r.a+i*r.c)*u.MathUtils.radDeg}rotateWorld(t){const i=this.matrix,e=i.a,r=i.c,o=i.b,d=i.d,h=u.MathUtils.cosDeg(t),n=u.MathUtils.sinDeg(t);i.a=h*e-n*o,i.c=h*r-n*d,i.b=n*e+h*o,i.d=n*r+h*d}}class he{constructor(t,i,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=u.TransformMode.Normal,this.skinRequired=!1,this.color=new u.Color,t<0)throw new Error("index must be >= 0.");if(i==null)throw new Error("name cannot be null.");this.index=t,this.name=i,this.parent=e}}class vt{constructor(t,i,e){this.name=t,this.order=i,this.skinRequired=e}}class ce{constructor(t,i){if(i==null)throw new Error("data cannot be null.");this.time=t,this.data=i}}class de{constructor(t){this.name=t}}class Ue{constructor(t,i){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(i.findBone(t.bones[e].name));this.target=i.findBone(t.target.name)}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,i=this.bones;switch(i.length){case 1:this.apply1(i[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(i[0],i[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,i,e,r,o,d,h){const n=t.parent.matrix,a=n.a;let l=n.c;const c=n.b;let m=n.d,f=-t.ashearX-t.arotation,g=0,x=0;const y=t.skeleton.scaleX,M=u.settings.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case u.TransformMode.OnlyTranslation:g=i-t.worldX,x=e-t.worldY,u.settings.yDown&&(x=-x);break;case u.TransformMode.NoRotationOrReflection:const k=Math.abs(a*m-l*c)/(a*a+c*c),w=a/y,B=c/M;l=-B*k*y,m=w*k*M,f+=Math.atan2(B,w)*u.MathUtils.radDeg;default:const Y=i-n.tx,X=e-n.ty,I=a*m-l*c;g=(Y*m-X*l)/I-t.ax,x=(X*a-Y*c)/I-t.ay}f+=Math.atan2(x,g)*u.MathUtils.radDeg,t.ascaleX<0&&(f+=180),f>180?f-=360:f<-180&&(f+=360);let p=t.ascaleX,S=t.ascaleY;if(r||o){switch(t.data.transformMode){case u.TransformMode.NoScale:case u.TransformMode.NoScaleOrReflection:g=i-t.worldX,x=e-t.worldY}const k=t.data.length*p,w=Math.sqrt(g*g+x*x);if(r&&w<k||o&&w>k&&k>1e-4){const B=(w/k-1)*h+1;p*=B,d&&(S*=B)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+f*h,p,S,t.ashearX,t.ashearY)}apply2(t,i,e,r,o,d,h,n,a){const l=t.ax,c=t.ay;let m=t.ascaleX,f=t.ascaleY,g=m,x=f,y=i.ascaleX;const M=t.matrix;let p=0,S=0,k=0;m<0?(m=-m,p=180,k=-1):(p=0,k=1),f<0&&(f=-f,k=-k),y<0?(y=-y,S=180):S=0;const w=i.ax;let B=0,Y=0,X=0,I=M.a,C=M.c,T=M.b,b=M.d;const E=Math.abs(m-f)<=1e-4;!E||d?(B=0,Y=I*w+M.tx,X=T*w+M.ty):(B=i.ay,Y=I*w+C*B+M.tx,X=T*w+b*B+M.ty);const v=t.parent.matrix;I=v.a,C=v.c,T=v.b,b=v.d;const W=1/(I*b-C*T);let U=Y-v.tx,V=X-v.ty;const z=(U*b-V*C)*W-l,_=(V*I-U*T)*W-c,q=Math.sqrt(z*z+_*_);let J=i.data.length*y,R,P;if(q<1e-4){this.apply1(t,e,r,!1,d,!1,a),i.updateWorldTransformWith(w,B,0,i.ascaleX,i.ascaleY,i.ashearX,i.ashearY);return}U=e-v.tx,V=r-v.ty;let O=(U*b-V*C)*W-l,Q=(V*I-U*T)*W-c,it=O*O+Q*Q;if(n!=0){n*=m*(y+1)*.5;const K=Math.sqrt(it),dt=K-q-J*m+n;if(dt>0){let mt=Math.min(1,dt/(n*2))-1;mt=(dt-n*(1-mt*mt))/K,O-=mt*O,Q-=mt*Q,it=O*O+Q*Q}}t:if(E){J*=m;let K=(it-q*q-J*J)/(2*q*J);K<-1?(K=-1,P=Math.PI*o):K>1?(K=1,P=0,d&&(I=(Math.sqrt(it)/(q+J)-1)*a+1,g*=I,h&&(x*=I))):P=Math.acos(K)*o,I=q+J*K,C=J*Math.sin(P),R=Math.atan2(Q*I-O*C,O*I+Q*C)}else{I=m*J,C=f*J;const K=I*I,dt=C*C,mt=Math.atan2(Q,O);T=dt*q*q+K*it-K*dt;const Ut=-2*dt*q,Le=dt-K;if(b=Ut*Ut-4*Le*T,b>=0){let Mt=Math.sqrt(b);Ut<0&&(Mt=-Mt),Mt=-(Ut+Mt)*.5;const qe=Mt/Le,ze=T/Mt,yt=Math.abs(qe)<Math.abs(ze)?qe:ze;if(yt*yt<=it){V=Math.sqrt(it-yt*yt)*o,R=mt-Math.atan2(V,yt),P=Math.atan2(V/f,(yt-q)/m);break t}}let Ne=u.MathUtils.PI,Dt=q-I,Se=Dt*Dt,We=0,$e=0,Rt=q+I,Be=Rt*Rt,Oe=0;T=-I*q/(K-dt),T>=-1&&T<=1&&(T=Math.acos(T),U=I*Math.cos(T)+q,V=C*Math.sin(T),b=U*U+V*V,b<Se&&(Ne=T,Se=b,Dt=U,We=V),b>Be&&($e=T,Be=b,Rt=U,Oe=V)),it<=(Se+Be)*.5?(R=mt-Math.atan2(We*o,Dt),P=Ne*o):(R=mt-Math.atan2(Oe*o,Rt),P=$e*o)}const Ve=Math.atan2(B,w)*k;let Yt=t.arotation;R=(R-Ve)*u.MathUtils.radDeg+p-Yt,R>180?R-=360:R<-180&&(R+=360),t.updateWorldTransformWith(l,c,Yt+R*a,g,x,0,0),Yt=i.arotation,P=((P+Ve)*u.MathUtils.radDeg-i.ashearX)*k+S-Yt,P>180?P-=360:P<-180&&(P+=360),i.updateWorldTransformWith(w,B,Yt+P*a,i.ascaleX,i.ascaleY,i.ashearX,i.ashearY)}}class me extends vt{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ue extends vt{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0}}var H=(s=>(s[s.Length=0]="Length",s[s.Fixed=1]="Fixed",s[s.Percent=2]="Percent",s[s.Proportional=3]="Proportional",s))(H||{});const ht=class{constructor(s,t){if(this.data=null,this.bones=null,this.target=null,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!s)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=s,this.bones=new Array;for(let i=0,e=s.bones.length;i<e;i++)this.bones.push(t.findBone(s.bones[i].name));this.target=t.findSlot(s.target.name),this.position=s.position,this.spacing=s.spacing,this.mixRotate=s.mixRotate,this.mixX=s.mixX,this.mixY=s.mixY}isActive(){return this.active}update(){const s=this.target.getAttachment();if(!(s instanceof gt))return;const t=this.mixRotate,i=this.mixX,e=this.mixY;if(t==0&&i==0&&e==0)return;const r=this.data,o=r.rotateMode==u.RotateMode.Tangent,d=r.rotateMode==u.RotateMode.ChainScale,h=this.bones,n=h.length,a=o?n:n+1,l=u.Utils.setArraySize(this.spaces,a),c=d?this.lengths=u.Utils.setArraySize(this.lengths,n):null,m=this.spacing;switch(r.spacingMode){case H.Percent:if(d)for(let k=0,w=a-1;k<w;k++){const B=h[k],Y=B.data.length;if(Y<ht.epsilon)c[k]=0;else{const X=Y*B.matrix.a,I=Y*B.matrix.b;c[k]=Math.sqrt(X*X+I*I)}}u.Utils.arrayFill(l,1,a,m);break;case H.Proportional:let p=0;for(let k=0,w=a-1;k<w;){const B=h[k],Y=B.data.length;if(Y<ht.epsilon)d&&(c[k]=0),l[++k]=m;else{const X=Y*B.matrix.a,I=Y*B.matrix.b,C=Math.sqrt(X*X+I*I);d&&(c[k]=C),l[++k]=C,p+=C}}if(p>0){p=a/p*m;for(let k=1;k<a;k++)l[k]*=p}break;default:const S=r.spacingMode==H.Length;for(let k=0,w=a-1;k<w;){const B=h[k],Y=B.data.length;if(Y<ht.epsilon)d&&(c[k]=0),l[++k]=m;else{const X=Y*B.matrix.a,I=Y*B.matrix.b,C=Math.sqrt(X*X+I*I);d&&(c[k]=C),l[++k]=(S?Y+m:m)*C/Y}}}const f=this.computeWorldPositions(s,a,o);let g=f[0],x=f[1],y=r.offsetRotation,M=!1;if(y==0)M=r.rotateMode==u.RotateMode.Chain;else{M=!1;const p=this.target.bone.matrix;y*=p.a*p.d-p.b*p.c>0?u.MathUtils.degRad:-u.MathUtils.degRad}for(let p=0,S=3;p<n;p++,S+=3){const k=h[p],w=k.matrix;w.tx+=(g-w.tx)*i,w.ty+=(x-w.ty)*e;const B=f[S],Y=f[S+1],X=B-g,I=Y-x;if(d){const C=c[p];if(C!=0){const T=(Math.sqrt(X*X+I*I)/C-1)*t+1;w.a*=T,w.b*=T}}if(g=B,x=Y,t>0){const C=w.a,T=w.c,b=w.b,E=w.d;let v=0,W=0,U=0;if(o&&(o?v=f[S-1]:l[p+1]==0?v=f[S+2]:v=Math.atan2(I,X)),v-=Math.atan2(b,C),M){W=Math.cos(v),U=Math.sin(v);const V=k.data.length;g+=(V*(W*C-U*b)-X)*t,x+=(V*(U*C+W*b)-I)*t}else v+=y;v>u.MathUtils.PI?v-=u.MathUtils.PI2:v<-u.MathUtils.PI&&(v+=u.MathUtils.PI2),v*=t,W=Math.cos(v),U=Math.sin(v),w.a=W*C-U*b,w.c=W*T-U*E,w.b=U*C+W*b,w.d=U*T+W*E}k.updateAppliedTransform()}}computeWorldPositions(s,t,i){const e=this.target;let r=this.position;const o=this.spaces,d=u.Utils.setArraySize(this.positions,t*3+2);let h=null;const n=s.closed;let a=s.worldVerticesLength,l=a/6,c=ht.NONE;if(!s.constantSpeed){const V=s.lengths;l-=n?1:2;const z=V[l];this.data.positionMode==u.PositionMode.Percent&&(r*=z);let _;switch(this.data.spacingMode){case H.Percent:_=z;break;case H.Proportional:_=z/t;break;default:_=1}h=u.Utils.setArraySize(this.world,8);for(let q=0,J=0,R=0;q<t;q++,J+=3){const P=o[q]*_;r+=P;let O=r;if(n)O%=z,O<0&&(O+=z),R=0;else if(O<0){c!=ht.BEFORE&&(c=ht.BEFORE,s.computeWorldVertices(e,2,4,h,0,2)),this.addBeforePosition(O,h,0,d,J);continue}else if(O>z){c!=ht.AFTER&&(c=ht.AFTER,s.computeWorldVertices(e,a-6,4,h,0,2)),this.addAfterPosition(O-z,h,0,d,J);continue}for(;;R++){const Q=V[R];if(!(O>Q)){if(R==0)O/=Q;else{const it=V[R-1];O=(O-it)/(Q-it)}break}}R!=c&&(c=R,n&&R==l?(s.computeWorldVertices(e,a-4,4,h,0,2),s.computeWorldVertices(e,0,4,h,4,2)):s.computeWorldVertices(e,R*6+2,8,h,0,2)),this.addCurvePosition(O,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],d,J,i||q>0&&P==0)}return d}n?(a+=2,h=u.Utils.setArraySize(this.world,a),s.computeWorldVertices(e,2,a-4,h,0,2),s.computeWorldVertices(e,0,2,h,a-4,2),h[a-2]=h[0],h[a-1]=h[1]):(l--,a-=4,h=u.Utils.setArraySize(this.world,a),s.computeWorldVertices(e,2,a,h,0,2));const m=u.Utils.setArraySize(this.curves,l);let f=0,g=h[0],x=h[1],y=0,M=0,p=0,S=0,k=0,w=0,B=0,Y=0,X=0,I=0,C=0,T=0,b=0,E=0;for(let V=0,z=2;V<l;V++,z+=6)y=h[z],M=h[z+1],p=h[z+2],S=h[z+3],k=h[z+4],w=h[z+5],B=(g-y*2+p)*.1875,Y=(x-M*2+S)*.1875,X=((y-p)*3-g+k)*.09375,I=((M-S)*3-x+w)*.09375,C=B*2+X,T=Y*2+I,b=(y-g)*.75+B+X*.16666667,E=(M-x)*.75+Y+I*.16666667,f+=Math.sqrt(b*b+E*E),b+=C,E+=T,C+=X,T+=I,f+=Math.sqrt(b*b+E*E),b+=C,E+=T,f+=Math.sqrt(b*b+E*E),b+=C+X,E+=T+I,f+=Math.sqrt(b*b+E*E),m[V]=f,g=k,x=w;this.data.positionMode==u.PositionMode.Percent&&(r*=f);let v;switch(this.data.spacingMode){case H.Percent:v=f;break;case H.Proportional:v=f/t;break;default:v=1}const W=this.segments;let U=0;for(let V=0,z=0,_=0,q=0;V<t;V++,z+=3){const J=o[V]*v;r+=J;let R=r;if(n)R%=f,R<0&&(R+=f),_=0;else if(R<0){this.addBeforePosition(R,h,0,d,z);continue}else if(R>f){this.addAfterPosition(R-f,h,a-4,d,z);continue}for(;;_++){const P=m[_];if(!(R>P)){if(_==0)R/=P;else{const O=m[_-1];R=(R-O)/(P-O)}break}}if(_!=c){c=_;let P=_*6;for(g=h[P],x=h[P+1],y=h[P+2],M=h[P+3],p=h[P+4],S=h[P+5],k=h[P+6],w=h[P+7],B=(g-y*2+p)*.03,Y=(x-M*2+S)*.03,X=((y-p)*3-g+k)*.006,I=((M-S)*3-x+w)*.006,C=B*2+X,T=Y*2+I,b=(y-g)*.3+B+X*.16666667,E=(M-x)*.3+Y+I*.16666667,U=Math.sqrt(b*b+E*E),W[0]=U,P=1;P<8;P++)b+=C,E+=T,C+=X,T+=I,U+=Math.sqrt(b*b+E*E),W[P]=U;b+=C,E+=T,U+=Math.sqrt(b*b+E*E),W[8]=U,b+=C+X,E+=T+I,U+=Math.sqrt(b*b+E*E),W[9]=U,q=0}for(R*=U;;q++){const P=W[q];if(!(R>P)){if(q==0)R/=P;else{const O=W[q-1];R=q+(R-O)/(P-O)}break}}this.addCurvePosition(R*.1,g,x,y,M,p,S,k,w,d,z,i||V>0&&J==0)}return d}addBeforePosition(s,t,i,e,r){const o=t[i],d=t[i+1],h=t[i+2]-o,n=t[i+3]-d,a=Math.atan2(n,h);e[r]=o+s*Math.cos(a),e[r+1]=d+s*Math.sin(a),e[r+2]=a}addAfterPosition(s,t,i,e,r){const o=t[i+2],d=t[i+3],h=o-t[i],n=d-t[i+1],a=Math.atan2(n,h);e[r]=o+s*Math.cos(a),e[r+1]=d+s*Math.sin(a),e[r+2]=a}addCurvePosition(s,t,i,e,r,o,d,h,n,a,l,c){if(s==0||isNaN(s)){a[l]=t,a[l+1]=i,a[l+2]=Math.atan2(r-i,e-t);return}const m=s*s,f=m*s,g=1-s,x=g*g,y=x*g,M=g*s,p=M*3,S=g*p,k=p*s,w=t*y+e*S+o*k+h*f,B=i*y+r*S+d*k+n*f;a[l]=w,a[l+1]=B,c&&(s<.001?a[l+2]=Math.atan2(r-i,e-t):a[l+2]=Math.atan2(B-(i*x+r*M*2+d*m),w-(t*x+e*M*2+o*m)))}};let wt=ht;wt.NONE=-1,wt.BEFORE=-2,wt.AFTER=-3,wt.epsilon=1e-5;class De{constructor(t,i){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new u.Vector2,this.active=!1,!t)throw new Error("data cannot be null.");if(!i)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(i.findBone(t.bones[e].name));this.target=i.findBone(t.target.name)}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,i=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,h=i!=0||e!=0,n=this.target,a=n.matrix,l=a.a,c=a.c,m=a.b,f=a.d,g=l*f-c*m>0?u.MathUtils.degRad:-u.MathUtils.degRad,x=this.data.offsetRotation*g,y=this.data.offsetShearY*g,M=this.bones;for(let p=0,S=M.length;p<S;p++){const k=M[p],w=k.matrix;if(t!=0){const B=w.a,Y=w.c,X=w.b,I=w.d;let C=Math.atan2(m,l)-Math.atan2(X,B)+x;C>u.MathUtils.PI?C-=u.MathUtils.PI2:C<-u.MathUtils.PI&&(C+=u.MathUtils.PI2),C*=t;const T=Math.cos(C),b=Math.sin(C);w.a=T*B-b*X,w.c=T*Y-b*I,w.b=b*B+T*X,w.d=b*Y+T*I}if(h){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),w.tx+=(B.x-w.tx)*i,w.ty+=(B.y-w.ty)*e}if(r!=0){let B=Math.sqrt(w.a*w.a+w.b*w.b);B!=0&&(B=(B+(Math.sqrt(l*l+m*m)-B+this.data.offsetScaleX)*r)/B),w.a*=B,w.b*=B}if(o!=0){let B=Math.sqrt(w.c*w.c+w.d*w.d);B!=0&&(B=(B+(Math.sqrt(c*c+f*f)-B+this.data.offsetScaleY)*o)/B),w.c*=B,w.d*=B}if(d>0){const B=w.c,Y=w.d,X=Math.atan2(Y,B);let I=Math.atan2(f,c)-Math.atan2(m,l)-(X-Math.atan2(w.b,w.a));I>u.MathUtils.PI?I-=u.MathUtils.PI2:I<-u.MathUtils.PI&&(I+=u.MathUtils.PI2),I=X+(I+y)*d;const C=Math.sqrt(B*B+Y*Y);w.c=Math.cos(I)*C,w.d=Math.sin(I)*C}k.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,i=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,h=i!=0||e!=0,n=this.target,a=n.matrix,l=a.a,c=a.c,m=a.b,f=a.d,g=l*f-c*m>0?u.MathUtils.degRad:-u.MathUtils.degRad,x=this.data.offsetRotation*g,y=this.data.offsetShearY*g,M=this.bones;for(let p=0,S=M.length;p<S;p++){const k=M[p],w=k.matrix;if(t!=0){const B=w.a,Y=w.c,X=w.b,I=w.d;let C=Math.atan2(m,l)+x;C>u.MathUtils.PI?C-=u.MathUtils.PI2:C<-u.MathUtils.PI&&(C+=u.MathUtils.PI2),C*=t;const T=Math.cos(C),b=Math.sin(C);w.a=T*B-b*X,w.c=T*Y-b*I,w.b=b*B+T*X,w.d=b*Y+T*I}if(h){const B=this.temp;n.localToWorld(B.set(this.data.offsetX,this.data.offsetY)),w.tx+=B.x*i,w.ty+=B.y*e}if(r!=0){const B=(Math.sqrt(l*l+m*m)-1+this.data.offsetScaleX)*r+1;w.a*=B,w.b*=B}if(o!=0){const B=(Math.sqrt(c*c+f*f)-1+this.data.offsetScaleY)*o+1;w.c*=B,w.d*=B}if(d>0){let B=Math.atan2(f,c)-Math.atan2(m,l);B>u.MathUtils.PI?B-=u.MathUtils.PI2:B<-u.MathUtils.PI&&(B+=u.MathUtils.PI2);const Y=w.c,X=w.d;B=Math.atan2(X,Y)+(B-u.MathUtils.PI/2+y)*d;const I=Math.sqrt(Y*Y+X*X);w.c=Math.cos(B)*I,w.d=Math.sin(B)*I}k.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,i=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,h=this.target,n=this.bones;for(let a=0,l=n.length;a<l;a++){const c=n[a];let m=c.arotation;if(t!=0){let p=h.arotation-m+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,m+=p*t}let f=c.ax,g=c.ay;f+=(h.ax-f+this.data.offsetX)*i,g+=(h.ay-g+this.data.offsetY)*e;let x=c.ascaleX,y=c.ascaleY;r!=0&&x!=0&&(x=(x+(h.ascaleX-x+this.data.offsetScaleX)*r)/x),o!=0&&y!=0&&(y=(y+(h.ascaleY-y+this.data.offsetScaleY)*o)/y);let M=c.ashearY;if(d!=0){let p=h.ashearY-M+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,M+=p*d}c.updateWorldTransformWith(f,g,m,x,y,c.ashearX,M)}}applyRelativeLocal(){const t=this.mixRotate,i=this.mixX,e=this.mixY,r=this.mixScaleX,o=this.mixScaleY,d=this.mixShearY,h=this.target,n=this.bones;for(let a=0,l=n.length;a<l;a++){const c=n[a],m=c.arotation+(h.arotation+this.data.offsetRotation)*t,f=c.ax+(h.ax+this.data.offsetX)*i,g=c.ay+(h.ay+this.data.offsetY)*e,x=c.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*r+1),y=c.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*o+1),M=c.ashearY+(h.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(f,g,m,x,y,c.ashearX,M)}}}const At=class{constructor(s){if(this.data=null,this.bones=null,this.slots=null,this.drawOrder=null,this.ikConstraints=null,this.transformConstraints=null,this.pathConstraints=null,this._updateCache=new Array,this.skin=null,this.color=null,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!s)throw new Error("data cannot be null.");this.data=s,this.bones=new Array;for(let t=0;t<s.bones.length;t++){const i=s.bones[t];let e;if(!i.parent)e=new le(i,this,null);else{const r=this.bones[i.parent.index];e=new le(i,this,r),r.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<s.slots.length;t++){const i=s.slots[t],e=this.bones[i.boneData.index],r=new Vt(i,e);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<s.ikConstraints.length;t++){const i=s.ikConstraints[t];this.ikConstraints.push(new Ue(i,this))}this.transformConstraints=new Array;for(let t=0;t<s.transformConstraints.length;t++){const i=s.transformConstraints[t];this.transformConstraints.push(new De(i,this))}this.pathConstraints=new Array;for(let t=0;t<s.pathConstraints.length;t++){const i=s.pathConstraints[t];this.pathConstraints.push(new wt(i,this))}this.color=new u.Color(1,1,1,1),this.updateCache()}updateCache(){const s=this._updateCache;s.length=0;const t=this.bones;for(let a=0,l=t.length;a<l;a++){const c=t[a];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const a=this.skin.bones;for(let l=0,c=this.skin.bones.length;l<c;l++){let m=this.bones[a[l].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const i=this.ikConstraints,e=this.transformConstraints,r=this.pathConstraints,o=i.length,d=e.length,h=r.length,n=o+d+h;t:for(let a=0;a<n;a++){for(let l=0;l<o;l++){const c=i[l];if(c.data.order==a){this.sortIkConstraint(c);continue t}}for(let l=0;l<d;l++){const c=e[l];if(c.data.order==a){this.sortTransformConstraint(c);continue t}}for(let l=0;l<h;l++){const c=r[l];if(c.data.order==a){this.sortPathConstraint(c);continue t}}}for(let a=0,l=t.length;a<l;a++)this.sortBone(t[a])}sortIkConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&u.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target;this.sortBone(t);const i=s.bones,e=i[0];if(this.sortBone(e),i.length==1)this._updateCache.push(s),this.sortReset(e.children);else{const r=i[i.length-1];this.sortBone(r),this._updateCache.push(s),this.sortReset(e.children),r.sorted=!0}}sortPathConstraint(s){if(s.active=s.target.bone.isActive()&&(!s.data.skinRequired||this.skin&&u.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target,i=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,i,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,i,e);for(let h=0,n=this.data.skins.length;h<n;h++)this.sortPathConstraintAttachment(this.data.skins[h],i,e);const r=t.getAttachment();r instanceof gt&&this.sortPathConstraintAttachmentWith(r,e);const o=s.bones,d=o.length;for(let h=0;h<d;h++)this.sortBone(o[h]);this._updateCache.push(s);for(let h=0;h<d;h++)this.sortReset(o[h].children);for(let h=0;h<d;h++)o[h].sorted=!0}sortTransformConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&u.Utils.contains(this.skin.constraints,s.data,!0)),!s.active)return;this.sortBone(s.target);const t=s.bones,i=t.length;if(s.data.local)for(let e=0;e<i;e++){const r=t[e];this.sortBone(r.parent),this.sortBone(r)}else for(let e=0;e<i;e++)this.sortBone(t[e]);this._updateCache.push(s);for(let e=0;e<i;e++)this.sortReset(t[e].children);for(let e=0;e<i;e++)t[e].sorted=!0}sortPathConstraintAttachment(s,t,i){const e=s.attachments[t];if(e)for(const r in e)this.sortPathConstraintAttachmentWith(e[r],i)}sortPathConstraintAttachmentWith(s,t){if(!(s instanceof gt))return;const i=s.bones;if(!i)this.sortBone(t);else{const e=this.bones;for(let r=0,o=i.length;r<o;){let d=i[r++];for(d+=r;r<d;)this.sortBone(e[i[r++]])}}}sortBone(s){if(s.sorted)return;const t=s.parent;t&&this.sortBone(t),s.sorted=!0,this._updateCache.push(s)}sortReset(s){for(let t=0,i=s.length;t<i;t++){const e=s[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const s=this.bones;for(let i=0,e=s.length;i<e;i++){const r=s[i];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const t=this._updateCache;for(let i=0,e=t.length;i<e;i++)t[i].update()}updateWorldTransformWith(s){const t=this.getRootBone(),i=s.matrix.a,e=s.matrix.c,r=s.matrix.b,o=s.matrix.d;t.matrix.tx=i*this.x+e*this.y+s.worldX,t.matrix.ty=r*this.x+o*this.y+s.worldY;const d=t.rotation+90+t.shearY,h=u.MathUtils.cosDeg(t.rotation+t.shearX)*t.scaleX,n=u.MathUtils.cosDeg(d)*t.scaleY,a=u.MathUtils.sinDeg(t.rotation+t.shearX)*t.scaleX,l=u.MathUtils.sinDeg(d)*t.scaleY,c=this.scaleX,m=u.settings.yDown?-this.scaleY:this.scaleY;t.matrix.a=(i*h+e*a)*c,t.matrix.c=(i*n+e*l)*c,t.matrix.b=(r*h+o*a)*m,t.matrix.d=(r*n+o*l)*m;const f=this._updateCache;for(let g=0,x=f.length;g<x;g++){const y=f[g];y!=t&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const s=this.bones;for(let r=0,o=s.length;r<o;r++)s[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,o=t.length;r<o;r++){const d=t[r];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const i=this.transformConstraints;for(let r=0,o=i.length;r<o;r++){const d=i[r],h=d.data;d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY,d.mixScaleX=h.mixScaleX,d.mixScaleY=h.mixScaleY,d.mixShearY=h.mixShearY}const e=this.pathConstraints;for(let r=0,o=e.length;r<o;r++){const d=e[r],h=d.data;d.position=h.position,d.spacing=h.spacing,d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY}}setSlotsToSetupPose(){const s=this.slots;u.Utils.arrayCopy(s,0,this.drawOrder,0,s.length);for(let t=0,i=s.length;t<i;t++)s[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(r.data.name==s)return r}return null}findBoneIndex(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let i=0,e=t.length;i<e;i++)if(t[i].data.name==s)return i;return-1}findSlot(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(r.data.name==s)return r}return null}findSlotIndex(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let i=0,e=t.length;i<e;i++)if(t[i].data.name==s)return i;return-1}setSkinByName(s){const t=this.data.findSkin(s);if(!t)throw new Error(`Skin not found: ${s}`);this.setSkin(t)}setSkin(s){if(s!=this.skin){if(s)if(this.skin)s.attachAll(this,this.skin);else{const t=this.slots;for(let i=0,e=t.length;i<e;i++){const r=t[i],o=r.data.attachmentName;if(o){const d=s.getAttachment(i,o);d&&r.setAttachment(d)}}}this.skin=s,this.updateCache()}}getAttachmentByName(s,t){return this.getAttachment(this.data.findSlot(s).index,t)}getAttachment(s,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const i=this.skin.getAttachment(s,t);if(i)return i}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(s,t):null}setAttachment(s,t){if(!s)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.data.name==s){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${s}`);o.setAttachment(d);return}}throw new Error(`Slot not found: ${s}`)}findIkConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(r.data.name==s)return r}return null}findTransformConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(r.data.name==s)return r}return null}findPathConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let i=0,e=t.length;i<e;i++){const r=t[i];if(r.data.name==s)return r}return null}getBoundsRect(){const s=new u.Vector2,t=new u.Vector2;return this.getBounds(s,t),{x:s.x,y:s.y,width:t.x,height:t.y}}getBounds(s,t,i=new Array(2)){if(!s)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let r=Number.POSITIVE_INFINITY,o=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let n=0,a=e.length;n<a;n++){const l=e[n];if(!l.bone.active)continue;let c=0,m=null;const f=l.getAttachment();if(f instanceof D)c=8,m=u.Utils.setArraySize(i,c,0),f.computeWorldVertices(l.bone,m,0,2);else if(f instanceof ft){const g=f;c=g.worldVerticesLength,m=u.Utils.setArraySize(i,c,0),g.computeWorldVertices(l,0,c,m,0,2)}if(m)for(let g=0,x=m.length;g<x;g+=2){const y=m[g],M=m[g+1];r=Math.min(r,y),o=Math.min(o,M),d=Math.max(d,y),h=Math.max(h,M)}}s.set(r,o),t.set(d-r,h-o)}update(s){this.time+=s}get flipX(){return this.scaleX==-1}set flipX(s){At.deprecatedWarning1||(At.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=s?1:-1}get flipY(){return this.scaleY==-1}set flipY(s){At.deprecatedWarning1||(At.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=s?1:-1}};let fe=At;fe.deprecatedWarning1=!1;class ge{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const i=this.bones;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const i=this.bones;for(let e=0,r=i.length;e<r;e++)if(i[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const i=this.slots;for(let e=0,r=i.length;e<r;e++)if(i[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const i=this.skins;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const i=this.events;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const i=this.animations;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.ikConstraints;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.transformConstraints;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const i=this.pathConstraints;for(let e=0,r=i.length;e<r;e++){const o=i[e];if(o.name==t)return o}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const i=this.pathConstraints;for(let e=0,r=i.length;e<r;e++)if(i[e].name==t)return e;return-1}}class pe{constructor(t,i,e){if(this.color=new u.Color(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(!i)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=i,this.boneData=e}}class xe extends vt{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class we{constructor(t,i,e){this.slotIndex=t,this.name=i,this.attachment=e}}class Et{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,i,e){if(!e)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][i]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let o=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){o=!0;break}o||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let o=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){o=!0;break}o||this.constraints.push(r)}const i=t.getAttachments();for(let e=0;e<i.length;e++){const r=i[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let o=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){o=!0;break}o||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let o=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){o=!0;break}o||this.constraints.push(r)}const i=t.getAttachments();for(let e=0;e<i.length;e++){const r=i[e];r.attachment&&(r.attachment instanceof ft?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,i){const e=this.attachments[t];return e?e[i]:null}removeAttachment(t,i){const e=this.attachments[t];e&&(e[i]=null)}getAttachments(){const t=new Array;for(let i=0;i<this.attachments.length;i++){const e=this.attachments[i];if(e)for(const r in e){const o=e[r];o&&t.push(new we(i,r,o))}}return t}getAttachmentsForSlot(t,i){const e=this.attachments[t];if(e)for(const r in e){const o=e[r];o&&i.push(new we(t,r,o))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,i){let e=0;for(let r=0;r<t.slots.length;r++){const o=t.slots[r],d=o.getAttachment();if(d&&e<i.attachments.length){const h=i.attachments[e];for(const n in h){const a=h[n];if(d==a){const l=this.getAttachment(e,n);l&&o.setAttachment(l);break}}}e++}}}const Re=class{constructor(s){this.scale=1,this.attachmentLoader=null,this.linkedMeshes=new Array,this.attachmentLoader=s}readSkeletonData(s){const t=this.scale,i=new ge;i.name="";const e=new u.BinaryInput(s),r=e.readInt32(),o=e.readInt32();if(i.hash=o==0&&r==0?null:o.toString(16)+r.toString(16),i.version=e.readString(),i.version.substr(0,3)!=="4.0"){const a=`Spine 4.0 loader cant load version ${i.version}. Please configure your pixi-spine bundle`;console.error(a)}i.x=e.readFloat(),i.y=e.readFloat(),i.width=e.readFloat(),i.height=e.readFloat();const d=e.readBoolean();d&&(i.fps=e.readFloat(),i.imagesPath=e.readString(),i.audioPath=e.readString());let h=0;h=e.readInt(!0);for(let a=0;a<h;a++)e.strings.push(e.readString());h=e.readInt(!0);for(let a=0;a<h;a++){const l=e.readString(),c=a==0?null:i.bones[e.readInt(!0)],m=new he(a,l,c);m.rotation=e.readFloat(),m.x=e.readFloat()*t,m.y=e.readFloat()*t,m.scaleX=e.readFloat(),m.scaleY=e.readFloat(),m.shearX=e.readFloat(),m.shearY=e.readFloat(),m.length=e.readFloat()*t,m.transformMode=e.readInt(!0),m.skinRequired=e.readBoolean(),d&&u.Color.rgba8888ToColor(m.color,e.readInt32()),i.bones.push(m)}h=e.readInt(!0);for(let a=0;a<h;a++){const l=e.readString(),c=i.bones[e.readInt(!0)],m=new pe(a,l,c);u.Color.rgba8888ToColor(m.color,e.readInt32());const f=e.readInt32();f!=-1&&u.Color.rgb888ToColor(m.darkColor=new u.Color,f),m.attachmentName=e.readStringRef(),m.blendMode=Re.BlendModeValues[e.readInt(!0)],i.slots.push(m)}h=e.readInt(!0);for(let a=0,l;a<h;a++){const c=new me(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let m=0;m<l;m++)c.bones.push(i.bones[e.readInt(!0)]);c.target=i.bones[e.readInt(!0)],c.mix=e.readFloat(),c.softness=e.readFloat()*t,c.bendDirection=e.readByte(),c.compress=e.readBoolean(),c.stretch=e.readBoolean(),c.uniform=e.readBoolean(),i.ikConstraints.push(c)}h=e.readInt(!0);for(let a=0,l;a<h;a++){const c=new xe(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let m=0;m<l;m++)c.bones.push(i.bones[e.readInt(!0)]);c.target=i.bones[e.readInt(!0)],c.local=e.readBoolean(),c.relative=e.readBoolean(),c.offsetRotation=e.readFloat(),c.offsetX=e.readFloat()*t,c.offsetY=e.readFloat()*t,c.offsetScaleX=e.readFloat(),c.offsetScaleY=e.readFloat(),c.offsetShearY=e.readFloat(),c.mixRotate=e.readFloat(),c.mixX=e.readFloat(),c.mixY=e.readFloat(),c.mixScaleX=e.readFloat(),c.mixScaleY=e.readFloat(),c.mixShearY=e.readFloat(),i.transformConstraints.push(c)}h=e.readInt(!0);for(let a=0,l;a<h;a++){const c=new ue(e.readString());c.order=e.readInt(!0),c.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let m=0;m<l;m++)c.bones.push(i.bones[e.readInt(!0)]);c.target=i.slots[e.readInt(!0)],c.positionMode=e.readInt(!0),c.spacingMode=e.readInt(!0),c.rotateMode=e.readInt(!0),c.offsetRotation=e.readFloat(),c.position=e.readFloat(),c.positionMode==u.PositionMode.Fixed&&(c.position*=t),c.spacing=e.readFloat(),(c.spacingMode==H.Length||c.spacingMode==H.Fixed)&&(c.spacing*=t),c.mixRotate=e.readFloat(),c.mixX=e.readFloat(),c.mixY=e.readFloat(),i.pathConstraints.push(c)}const n=this.readSkin(e,i,!0,d);n&&(i.defaultSkin=n,i.skins.push(n));{let a=i.skins.length;for(u.Utils.setArraySize(i.skins,h=a+e.readInt(!0));a<h;a++)i.skins[a]=this.readSkin(e,i,!1,d)}h=this.linkedMeshes.length;for(let a=0;a<h;a++){const l=this.linkedMeshes[a],c=(l.skin?i.findSkin(l.skin):i.defaultSkin).getAttachment(l.slotIndex,l.parent);l.mesh.deformAttachment=l.inheritDeform?c:l.mesh,l.mesh.setParentMesh(c)}this.linkedMeshes.length=0,h=e.readInt(!0);for(let a=0;a<h;a++){const l=new de(e.readStringRef());l.intValue=e.readInt(!1),l.floatValue=e.readFloat(),l.stringValue=e.readString(),l.audioPath=e.readString(),l.audioPath&&(l.volume=e.readFloat(),l.balance=e.readFloat()),i.events.push(l)}h=e.readInt(!0);for(let a=0;a<h;a++)i.animations.push(this.readAnimation(e,e.readString(),i));return i}readSkin(s,t,i,e){let r=null,o=0;if(i){if(o=s.readInt(!0),o==0)return null;r=new Et("default")}else{r=new Et(s.readStringRef()),r.bones.length=s.readInt(!0);for(let d=0,h=r.bones.length;d<h;d++)r.bones[d]=t.bones[s.readInt(!0)];for(let d=0,h=s.readInt(!0);d<h;d++)r.constraints.push(t.ikConstraints[s.readInt(!0)]);for(let d=0,h=s.readInt(!0);d<h;d++)r.constraints.push(t.transformConstraints[s.readInt(!0)]);for(let d=0,h=s.readInt(!0);d<h;d++)r.constraints.push(t.pathConstraints[s.readInt(!0)]);o=s.readInt(!0)}for(let d=0;d<o;d++){const h=s.readInt(!0);for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readStringRef(),c=this.readAttachment(s,t,r,h,l,e);c&&r.setAttachment(h,l,c)}}return r}readAttachment(s,t,i,e,r,o){const d=this.scale;let h=s.readStringRef();switch(h||(h=r),s.readByte()){case u.AttachmentType.Region:{let n=s.readStringRef();const a=s.readFloat(),l=s.readFloat(),c=s.readFloat(),m=s.readFloat(),f=s.readFloat(),g=s.readFloat(),x=s.readFloat(),y=s.readInt32();n||(n=h);const M=this.attachmentLoader.newRegionAttachment(i,h,n);return M?(M.path=n,M.x=l*d,M.y=c*d,M.scaleX=m,M.scaleY=f,M.rotation=a,M.width=g*d,M.height=x*d,u.Color.rgba8888ToColor(M.color,y),M):null}case u.AttachmentType.BoundingBox:{const n=s.readInt(!0),a=this.readVertices(s,n),l=o?s.readInt32():0,c=this.attachmentLoader.newBoundingBoxAttachment(i,h);return c?(c.worldVerticesLength=n<<1,c.vertices=a.vertices,c.bones=a.bones,o&&u.Color.rgba8888ToColor(c.color,l),c):null}case u.AttachmentType.Mesh:{let n=s.readStringRef();const a=s.readInt32(),l=s.readInt(!0),c=this.readFloatArray(s,l<<1,1),m=this.readShortArray(s),f=this.readVertices(s,l),g=s.readInt(!0);let x=null,y=0,M=0;o&&(x=this.readShortArray(s),y=s.readFloat(),M=s.readFloat()),n||(n=h);const p=this.attachmentLoader.newMeshAttachment(i,h,n);return p?(p.path=n,u.Color.rgba8888ToColor(p.color,a),p.bones=f.bones,p.vertices=f.vertices,p.worldVerticesLength=l<<1,p.triangles=m,p.regionUVs=new Float32Array(c),p.hullLength=g<<1,o&&(p.edges=x,p.width=y*d,p.height=M*d),p):null}case u.AttachmentType.LinkedMesh:{let n=s.readStringRef();const a=s.readInt32(),l=s.readStringRef(),c=s.readStringRef(),m=s.readBoolean();let f=0,g=0;o&&(f=s.readFloat(),g=s.readFloat()),n||(n=h);const x=this.attachmentLoader.newMeshAttachment(i,h,n);return x?(x.path=n,u.Color.rgba8888ToColor(x.color,a),o&&(x.width=f*d,x.height=g*d),this.linkedMeshes.push(new Ze(x,l,e,c,m)),x):null}case u.AttachmentType.Path:{const n=s.readBoolean(),a=s.readBoolean(),l=s.readInt(!0),c=this.readVertices(s,l),m=u.Utils.newArray(l/3,0);for(let x=0,y=m.length;x<y;x++)m[x]=s.readFloat()*d;const f=o?s.readInt32():0,g=this.attachmentLoader.newPathAttachment(i,h);return g?(g.closed=n,g.constantSpeed=a,g.worldVerticesLength=l<<1,g.vertices=c.vertices,g.bones=c.bones,g.lengths=m,o&&u.Color.rgba8888ToColor(g.color,f),g):null}case u.AttachmentType.Point:{const n=s.readFloat(),a=s.readFloat(),l=s.readFloat(),c=o?s.readInt32():0,m=this.attachmentLoader.newPointAttachment(i,h);return m?(m.x=a*d,m.y=l*d,m.rotation=n,o&&u.Color.rgba8888ToColor(m.color,c),m):null}case u.AttachmentType.Clipping:{const n=s.readInt(!0),a=s.readInt(!0),l=this.readVertices(s,a),c=o?s.readInt32():0,m=this.attachmentLoader.newClippingAttachment(i,h);return m?(m.endSlot=t.slots[n],m.worldVerticesLength=a<<1,m.vertices=l.vertices,m.bones=l.bones,o&&u.Color.rgba8888ToColor(m.color,c),m):null}}return null}readVertices(s,t){const i=this.scale,e=t<<1,r=new Ke;if(!s.readBoolean())return r.vertices=this.readFloatArray(s,e,i),r;const o=new Array,d=new Array;for(let h=0;h<t;h++){const n=s.readInt(!0);d.push(n);for(let a=0;a<n;a++)d.push(s.readInt(!0)),o.push(s.readFloat()*i),o.push(s.readFloat()*i),o.push(s.readFloat())}return r.vertices=u.Utils.toFloatArray(o),r.bones=d,r}readFloatArray(s,t,i){const e=new Array(t);if(i==1)for(let r=0;r<t;r++)e[r]=s.readFloat();else for(let r=0;r<t;r++)e[r]=s.readFloat()*i;return e}readShortArray(s){const t=s.readInt(!0),i=new Array(t);for(let e=0;e<t;e++)i[e]=s.readShort();return i}readAnimation(s,t,i){s.readInt(!0);const e=new Array,r=this.scale;for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readInt(!0);for(let c=0,m=s.readInt(!0);c<m;c++){const f=s.readByte(),g=s.readInt(!0),x=g-1;switch(f){case cn:{const y=new pt(g,l);for(let M=0;M<g;M++)y.setFrame(M,s.readFloat(),s.readStringRef());e.push(y);break}case dn:{const y=s.readInt(!0),M=new Gt(g,y,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,w=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255;for(let Y=0,X=0;M.setFrame(Y,p,S,k,w,B),Y!=x;Y++){const I=s.readFloat(),C=s.readUnsignedByte()/255,T=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255;switch(s.readByte()){case nt:M.setStepped(Y);break;case st:L(s,M,X++,Y,0,p,I,S,C,1),L(s,M,X++,Y,1,p,I,k,T,1),L(s,M,X++,Y,2,p,I,w,b,1),L(s,M,X++,Y,3,p,I,B,E,1)}p=I,S=C,k=T,w=b,B=E}e.push(M);break}case mn:{const y=s.readInt(!0),M=new Ht(g,y,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,w=s.readUnsignedByte()/255;for(let B=0,Y=0;M.setFrame(B,p,S,k,w),B!=x;B++){const X=s.readFloat(),I=s.readUnsignedByte()/255,C=s.readUnsignedByte()/255,T=s.readUnsignedByte()/255;switch(s.readByte()){case nt:M.setStepped(B);break;case st:L(s,M,Y++,B,0,p,X,S,I,1),L(s,M,Y++,B,1,p,X,k,C,1),L(s,M,Y++,B,2,p,X,w,T,1)}p=X,S=I,k=C,w=T}e.push(M);break}case un:{const y=s.readInt(!0),M=new Zt(g,y,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,w=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255,Y=s.readUnsignedByte()/255,X=s.readUnsignedByte()/255,I=s.readUnsignedByte()/255;for(let C=0,T=0;M.setFrame(C,p,S,k,w,B,Y,X,I),C!=x;C++){const b=s.readFloat(),E=s.readUnsignedByte()/255,v=s.readUnsignedByte()/255,W=s.readUnsignedByte()/255,U=s.readUnsignedByte()/255,V=s.readUnsignedByte()/255,z=s.readUnsignedByte()/255,_=s.readUnsignedByte()/255;switch(s.readByte()){case nt:M.setStepped(C);break;case st:L(s,M,T++,C,0,p,b,S,E,1),L(s,M,T++,C,1,p,b,k,v,1),L(s,M,T++,C,2,p,b,w,W,1),L(s,M,T++,C,3,p,b,B,U,1),L(s,M,T++,C,4,p,b,Y,V,1),L(s,M,T++,C,5,p,b,X,z,1),L(s,M,T++,C,6,p,b,I,_,1)}p=b,S=E,k=v,w=W,B=U,Y=V,X=z,I=_}e.push(M);break}case fn:{const y=s.readInt(!0),M=new Kt(g,y,l);let p=s.readFloat(),S=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,w=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255,Y=s.readUnsignedByte()/255,X=s.readUnsignedByte()/255;for(let I=0,C=0;M.setFrame(I,p,S,k,w,B,Y,X),I!=x;I++){const T=s.readFloat(),b=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255,v=s.readUnsignedByte()/255,W=s.readUnsignedByte()/255,U=s.readUnsignedByte()/255,V=s.readUnsignedByte()/255;switch(s.readByte()){case nt:M.setStepped(I);break;case st:L(s,M,C++,I,0,p,T,S,b,1),L(s,M,C++,I,1,p,T,k,E,1),L(s,M,C++,I,2,p,T,w,v,1),L(s,M,C++,I,3,p,T,B,W,1),L(s,M,C++,I,4,p,T,Y,U,1),L(s,M,C++,I,5,p,T,X,V,1)}p=T,S=b,k=E,w=v,B=W,Y=U,X=V}e.push(M);break}case gn:{const y=new Jt(g,s.readInt(!0),l);let M=s.readFloat(),p=s.readUnsignedByte()/255;for(let S=0,k=0;y.setFrame(S,M,p),S!=x;S++){const w=s.readFloat(),B=s.readUnsignedByte()/255;switch(s.readByte()){case nt:y.setStepped(S);break;case st:L(s,y,k++,S,0,M,w,p,B,1)}M=w,p=B}e.push(y);break}}}}for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readInt(!0);for(let c=0,m=s.readInt(!0);c<m;c++){const f=s.readByte(),g=s.readInt(!0),x=s.readInt(!0);switch(f){case Qe:e.push(ct(s,new kt(g,x,l),1));break;case tn:e.push(Me(s,new Lt(g,x,l),r));break;case en:e.push(ct(s,new Nt(g,x,l),r));break;case nn:e.push(ct(s,new Wt(g,x,l),r));break;case sn:e.push(Me(s,new $t(g,x,l),1));break;case an:e.push(ct(s,new Ot(g,x,l),1));break;case rn:e.push(ct(s,new qt(g,x,l),1));break;case on:e.push(Me(s,new zt(g,x,l),1));break;case ln:e.push(ct(s,new jt(g,x,l),1));break;case hn:e.push(ct(s,new _t(g,x,l),1))}}}for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readInt(!0),c=s.readInt(!0),m=c-1,f=new te(c,s.readInt(!0),l);let g=s.readFloat(),x=s.readFloat(),y=s.readFloat()*r;for(let M=0,p=0;f.setFrame(M,g,x,y,s.readByte(),s.readBoolean(),s.readBoolean()),M!=m;M++){const S=s.readFloat(),k=s.readFloat(),w=s.readFloat()*r;switch(s.readByte()){case nt:f.setStepped(M);break;case st:L(s,f,p++,M,0,g,S,x,k,1),L(s,f,p++,M,1,g,S,y,w,r)}g=S,x=k,y=w}e.push(f)}for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readInt(!0),c=s.readInt(!0),m=c-1,f=new ee(c,s.readInt(!0),l);let g=s.readFloat(),x=s.readFloat(),y=s.readFloat(),M=s.readFloat(),p=s.readFloat(),S=s.readFloat(),k=s.readFloat();for(let w=0,B=0;f.setFrame(w,g,x,y,M,p,S,k),w!=m;w++){const Y=s.readFloat(),X=s.readFloat(),I=s.readFloat(),C=s.readFloat(),T=s.readFloat(),b=s.readFloat(),E=s.readFloat();switch(s.readByte()){case nt:f.setStepped(w);break;case st:L(s,f,B++,w,0,g,Y,x,X,1),L(s,f,B++,w,1,g,Y,y,I,1),L(s,f,B++,w,2,g,Y,M,C,1),L(s,f,B++,w,3,g,Y,p,T,1),L(s,f,B++,w,4,g,Y,S,b,1),L(s,f,B++,w,5,g,Y,k,E,1)}g=Y,x=X,y=I,M=C,p=T,S=b,k=E}e.push(f)}for(let n=0,a=s.readInt(!0);n<a;n++){const l=s.readInt(!0),c=i.pathConstraints[l];for(let m=0,f=s.readInt(!0);m<f;m++)switch(s.readByte()){case pn:e.push(ct(s,new ne(s.readInt(!0),s.readInt(!0),l),c.positionMode==u.PositionMode.Fixed?r:1));break;case xn:e.push(ct(s,new se(s.readInt(!0),s.readInt(!0),l),c.spacingMode==H.Length||c.spacingMode==H.Fixed?r:1));break;case wn:const g=new ie(s.readInt(!0),s.readInt(!0),l);let x=s.readFloat(),y=s.readFloat(),M=s.readFloat(),p=s.readFloat();for(let S=0,k=0,w=g.getFrameCount()-1;g.setFrame(S,x,y,M,p),S!=w;S++){const B=s.readFloat(),Y=s.readFloat(),X=s.readFloat(),I=s.readFloat();switch(s.readByte()){case nt:g.setStepped(S);break;case st:L(s,g,k++,S,0,x,B,y,Y,1),L(s,g,k++,S,1,x,B,M,X,1),L(s,g,k++,S,2,x,B,p,I,1)}x=B,y=Y,M=X,p=I}e.push(g)}}for(let n=0,a=s.readInt(!0);n<a;n++){const l=i.skins[s.readInt(!0)];for(let c=0,m=s.readInt(!0);c<m;c++){const f=s.readInt(!0);for(let g=0,x=s.readInt(!0);g<x;g++){const y=s.readStringRef(),M=l.getAttachment(f,y),p=M.bones,S=M.vertices,k=p?S.length/3*2:S.length,w=s.readInt(!0),B=w-1,Y=s.readInt(!0),X=new Qt(w,Y,f,M);let I=s.readFloat();for(let C=0,T=0;;C++){let b,E=s.readInt(!0);if(E==0)b=p?u.Utils.newFloatArray(k):S;else{b=u.Utils.newFloatArray(k);const W=s.readInt(!0);if(E+=W,r==1)for(let U=W;U<E;U++)b[U]=s.readFloat();else for(let U=W;U<E;U++)b[U]=s.readFloat()*r;if(!p)for(let U=0,V=b.length;U<V;U++)b[U]+=S[U]}if(X.setFrame(C,I,b),C==B)break;const v=s.readFloat();switch(s.readByte()){case nt:X.setStepped(C);break;case st:L(s,X,T++,C,0,I,v,0,1,1)}I=v}e.push(X)}}}const o=s.readInt(!0);if(o>0){const n=new xt(o),a=i.slots.length;for(let l=0;l<o;l++){const c=s.readFloat(),m=s.readInt(!0),f=u.Utils.newArray(a,0);for(let M=a-1;M>=0;M--)f[M]=-1;const g=u.Utils.newArray(a-m,0);let x=0,y=0;for(let M=0;M<m;M++){const p=s.readInt(!0);for(;x!=p;)g[y++]=x++;f[x+s.readInt(!0)]=x++}for(;x<a;)g[y++]=x++;for(let M=a-1;M>=0;M--)f[M]==-1&&(f[M]=g[--y]);n.setFrame(l,c,f)}e.push(n)}const d=s.readInt(!0);if(d>0){const n=new St(d);for(let a=0;a<d;a++){const l=s.readFloat(),c=i.events[s.readInt(!0)],m=new ce(l,c);m.intValue=s.readInt(!1),m.floatValue=s.readFloat(),m.stringValue=s.readBoolean()?s.readString():c.stringValue,m.data.audioPath&&(m.volume=s.readFloat(),m.balance=s.readFloat()),n.setFrame(a,m)}e.push(n)}let h=0;for(let n=0,a=e.length;n<a;n++)h=Math.max(h,e[n].getDuration());return new Tt(t,e,h)}};let Pe=Re;Pe.BlendModeValues=[rt.BLEND_MODES.NORMAL,rt.BLEND_MODES.ADD,rt.BLEND_MODES.MULTIPLY,rt.BLEND_MODES.SCREEN];class Ze{constructor(t,i,e,r,o){this.mesh=t,this.skin=i,this.slotIndex=e,this.parent=r,this.inheritDeform=o}}class Ke{constructor(t=null,i=null){this.bones=t,this.vertices=i}}function ct(s,t,i){let e=s.readFloat(),r=s.readFloat()*i;for(let o=0,d=0,h=t.getFrameCount()-1;t.setFrame(o,e,r),o!=h;o++){const n=s.readFloat(),a=s.readFloat()*i;switch(s.readByte()){case nt:t.setStepped(o);break;case st:L(s,t,d++,o,0,e,n,r,a,i)}e=n,r=a}return t}function Me(s,t,i){let e=s.readFloat(),r=s.readFloat()*i,o=s.readFloat()*i;for(let d=0,h=0,n=t.getFrameCount()-1;t.setFrame(d,e,r,o),d!=n;d++){const a=s.readFloat(),l=s.readFloat()*i,c=s.readFloat()*i;switch(s.readByte()){case nt:t.setStepped(d);break;case st:L(s,t,h++,d,0,e,a,r,l,i),L(s,t,h++,d,1,e,a,o,c,i)}e=a,r=l,o=c}return t}function L(s,t,i,e,r,o,d,h,n,a){t.setBezier(i,e,r,o,h,s.readFloat(),s.readFloat()*a,s.readFloat(),s.readFloat()*a,d,n)}const Qe=0,tn=1,en=2,nn=3,sn=4,an=5,rn=6,on=7,ln=8,hn=9,cn=0,dn=1,mn=2,un=3,fn=4,gn=5,pn=0,xn=1,wn=2,Sn=0,nt=1,st=2;class Mn extends u.SkeletonBoundsBase{}class ye{constructor(t){this.attachmentLoader=null,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const i=this.scale,e=new ge,r=typeof t=="string"?JSON.parse(t):t,o=r.skeleton;if(o){if(e.hash=o.hash,e.version=o.spine,e.version.substr(0,3)!=="4.0"){const d=`Spine 4.0 loader cant load version ${o.spine}. Please configure your pixi-spine bundle`;console.error(d)}e.x=o.x,e.y=o.y,e.width=o.width,e.height=o.height,e.fps=o.fps,e.imagesPath=o.images}if(r.bones)for(let d=0;d<r.bones.length;d++){const h=r.bones[d];let n=null;const a=A(h,"parent",null);if(a!=null&&(n=e.findBone(a),n==null))throw new Error(`Parent bone not found: ${a}`);const l=new he(e.bones.length,h.name,n);l.length=A(h,"length",0)*i,l.x=A(h,"x",0)*i,l.y=A(h,"y",0)*i,l.rotation=A(h,"rotation",0),l.scaleX=A(h,"scaleX",1),l.scaleY=A(h,"scaleY",1),l.shearX=A(h,"shearX",0),l.shearY=A(h,"shearY",0),l.transformMode=u.Utils.enumValue(u.TransformMode,A(h,"transform","Normal")),l.skinRequired=A(h,"skin",!1);const c=A(h,"color",null);c&&l.color.setFromString(c),e.bones.push(l)}if(r.slots)for(let d=0;d<r.slots.length;d++){const h=r.slots[d],n=e.findBone(h.bone),a=new pe(e.slots.length,h.name,n),l=A(h,"color",null);l&&a.color.setFromString(l);const c=A(h,"dark",null);c&&(a.darkColor=u.Color.fromString(c)),a.attachmentName=A(h,"attachment",null),a.blendMode=ye.blendModeFromString(A(h,"blend","normal")),e.slots.push(a)}if(r.ik)for(let d=0;d<r.ik.length;d++){const h=r.ik[d],n=new me(h.name);n.order=A(h,"order",0),n.skinRequired=A(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const l=h.bones[a],c=e.findBone(l);if(c==null)throw new Error(`IK bone not found: ${l}`);n.bones.push(c)}n.target=e.findBone(h.target),n.mix=A(h,"mix",1),n.softness=A(h,"softness",0)*i,n.bendDirection=A(h,"bendPositive",!0)?1:-1,n.compress=A(h,"compress",!1),n.stretch=A(h,"stretch",!1),n.uniform=A(h,"uniform",!1),e.ikConstraints.push(n)}if(r.transform)for(let d=0;d<r.transform.length;d++){const h=r.transform[d],n=new xe(h.name);n.order=A(h,"order",0),n.skinRequired=A(h,"skin",!1);for(let l=0;l<h.bones.length;l++){const c=h.bones[l],m=e.findBone(c);if(m==null)throw new Error(`Transform constraint bone not found: ${c}`);n.bones.push(m)}const a=h.target;if(n.target=e.findBone(a),n.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);n.local=A(h,"local",!1),n.relative=A(h,"relative",!1),n.offsetRotation=A(h,"rotation",0),n.offsetX=A(h,"x",0)*i,n.offsetY=A(h,"y",0)*i,n.offsetScaleX=A(h,"scaleX",0),n.offsetScaleY=A(h,"scaleY",0),n.offsetShearY=A(h,"shearY",0),n.mixRotate=A(h,"mixRotate",1),n.mixX=A(h,"mixX",1),n.mixY=A(h,"mixY",n.mixX),n.mixScaleX=A(h,"mixScaleX",1),n.mixScaleY=A(h,"mixScaleY",n.mixScaleX),n.mixShearY=A(h,"mixShearY",1),e.transformConstraints.push(n)}if(r.path)for(let d=0;d<r.path.length;d++){const h=r.path[d],n=new ue(h.name);n.order=A(h,"order",0),n.skinRequired=A(h,"skin",!1);for(let l=0;l<h.bones.length;l++){const c=h.bones[l],m=e.findBone(c);if(m==null)throw new Error(`Transform constraint bone not found: ${c}`);n.bones.push(m)}const a=h.target;if(n.target=e.findSlot(a),n.target==null)throw new Error(`Path target slot not found: ${a}`);n.positionMode=u.Utils.enumValue(u.PositionMode,A(h,"positionMode","Percent")),n.spacingMode=u.Utils.enumValue(H,A(h,"spacingMode","Length")),n.rotateMode=u.Utils.enumValue(u.RotateMode,A(h,"rotateMode","Tangent")),n.offsetRotation=A(h,"rotation",0),n.position=A(h,"position",0),n.positionMode==u.PositionMode.Fixed&&(n.position*=i),n.spacing=A(h,"spacing",0),(n.spacingMode==H.Length||n.spacingMode==H.Fixed)&&(n.spacing*=i),n.mixRotate=A(h,"mixRotate",1),n.mixX=A(h,"mixX",1),n.mixY=A(h,"mixY",n.mixX),e.pathConstraints.push(n)}if(r.skins)for(let d=0;d<r.skins.length;d++){const h=r.skins[d],n=new Et(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const l=e.findBone(h.bones[a]);if(l==null)throw new Error(`Skin bone not found: ${h.bones[d]}`);n.bones.push(l)}if(h.ik)for(let a=0;a<h.ik.length;a++){const l=e.findIkConstraint(h.ik[a]);if(l==null)throw new Error(`Skin IK constraint not found: ${h.ik[d]}`);n.constraints.push(l)}if(h.transform)for(let a=0;a<h.transform.length;a++){const l=e.findTransformConstraint(h.transform[a]);if(l==null)throw new Error(`Skin transform constraint not found: ${h.transform[d]}`);n.constraints.push(l)}if(h.path)for(let a=0;a<h.path.length;a++){const l=e.findPathConstraint(h.path[a]);if(l==null)throw new Error(`Skin path constraint not found: ${h.path[d]}`);n.constraints.push(l)}for(const a in h.attachments){const l=e.findSlot(a);if(l==null)throw new Error(`Slot not found: ${a}`);const c=h.attachments[a];for(const m in c){const f=this.readAttachment(c[m],n,l.index,m,e);f&&n.setAttachment(l.index,m,f)}}e.skins.push(n),n.name=="default"&&(e.defaultSkin=n)}for(let d=0,h=this.linkedMeshes.length;d<h;d++){const n=this.linkedMeshes[d],a=(n.skin?e.findSkin(n.skin):e.defaultSkin).getAttachment(n.slotIndex,n.parent);n.mesh.deformAttachment=n.inheritDeform?a:n.mesh,n.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,r.events)for(const d in r.events){const h=r.events[d],n=new de(d);n.intValue=A(h,"int",0),n.floatValue=A(h,"float",0),n.stringValue=A(h,"string",""),n.audioPath=A(h,"audio",null),n.audioPath&&(n.volume=A(h,"volume",1),n.balance=A(h,"balance",0)),e.events.push(n)}if(r.animations)for(const d in r.animations){const h=r.animations[d];this.readAnimation(h,d,e)}return e}readAttachment(t,i,e,r,o){const d=this.scale;switch(r=A(t,"name",r),A(t,"type","region")){case"region":{const h=A(t,"path",r),n=this.attachmentLoader.newRegionAttachment(i,r,h);if(!n)return null;n.path=h,n.x=A(t,"x",0)*d,n.y=A(t,"y",0)*d,n.scaleX=A(t,"scaleX",1),n.scaleY=A(t,"scaleY",1),n.rotation=A(t,"rotation",0),n.width=t.width*d,n.height=t.height*d;const a=A(t,"color",null);return a&&n.color.setFromString(a),n}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(i,r);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const n=A(t,"color",null);return n&&h.color.setFromString(n),h}case"mesh":case"linkedmesh":{const h=A(t,"path",r),n=this.attachmentLoader.newMeshAttachment(i,r,h);if(!n)return null;n.path=h;const a=A(t,"color",null);a&&n.color.setFromString(a),n.width=A(t,"width",0)*d,n.height=A(t,"height",0)*d;const l=A(t,"parent",null);if(l)return this.linkedMeshes.push(new yn(n,A(t,"skin",null),e,l,A(t,"deform",!0))),n;const c=t.uvs;return this.readVertices(t,n,c.length),n.triangles=t.triangles,n.regionUVs=new Float32Array(c),n.edges=A(t,"edges",null),n.hullLength=A(t,"hull",0)*2,n}case"path":{const h=this.attachmentLoader.newPathAttachment(i,r);if(!h)return null;h.closed=A(t,"closed",!1),h.constantSpeed=A(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,h,n<<1);const a=u.Utils.newArray(n/3,0);for(let c=0;c<t.lengths.length;c++)a[c]=t.lengths[c]*d;h.lengths=a;const l=A(t,"color",null);return l&&h.color.setFromString(l),h}case"point":{const h=this.attachmentLoader.newPointAttachment(i,r);if(!h)return null;h.x=A(t,"x",0)*d,h.y=A(t,"y",0)*d,h.rotation=A(t,"rotation",0);const n=A(t,"color",null);return n&&h.color.setFromString(n),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(i,r);if(!h)return null;const n=A(t,"end",null);if(n!=null){const c=o.findSlot(n);if(c==null)throw new Error(`Clipping end slot not found: ${n}`);h.endSlot=c}const a=t.vertexCount;this.readVertices(t,h,a<<1);const l=A(t,"color",null);return l&&h.color.setFromString(l),h}}return null}readVertices(t,i,e){const r=this.scale;i.worldVerticesLength=e;const o=t.vertices;if(e==o.length){const n=u.Utils.toFloatArray(o);if(r!=1)for(let a=0,l=o.length;a<l;a++)n[a]*=r;i.vertices=n;return}const d=new Array,h=new Array;for(let n=0,a=o.length;n<a;){const l=o[n++];h.push(l);for(let c=n+l*4;n<c;n+=4)h.push(o[n]),d.push(o[n+1]*r),d.push(o[n+2]*r),d.push(o[n+3])}i.bones=h,i.vertices=u.Utils.toFloatArray(d)}readAnimation(t,i,e){const r=this.scale,o=new Array;if(t.slots)for(const h in t.slots){const n=t.slots[h],a=e.findSlot(h).index;if(a==-1)throw new Error(`Slot not found: ${h}`);for(const l in n){const c=n[l];if(!c)continue;const m=c.length;if(l=="attachment"){const f=new pt(m,a);for(let g=0;g<m;g++){const x=c[g];f.setFrame(g,A(x,"time",0),x.name)}o.push(f)}else if(l=="rgba"){const f=new Gt(m,m<<2,a);let g=c[0],x=A(g,"time",0),y=u.Color.fromString(g.color);for(let M=0,p=0;;M++){f.setFrame(M,x,y.r,y.g,y.b,y.a);const S=c[M+1];if(!S){f.shrink(p);break}const k=A(S,"time",0),w=u.Color.fromString(S.color),B=g.curve;B&&(p=N(B,f,p,M,0,x,k,y.r,w.r,1),p=N(B,f,p,M,1,x,k,y.g,w.g,1),p=N(B,f,p,M,2,x,k,y.b,w.b,1),p=N(B,f,p,M,3,x,k,y.a,w.a,1)),x=k,y=w,g=S}o.push(f)}else if(l=="rgb"){const f=new Ht(m,m*3,a);let g=c[0],x=A(g,"time",0),y=u.Color.fromString(g.color);for(let M=0,p=0;;M++){f.setFrame(M,x,y.r,y.g,y.b);const S=c[M+1];if(!S){f.shrink(p);break}const k=A(S,"time",0),w=u.Color.fromString(S.color),B=g.curve;B&&(p=N(B,f,p,M,0,x,k,y.r,w.r,1),p=N(B,f,p,M,1,x,k,y.g,w.g,1),p=N(B,f,p,M,2,x,k,y.b,w.b,1)),x=k,y=w,g=S}o.push(f)}else if(l=="alpha")o.push(at(c,new Jt(m,m,a),0,1));else if(l=="rgba2"){const f=new Zt(m,m*7,a);let g=c[0],x=A(g,"time",0),y=u.Color.fromString(g.light),M=u.Color.fromString(g.dark);for(let p=0,S=0;;p++){f.setFrame(p,x,y.r,y.g,y.b,y.a,M.r,M.g,M.b);const k=c[p+1];if(!k){f.shrink(S);break}const w=A(k,"time",0),B=u.Color.fromString(k.light),Y=u.Color.fromString(k.dark),X=g.curve;X&&(S=N(X,f,S,p,0,x,w,y.r,B.r,1),S=N(X,f,S,p,1,x,w,y.g,B.g,1),S=N(X,f,S,p,2,x,w,y.b,B.b,1),S=N(X,f,S,p,3,x,w,y.a,B.a,1),S=N(X,f,S,p,4,x,w,M.r,Y.r,1),S=N(X,f,S,p,5,x,w,M.g,Y.g,1),S=N(X,f,S,p,6,x,w,M.b,Y.b,1)),x=w,y=B,M=Y,g=k}o.push(f)}else if(l=="rgb2"){const f=new Kt(m,m*6,a);let g=c[0],x=A(g,"time",0),y=u.Color.fromString(g.light),M=u.Color.fromString(g.dark);for(let p=0,S=0;;p++){f.setFrame(p,x,y.r,y.g,y.b,M.r,M.g,M.b);const k=c[p+1];if(!k){f.shrink(S);break}const w=A(k,"time",0),B=u.Color.fromString(k.light),Y=u.Color.fromString(k.dark),X=g.curve;X&&(S=N(X,f,S,p,0,x,w,y.r,B.r,1),S=N(X,f,S,p,1,x,w,y.g,B.g,1),S=N(X,f,S,p,2,x,w,y.b,B.b,1),S=N(X,f,S,p,3,x,w,M.r,Y.r,1),S=N(X,f,S,p,4,x,w,M.g,Y.g,1),S=N(X,f,S,p,5,x,w,M.b,Y.b,1)),x=w,y=B,M=Y,g=k}o.push(f)}else throw new Error(`Invalid timeline type for a slot: ${l} (${h})`)}}if(t.bones)for(const h in t.bones){const n=t.bones[h],a=e.findBone(h).index;if(a==-1)throw new Error(`Bone not found: ${h}`);for(const l in n){const c=n[l],m=c.length;if(m!=0){if(l==="rotate")o.push(at(c,new kt(m,m,a),0,1));else if(l==="translate"){const f=new Lt(m,m<<1,a);o.push(ke(c,f,"x","y",0,r))}else if(l==="translatex"){const f=new Nt(m,m,a);o.push(at(c,f,0,r))}else if(l==="translatey"){const f=new Wt(m,m,a);o.push(at(c,f,0,r))}else if(l==="scale"){const f=new $t(m,m<<1,a);o.push(ke(c,f,"x","y",1,1))}else if(l==="scalex"){const f=new Ot(m,m,a);o.push(at(c,f,1,1))}else if(l==="scaley"){const f=new qt(m,m,a);o.push(at(c,f,1,1))}else if(l==="shear"){const f=new zt(m,m<<1,a);o.push(ke(c,f,"x","y",0,1))}else if(l==="shearx"){const f=new jt(m,m,a);o.push(at(c,f,0,1))}else if(l==="sheary"){const f=new _t(m,m,a);o.push(at(c,f,0,1))}}}}if(t.ik)for(const h in t.ik){const n=t.ik[h];let a=n[0];if(!a)continue;const l=e.findIkConstraint(h),c=e.ikConstraints.indexOf(l),m=new te(n.length,n.length<<1,c);let f=A(a,"time",0),g=A(a,"mix",1),x=A(a,"softness",0)*r;for(let y=0,M=0;;y++){m.setFrame(y,f,g,x,A(a,"bendPositive",!0)?1:-1,A(a,"compress",!1),A(a,"stretch",!1));const p=n[y+1];if(!p){m.shrink(M);break}const S=A(p,"time",0),k=A(p,"mix",1),w=A(p,"softness",0)*r,B=a.curve;B&&(M=N(B,m,M,y,0,f,S,g,k,1),M=N(B,m,M,y,1,f,S,x,w,r)),f=S,g=k,x=w,a=p}o.push(m)}if(t.transform)for(const h in t.transform){const n=t.transform[h];let a=n[0];if(!a)continue;const l=e.findTransformConstraint(h),c=e.transformConstraints.indexOf(l),m=new ee(n.length,n.length*6,c);let f=A(a,"time",0),g=A(a,"mixRotate",1),x=A(a,"mixX",1),y=A(a,"mixY",x),M=A(a,"mixScaleX",1),p=A(a,"mixScaleY",M);const S=A(a,"mixShearY",1);for(let k=0,w=0;;k++){m.setFrame(k,f,g,x,y,M,p,S);const B=n[k+1];if(!B){m.shrink(w);break}const Y=A(B,"time",0),X=A(B,"mixRotate",1),I=A(B,"mixX",1),C=A(B,"mixY",I),T=A(B,"mixScaleX",1),b=A(B,"mixScaleY",T),E=A(B,"mixShearY",1),v=a.curve;v&&(w=N(v,m,w,k,0,f,Y,g,X,1),w=N(v,m,w,k,1,f,Y,x,I,1),w=N(v,m,w,k,2,f,Y,y,C,1),w=N(v,m,w,k,3,f,Y,M,T,1),w=N(v,m,w,k,4,f,Y,p,b,1),w=N(v,m,w,k,5,f,Y,S,E,1)),f=Y,g=X,x=I,y=C,M=T,p=b,M=T,a=B}o.push(m)}if(t.path)for(const h in t.path){const n=t.path[h],a=e.findPathConstraintIndex(h);if(a==-1)throw new Error(`Path constraint not found: ${h}`);const l=e.pathConstraints[a];for(const c in n){const m=n[c];let f=m[0];if(!f)continue;const g=m.length;if(c==="position"){const x=new ne(g,g,a);o.push(at(m,x,0,l.positionMode==u.PositionMode.Fixed?r:1))}else if(c==="spacing"){const x=new se(g,g,a);o.push(at(m,x,0,l.spacingMode==H.Length||l.spacingMode==H.Fixed?r:1))}else if(c==="mix"){const x=new ie(g,g*3,a);let y=A(f,"time",0),M=A(f,"mixRotate",1),p=A(f,"mixX",1),S=A(f,"mixY",p);for(let k=0,w=0;;k++){x.setFrame(k,y,M,p,S);const B=m[k+1];if(!B){x.shrink(w);break}const Y=A(B,"time",0),X=A(B,"mixRotate",1),I=A(B,"mixX",1),C=A(B,"mixY",I),T=f.curve;T&&(w=N(T,x,w,k,0,y,Y,M,X,1),w=N(T,x,w,k,1,y,Y,p,I,1),w=N(T,x,w,k,2,y,Y,S,C,1)),y=Y,M=X,p=I,S=C,f=B}o.push(x)}}}if(t.deform)for(const h in t.deform){const n=t.deform[h],a=e.findSkin(h);if(a==null){if(u.settings.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${h}`);continue}for(const l in n){const c=n[l],m=e.findSlot(l).index;for(const f in c){const g=c[f];let x=g[0];if(!x)continue;const y=a.getAttachment(m,f),M=y.bones,p=y.vertices,S=M?p.length/3*2:p.length,k=new Qt(g.length,g.length,m,y);let w=A(x,"time",0);for(let B=0,Y=0;;B++){let X;const I=A(x,"vertices",null);if(!I)X=M?u.Utils.newFloatArray(S):p;else{X=u.Utils.newFloatArray(S);const E=A(x,"offset",0);if(u.Utils.arrayCopy(I,0,X,E,I.length),r!=1)for(let v=E,W=v+I.length;v<W;v++)X[v]*=r;if(!M)for(let v=0;v<S;v++)X[v]+=p[v]}k.setFrame(B,w,X);const C=g[B+1];if(!C){k.shrink(Y);break}const T=A(C,"time",0),b=x.curve;b&&(Y=N(b,k,Y,B,0,w,T,0,1,1)),w=T,x=C}o.push(k)}}}if(t.drawOrder){const h=new xt(t.drawOrder.length),n=e.slots.length;let a=0;for(let l=0;l<t.drawOrder.length;l++,a++){const c=t.drawOrder[l];let m=null;const f=A(c,"offsets",null);if(f){m=u.Utils.newArray(n,-1);const g=u.Utils.newArray(n-f.length,0);let x=0,y=0;for(let M=0;M<f.length;M++){const p=f[M],S=e.findSlot(p.slot).index;for(;x!=S;)g[y++]=x++;m[x+p.offset]=x++}for(;x<n;)g[y++]=x++;for(let M=n-1;M>=0;M--)m[M]==-1&&(m[M]=g[--y])}h.setFrame(a,A(c,"time",0),m)}o.push(h)}if(t.events){const h=new St(t.events.length);let n=0;for(let a=0;a<t.events.length;a++,n++){const l=t.events[a],c=e.findEvent(l.name),m=new ce(u.Utils.toSinglePrecision(A(l,"time",0)),c);m.intValue=A(l,"int",c.intValue),m.floatValue=A(l,"float",c.floatValue),m.stringValue=A(l,"string",c.stringValue),m.data.audioPath&&(m.volume=A(l,"volume",1),m.balance=A(l,"balance",0)),h.setFrame(n,m)}o.push(h)}let d=0;for(let h=0,n=o.length;h<n;h++)d=Math.max(d,o[h].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Tt(i,o,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return rt.BLEND_MODES.NORMAL;if(t=="additive")return rt.BLEND_MODES.ADD;if(t=="multiply")return rt.BLEND_MODES.MULTIPLY;if(t=="screen")return rt.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class yn{constructor(t,i,e,r,o){this.mesh=t,this.skin=i,this.slotIndex=e,this.parent=r,this.inheritDeform=o}}function at(s,t,i,e){let r=s[0],o=A(r,"time",0),d=A(r,"value",i)*e,h=0;for(let n=0;;n++){t.setFrame(n,o,d);const a=s[n+1];if(!a)return t.shrink(h),t;const l=A(a,"time",0),c=A(a,"value",i)*e;r.curve&&(h=N(r.curve,t,h,n,0,o,l,d,c,e)),o=l,d=c,r=a}}function ke(s,t,i,e,r,o){let d=s[0],h=A(d,"time",0),n=A(d,i,r)*o,a=A(d,e,r)*o,l=0;for(let c=0;;c++){t.setFrame(c,h,n,a);const m=s[c+1];if(!m)return t.shrink(l),t;const f=A(m,"time",0),g=A(m,i,r)*o,x=A(m,e,r)*o,y=d.curve;y&&(l=N(y,t,l,c,0,h,f,n,g,o),l=N(y,t,l,c,1,h,f,a,x,o)),h=f,n=g,a=x,d=m}}function N(s,t,i,e,r,o,d,h,n,a){if(s=="stepped")return t.setStepped(e),i;const l=r<<2,c=s[l],m=s[l+1]*a,f=s[l+2],g=s[l+3]*a;return t.setBezier(i,e,r,o,h,c,m,f,g,d,n),i+1}function A(s,t,i){return s[t]!==void 0?s[t]:i}class kn extends u.SpineBase{createSkeleton(t){this.skeleton=new fe(t),this.skeleton.updateWorldTransform(),this.stateData=new Ee(t),this.state=new Bt(this.stateData)}}return F.AlphaTimeline=Jt,F.Animation=Tt,F.AnimationState=Bt,F.AnimationStateAdapter=_e,F.AnimationStateData=Ee,F.AtlasAttachmentLoader=Je,F.Attachment=Pt,F.AttachmentTimeline=pt,F.Bone=le,F.BoneData=he,F.BoundingBoxAttachment=It,F.ClippingAttachment=Xt,F.ConstraintData=vt,F.CurveTimeline=tt,F.CurveTimeline1=et,F.CurveTimeline2=bt,F.DeformTimeline=Qt,F.DrawOrderTimeline=xt,F.Event=ce,F.EventData=de,F.EventQueue=Te,F.EventTimeline=St,F.EventType=Z,F.IkConstraint=Ue,F.IkConstraintData=me,F.IkConstraintTimeline=te,F.JitterEffect=je,F.MeshAttachment=ft,F.PathAttachment=gt,F.PathConstraint=wt,F.PathConstraintData=ue,F.PathConstraintMixTimeline=ie,F.PathConstraintPositionTimeline=ne,F.PathConstraintSpacingTimeline=se,F.PointAttachment=Ct,F.RGB2Timeline=Kt,F.RGBA2Timeline=Zt,F.RGBATimeline=Gt,F.RGBTimeline=Ht,F.RegionAttachment=D,F.RotateTimeline=kt,F.ScaleTimeline=$t,F.ScaleXTimeline=Ot,F.ScaleYTimeline=qt,F.ShearTimeline=zt,F.ShearXTimeline=jt,F.ShearYTimeline=_t,F.Skeleton=fe,F.SkeletonBinary=Pe,F.SkeletonBounds=Mn,F.SkeletonData=ge,F.SkeletonJson=ye,F.Skin=Et,F.SkinEntry=we,F.Slot=Vt,F.SlotData=pe,F.SpacingMode=H,F.Spine=kn,F.SwirlEffect=Ie,F.Timeline=j,F.TrackEntry=Ft,F.TransformConstraint=De,F.TransformConstraintData=xe,F.TransformConstraintTimeline=ee,F.TranslateTimeline=Lt,F.TranslateXTimeline=Nt,F.TranslateYTimeline=Wt,F.VertexAttachment=ut,F}({},PIXI.spine,PIXI);
//# sourceMappingURL=runtime-4.0.js.map
