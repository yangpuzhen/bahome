{"version":3,"file":"SkeletonJson.js","sources":["../../src/core/SkeletonJson.ts"],"sourcesContent":["import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { NumberArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader = null;\n\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            if (skeletonData.version.substr(0, 3) !== '4.0') {\n                const error = `Spine 4.0 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = getValue(boneMap, 'length', 0) * scale;\n                data.x = getValue(boneMap, 'x', 0) * scale;\n                data.y = getValue(boneMap, 'y', 0) * scale;\n                data.rotation = getValue(boneMap, 'rotation', 0);\n                data.scaleX = getValue(boneMap, 'scaleX', 1);\n                data.scaleY = getValue(boneMap, 'scaleY', 1);\n                data.shearX = getValue(boneMap, 'shearX', 0);\n                data.shearY = getValue(boneMap, 'shearY', 0);\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\n                data.skinRequired = getValue(boneMap, 'skin', false);\n\n                const color = getValue(boneMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const boneData = skeletonData.findBone(slotMap.bone);\n                const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n\n                const color: string = getValue(slotMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                const dark: string = getValue(slotMap, 'dark', null);\n\n                if (dark) data.darkColor = Color.fromString(dark);\n\n                data.attachmentName = getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                data.target = skeletonData.findBone(constraintMap.target);\n\n                data.mix = getValue(constraintMap, 'mix', 1);\n                data.softness = getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = getValue(constraintMap, 'compress', false);\n                data.stretch = getValue(constraintMap, 'stretch', false);\n                data.uniform = getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = getValue(constraintMap, 'local', false);\n                data.relative = getValue(constraintMap, 'relative', false);\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.offsetX = getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = getValue(constraintMap, 'shearY', 0);\n\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n                data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\n                data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\n                data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.position = getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\n\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = getValue(eventMap, 'int', 0);\n                data.floatValue = getValue(eventMap, 'float', 0);\n                data.stringValue = getValue(eventMap, 'string', '');\n                data.audioPath = getValue(eventMap, 'audio', null);\n                if (data.audioPath) {\n                    data.volume = getValue(eventMap, 'volume', 1);\n                    data.balance = getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = getValue(map, 'name', name);\n\n        switch (getValue(map, 'type', 'region')) {\n            case 'region': {\n                const path = getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = getValue(map, 'x', 0) * scale;\n                region.y = getValue(map, 'y', 0) * scale;\n                region.scaleX = getValue(map, 'scaleX', 1);\n                region.scaleY = getValue(map, 'scaleY', 1);\n                region.rotation = getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = getValue(map, 'color', null);\n\n                if (color) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (!mesh) return null;\n                mesh.path = path;\n\n                const color = getValue(map, 'color', null);\n\n                if (color) mesh.color.setFromString(color);\n\n                mesh.width = getValue(map, 'width', 0) * scale;\n                mesh.height = getValue(map, 'height', 0) * scale;\n\n                const parent: string = getValue(map, 'parent', null);\n\n                if (parent) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, 'skin', null), slotIndex, parent, getValue(map, 'deform', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.edges = getValue(map, 'edges', null);\n                mesh.hullLength = getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = getValue(map, 'closed', false);\n                path.constantSpeed = getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = getValue(map, 'x', 0) * scale;\n                point.y = getValue(map, 'y', 0) * scale;\n                point.rotation = getValue(map, 'rotation', 0);\n\n                const color = getValue(map, 'color', null);\n\n                if (color) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n\n                const end = getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlot(slotName).index;\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (!timelineMap) continue;\n                    const frames = timelineMap.length;\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(frames, slotIndex);\n\n                        for (let frame = 0; frame < frames; frame++) {\n                            const keyMap = timelineMap[frame];\n\n                            timeline.setFrame(frame, getValue(keyMap, 'time', 0), keyMap.name);\n                        }\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgba') {\n                        const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb') {\n                        const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'alpha') {\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n                    } else if (timelineName == 'rgba2') {\n                        const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb2') {\n                        const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBone(boneName).index;\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n                    const frames = timelineMap.length;\n\n                    if (frames == 0) continue;\n\n                    if (timelineName === 'rotate') {\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n                    } else if (timelineName === 'translate') {\n                        const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\n                    } else if (timelineName === 'translatex') {\n                        const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'translatey') {\n                        const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'scale') {\n                        const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\n                    } else if (timelineName === 'scalex') {\n                        const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'scaley') {\n                        const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'shear') {\n                        const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\n                    } else if (timelineName === 'shearx') {\n                        const timeline = new ShearXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    } else if (timelineName === 'sheary') {\n                        const timeline = new ShearYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    }\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                let keyMap = constraintMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mix = getValue(keyMap, 'mix', 1);\n                let softness = getValue(keyMap, 'softness', 0) * scale;\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(\n                        frame,\n                        time,\n                        mix,\n                        softness,\n                        getValue(keyMap, 'bendPositive', true) ? 1 : -1,\n                        getValue(keyMap, 'compress', false),\n                        getValue(keyMap, 'stretch', false)\n                    );\n                    const nextMap = constraintMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mix2 = getValue(nextMap, 'mix', 1);\n                    const softness2 = getValue(nextMap, 'softness', 0) * scale;\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n                    }\n\n                    time = time2;\n                    mix = mix2;\n                    softness = softness2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const timelineMap = map.transform[constraintName];\n                let keyMap = timelineMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                let mixX = getValue(keyMap, 'mixX', 1);\n                let mixY = getValue(keyMap, 'mixY', mixX);\n                let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\n                let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\n                const mixShearY = getValue(keyMap, 'mixShearY', 1);\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                    const nextMap = timelineMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                    const mixX2 = getValue(nextMap, 'mixX', 1);\n                    const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                    const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\n                    const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\n                    const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                    }\n\n                    time = time2;\n                    mixRotate = mixRotate2;\n                    mixX = mixX2;\n                    mixY = mixY2;\n                    mixScaleX = mixScaleX2;\n                    mixScaleY = mixScaleY2;\n                    mixScaleX = mixScaleX2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const constraintIndex = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (constraintIndex == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const constraint = skeletonData.pathConstraints[constraintIndex];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n                    let keyMap = timelineMap[0];\n\n                    if (!keyMap) continue;\n\n                    const frames = timelineMap.length;\n\n                    if (timelineName === 'position') {\n                        const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n                    } else if (timelineName === 'spacing') {\n                        const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(\n                            readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\n                        );\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n                        let time = getValue(keyMap, 'time', 0);\n                        let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                        let mixX = getValue(keyMap, 'mixX', 1);\n                        let mixY = getValue(keyMap, 'mixY', mixX);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                            const mixX2 = getValue(nextMap, 'mixX', 1);\n                            const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlot(slotName).index;\n\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        let keyMap = timelineMap[0];\n\n                        if (!keyMap) continue;\n\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                        const weighted = attachment.bones;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                        let time = getValue(keyMap, 'time', 0);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            let deform: NumberArrayLike;\n                            const verticesValue: Array<Number> = getValue(keyMap, 'vertices', null);\n\n                            if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>getValue(keyMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frame, time, deform);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const curve = keyMap.curve;\n\n                            if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                            time = time2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Draw order timelines.\n        if (map.drawOrder) {\n            const timeline = new DrawOrderTimeline(map.drawOrder.length);\n            const slotCount = skeletonData.slots.length;\n            let frame = 0;\n\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n                const drawOrderMap = map.drawOrder[i];\n                let drawOrder: Array<number> = null;\n                const offsets = getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let ii = 0; ii < offsets.length; ii++) {\n                        const offsetMap = offsets[ii];\n                        const slotIndex = skeletonData.findSlot(offsetMap.slot).index;\n                        // Collect unchanged items.\n\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timelines.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frame = 0;\n\n            for (let i = 0; i < map.events.length; i++, frame++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n                const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath) {\n                    event.volume = getValue(eventMap, 'volume', 1);\n                    event.balance = getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frame, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value = getValue(keyMap, 'value', defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const value2 = getValue(nextMap, 'value', defaultValue) * scale;\n\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n        time = time2;\n        value = value2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readTimeline2(keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n        const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n        const curve = keyMap.curve;\n\n        if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readCurve(curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number, value1: number, value2: number, scale: number) {\n    if (curve == 'stepped') {\n        timeline.setStepped(frame);\n\n        return bezier;\n    }\n    const i = value << 2;\n    const cx1 = curve[i];\n    const cy1 = curve[i + 1] * scale;\n    const cx2 = curve[i + 2];\n    const cy2 = curve[i + 3] * scale;\n\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n\n    return bezier + 1;\n}\n\nfunction getValue(map: any, property: string, defaultValue: any) {\n    return map[property] !== undefined ? map[property] : defaultValue;\n}\n"],"names":["SkeletonData","BoneData","Utils","TransformMode","SlotData","Color","IkConstraintData","TransformConstraintData","PathConstraintData","PositionMode","SpacingMode","RotateMode","Skin","EventData","AttachmentTimeline","RGBATimeline","RGBTimeline","AlphaTimeline","RGBA2Timeline","RGB2Timeline","RotateTimeline","TranslateTimeline","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","IkConstraintTimeline","TransformConstraintTimeline","PathConstraintPositionTimeline","PathConstraintSpacingTimeline","PathConstraintMixTimeline","settings","DeformTimeline","DrawOrderTimeline","EventTimeline","Event","Animation","BLEND_MODES"],"mappings":"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"}