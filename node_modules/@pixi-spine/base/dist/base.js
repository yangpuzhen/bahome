/*!
 * @pixi-spine/base - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:28 UTC
 *
 * @pixi-spine/base is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(b,S,F,oe,le,P){"use strict";var T=(i=>(i[i.Region=0]="Region",i[i.BoundingBox=1]="BoundingBox",i[i.Mesh=2]="Mesh",i[i.LinkedMesh=3]="LinkedMesh",i[i.Path=4]="Path",i[i.Point=5]="Point",i[i.Clipping=6]="Clipping",i))(T||{});class he{constructor(e,t=new Array,r=0,n=new DataView(e.buffer)){this.strings=t,this.index=r,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const e=this.buffer.getInt16(this.index);return this.index+=2,e}readInt32(){const e=this.buffer.getInt32(this.index);return this.index+=4,e}readInt(e){let t=this.readByte(),r=t&127;return t&128&&(t=this.readByte(),r|=(t&127)<<7,t&128&&(t=this.readByte(),r|=(t&127)<<14,t&128&&(t=this.readByte(),r|=(t&127)<<21,t&128&&(t=this.readByte(),r|=(t&127)<<28)))),e?r:r>>>1^-(r&1)}readStringRef(){const e=this.readInt(!0);return e==0?null:this.strings[e-1]}readString(){let e=this.readInt(!0);switch(e){case 0:return null;case 1:return""}e--;let t="";for(let r=0;r<e;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:t+=String.fromCharCode((n&31)<<6|this.readByte()&63),r+=2;break;case 14:t+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),r+=3;break;default:t+=String.fromCharCode(n),r++}}return t}readFloat(){const e=this.buffer.getFloat32(this.index);return this.index+=4,e}readBoolean(){return this.readByte()!=0}}var K=(i=>(i[i.setup=0]="setup",i[i.first=1]="first",i[i.replace=2]="replace",i[i.add=3]="add",i))(K||{}),j=(i=>(i[i.mixIn=0]="mixIn",i[i.mixOut=1]="mixOut",i))(j||{}),J=(i=>(i[i.Fixed=0]="Fixed",i[i.Percent=1]="Percent",i))(J||{}),Q=(i=>(i[i.Tangent=0]="Tangent",i[i.Chain=1]="Chain",i[i.ChainScale=2]="ChainScale",i))(Q||{}),Z=(i=>(i[i.Normal=0]="Normal",i[i.OnlyTranslation=1]="OnlyTranslation",i[i.NoRotationOrReflection=2]="NoRotationOrReflection",i[i.NoScale=3]="NoScale",i[i.NoScaleOrReflection=4]="NoScaleOrReflection",i))(Z||{});function U(i){switch(i.toLowerCase()){case"nearest":return M.Nearest;case"linear":return M.Linear;case"mipmap":return M.MipMap;case"mipmapnearestnearest":return M.MipMapNearestNearest;case"mipmaplinearnearest":return M.MipMapLinearNearest;case"mipmapnearestlinear":return M.MipMapNearestLinear;case"mipmaplinearlinear":return M.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${i}`)}}function ue(i){switch(i.toLowerCase()){case"mirroredtepeat":return L.MirroredRepeat;case"clamptoedge":return L.ClampToEdge;case"repeat":return L.Repeat;default:throw new Error(`Unknown texture wrap ${i}`)}}var M=(i=>(i[i.Nearest=9728]="Nearest",i[i.Linear=9729]="Linear",i[i.MipMap=9987]="MipMap",i[i.MipMapNearestNearest=9984]="MipMapNearestNearest",i[i.MipMapLinearNearest=9985]="MipMapLinearNearest",i[i.MipMapNearestLinear=9986]="MipMapNearestLinear",i[i.MipMapLinearLinear=9987]="MipMapLinearLinear",i))(M||{}),L=(i=>(i[i.MirroredRepeat=33648]="MirroredRepeat",i[i.ClampToEdge=33071]="ClampToEdge",i[i.Repeat=10497]="Repeat",i))(L||{});class G{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const e=this.texture;return e.trim?e.trim.width:e.orig.width}get height(){const e=this.texture;return e.trim?e.trim.height:e.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const e=this.texture;return e.trim?e.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const e=this.texture;return e.trim?e.trim.y:0}get spineOffsetY(){const e=this.texture;return this.originalHeight-this.height-(e.trim?e.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class ce{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class de{constructor(e,t,r){this.pages=new Array,this.regions=new Array,e&&this.addSpineAtlas(e,t,r)}addTexture(e,t){const r=this.pages;let n=null;for(let o=0;o<r.length;o++)if(r[o].baseTexture===t.baseTexture){n=r[o];break}if(n===null){n=new H,n.name="texturePage";const o=t.baseTexture;n.width=o.realWidth,n.height=o.realHeight,n.baseTexture=o,n.minFilter=n.magFilter=M.Nearest,n.uWrap=L.ClampToEdge,n.vWrap=L.ClampToEdge,r.push(n)}const a=new z;return a.name=e,a.page=n,a.texture=t,a.index=-1,this.regions.push(a),a}addTextureHash(e,t){for(const r in e)e.hasOwnProperty(r)&&this.addTexture(t&&r.indexOf(".")!==-1?r.substr(0,r.lastIndexOf(".")):r,e[r])}addSpineAtlas(e,t,r){return this.load(e,t,r)}load(e,t,r){if(t==null)throw new Error("textureLoader cannot be null.");const n=new ge(e),a=new Array(4);let o=null;const c={};let l=null;c.size=()=>{o.width=parseInt(a[1]),o.height=parseInt(a[2])},c.format=()=>{},c.filter=()=>{o.minFilter=U(a[1]),o.magFilter=U(a[2])},c.repeat=()=>{a[1].indexOf("x")!=-1&&(o.uWrap=L.Repeat),a[1].indexOf("y")!=-1&&(o.vWrap=L.Repeat)},c.pma=()=>{o.pma=a[1]=="true"};const u={};u.xy=()=>{l.x=parseInt(a[1]),l.y=parseInt(a[2])},u.size=()=>{l.width=parseInt(a[1]),l.height=parseInt(a[2])},u.bounds=()=>{l.x=parseInt(a[1]),l.y=parseInt(a[2]),l.width=parseInt(a[3]),l.height=parseInt(a[4])},u.offset=()=>{l.offsetX=parseInt(a[1]),l.offsetY=parseInt(a[2])},u.orig=()=>{l.originalWidth=parseInt(a[1]),l.originalHeight=parseInt(a[2])},u.offsets=()=>{l.offsetX=parseInt(a[1]),l.offsetY=parseInt(a[2]),l.originalWidth=parseInt(a[3]),l.originalHeight=parseInt(a[4])},u.rotate=()=>{const s=a[1];let d=0;s.toLocaleLowerCase()=="true"?d=6:s.toLocaleLowerCase()=="false"?d=0:d=(720-parseFloat(s))%360/45,l.rotate=d},u.index=()=>{l.index=parseInt(a[1])};let h=n.readLine();for(;h!=null&&h.trim().length==0;)h=n.readLine();for(;!(h==null||h.trim().length==0||n.readEntry(a,h)==0);)h=n.readLine();const g=()=>{for(;;){if(h==null)return r&&r(this);if(h.trim().length==0)o=null,h=n.readLine();else if(o===null){for(o=new H,o.name=h.trim();n.readEntry(a,h=n.readLine())!=0;){const s=c[a[0]];s&&s()}this.pages.push(o),t(o.name,s=>{if(s===null)return this.pages.splice(this.pages.indexOf(o),1),r&&r(null);o.baseTexture=s,o.pma&&(s.alphaMode=S.ALPHA_MODES.PMA),s.valid||s.setSize(o.width,o.height),o.setFilters(),(!o.width||!o.height)&&(o.width=s.realWidth,o.height=s.realHeight,(!o.width||!o.height)&&console.log(`ERROR spine atlas page ${o.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),g()});break}else{l=new ce;const s=new z;s.name=h,s.page=o;let d=null,p=null;for(;;){const x=n.readEntry(a,h=n.readLine());if(x==0)break;const I=u[a[0]];if(I)I();else{d==null&&(d=[],p=[]),d.push(a[0]);const O=[];for(let A=0;A<x;A++)O.push(parseInt(a[A+1]));p.push(O)}}l.originalWidth==0&&l.originalHeight==0&&(l.originalWidth=l.width,l.originalHeight=l.height);const m=o.baseTexture.resolution;l.x/=m,l.y/=m,l.width/=m,l.height/=m,l.originalWidth/=m,l.originalHeight/=m,l.offsetX/=m,l.offsetY/=m;const f=l.rotate%4!==0,w=new S.Rectangle(l.x,l.y,f?l.height:l.width,f?l.width:l.height),C=new S.Rectangle(0,0,l.originalWidth,l.originalHeight),y=new S.Rectangle(l.offsetX,l.originalHeight-l.height-l.offsetY,l.width,l.height);s.texture=new S.Texture(s.page.baseTexture,w,C,y,l.rotate),s.index=l.index,s.texture.updateUvs(),this.regions.push(s)}}};g()}findRegion(e){for(let t=0;t<this.regions.length;t++)if(this.regions[t].name==e)return this.regions[t];return null}dispose(){for(let e=0;e<this.pages.length;e++)this.pages[e].baseTexture.dispose()}}class ge{constructor(e){this.index=0,this.lines=e.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(e,t){if(t==null||(t=t.trim(),t.length==0))return 0;const r=t.indexOf(":");if(r==-1)return 0;e[0]=t.substr(0,r).trim();for(let n=1,a=r+1;;n++){const o=t.indexOf(",",a);if(o==-1)return e[n]=t.substr(a).trim(),n;if(e[n]=t.substr(a,o-a).trim(),a=o+1,n==4)return 4}}}class H{constructor(){this.minFilter=M.Nearest,this.magFilter=M.Nearest,this.uWrap=L.ClampToEdge,this.vWrap=L.ClampToEdge}setFilters(){const e=this.baseTexture,t=this.minFilter;t==M.Linear?e.scaleMode=S.SCALE_MODES.LINEAR:this.minFilter==M.Nearest?e.scaleMode=S.SCALE_MODES.NEAREST:(e.mipmap=S.MIPMAP_MODES.POW2,t==M.MipMapNearestNearest?e.scaleMode=S.SCALE_MODES.NEAREST:e.scaleMode=S.SCALE_MODES.LINEAR)}}class z extends G{}class pe{constructor(){this.array=new Array}add(e){const t=this.contains(e);return this.array[e|0]=e|0,!t}contains(e){return this.array[e|0]!=null}remove(e){this.array[e|0]=void 0}clear(){this.array.length=0}}class me{constructor(){this.entries={},this.size=0}add(e){const t=this.entries[e];return this.entries[e]=!0,t?!1:(this.size++,!0)}addAll(e){const t=this.size;for(let r=0,n=e.length;r<n;r++)this.add(e[r]);return t!=this.size}contains(e){return this.entries[e]}clear(){this.entries={},this.size=0}}const D=class{constructor(i=0,e=0,t=0,r=0){this.r=i,this.g=e,this.b=t,this.a=r}set(i,e,t,r){return this.r=i,this.g=e,this.b=t,this.a=r,this.clamp()}setFromColor(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}setFromString(i){return i=i.charAt(0)=="#"?i.substr(1):i,this.r=parseInt(i.substr(0,2),16)/255,this.g=parseInt(i.substr(2,2),16)/255,this.b=parseInt(i.substr(4,2),16)/255,this.a=i.length!=8?1:parseInt(i.substr(6,2),16)/255,this}add(i,e,t,r){return this.r+=i,this.g+=e,this.b+=t,this.a+=r,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(i,e){i.r=((e&4278190080)>>>24)/255,i.g=((e&16711680)>>>16)/255,i.b=((e&65280)>>>8)/255,i.a=(e&255)/255}static rgb888ToColor(i,e){i.r=((e&16711680)>>>16)/255,i.g=((e&65280)>>>8)/255,i.b=(e&255)/255}static fromString(i){return new D().setFromString(i)}};let _=D;_.WHITE=new D(1,1,1,1),_.RED=new D(1,0,0,1),_.GREEN=new D(0,1,0,1),_.BLUE=new D(0,0,1,1),_.MAGENTA=new D(1,0,1,1);const v=class{static clamp(i,e,t){return i<e?e:i>t?t:i}static cosDeg(i){return Math.cos(i*v.degRad)}static sinDeg(i){return Math.sin(i*v.degRad)}static signum(i){return Math.sign(i)}static toInt(i){return i>0?Math.floor(i):Math.ceil(i)}static cbrt(i){const e=Math.pow(Math.abs(i),.3333333333333333);return i<0?-e:e}static randomTriangular(i,e){return v.randomTriangularWith(i,e,(i+e)*.5)}static randomTriangularWith(i,e,t){const r=Math.random(),n=e-i;return r<=(t-i)/n?i+Math.sqrt(r*n*(t-i)):e-Math.sqrt((1-r)*n*(e-t))}static isPowerOfTwo(i){return i&&(i&i-1)===0}};let N=v;N.PI=3.1415927,N.PI2=v.PI*2,N.radiansToDegrees=180/v.PI,N.radDeg=v.radiansToDegrees,N.degreesToRadians=v.PI/180,N.degRad=v.degreesToRadians;class ee{apply(e,t,r){return e+(t-e)*this.applyInternal(r)}}class te extends ee{constructor(e){super(),this.power=2,this.power=e}applyInternal(e){return e<=.5?Math.pow(e*2,this.power)/2:Math.pow((e-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class fe extends te{applyInternal(e){return Math.pow(e-1,this.power)*(this.power%2==0?-1:1)+1}}const Y=class{static arrayCopy(i,e,t,r,n){for(let a=e,o=r;a<e+n;a++,o++)t[o]=i[a]}static arrayFill(i,e,t,r){for(let n=e;n<t;n++)i[n]=r}static setArraySize(i,e,t=0){const r=i.length;if(r==e)return i;if(i.length=e,r<e)for(let n=r;n<e;n++)i[n]=t;return i}static ensureArrayCapacity(i,e,t=0){return i.length>=e?i:Y.setArraySize(i,e,t)}static newArray(i,e){const t=new Array(i);for(let r=0;r<i;r++)t[r]=e;return t}static newFloatArray(i){if(Y.SUPPORTS_TYPED_ARRAYS)return new Float32Array(i);const e=new Array(i);for(let t=0;t<e.length;t++)e[t]=0;return e}static newShortArray(i){if(Y.SUPPORTS_TYPED_ARRAYS)return new Int16Array(i);const e=new Array(i);for(let t=0;t<e.length;t++)e[t]=0;return e}static toFloatArray(i){return Y.SUPPORTS_TYPED_ARRAYS?new Float32Array(i):i}static toSinglePrecision(i){return Y.SUPPORTS_TYPED_ARRAYS?Math.fround(i):i}static webkit602BugfixHelper(i,e){}static contains(i,e,t=!0){for(let r=0;r<i.length;r++)if(i[r]==e)return!0;return!1}static enumValue(i,e){return i[e[0].toUpperCase()+e.slice(1)]}};let W=Y;W.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class we{static logBones(e){for(let t=0;t<e.bones.length;t++){const r=e.bones[t],n=r.matrix;console.log(`${r.data.name}, ${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx}, ${n.ty}`)}}}class ie{constructor(e){this.items=new Array,this.instantiator=e}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(e){e.reset&&e.reset(),this.items.push(e)}freeAll(e){for(let t=0;t<e.length;t++)this.free(e[t])}clear(){this.items.length=0}}class be{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}length(){const e=this.x,t=this.y;return Math.sqrt(e*e+t*t)}normalize(){const e=this.length();return e!=0&&(this.x/=e,this.y/=e),this}}class ye{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const e=Date.now()/1e3;this.delta=e-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=e,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class xe{constructor(e=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(e)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(e){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=e,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let e=0;for(let t=0;t<this.values.length;t++)e+=this.values[t];this.mean=e/this.values.length,this.dirty=!1}return this.mean}return 0}}class re{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new ie(()=>W.newFloatArray(16))}update(e,t){if(!e)throw new Error("skeleton cannot be null.");const r=this.boundingBoxes,n=this.polygons,a=this.polygonPool,o=e.slots,c=o.length;r.length=0,a.freeAll(n),n.length=0;for(let l=0;l<c;l++){const u=o[l];if(!u.bone.active)continue;const h=u.getAttachment();if(h!=null&&h.type===T.BoundingBox){const g=h;r.push(g);let s=a.obtain();s.length!=g.worldVerticesLength&&(s=W.newFloatArray(g.worldVerticesLength)),n.push(s),g.computeWorldVertices(u,0,g.worldVerticesLength,s,0,2)}}t?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let e=Number.POSITIVE_INFINITY,t=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const a=this.polygons;for(let o=0,c=a.length;o<c;o++){const l=a[o],u=l;for(let h=0,g=l.length;h<g;h+=2){const s=u[h],d=u[h+1];e=Math.min(e,s),t=Math.min(t,d),r=Math.max(r,s),n=Math.max(n,d)}}this.minX=e,this.minY=t,this.maxX=r,this.maxY=n}aabbContainsPoint(e,t){return e>=this.minX&&e<=this.maxX&&t>=this.minY&&t<=this.maxY}aabbIntersectsSegment(e,t,r,n){const a=this.minX,o=this.minY,c=this.maxX,l=this.maxY;if(e<=a&&r<=a||t<=o&&n<=o||e>=c&&r>=c||t>=l&&n>=l)return!1;const u=(n-t)/(r-e);let h=u*(a-e)+t;if(h>o&&h<l||(h=u*(c-e)+t,h>o&&h<l))return!0;let g=(o-t)/u+e;return g>a&&g<c||(g=(l-t)/u+e,g>a&&g<c)}aabbIntersectsSkeleton(e){return this.minX<e.maxX&&this.maxX>e.minX&&this.minY<e.maxY&&this.maxY>e.minY}containsPoint(e,t){const r=this.polygons;for(let n=0,a=r.length;n<a;n++)if(this.containsPointPolygon(r[n],e,t))return this.boundingBoxes[n];return null}containsPointPolygon(e,t,r){const n=e,a=e.length;let o=a-2,c=!1;for(let l=0;l<a;l+=2){const u=n[l+1],h=n[o+1];if(u<r&&h>=r||h<r&&u>=r){const g=n[l];g+(r-u)/(h-u)*(n[o]-g)<t&&(c=!c)}o=l}return c}intersectsSegment(e,t,r,n){const a=this.polygons;for(let o=0,c=a.length;o<c;o++)if(this.intersectsSegmentPolygon(a[o],e,t,r,n))return this.boundingBoxes[o];return null}intersectsSegmentPolygon(e,t,r,n,a){const o=e,c=e.length,l=t-n,u=r-a,h=t*a-r*n;let g=o[c-2],s=o[c-1];for(let d=0;d<c;d+=2){const p=o[d],m=o[d+1],f=g*m-s*p,w=g-p,C=s-m,y=l*C-u*w,x=(h*w-l*f)/y;if((x>=g&&x<=p||x>=p&&x<=g)&&(x>=t&&x<=n||x>=n&&x<=t)){const I=(h*C-u*f)/y;if((I>=s&&I<=m||I>=m&&I<=s)&&(I>=r&&I<=a||I>=a&&I<=r))return!0}g=p,s=m}return!1}getPolygon(e){if(!e)throw new Error("boundingBox cannot be null.");const t=this.boundingBoxes.indexOf(e);return t==-1?null:this.polygons[t]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const $={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},k=[0,0,0];class ne extends oe.Sprite{constructor(){super(...arguments),this.region=null,this.attachment=null}}class se extends le.SimpleMesh{constructor(e,t,r,n,a){super(e,t,r,n,a),this.region=null,this.attachment=null}}const ae=class extends F.Container{constructor(i){if(super(),!i)throw new Error("The spineData param is required.");if(typeof i=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=i,this.createSkeleton(i),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,t=this.skeleton.slots.length;e<t;e++){const r=this.skeleton.slots[e],n=r.getAttachment(),a=this.newContainer();if(this.slotContainers.push(a),this.addChild(a),this.tempClipContainers.push(null),!!n)if(n.type===T.Region){const o=n.name,c=this.createSprite(r,n,o);r.currentSprite=c,r.currentSpriteName=o,a.addChild(c)}else if(n.type===T.Mesh){const o=this.createMesh(r,n);r.currentMesh=o,r.currentMeshId=n.id,r.currentMeshName=n.name,a.addChild(o)}else n.type===T.Clipping&&(this.createGraphics(r,n),a.addChild(r.clippingContainer),a.addChild(r.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(i){var e;i!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),i==null||i.registerSpine(this),this._debug=i)}get autoUpdate(){return this._autoUpdate}set autoUpdate(i){i!==this._autoUpdate&&(this._autoUpdate=i,this.updateTransform=i?ae.prototype.autoUpdateTransform:F.Container.prototype.updateTransform)}get tint(){return S.utils.rgb2hex(this.tintRgb)}set tint(i){this.tintRgb=S.utils.hex2rgb(i,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:$.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(i){var e;const t=this.delayLimit;if(i>t&&(i=t),this.state.update(i),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const r=this.skeleton.slots,n=this.color;let a=null,o=null;n?(a=n.light,o=n.dark):a=this.tintRgb;for(let h=0,g=r.length;h<g;h++){const s=r[h],d=s.getAttachment(),p=this.slotContainers[h];if(!d){p.visible=!1;continue}let m=null;d.sequence&&d.sequence.apply(s,d);let f=d.region;const w=d.color;switch(d!=null&&d.type){case T.Region:if(p.transform.setFromMatrix(s.bone.matrix),f=d.region,s.currentMesh&&(s.currentMesh.visible=!1,s.currentMesh=null,s.currentMeshId=void 0,s.currentMeshName=void 0),!f){s.currentSprite&&(s.currentSprite.renderable=!1);break}if(!s.currentSpriteName||s.currentSpriteName!==d.name){const y=d.name;if(s.currentSprite&&(s.currentSprite.visible=!1),s.sprites=s.sprites||{},s.sprites[y]!==void 0)s.sprites[y].visible=!0;else{const x=this.createSprite(s,d,y);p.addChild(x)}s.currentSprite=s.sprites[y],s.currentSpriteName=y}s.currentSprite.renderable=!0,s.hackRegion||this.setSpriteRegion(d,s.currentSprite,f),s.currentSprite.color?m=s.currentSprite.color:(k[0]=a[0]*s.color.r*w.r,k[1]=a[1]*s.color.g*w.g,k[2]=a[2]*s.color.b*w.b,s.currentSprite.tint=S.utils.rgb2hex(k)),s.currentSprite.blendMode=s.blendMode;break;case T.Mesh:if(s.currentSprite){s.currentSprite.visible=!1,s.currentSprite=null,s.currentSpriteName=void 0;const y=new S.Transform;y._parentID=-1,y._worldID=p.transform._worldID,p.transform=y}if(!f){s.currentMesh&&(s.currentMesh.renderable=!1);break}const C=d.id;if(s.currentMeshId===void 0||s.currentMeshId!==C){const y=C;if(s.currentMesh&&(s.currentMesh.visible=!1),s.meshes=s.meshes||{},s.meshes[y]!==void 0)s.meshes[y].visible=!0;else{const x=this.createMesh(s,d);p.addChild(x)}s.currentMesh=s.meshes[y],s.currentMeshName=d.name,s.currentMeshId=y}s.currentMesh.renderable=!0,d.computeWorldVerticesOld(s,s.currentMesh.vertices),s.currentMesh.color?m=s.currentMesh.color:(k[0]=a[0]*s.color.r*w.r,k[1]=a[1]*s.color.g*w.g,k[2]=a[2]*s.color.b*w.b,s.currentMesh.tint=S.utils.rgb2hex(k)),s.currentMesh.blendMode=s.blendMode,s.hackRegion||this.setMeshRegion(d,s.currentMesh,f);break;case T.Clipping:s.currentGraphics||(this.createGraphics(s,d),p.addChild(s.clippingContainer),p.addChild(s.currentGraphics)),this.updateGraphics(s,d),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,m){let C=s.color.r*w.r,y=s.color.g*w.g,x=s.color.b*w.b;m.setLight(a[0]*C+o[0]*(1-C),a[1]*y+o[1]*(1-y),a[2]*x+o[2]*(1-x)),s.darkColor?(C=s.darkColor.r,y=s.darkColor.g,x=s.darkColor.b):(C=0,y=0,x=0),m.setDark(a[0]*C+o[0]*(1-C),a[1]*y+o[1]*(1-y),a[2]*x+o[2]*(1-x))}p.alpha=s.color.a}const c=this.skeleton.drawOrder;let l=null,u=null;for(let h=0,g=c.length;h<g;h++){const s=r[c[h].data.index],d=this.slotContainers[c[h].data.index];if(u||d.parent!==null&&d.parent!==this&&(d.parent.removeChild(d),d.parent=this),s.currentGraphics&&s.getAttachment())u=s.clippingContainer,l=s.getAttachment(),u.children.length=0,this.children[h]=d,l.endSlot===s.data&&(l.endSlot=null);else if(u){let p=this.tempClipContainers[h];p||(p=this.tempClipContainers[h]=this.newContainer(),p.visible=!1),this.children[h]=p,d.parent=null,u.addChild(d),l.endSlot==s.data&&(u.renderable=!0,u=null,l=null)}else this.children[h]=d}(e=this._debug)==null||e.renderDebug(this)}setSpriteRegion(i,e,t){e.attachment===i&&e.region===t||(e.region=t,e.attachment=i,e.texture=t.texture,e.rotation=i.rotation*N.degRad,e.position.x=i.x,e.position.y=i.y,e.alpha=i.color.a,t.size?(e.scale.x=t.size.width/t.originalWidth,e.scale.y=-t.size.height/t.originalHeight):(e.scale.x=i.scaleX*i.width/t.originalWidth,e.scale.y=-i.scaleY*i.height/t.originalHeight))}setMeshRegion(i,e,t){e.attachment===i&&e.region===t||(e.region=t,e.attachment=i,e.texture=t.texture,t.texture.updateUvs(),e.uvBuffer.update(i.regionUVs))}autoUpdateTransform(){if($.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const i=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(i)}else this.lastTime=0;F.Container.prototype.updateTransform.call(this)}createSprite(i,e,t){let r=e.region;i.hackAttachment===e&&(r=i.hackRegion);const n=r?r.texture:null,a=this.newSprite(n);return a.anchor.set(.5),r&&this.setSpriteRegion(e,a,e.region),i.sprites=i.sprites||{},i.sprites[t]=a,a}createMesh(i,e){let t=e.region;i.hackAttachment===e&&(t=i.hackRegion,i.hackAttachment=null,i.hackRegion=null);const r=this.newMesh(t?t.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),S.DRAW_MODES.TRIANGLES);return typeof r._canvasPadding!="undefined"&&(r._canvasPadding=1.5),r.alpha=e.color.a,r.region=e.region,t&&this.setMeshRegion(e,r,t),i.meshes=i.meshes||{},i.meshes[e.id]=r,r}createGraphics(i,e){const t=this.newGraphics(),r=new S.Polygon([]);return t.clear(),t.beginFill(16777215,1),t.drawPolygon(r),t.renderable=!1,i.currentGraphics=t,i.clippingContainer=this.newContainer(),i.clippingContainer.mask=i.currentGraphics,t}updateGraphics(i,e){const t=i.currentGraphics.geometry,r=t.graphicsData[0].shape.points,n=e.worldVerticesLength;r.length=n,e.computeWorldVertices(i,0,n,r,0,2),t.invalidate()}hackTextureBySlotIndex(i,e=null,t=null){const r=this.skeleton.slots[i];if(!r)return!1;const n=r.getAttachment();let a=n.region;return e?(a=new G,a.texture=e,a.size=t,r.hackRegion=a,r.hackAttachment=n):(r.hackRegion=null,r.hackAttachment=null),r.currentSprite?this.setSpriteRegion(n,r.currentSprite,a):r.currentMesh&&this.setMeshRegion(n,r.currentMesh,a),!0}hackTextureBySlotName(i,e=null,t=null){const r=this.skeleton.findSlotIndex(i);return r==-1?!1:this.hackTextureBySlotIndex(r,e,t)}hackTextureAttachment(i,e,t,r=null){const n=this.skeleton.findSlotIndex(i),a=this.skeleton.getAttachmentByName(i,e);a.region.texture=t;const o=this.skeleton.slots[n];if(!o)return!1;const c=o.getAttachment();if(e===c.name){let l=a.region;return t?(l=new G,l.texture=t,l.size=r,o.hackRegion=l,o.hackAttachment=c):(o.hackRegion=null,o.hackAttachment=null),o.currentSprite&&o.currentSprite.region!=l?(this.setSpriteRegion(c,o.currentSprite,l),o.currentSprite.region=l):o.currentMesh&&o.currentMesh.region!=l&&this.setMeshRegion(c,o.currentMesh,l),!0}return!1}newContainer(){return new F.Container}newSprite(i){return new ne(i)}newGraphics(){return new P.Graphics}newMesh(i,e,t,r,n){return new se(i,e,t,r,n)}transformHack(){return 1}hackAttachmentGroups(i,e,t){if(!i)return;const r=[],n=[];for(let a=0,o=this.skeleton.slots.length;a<o;a++){const c=this.skeleton.slots[a],l=c.currentSpriteName||c.currentMeshName||"",u=c.currentSprite||c.currentMesh;l.endsWith(i)?(u.parentGroup=e,n.push(u)):t&&u&&(u.parentGroup=t,r.push(u))}return[r,n]}destroy(i){this.debug=null;for(let e=0,t=this.skeleton.slots.length;e<t;e++){const r=this.skeleton.slots[e];for(const n in r.meshes)r.meshes[n].destroy(i);r.meshes=null;for(const n in r.sprites)r.sprites[n].destroy(i);r.sprites=null}for(let e=0,t=this.slotContainers.length;e<t;e++)this.slotContainers[e].destroy(i);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(i)}};let q=ae;q.clippingPolygon=[],Object.defineProperty(q.prototype,"visible",{get(){return this._visible},set(i){i!==this._visible&&(this._visible=i,i&&(this.lastTime=0))}});class Ce{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(e){this.registeredSpines.has(e)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",e);const t={parentDebugContainer:new F.Container,bones:new F.Container,skeletonXY:new P.Graphics,regionAttachmentsShape:new P.Graphics,meshTrianglesLine:new P.Graphics,meshHullLine:new P.Graphics,clippingPolygon:new P.Graphics,boundingBoxesRect:new P.Graphics,boundingBoxesCircle:new P.Graphics,boundingBoxesPolygon:new P.Graphics,pathsCurve:new P.Graphics,pathsLine:new P.Graphics};t.parentDebugContainer.addChild(t.bones),t.parentDebugContainer.addChild(t.skeletonXY),t.parentDebugContainer.addChild(t.regionAttachmentsShape),t.parentDebugContainer.addChild(t.meshTrianglesLine),t.parentDebugContainer.addChild(t.meshHullLine),t.parentDebugContainer.addChild(t.clippingPolygon),t.parentDebugContainer.addChild(t.boundingBoxesRect),t.parentDebugContainer.addChild(t.boundingBoxesCircle),t.parentDebugContainer.addChild(t.boundingBoxesPolygon),t.parentDebugContainer.addChild(t.pathsCurve),t.parentDebugContainer.addChild(t.pathsLine),e.addChild(t.parentDebugContainer),this.registeredSpines.set(e,t)}renderDebug(e){this.registeredSpines.has(e)||this.registerSpine(e);const t=this.registeredSpines.get(e);t.skeletonXY.clear(),t.regionAttachmentsShape.clear(),t.meshTrianglesLine.clear(),t.meshHullLine.clear(),t.clippingPolygon.clear(),t.boundingBoxesRect.clear(),t.boundingBoxesCircle.clear(),t.boundingBoxesPolygon.clear(),t.pathsCurve.clear(),t.pathsLine.clear();for(let a=t.bones.children.length;a>0;a--)t.bones.children[a-1].destroy({children:!0,texture:!0,baseTexture:!0});const r=e.scale.x||e.scale.y||1,n=this.lineWidth/r;this.drawBones&&this.drawBonesFunc(e,t,n,r),this.drawPaths&&this.drawPathsFunc(e,t,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(e,t,n),this.drawClipping&&this.drawClippingFunc(e,t,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(e,t,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(e,t,n)}drawBonesFunc(e,t,r,n){const a=e.skeleton,o=a.x,c=a.y,l=a.bones;t.skeletonXY.lineStyle(r,this.skeletonXYColor,1);for(let h=0,g=l.length;h<g;h++){const s=l[h],d=s.data.length,p=o+s.matrix.tx,m=c+s.matrix.ty,f=o+d*s.matrix.a+s.matrix.tx,w=c+d*s.matrix.b+s.matrix.ty;if(s.data.name==="root"||s.data.parent===null)continue;const C=Math.abs(p-f),y=Math.abs(m-w),x=Math.pow(C,2),I=y,O=Math.pow(y,2),A=Math.sqrt(x+O),Se=Math.pow(A,2),X=Math.PI/180,V=Math.acos((Se+O-x)/(2*I*A))||0;if(A===0)continue;const R=new P.Graphics;t.bones.addChild(R);const E=A/50/n;R.beginFill(this.bonesColor,1),R.drawPolygon(0,0,0-E,A-E*3,0,A-E,0+E,A-E*3),R.endFill(),R.x=p,R.y=m,R.pivot.y=A;let B=0;p<f&&m<w?B=-V+180*X:p>f&&m<w?B=180*X+V:p>f&&m>w?B=-V:p<f&&m>w?B=V:m===w&&p<f?B=90*X:m===w&&p>f?B=-90*X:p===f&&m<w?B=180*X:p===f&&m>w&&(B=0),R.rotation=B,R.lineStyle(r+E/2.4,this.bonesColor,1),R.beginFill(0,.6),R.drawCircle(0,A,E*1.2),R.endFill()}const u=r*3;t.skeletonXY.moveTo(o-u,c-u),t.skeletonXY.lineTo(o+u,c+u),t.skeletonXY.moveTo(o+u,c-u),t.skeletonXY.lineTo(o-u,c+u)}drawRegionAttachmentsFunc(e,t,r){const n=e.skeleton.slots;t.regionAttachmentsShape.lineStyle(r,this.regionAttachmentsColor,1);for(let a=0,o=n.length;a<o;a++){const c=n[a],l=c.getAttachment();if(l==null||l.type!==T.Region)continue;const u=l,h=new Float32Array(8);u.updateOffset&&u.updateOffset(),u.computeWorldVertices(c,h,0,2),t.regionAttachmentsShape.drawPolygon(Array.from(h.slice(0,8)))}}drawMeshHullAndMeshTriangles(e,t,r){const n=e.skeleton.slots;t.meshHullLine.lineStyle(r,this.meshHullColor,1),t.meshTrianglesLine.lineStyle(r,this.meshTrianglesColor,1);for(let a=0,o=n.length;a<o;a++){const c=n[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Mesh)continue;const u=l,h=new Float32Array(u.worldVerticesLength),g=u.triangles;let s=u.hullLength;if(u.computeWorldVertices(c,0,u.worldVerticesLength,h,0,2),this.drawMeshTriangles)for(let d=0,p=g.length;d<p;d+=3){const m=g[d]*2,f=g[d+1]*2,w=g[d+2]*2;t.meshTrianglesLine.moveTo(h[m],h[m+1]),t.meshTrianglesLine.lineTo(h[f],h[f+1]),t.meshTrianglesLine.lineTo(h[w],h[w+1])}if(this.drawMeshHull&&s>0){s=(s>>1)*2;let d=h[s-2],p=h[s-1];for(let m=0,f=s;m<f;m+=2){const w=h[m],C=h[m+1];t.meshHullLine.moveTo(w,C),t.meshHullLine.lineTo(d,p),d=w,p=C}}}}drawClippingFunc(e,t,r){const n=e.skeleton.slots;t.clippingPolygon.lineStyle(r,this.clippingPolygonColor,1);for(let a=0,o=n.length;a<o;a++){const c=n[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Clipping)continue;const u=l,h=u.worldVerticesLength,g=new Float32Array(h);u.computeWorldVertices(c,0,h,g,0,2),t.clippingPolygon.drawPolygon(Array.from(g))}}drawBoundingBoxesFunc(e,t,r){t.boundingBoxesRect.lineStyle(r,this.boundingBoxesRectColor,5);const n=new re;n.update(e.skeleton,!0),t.boundingBoxesRect.drawRect(n.minX,n.minY,n.getWidth(),n.getHeight());const a=n.polygons,o=(c,l,u)=>{if(t.boundingBoxesPolygon.lineStyle(r,this.boundingBoxesPolygonColor,1),t.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),u<3)throw new Error("Polygon must contain at least 3 vertices");const h=[],g=r*2;for(let s=0,d=c.length;s<d;s+=2){const p=c[s],m=c[s+1];t.boundingBoxesCircle.lineStyle(0),t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),t.boundingBoxesCircle.drawCircle(p,m,g),t.boundingBoxesCircle.endFill(),h.push(p,m)}t.boundingBoxesPolygon.drawPolygon(h),t.boundingBoxesPolygon.endFill()};for(let c=0,l=a.length;c<l;c++){const u=a[c];o(u,0,u.length)}}drawPathsFunc(e,t,r){const n=e.skeleton.slots;t.pathsCurve.lineStyle(r,this.pathsCurveColor,1),t.pathsLine.lineStyle(r,this.pathsLineColor,1);for(let a=0,o=n.length;a<o;a++){const c=n[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Path)continue;const u=l;let h=u.worldVerticesLength;const g=new Float32Array(h);u.computeWorldVertices(c,0,h,g,0,2);let s=g[2],d=g[3],p=0,m=0;if(u.closed){const f=g[0],w=g[1],C=g[h-2],y=g[h-1];p=g[h-4],m=g[h-3],t.pathsCurve.moveTo(s,d),t.pathsCurve.bezierCurveTo(f,w,C,y,p,m),t.pathsLine.moveTo(s,d),t.pathsLine.lineTo(f,w),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(C,y)}h-=4;for(let f=4;f<h;f+=6){const w=g[f],C=g[f+1],y=g[f+2],x=g[f+3];p=g[f+4],m=g[f+5],t.pathsCurve.moveTo(s,d),t.pathsCurve.bezierCurveTo(w,C,y,x,p,m),t.pathsLine.moveTo(s,d),t.pathsLine.lineTo(w,C),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(y,x),s=p,d=m}}}unregisterSpine(e){this.registeredSpines.has(e)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",e),this.registeredSpines.get(e).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(e)}}return b.AttachmentType=T,b.BinaryInput=he,b.Color=_,b.DebugUtils=we,b.IntSet=pe,b.Interpolation=ee,b.MathUtils=N,b.MixBlend=K,b.MixDirection=j,b.Pool=ie,b.PositionMode=J,b.Pow=te,b.PowOut=fe,b.RotateMode=Q,b.SkeletonBoundsBase=re,b.SpineBase=q,b.SpineDebugRenderer=Ce,b.SpineMesh=se,b.SpineSprite=ne,b.StringSet=me,b.TextureAtlas=de,b.TextureAtlasPage=H,b.TextureAtlasRegion=z,b.TextureFilter=M,b.TextureRegion=G,b.TextureWrap=L,b.TimeKeeper=ye,b.TransformMode=Z,b.Utils=W,b.Vector2=be,b.WindowedMean=xe,b.filterFromString=U,b.settings=$,b.wrapFromString=ue,b}({},PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=base.js.map
