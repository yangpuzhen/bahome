/*!
 * @pixi-spine/base - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:28 UTC
 *
 * @pixi-spine/base is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{ALPHA_MODES as he,Rectangle as H,Texture as ue,SCALE_MODES as V,MIPMAP_MODES as ce,utils as W,Transform as de,DRAW_MODES as ge,Polygon as pe}from"@pixi/core";import{Container as D}from"@pixi/display";import{Sprite as me}from"@pixi/sprite";import{SimpleMesh as fe}from"@pixi/mesh-extras";import{Graphics as I}from"@pixi/graphics";var T=(r=>(r[r.Region=0]="Region",r[r.BoundingBox=1]="BoundingBox",r[r.Mesh=2]="Mesh",r[r.LinkedMesh=3]="LinkedMesh",r[r.Path=4]="Path",r[r.Point=5]="Point",r[r.Clipping=6]="Clipping",r))(T||{});class be{constructor(e,t=new Array,i=0,s=new DataView(e.buffer)){this.strings=t,this.index=i,this.buffer=s}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const e=this.buffer.getInt16(this.index);return this.index+=2,e}readInt32(){const e=this.buffer.getInt32(this.index);return this.index+=4,e}readInt(e){let t=this.readByte(),i=t&127;return t&128&&(t=this.readByte(),i|=(t&127)<<7,t&128&&(t=this.readByte(),i|=(t&127)<<14,t&128&&(t=this.readByte(),i|=(t&127)<<21,t&128&&(t=this.readByte(),i|=(t&127)<<28)))),e?i:i>>>1^-(i&1)}readStringRef(){const e=this.readInt(!0);return e==0?null:this.strings[e-1]}readString(){let e=this.readInt(!0);switch(e){case 0:return null;case 1:return""}e--;let t="";for(let i=0;i<e;){const s=this.readUnsignedByte();switch(s>>4){case 12:case 13:t+=String.fromCharCode((s&31)<<6|this.readByte()&63),i+=2;break;case 14:t+=String.fromCharCode((s&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),i+=3;break;default:t+=String.fromCharCode(s),i++}}return t}readFloat(){const e=this.buffer.getFloat32(this.index);return this.index+=4,e}readBoolean(){return this.readByte()!=0}}var K=(r=>(r[r.setup=0]="setup",r[r.first=1]="first",r[r.replace=2]="replace",r[r.add=3]="add",r))(K||{}),J=(r=>(r[r.mixIn=0]="mixIn",r[r.mixOut=1]="mixOut",r))(J||{}),Q=(r=>(r[r.Fixed=0]="Fixed",r[r.Percent=1]="Percent",r))(Q||{}),Z=(r=>(r[r.Tangent=0]="Tangent",r[r.Chain=1]="Chain",r[r.ChainScale=2]="ChainScale",r))(Z||{}),ee=(r=>(r[r.Normal=0]="Normal",r[r.OnlyTranslation=1]="OnlyTranslation",r[r.NoRotationOrReflection=2]="NoRotationOrReflection",r[r.NoScale=3]="NoScale",r[r.NoScaleOrReflection=4]="NoScaleOrReflection",r))(ee||{});function G(r){switch(r.toLowerCase()){case"nearest":return C.Nearest;case"linear":return C.Linear;case"mipmap":return C.MipMap;case"mipmapnearestnearest":return C.MipMapNearestNearest;case"mipmaplinearnearest":return C.MipMapLinearNearest;case"mipmapnearestlinear":return C.MipMapNearestLinear;case"mipmaplinearlinear":return C.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${r}`)}}function we(r){switch(r.toLowerCase()){case"mirroredtepeat":return R.MirroredRepeat;case"clamptoedge":return R.ClampToEdge;case"repeat":return R.Repeat;default:throw new Error(`Unknown texture wrap ${r}`)}}var C=(r=>(r[r.Nearest=9728]="Nearest",r[r.Linear=9729]="Linear",r[r.MipMap=9987]="MipMap",r[r.MipMapNearestNearest=9984]="MipMapNearestNearest",r[r.MipMapLinearNearest=9985]="MipMapLinearNearest",r[r.MipMapNearestLinear=9986]="MipMapNearestLinear",r[r.MipMapLinearLinear=9987]="MipMapLinearLinear",r))(C||{}),R=(r=>(r[r.MirroredRepeat=33648]="MirroredRepeat",r[r.ClampToEdge=33071]="ClampToEdge",r[r.Repeat=10497]="Repeat",r))(R||{});class U{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const e=this.texture;return e.trim?e.trim.width:e.orig.width}get height(){const e=this.texture;return e.trim?e.trim.height:e.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const e=this.texture;return e.trim?e.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const e=this.texture;return e.trim?e.trim.y:0}get spineOffsetY(){const e=this.texture;return this.originalHeight-this.height-(e.trim?e.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class xe{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class ye{constructor(e,t,i){this.pages=new Array,this.regions=new Array,e&&this.addSpineAtlas(e,t,i)}addTexture(e,t){const i=this.pages;let s=null;for(let o=0;o<i.length;o++)if(i[o].baseTexture===t.baseTexture){s=i[o];break}if(s===null){s=new z,s.name="texturePage";const o=t.baseTexture;s.width=o.realWidth,s.height=o.realHeight,s.baseTexture=o,s.minFilter=s.magFilter=C.Nearest,s.uWrap=R.ClampToEdge,s.vWrap=R.ClampToEdge,i.push(s)}const a=new $;return a.name=e,a.page=s,a.texture=t,a.index=-1,this.regions.push(a),a}addTextureHash(e,t){for(const i in e)e.hasOwnProperty(i)&&this.addTexture(t&&i.indexOf(".")!==-1?i.substr(0,i.lastIndexOf(".")):i,e[i])}addSpineAtlas(e,t,i){return this.load(e,t,i)}load(e,t,i){if(t==null)throw new Error("textureLoader cannot be null.");const s=new Ce(e),a=new Array(4);let o=null;const c={};let l=null;c.size=()=>{o.width=parseInt(a[1]),o.height=parseInt(a[2])},c.format=()=>{},c.filter=()=>{o.minFilter=G(a[1]),o.magFilter=G(a[2])},c.repeat=()=>{a[1].indexOf("x")!=-1&&(o.uWrap=R.Repeat),a[1].indexOf("y")!=-1&&(o.vWrap=R.Repeat)},c.pma=()=>{o.pma=a[1]=="true"};const u={};u.xy=()=>{l.x=parseInt(a[1]),l.y=parseInt(a[2])},u.size=()=>{l.width=parseInt(a[1]),l.height=parseInt(a[2])},u.bounds=()=>{l.x=parseInt(a[1]),l.y=parseInt(a[2]),l.width=parseInt(a[3]),l.height=parseInt(a[4])},u.offset=()=>{l.offsetX=parseInt(a[1]),l.offsetY=parseInt(a[2])},u.orig=()=>{l.originalWidth=parseInt(a[1]),l.originalHeight=parseInt(a[2])},u.offsets=()=>{l.offsetX=parseInt(a[1]),l.offsetY=parseInt(a[2]),l.originalWidth=parseInt(a[3]),l.originalHeight=parseInt(a[4])},u.rotate=()=>{const n=a[1];let d=0;n.toLocaleLowerCase()=="true"?d=6:n.toLocaleLowerCase()=="false"?d=0:d=(720-parseFloat(n))%360/45,l.rotate=d},u.index=()=>{l.index=parseInt(a[1])};let h=s.readLine();for(;h!=null&&h.trim().length==0;)h=s.readLine();for(;!(h==null||h.trim().length==0||s.readEntry(a,h)==0);)h=s.readLine();const g=()=>{for(;;){if(h==null)return i&&i(this);if(h.trim().length==0)o=null,h=s.readLine();else if(o===null){for(o=new z,o.name=h.trim();s.readEntry(a,h=s.readLine())!=0;){const n=c[a[0]];n&&n()}this.pages.push(o),t(o.name,n=>{if(n===null)return this.pages.splice(this.pages.indexOf(o),1),i&&i(null);o.baseTexture=n,o.pma&&(n.alphaMode=he.PMA),n.valid||n.setSize(o.width,o.height),o.setFilters(),(!o.width||!o.height)&&(o.width=n.realWidth,o.height=n.realHeight,(!o.width||!o.height)&&console.log(`ERROR spine atlas page ${o.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),g()});break}else{l=new xe;const n=new $;n.name=h,n.page=o;let d=null,p=null;for(;;){const x=s.readEntry(a,h=s.readLine());if(x==0)break;const S=u[a[0]];if(S)S();else{d==null&&(d=[],p=[]),d.push(a[0]);const Y=[];for(let M=0;M<x;M++)Y.push(parseInt(a[M+1]));p.push(Y)}}l.originalWidth==0&&l.originalHeight==0&&(l.originalWidth=l.width,l.originalHeight=l.height);const m=o.baseTexture.resolution;l.x/=m,l.y/=m,l.width/=m,l.height/=m,l.originalWidth/=m,l.originalHeight/=m,l.offsetX/=m,l.offsetY/=m;const f=l.rotate%4!==0,b=new H(l.x,l.y,f?l.height:l.width,f?l.width:l.height),y=new H(0,0,l.originalWidth,l.originalHeight),w=new H(l.offsetX,l.originalHeight-l.height-l.offsetY,l.width,l.height);n.texture=new ue(n.page.baseTexture,b,y,w,l.rotate),n.index=l.index,n.texture.updateUvs(),this.regions.push(n)}}};g()}findRegion(e){for(let t=0;t<this.regions.length;t++)if(this.regions[t].name==e)return this.regions[t];return null}dispose(){for(let e=0;e<this.pages.length;e++)this.pages[e].baseTexture.dispose()}}class Ce{constructor(e){this.index=0,this.lines=e.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(e,t){if(t==null||(t=t.trim(),t.length==0))return 0;const i=t.indexOf(":");if(i==-1)return 0;e[0]=t.substr(0,i).trim();for(let s=1,a=i+1;;s++){const o=t.indexOf(",",a);if(o==-1)return e[s]=t.substr(a).trim(),s;if(e[s]=t.substr(a,o-a).trim(),a=o+1,s==4)return 4}}}class z{constructor(){this.minFilter=C.Nearest,this.magFilter=C.Nearest,this.uWrap=R.ClampToEdge,this.vWrap=R.ClampToEdge}setFilters(){const e=this.baseTexture,t=this.minFilter;t==C.Linear?e.scaleMode=V.LINEAR:this.minFilter==C.Nearest?e.scaleMode=V.NEAREST:(e.mipmap=ce.POW2,t==C.MipMapNearestNearest?e.scaleMode=V.NEAREST:e.scaleMode=V.LINEAR)}}class $ extends U{}class Se{constructor(){this.array=new Array}add(e){const t=this.contains(e);return this.array[e|0]=e|0,!t}contains(e){return this.array[e|0]!=null}remove(e){this.array[e|0]=void 0}clear(){this.array.length=0}}class Me{constructor(){this.entries={},this.size=0}add(e){const t=this.entries[e];return this.entries[e]=!0,t?!1:(this.size++,!0)}addAll(e){const t=this.size;for(let i=0,s=e.length;i<s;i++)this.add(e[i]);return t!=this.size}contains(e){return this.entries[e]}clear(){this.entries={},this.size=0}}const B=class{constructor(r=0,e=0,t=0,i=0){this.r=r,this.g=e,this.b=t,this.a=i}set(r,e,t,i){return this.r=r,this.g=e,this.b=t,this.a=i,this.clamp()}setFromColor(r){return this.r=r.r,this.g=r.g,this.b=r.b,this.a=r.a,this}setFromString(r){return r=r.charAt(0)=="#"?r.substr(1):r,this.r=parseInt(r.substr(0,2),16)/255,this.g=parseInt(r.substr(2,2),16)/255,this.b=parseInt(r.substr(4,2),16)/255,this.a=r.length!=8?1:parseInt(r.substr(6,2),16)/255,this}add(r,e,t,i){return this.r+=r,this.g+=e,this.b+=t,this.a+=i,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(r,e){r.r=((e&4278190080)>>>24)/255,r.g=((e&16711680)>>>16)/255,r.b=((e&65280)>>>8)/255,r.a=(e&255)/255}static rgb888ToColor(r,e){r.r=((e&16711680)>>>16)/255,r.g=((e&65280)>>>8)/255,r.b=(e&255)/255}static fromString(r){return new B().setFromString(r)}};let E=B;E.WHITE=new B(1,1,1,1),E.RED=new B(1,0,0,1),E.GREEN=new B(0,1,0,1),E.BLUE=new B(0,0,1,1),E.MAGENTA=new B(1,0,1,1);const L=class{static clamp(r,e,t){return r<e?e:r>t?t:r}static cosDeg(r){return Math.cos(r*L.degRad)}static sinDeg(r){return Math.sin(r*L.degRad)}static signum(r){return Math.sign(r)}static toInt(r){return r>0?Math.floor(r):Math.ceil(r)}static cbrt(r){const e=Math.pow(Math.abs(r),.3333333333333333);return r<0?-e:e}static randomTriangular(r,e){return L.randomTriangularWith(r,e,(r+e)*.5)}static randomTriangularWith(r,e,t){const i=Math.random(),s=e-r;return i<=(t-r)/s?r+Math.sqrt(i*s*(t-r)):e-Math.sqrt((1-i)*s*(e-t))}static isPowerOfTwo(r){return r&&(r&r-1)===0}};let v=L;v.PI=3.1415927,v.PI2=L.PI*2,v.radiansToDegrees=180/L.PI,v.radDeg=L.radiansToDegrees,v.degreesToRadians=L.PI/180,v.degRad=L.degreesToRadians;class te{apply(e,t,i){return e+(t-e)*this.applyInternal(i)}}class re extends te{constructor(e){super(),this.power=2,this.power=e}applyInternal(e){return e<=.5?Math.pow(e*2,this.power)/2:Math.pow((e-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class Te extends re{applyInternal(e){return Math.pow(e-1,this.power)*(this.power%2==0?-1:1)+1}}const F=class{static arrayCopy(r,e,t,i,s){for(let a=e,o=i;a<e+s;a++,o++)t[o]=r[a]}static arrayFill(r,e,t,i){for(let s=e;s<t;s++)r[s]=i}static setArraySize(r,e,t=0){const i=r.length;if(i==e)return r;if(r.length=e,i<e)for(let s=i;s<e;s++)r[s]=t;return r}static ensureArrayCapacity(r,e,t=0){return r.length>=e?r:F.setArraySize(r,e,t)}static newArray(r,e){const t=new Array(r);for(let i=0;i<r;i++)t[i]=e;return t}static newFloatArray(r){if(F.SUPPORTS_TYPED_ARRAYS)return new Float32Array(r);const e=new Array(r);for(let t=0;t<e.length;t++)e[t]=0;return e}static newShortArray(r){if(F.SUPPORTS_TYPED_ARRAYS)return new Int16Array(r);const e=new Array(r);for(let t=0;t<e.length;t++)e[t]=0;return e}static toFloatArray(r){return F.SUPPORTS_TYPED_ARRAYS?new Float32Array(r):r}static toSinglePrecision(r){return F.SUPPORTS_TYPED_ARRAYS?Math.fround(r):r}static webkit602BugfixHelper(r,e){}static contains(r,e,t=!0){for(let i=0;i<r.length;i++)if(r[i]==e)return!0;return!1}static enumValue(r,e){return r[e[0].toUpperCase()+e.slice(1)]}};let X=F;X.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class Ae{static logBones(e){for(let t=0;t<e.bones.length;t++){const i=e.bones[t],s=i.matrix;console.log(`${i.data.name}, ${s.a}, ${s.b}, ${s.c}, ${s.d}, ${s.tx}, ${s.ty}`)}}}class ie{constructor(e){this.items=new Array,this.instantiator=e}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(e){e.reset&&e.reset(),this.items.push(e)}freeAll(e){for(let t=0;t<e.length;t++)this.free(e[t])}clear(){this.items.length=0}}class Ie{constructor(e=0,t=0){this.x=e,this.y=t}set(e,t){return this.x=e,this.y=t,this}length(){const e=this.x,t=this.y;return Math.sqrt(e*e+t*t)}normalize(){const e=this.length();return e!=0&&(this.x/=e,this.y/=e),this}}class Re{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const e=Date.now()/1e3;this.delta=e-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=e,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class Pe{constructor(e=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(e)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(e){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=e,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let e=0;for(let t=0;t<this.values.length;t++)e+=this.values[t];this.mean=e/this.values.length,this.dirty=!1}return this.mean}return 0}}class se{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new ie(()=>X.newFloatArray(16))}update(e,t){if(!e)throw new Error("skeleton cannot be null.");const i=this.boundingBoxes,s=this.polygons,a=this.polygonPool,o=e.slots,c=o.length;i.length=0,a.freeAll(s),s.length=0;for(let l=0;l<c;l++){const u=o[l];if(!u.bone.active)continue;const h=u.getAttachment();if(h!=null&&h.type===T.BoundingBox){const g=h;i.push(g);let n=a.obtain();n.length!=g.worldVerticesLength&&(n=X.newFloatArray(g.worldVerticesLength)),s.push(n),g.computeWorldVertices(u,0,g.worldVerticesLength,n,0,2)}}t?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let e=Number.POSITIVE_INFINITY,t=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const a=this.polygons;for(let o=0,c=a.length;o<c;o++){const l=a[o],u=l;for(let h=0,g=l.length;h<g;h+=2){const n=u[h],d=u[h+1];e=Math.min(e,n),t=Math.min(t,d),i=Math.max(i,n),s=Math.max(s,d)}}this.minX=e,this.minY=t,this.maxX=i,this.maxY=s}aabbContainsPoint(e,t){return e>=this.minX&&e<=this.maxX&&t>=this.minY&&t<=this.maxY}aabbIntersectsSegment(e,t,i,s){const a=this.minX,o=this.minY,c=this.maxX,l=this.maxY;if(e<=a&&i<=a||t<=o&&s<=o||e>=c&&i>=c||t>=l&&s>=l)return!1;const u=(s-t)/(i-e);let h=u*(a-e)+t;if(h>o&&h<l||(h=u*(c-e)+t,h>o&&h<l))return!0;let g=(o-t)/u+e;return g>a&&g<c||(g=(l-t)/u+e,g>a&&g<c)}aabbIntersectsSkeleton(e){return this.minX<e.maxX&&this.maxX>e.minX&&this.minY<e.maxY&&this.maxY>e.minY}containsPoint(e,t){const i=this.polygons;for(let s=0,a=i.length;s<a;s++)if(this.containsPointPolygon(i[s],e,t))return this.boundingBoxes[s];return null}containsPointPolygon(e,t,i){const s=e,a=e.length;let o=a-2,c=!1;for(let l=0;l<a;l+=2){const u=s[l+1],h=s[o+1];if(u<i&&h>=i||h<i&&u>=i){const g=s[l];g+(i-u)/(h-u)*(s[o]-g)<t&&(c=!c)}o=l}return c}intersectsSegment(e,t,i,s){const a=this.polygons;for(let o=0,c=a.length;o<c;o++)if(this.intersectsSegmentPolygon(a[o],e,t,i,s))return this.boundingBoxes[o];return null}intersectsSegmentPolygon(e,t,i,s,a){const o=e,c=e.length,l=t-s,u=i-a,h=t*a-i*s;let g=o[c-2],n=o[c-1];for(let d=0;d<c;d+=2){const p=o[d],m=o[d+1],f=g*m-n*p,b=g-p,y=n-m,w=l*y-u*b,x=(h*b-l*f)/w;if((x>=g&&x<=p||x>=p&&x<=g)&&(x>=t&&x<=s||x>=s&&x<=t)){const S=(h*y-u*f)/w;if((S>=n&&S<=m||S>=m&&S<=n)&&(S>=i&&S<=a||S>=a&&S<=i))return!0}g=p,n=m}return!1}getPolygon(e){if(!e)throw new Error("boundingBox cannot be null.");const t=this.boundingBoxes.indexOf(e);return t==-1?null:this.polygons[t]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const q={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},N=[0,0,0];class ne extends me{constructor(){super(...arguments),this.region=null,this.attachment=null}}class ae extends fe{constructor(e,t,i,s,a){super(e,t,i,s,a),this.region=null,this.attachment=null}}const oe=class extends D{constructor(r){if(super(),!r)throw new Error("The spineData param is required.");if(typeof r=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=r,this.createSkeleton(r),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,t=this.skeleton.slots.length;e<t;e++){const i=this.skeleton.slots[e],s=i.getAttachment(),a=this.newContainer();if(this.slotContainers.push(a),this.addChild(a),this.tempClipContainers.push(null),!!s)if(s.type===T.Region){const o=s.name,c=this.createSprite(i,s,o);i.currentSprite=c,i.currentSpriteName=o,a.addChild(c)}else if(s.type===T.Mesh){const o=this.createMesh(i,s);i.currentMesh=o,i.currentMeshId=s.id,i.currentMeshName=s.name,a.addChild(o)}else s.type===T.Clipping&&(this.createGraphics(i,s),a.addChild(i.clippingContainer),a.addChild(i.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(r){var e;r!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),r==null||r.registerSpine(this),this._debug=r)}get autoUpdate(){return this._autoUpdate}set autoUpdate(r){r!==this._autoUpdate&&(this._autoUpdate=r,this.updateTransform=r?oe.prototype.autoUpdateTransform:D.prototype.updateTransform)}get tint(){return W.rgb2hex(this.tintRgb)}set tint(r){this.tintRgb=W.hex2rgb(r,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:q.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(r){var e;const t=this.delayLimit;if(r>t&&(r=t),this.state.update(r),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const i=this.skeleton.slots,s=this.color;let a=null,o=null;s?(a=s.light,o=s.dark):a=this.tintRgb;for(let h=0,g=i.length;h<g;h++){const n=i[h],d=n.getAttachment(),p=this.slotContainers[h];if(!d){p.visible=!1;continue}let m=null;d.sequence&&d.sequence.apply(n,d);let f=d.region;const b=d.color;switch(d!=null&&d.type){case T.Region:if(p.transform.setFromMatrix(n.bone.matrix),f=d.region,n.currentMesh&&(n.currentMesh.visible=!1,n.currentMesh=null,n.currentMeshId=void 0,n.currentMeshName=void 0),!f){n.currentSprite&&(n.currentSprite.renderable=!1);break}if(!n.currentSpriteName||n.currentSpriteName!==d.name){const w=d.name;if(n.currentSprite&&(n.currentSprite.visible=!1),n.sprites=n.sprites||{},n.sprites[w]!==void 0)n.sprites[w].visible=!0;else{const x=this.createSprite(n,d,w);p.addChild(x)}n.currentSprite=n.sprites[w],n.currentSpriteName=w}n.currentSprite.renderable=!0,n.hackRegion||this.setSpriteRegion(d,n.currentSprite,f),n.currentSprite.color?m=n.currentSprite.color:(N[0]=a[0]*n.color.r*b.r,N[1]=a[1]*n.color.g*b.g,N[2]=a[2]*n.color.b*b.b,n.currentSprite.tint=W.rgb2hex(N)),n.currentSprite.blendMode=n.blendMode;break;case T.Mesh:if(n.currentSprite){n.currentSprite.visible=!1,n.currentSprite=null,n.currentSpriteName=void 0;const w=new de;w._parentID=-1,w._worldID=p.transform._worldID,p.transform=w}if(!f){n.currentMesh&&(n.currentMesh.renderable=!1);break}const y=d.id;if(n.currentMeshId===void 0||n.currentMeshId!==y){const w=y;if(n.currentMesh&&(n.currentMesh.visible=!1),n.meshes=n.meshes||{},n.meshes[w]!==void 0)n.meshes[w].visible=!0;else{const x=this.createMesh(n,d);p.addChild(x)}n.currentMesh=n.meshes[w],n.currentMeshName=d.name,n.currentMeshId=w}n.currentMesh.renderable=!0,d.computeWorldVerticesOld(n,n.currentMesh.vertices),n.currentMesh.color?m=n.currentMesh.color:(N[0]=a[0]*n.color.r*b.r,N[1]=a[1]*n.color.g*b.g,N[2]=a[2]*n.color.b*b.b,n.currentMesh.tint=W.rgb2hex(N)),n.currentMesh.blendMode=n.blendMode,n.hackRegion||this.setMeshRegion(d,n.currentMesh,f);break;case T.Clipping:n.currentGraphics||(this.createGraphics(n,d),p.addChild(n.clippingContainer),p.addChild(n.currentGraphics)),this.updateGraphics(n,d),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,m){let y=n.color.r*b.r,w=n.color.g*b.g,x=n.color.b*b.b;m.setLight(a[0]*y+o[0]*(1-y),a[1]*w+o[1]*(1-w),a[2]*x+o[2]*(1-x)),n.darkColor?(y=n.darkColor.r,w=n.darkColor.g,x=n.darkColor.b):(y=0,w=0,x=0),m.setDark(a[0]*y+o[0]*(1-y),a[1]*w+o[1]*(1-w),a[2]*x+o[2]*(1-x))}p.alpha=n.color.a}const c=this.skeleton.drawOrder;let l=null,u=null;for(let h=0,g=c.length;h<g;h++){const n=i[c[h].data.index],d=this.slotContainers[c[h].data.index];if(u||d.parent!==null&&d.parent!==this&&(d.parent.removeChild(d),d.parent=this),n.currentGraphics&&n.getAttachment())u=n.clippingContainer,l=n.getAttachment(),u.children.length=0,this.children[h]=d,l.endSlot===n.data&&(l.endSlot=null);else if(u){let p=this.tempClipContainers[h];p||(p=this.tempClipContainers[h]=this.newContainer(),p.visible=!1),this.children[h]=p,d.parent=null,u.addChild(d),l.endSlot==n.data&&(u.renderable=!0,u=null,l=null)}else this.children[h]=d}(e=this._debug)==null||e.renderDebug(this)}setSpriteRegion(r,e,t){e.attachment===r&&e.region===t||(e.region=t,e.attachment=r,e.texture=t.texture,e.rotation=r.rotation*v.degRad,e.position.x=r.x,e.position.y=r.y,e.alpha=r.color.a,t.size?(e.scale.x=t.size.width/t.originalWidth,e.scale.y=-t.size.height/t.originalHeight):(e.scale.x=r.scaleX*r.width/t.originalWidth,e.scale.y=-r.scaleY*r.height/t.originalHeight))}setMeshRegion(r,e,t){e.attachment===r&&e.region===t||(e.region=t,e.attachment=r,e.texture=t.texture,t.texture.updateUvs(),e.uvBuffer.update(r.regionUVs))}autoUpdateTransform(){if(q.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const r=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(r)}else this.lastTime=0;D.prototype.updateTransform.call(this)}createSprite(r,e,t){let i=e.region;r.hackAttachment===e&&(i=r.hackRegion);const s=i?i.texture:null,a=this.newSprite(s);return a.anchor.set(.5),i&&this.setSpriteRegion(e,a,e.region),r.sprites=r.sprites||{},r.sprites[t]=a,a}createMesh(r,e){let t=e.region;r.hackAttachment===e&&(t=r.hackRegion,r.hackAttachment=null,r.hackRegion=null);const i=this.newMesh(t?t.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),ge.TRIANGLES);return typeof i._canvasPadding!="undefined"&&(i._canvasPadding=1.5),i.alpha=e.color.a,i.region=e.region,t&&this.setMeshRegion(e,i,t),r.meshes=r.meshes||{},r.meshes[e.id]=i,i}createGraphics(r,e){const t=this.newGraphics(),i=new pe([]);return t.clear(),t.beginFill(16777215,1),t.drawPolygon(i),t.renderable=!1,r.currentGraphics=t,r.clippingContainer=this.newContainer(),r.clippingContainer.mask=r.currentGraphics,t}updateGraphics(r,e){const t=r.currentGraphics.geometry,i=t.graphicsData[0].shape.points,s=e.worldVerticesLength;i.length=s,e.computeWorldVertices(r,0,s,i,0,2),t.invalidate()}hackTextureBySlotIndex(r,e=null,t=null){const i=this.skeleton.slots[r];if(!i)return!1;const s=i.getAttachment();let a=s.region;return e?(a=new U,a.texture=e,a.size=t,i.hackRegion=a,i.hackAttachment=s):(i.hackRegion=null,i.hackAttachment=null),i.currentSprite?this.setSpriteRegion(s,i.currentSprite,a):i.currentMesh&&this.setMeshRegion(s,i.currentMesh,a),!0}hackTextureBySlotName(r,e=null,t=null){const i=this.skeleton.findSlotIndex(r);return i==-1?!1:this.hackTextureBySlotIndex(i,e,t)}hackTextureAttachment(r,e,t,i=null){const s=this.skeleton.findSlotIndex(r),a=this.skeleton.getAttachmentByName(r,e);a.region.texture=t;const o=this.skeleton.slots[s];if(!o)return!1;const c=o.getAttachment();if(e===c.name){let l=a.region;return t?(l=new U,l.texture=t,l.size=i,o.hackRegion=l,o.hackAttachment=c):(o.hackRegion=null,o.hackAttachment=null),o.currentSprite&&o.currentSprite.region!=l?(this.setSpriteRegion(c,o.currentSprite,l),o.currentSprite.region=l):o.currentMesh&&o.currentMesh.region!=l&&this.setMeshRegion(c,o.currentMesh,l),!0}return!1}newContainer(){return new D}newSprite(r){return new ne(r)}newGraphics(){return new I}newMesh(r,e,t,i,s){return new ae(r,e,t,i,s)}transformHack(){return 1}hackAttachmentGroups(r,e,t){if(!r)return;const i=[],s=[];for(let a=0,o=this.skeleton.slots.length;a<o;a++){const c=this.skeleton.slots[a],l=c.currentSpriteName||c.currentMeshName||"",u=c.currentSprite||c.currentMesh;l.endsWith(r)?(u.parentGroup=e,s.push(u)):t&&u&&(u.parentGroup=t,i.push(u))}return[i,s]}destroy(r){this.debug=null;for(let e=0,t=this.skeleton.slots.length;e<t;e++){const i=this.skeleton.slots[e];for(const s in i.meshes)i.meshes[s].destroy(r);i.meshes=null;for(const s in i.sprites)i.sprites[s].destroy(r);i.sprites=null}for(let e=0,t=this.slotContainers.length;e<t;e++)this.slotContainers[e].destroy(r);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(r)}};let j=oe;j.clippingPolygon=[],Object.defineProperty(j.prototype,"visible",{get(){return this._visible},set(r){r!==this._visible&&(this._visible=r,r&&(this.lastTime=0))}});class Le{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(e){this.registeredSpines.has(e)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",e);const t={parentDebugContainer:new D,bones:new D,skeletonXY:new I,regionAttachmentsShape:new I,meshTrianglesLine:new I,meshHullLine:new I,clippingPolygon:new I,boundingBoxesRect:new I,boundingBoxesCircle:new I,boundingBoxesPolygon:new I,pathsCurve:new I,pathsLine:new I};t.parentDebugContainer.addChild(t.bones),t.parentDebugContainer.addChild(t.skeletonXY),t.parentDebugContainer.addChild(t.regionAttachmentsShape),t.parentDebugContainer.addChild(t.meshTrianglesLine),t.parentDebugContainer.addChild(t.meshHullLine),t.parentDebugContainer.addChild(t.clippingPolygon),t.parentDebugContainer.addChild(t.boundingBoxesRect),t.parentDebugContainer.addChild(t.boundingBoxesCircle),t.parentDebugContainer.addChild(t.boundingBoxesPolygon),t.parentDebugContainer.addChild(t.pathsCurve),t.parentDebugContainer.addChild(t.pathsLine),e.addChild(t.parentDebugContainer),this.registeredSpines.set(e,t)}renderDebug(e){this.registeredSpines.has(e)||this.registerSpine(e);const t=this.registeredSpines.get(e);t.skeletonXY.clear(),t.regionAttachmentsShape.clear(),t.meshTrianglesLine.clear(),t.meshHullLine.clear(),t.clippingPolygon.clear(),t.boundingBoxesRect.clear(),t.boundingBoxesCircle.clear(),t.boundingBoxesPolygon.clear(),t.pathsCurve.clear(),t.pathsLine.clear();for(let a=t.bones.children.length;a>0;a--)t.bones.children[a-1].destroy({children:!0,texture:!0,baseTexture:!0});const i=e.scale.x||e.scale.y||1,s=this.lineWidth/i;this.drawBones&&this.drawBonesFunc(e,t,s,i),this.drawPaths&&this.drawPathsFunc(e,t,s),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(e,t,s),this.drawClipping&&this.drawClippingFunc(e,t,s),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(e,t,s),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(e,t,s)}drawBonesFunc(e,t,i,s){const a=e.skeleton,o=a.x,c=a.y,l=a.bones;t.skeletonXY.lineStyle(i,this.skeletonXYColor,1);for(let h=0,g=l.length;h<g;h++){const n=l[h],d=n.data.length,p=o+n.matrix.tx,m=c+n.matrix.ty,f=o+d*n.matrix.a+n.matrix.tx,b=c+d*n.matrix.b+n.matrix.ty;if(n.data.name==="root"||n.data.parent===null)continue;const y=Math.abs(p-f),w=Math.abs(m-b),x=Math.pow(y,2),S=w,Y=Math.pow(w,2),M=Math.sqrt(x+Y),le=Math.pow(M,2),_=Math.PI/180,O=Math.acos((le+Y-x)/(2*S*M))||0;if(M===0)continue;const A=new I;t.bones.addChild(A);const k=M/50/s;A.beginFill(this.bonesColor,1),A.drawPolygon(0,0,0-k,M-k*3,0,M-k,0+k,M-k*3),A.endFill(),A.x=p,A.y=m,A.pivot.y=M;let P=0;p<f&&m<b?P=-O+180*_:p>f&&m<b?P=180*_+O:p>f&&m>b?P=-O:p<f&&m>b?P=O:m===b&&p<f?P=90*_:m===b&&p>f?P=-90*_:p===f&&m<b?P=180*_:p===f&&m>b&&(P=0),A.rotation=P,A.lineStyle(i+k/2.4,this.bonesColor,1),A.beginFill(0,.6),A.drawCircle(0,M,k*1.2),A.endFill()}const u=i*3;t.skeletonXY.moveTo(o-u,c-u),t.skeletonXY.lineTo(o+u,c+u),t.skeletonXY.moveTo(o+u,c-u),t.skeletonXY.lineTo(o-u,c+u)}drawRegionAttachmentsFunc(e,t,i){const s=e.skeleton.slots;t.regionAttachmentsShape.lineStyle(i,this.regionAttachmentsColor,1);for(let a=0,o=s.length;a<o;a++){const c=s[a],l=c.getAttachment();if(l==null||l.type!==T.Region)continue;const u=l,h=new Float32Array(8);u.updateOffset&&u.updateOffset(),u.computeWorldVertices(c,h,0,2),t.regionAttachmentsShape.drawPolygon(Array.from(h.slice(0,8)))}}drawMeshHullAndMeshTriangles(e,t,i){const s=e.skeleton.slots;t.meshHullLine.lineStyle(i,this.meshHullColor,1),t.meshTrianglesLine.lineStyle(i,this.meshTrianglesColor,1);for(let a=0,o=s.length;a<o;a++){const c=s[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Mesh)continue;const u=l,h=new Float32Array(u.worldVerticesLength),g=u.triangles;let n=u.hullLength;if(u.computeWorldVertices(c,0,u.worldVerticesLength,h,0,2),this.drawMeshTriangles)for(let d=0,p=g.length;d<p;d+=3){const m=g[d]*2,f=g[d+1]*2,b=g[d+2]*2;t.meshTrianglesLine.moveTo(h[m],h[m+1]),t.meshTrianglesLine.lineTo(h[f],h[f+1]),t.meshTrianglesLine.lineTo(h[b],h[b+1])}if(this.drawMeshHull&&n>0){n=(n>>1)*2;let d=h[n-2],p=h[n-1];for(let m=0,f=n;m<f;m+=2){const b=h[m],y=h[m+1];t.meshHullLine.moveTo(b,y),t.meshHullLine.lineTo(d,p),d=b,p=y}}}}drawClippingFunc(e,t,i){const s=e.skeleton.slots;t.clippingPolygon.lineStyle(i,this.clippingPolygonColor,1);for(let a=0,o=s.length;a<o;a++){const c=s[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Clipping)continue;const u=l,h=u.worldVerticesLength,g=new Float32Array(h);u.computeWorldVertices(c,0,h,g,0,2),t.clippingPolygon.drawPolygon(Array.from(g))}}drawBoundingBoxesFunc(e,t,i){t.boundingBoxesRect.lineStyle(i,this.boundingBoxesRectColor,5);const s=new se;s.update(e.skeleton,!0),t.boundingBoxesRect.drawRect(s.minX,s.minY,s.getWidth(),s.getHeight());const a=s.polygons,o=(c,l,u)=>{if(t.boundingBoxesPolygon.lineStyle(i,this.boundingBoxesPolygonColor,1),t.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),u<3)throw new Error("Polygon must contain at least 3 vertices");const h=[],g=i*2;for(let n=0,d=c.length;n<d;n+=2){const p=c[n],m=c[n+1];t.boundingBoxesCircle.lineStyle(0),t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),t.boundingBoxesCircle.drawCircle(p,m,g),t.boundingBoxesCircle.endFill(),h.push(p,m)}t.boundingBoxesPolygon.drawPolygon(h),t.boundingBoxesPolygon.endFill()};for(let c=0,l=a.length;c<l;c++){const u=a[c];o(u,0,u.length)}}drawPathsFunc(e,t,i){const s=e.skeleton.slots;t.pathsCurve.lineStyle(i,this.pathsCurveColor,1),t.pathsLine.lineStyle(i,this.pathsLineColor,1);for(let a=0,o=s.length;a<o;a++){const c=s[a];if(!c.bone.active)continue;const l=c.getAttachment();if(l==null||l.type!==T.Path)continue;const u=l;let h=u.worldVerticesLength;const g=new Float32Array(h);u.computeWorldVertices(c,0,h,g,0,2);let n=g[2],d=g[3],p=0,m=0;if(u.closed){const f=g[0],b=g[1],y=g[h-2],w=g[h-1];p=g[h-4],m=g[h-3],t.pathsCurve.moveTo(n,d),t.pathsCurve.bezierCurveTo(f,b,y,w,p,m),t.pathsLine.moveTo(n,d),t.pathsLine.lineTo(f,b),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(y,w)}h-=4;for(let f=4;f<h;f+=6){const b=g[f],y=g[f+1],w=g[f+2],x=g[f+3];p=g[f+4],m=g[f+5],t.pathsCurve.moveTo(n,d),t.pathsCurve.bezierCurveTo(b,y,w,x,p,m),t.pathsLine.moveTo(n,d),t.pathsLine.lineTo(b,y),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(w,x),n=p,d=m}}}unregisterSpine(e){this.registeredSpines.has(e)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",e),this.registeredSpines.get(e).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(e)}}export{T as AttachmentType,be as BinaryInput,E as Color,Ae as DebugUtils,Se as IntSet,te as Interpolation,v as MathUtils,K as MixBlend,J as MixDirection,ie as Pool,Q as PositionMode,re as Pow,Te as PowOut,Z as RotateMode,se as SkeletonBoundsBase,j as SpineBase,Le as SpineDebugRenderer,ae as SpineMesh,ne as SpineSprite,Me as StringSet,ye as TextureAtlas,z as TextureAtlasPage,$ as TextureAtlasRegion,C as TextureFilter,U as TextureRegion,R as TextureWrap,Re as TimeKeeper,ee as TransformMode,X as Utils,Ie as Vector2,Pe as WindowedMean,G as filterFromString,q as settings,we as wrapFromString};
//# sourceMappingURL=base.mjs.map
