{"version":3,"file":"base.mjs","sources":["../src/core/AttachmentType.ts","../src/core/BinaryInput.ts","../src/core/IAnimation.ts","../src/core/IConstraint.ts","../src/core/ISkeleton.ts","../src/core/TextureRegion.ts","../src/core/TextureAtlas.ts","../src/core/Utils.ts","../src/core/SkeletonBoundsBase.ts","../src/settings.ts","../src/SpineBase.ts","../src/SpineDebugRenderer.ts"],"sourcesContent":["/**\n * @public\n */\nexport enum AttachmentType {\n    Region,\n    BoundingBox,\n    Mesh,\n    LinkedMesh,\n    Path,\n    Point,\n    Clipping,\n}\n","/**\n * @public\n */\nexport class BinaryInput {\n    constructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {}\n\n    readByte(): number {\n        return this.buffer.getInt8(this.index++);\n    }\n\n    readUnsignedByte(): number {\n        return this.buffer.getUint8(this.index++);\n    }\n\n    readShort(): number {\n        const value = this.buffer.getInt16(this.index);\n\n        this.index += 2;\n\n        return value;\n    }\n\n    readInt32(): number {\n        const value = this.buffer.getInt32(this.index);\n\n        this.index += 4;\n\n        return value;\n    }\n\n    readInt(optimizePositive: boolean) {\n        let b = this.readByte();\n        let result = b & 0x7f;\n\n        if ((b & 0x80) != 0) {\n            b = this.readByte();\n            result |= (b & 0x7f) << 7;\n            if ((b & 0x80) != 0) {\n                b = this.readByte();\n                result |= (b & 0x7f) << 14;\n                if ((b & 0x80) != 0) {\n                    b = this.readByte();\n                    result |= (b & 0x7f) << 21;\n                    if ((b & 0x80) != 0) {\n                        b = this.readByte();\n                        result |= (b & 0x7f) << 28;\n                    }\n                }\n            }\n        }\n\n        return optimizePositive ? result : (result >>> 1) ^ -(result & 1);\n    }\n\n    readStringRef(): string | null {\n        const index = this.readInt(true);\n\n        return index == 0 ? null : this.strings[index - 1];\n    }\n\n    readString(): string | null {\n        let byteCount = this.readInt(true);\n\n        switch (byteCount) {\n            case 0:\n                return null;\n            case 1:\n                return '';\n        }\n        byteCount--;\n        let chars = '';\n\n        for (let i = 0; i < byteCount; ) {\n            const b = this.readUnsignedByte();\n\n            switch (b >> 4) {\n                case 12:\n                case 13:\n                    chars += String.fromCharCode(((b & 0x1f) << 6) | (this.readByte() & 0x3f));\n                    i += 2;\n                    break;\n                case 14:\n                    chars += String.fromCharCode(((b & 0x0f) << 12) | ((this.readByte() & 0x3f) << 6) | (this.readByte() & 0x3f));\n                    i += 3;\n                    break;\n                default:\n                    chars += String.fromCharCode(b);\n                    i++;\n            }\n        }\n\n        return chars;\n    }\n\n    readFloat(): number {\n        const value = this.buffer.getFloat32(this.index);\n\n        this.index += 4;\n\n        return value;\n    }\n\n    readBoolean(): boolean {\n        return this.readByte() != 0;\n    }\n}\n","import type { ISkeleton, ISkeletonData } from './ISkeleton';\nimport type { Map } from './Utils';\n\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixBlend {\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n     * value is set. */\n    setup,\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\n     * AttachmentTimeline, use the setup value before the first key.\n     *\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\n    first,\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n     * kept until the first key).\n     *\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n    replace,\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n     * (the current value is kept until the first key).\n     *\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n     * the property values will increase continually. */\n    add,\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixDirection {\n    mixIn,\n    mixOut,\n}\n\n/**\n * @public\n */\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\n    name: string;\n    timelines: Timeline[];\n    duration: number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\n    data: AnimationStateData;\n    tracks: ITrackEntry[];\n    listeners: IAnimationStateListener[];\n    timeScale: number;\n\n    update(dt: number): void;\n    apply(skeleton: ISkeleton): boolean;\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\n    setEmptyAnimation(trackIndex: number, mixDuration: number): ITrackEntry;\n    setEmptyAnimations(mixDuration: number): void;\n    hasAnimation(animationName: string): boolean;\n    addListener(listener: IAnimationStateListener): void;\n    removeListener(listener: IAnimationStateListener): void;\n    clearListeners(): void;\n    clearTracks(): void;\n    clearTrack(index: number): void;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number>;\n    defaultMix: number;\n    setMix(fromName: string, toName: string, duration: number): void;\n    setMixWith(from: Animation, to: Animation, duration: number): void;\n    getMix(from: Animation, to: Animation): number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateListener {\n    start?(entry: ITrackEntry): void;\n    interrupt?(entry: ITrackEntry): void;\n    end?(entry: ITrackEntry): void;\n    dispose?(entry: ITrackEntry): void;\n    complete?(entry: ITrackEntry): void;\n    event?(entry: ITrackEntry, event: IEvent): void;\n}\n\n/**\n * @public\n */\nexport interface ITimeline {}\n\n/**\n * @public\n */\nexport interface ITrackEntry {\n    trackIndex: number;\n    loop: boolean;\n    animationEnd: number;\n    listener: IAnimationStateListener;\n\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n}\n\n/**\n * @public\n */\nexport interface IEventData {\n    name: string;\n}\n\n/**\n * @public\n */\nexport interface IEvent {\n    time: number;\n    data: IEventData;\n}\n","// These enums were moved from PathConstraintData.ts of spine 3.7, 3.8 and 4.0\n\n/** Controls how the first bone is positioned along the path.\n *\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\n * @public\n * */\nexport enum PositionMode {\n    Fixed,\n    Percent,\n}\n\n/** Controls how bones are rotated, translated, and scaled to match the path.\n *\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\n * @public\n * */\nexport enum RotateMode {\n    Tangent,\n    Chain,\n    ChainScale,\n}\n\n/**\n * @public\n */\nexport interface IConstraintData {\n    name: string;\n    order: number;\n}\n\n/**\n * @public\n */\nexport interface IIkConstraint {\n    data: IIkConstraintData;\n    /** -1 | 0 | 1 */\n    bendDirection: number;\n    compress: boolean;\n    stretch: boolean;\n\n    /** A percentage (0-1) */\n    mix: number;\n}\n\n/**\n * @public\n */\nexport interface IIkConstraintData extends IConstraintData {\n    /** -1 | 0 | 1 */\n    bendDirection: number;\n    compress: boolean;\n    stretch: boolean;\n    uniform: boolean;\n\n    /** A percentage (0-1) */\n    mix: number;\n}\n\n/**\n * @public\n */\nexport interface IPathConstraint {\n    data: IPathConstraintData;\n    position: number;\n    spacing: number;\n\n    spaces: number[];\n    positions: number[];\n    world: number[];\n    curves: number[];\n    lengths: number[];\n    segments: number[];\n}\n\n/**\n * @public\n */\nexport interface IPathConstraintData extends IConstraintData {\n    positionMode: PositionMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n}\n\n/**\n * @public\n */\nexport interface ITransformConstraint {\n    data: ITransformConstraintData;\n}\n\n/**\n * @public\n */\nexport interface ITransformConstraintData extends IConstraintData {\n    offsetRotation: number;\n    offsetX: number;\n    offsetY: number;\n    offsetScaleX: number;\n    offsetScaleY: number;\n    offsetShearY: number;\n    relative: boolean;\n    local: boolean;\n}\n","import type { AttachmentType } from './AttachmentType';\nimport type { IAnimation, IEventData } from './IAnimation';\nimport type { IIkConstraintData, IPathConstraintData, ITransformConstraintData } from './IConstraint';\nimport type { Color, Vector2, Map } from './Utils';\nimport type { TextureRegion } from './TextureRegion';\nimport type { BLEND_MODES, Matrix } from '@pixi/core';\n\n// This enum was moved from BoneData.ts of spine 3.7, 3.8 and 4.0\n\n/** Determines how a bone inherits world transforms from parent bones.\n * @public\n * */\nexport enum TransformMode {\n    Normal,\n    OnlyTranslation,\n    NoRotationOrReflection,\n    NoScale,\n    NoScaleOrReflection,\n}\n\n/**\n * @public\n */\nexport interface IBone {\n    data: IBoneData;\n    matrix: Matrix;\n    active: boolean;\n}\n\n/**\n * @public\n */\nexport interface ISkin {\n    name: string;\n    attachments: Array<Map<IAttachment>>;\n\n    getAttachment(slotIndex: number, name: string): IAttachment | null;\n}\n\n/**\n * @public\n */\nexport interface IAttachment {\n    name: string;\n    type: AttachmentType;\n    readonly sequence?: ISequence;\n}\n\n/**\n * @public\n */\nexport interface IHasTextureRegion {\n    /** The name used to find the {@link #region()}. */\n    path: string;\n\n    /** The region used to draw the attachment. After setting the region or if the region's properties are changed,\n     * {@link #updateRegion()} must be called. */\n    region: TextureRegion | null;\n\n    /** Updates any values the attachment calculates using the {@link #getRegion()}. Must be called after setting the\n     * {@link #getRegion()} or if the region's properties are changed. */\n    // updateRegion (): void;\n\n    /** The color to tint the attachment. */\n    color: Color;\n\n    readonly sequence: ISequence | null;\n}\n\n/**\n * @public\n */\nexport interface ISequence {\n    id: number;\n    regions: TextureRegion[];\n    apply(slot: ISlot, attachment: IHasTextureRegion): void;\n}\n\n/**\n * @public\n */\nexport interface IVertexAttachment<Slot extends ISlot = ISlot> extends IAttachment {\n    id: number;\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>): void;\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number): void;\n    worldVerticesLength: number;\n}\n\n/**\n * @public\n */\nexport interface IClippingAttachment extends IVertexAttachment {\n    endSlot?: ISlotData;\n}\n\n/**\n * @public\n */\nexport interface IRegionAttachment extends IAttachment {\n    region: TextureRegion;\n    color: Color;\n    x;\n    y;\n    scaleX;\n    scaleY;\n    rotation;\n    width;\n    height: number;\n}\n\n/**\n * @public\n */\nexport interface IMeshAttachment extends IVertexAttachment {\n    region: TextureRegion;\n    color: Color;\n    regionUVs: Float32Array;\n    triangles: number[];\n    hullLength: number;\n}\n\n/**\n * @public\n */\nexport interface ISlotData {\n    index: number;\n    name: string;\n    boneData: IBoneData;\n    color: Color;\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * @public\n */\nexport interface IBoneData {\n    index: number;\n    name: string;\n    parent: IBoneData;\n    length: number;\n    x: number;\n    y: number;\n    rotation: number;\n    scaleX: number;\n    scaleY: number;\n    shearX: number;\n    shearY: number;\n    transformMode: TransformMode;\n}\n\n/**\n * @public\n */\nexport interface ISlot {\n    getAttachment(): IAttachment;\n    data: ISlotData;\n    color: Color;\n    darkColor: Color;\n    blendMode: number;\n    bone: IBone;\n\n    sprites?: any;\n    currentSprite?: any;\n    currentSpriteName?: string;\n\n    meshes?: any;\n    currentMesh?: any;\n    currentMeshName?: string;\n    currentMeshId?: number;\n\n    currentGraphics?: any;\n    clippingContainer?: any;\n\n    hackRegion?: TextureRegion;\n    hackAttachment?: IAttachment;\n}\n\n/**\n * @public\n */\nexport interface ISkeleton<SkeletonData extends ISkeletonData = ISkeletonData, Bone extends IBone = IBone, Slot extends ISlot = ISlot, Skin extends ISkin = ISkin> {\n    bones: Bone[];\n    slots: Slot[];\n    drawOrder: Slot[];\n    skin: Skin;\n    data: SkeletonData;\n    x: number; // added for debug purposes\n    y: number; // added for debug purposes\n    updateWorldTransform(): void;\n    setToSetupPose(): void;\n    findSlotIndex(slotName: string): number;\n    getAttachmentByName(slotName: string, attachmentName: string): IAttachment;\n\n    setBonesToSetupPose(): void;\n    setSlotsToSetupPose(): void;\n    findBone(boneName: string): Bone;\n    findSlot(slotName: string): Slot;\n    findBoneIndex(boneName: string): number;\n    findSlotIndex(slotName: string): number;\n    setSkinByName(skinName: string): void;\n    setAttachment(slotName: string, attachmentName: string): void;\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number>): void;\n}\n\n/**\n * @public\n */\nexport interface ISkeletonParser {\n    scale: number;\n}\n\n/**\n * @public\n */\nexport interface ISkeletonData<\n    BoneData extends IBoneData = IBoneData,\n    SlotData extends ISlotData = ISlotData,\n    Skin extends ISkin = ISkin,\n    Animation extends IAnimation = IAnimation,\n    EventData extends IEventData = IEventData,\n    IkConstraintData extends IIkConstraintData = IIkConstraintData,\n    TransformConstraintData extends ITransformConstraintData = ITransformConstraintData,\n    PathConstraintData extends IPathConstraintData = IPathConstraintData\n> {\n    name: string;\n    bones: BoneData[];\n    slots: SlotData[];\n    skins: Skin[];\n    defaultSkin: Skin;\n    events: EventData[];\n    animations: Animation[];\n    version: string;\n    hash: string;\n    width: number;\n    height: number;\n    ikConstraints: IkConstraintData[];\n    transformConstraints: TransformConstraintData[];\n    pathConstraints: PathConstraintData[];\n\n    findBone(boneName: string): BoneData | null;\n    findBoneIndex(boneName: string): number;\n    findSlot(slotName: string): SlotData | null;\n    findSlotIndex(slotName: string): number;\n    findSkin(skinName: string): Skin | null;\n\n    findEvent(eventDataName: string): EventData | null;\n    findAnimation(animationName: string): Animation | null;\n    findIkConstraint(constraintName: string): IkConstraintData | null;\n    findTransformConstraint(constraintName: string): TransformConstraintData | null;\n    findPathConstraint(constraintName: string): PathConstraintData | null;\n}\n","import type { Texture, Rectangle } from '@pixi/core';\n\n/**\n * @public\n */\nexport function filterFromString(text: string): TextureFilter {\n    switch (text.toLowerCase()) {\n        case 'nearest':\n            return TextureFilter.Nearest;\n        case 'linear':\n            return TextureFilter.Linear;\n        case 'mipmap':\n            return TextureFilter.MipMap;\n        case 'mipmapnearestnearest':\n            return TextureFilter.MipMapNearestNearest;\n        case 'mipmaplinearnearest':\n            return TextureFilter.MipMapLinearNearest;\n        case 'mipmapnearestlinear':\n            return TextureFilter.MipMapNearestLinear;\n        case 'mipmaplinearlinear':\n            return TextureFilter.MipMapLinearLinear;\n        default:\n            throw new Error(`Unknown texture filter ${text}`);\n    }\n}\n\n/**\n * @public\n */\nexport function wrapFromString(text: string): TextureWrap {\n    switch (text.toLowerCase()) {\n        case 'mirroredtepeat':\n            return TextureWrap.MirroredRepeat;\n        case 'clamptoedge':\n            return TextureWrap.ClampToEdge;\n        case 'repeat':\n            return TextureWrap.Repeat;\n        default:\n            throw new Error(`Unknown texture wrap ${text}`);\n    }\n}\n\n/**\n * @public\n */\nexport enum TextureFilter {\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\n    Linear = 9729, // WebGLRenderingContext.LINEAR\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n    MipMapLinearLinear = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\n/**\n * @public\n */\nexport enum TextureWrap {\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n    Repeat = 10497, // WebGLRenderingContext.REPEAT\n}\n\n/**\n * @public\n */\nexport class TextureRegion {\n    texture: Texture;\n\n    // thats for overrides\n    size: Rectangle = null;\n\n    names: string[] = null;\n    values: number[][] = null;\n\n    renderObject: any = null;\n\n    get width(): number {\n        const tex = this.texture;\n\n        if (tex.trim) {\n            return tex.trim.width;\n        }\n\n        return tex.orig.width;\n    }\n\n    get height(): number {\n        const tex = this.texture;\n\n        if (tex.trim) {\n            return tex.trim.height;\n        }\n\n        return tex.orig.height;\n    }\n\n    get u(): number {\n        return (this.texture as any)._uvs.x0;\n    }\n\n    get v(): number {\n        return (this.texture as any)._uvs.y0;\n    }\n\n    get u2(): number {\n        return (this.texture as any)._uvs.x2;\n    }\n\n    get v2(): number {\n        return (this.texture as any)._uvs.y2;\n    }\n\n    get offsetX(): number {\n        const tex = this.texture;\n\n        return tex.trim ? tex.trim.x : 0;\n    }\n\n    get offsetY(): number {\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n        return this.spineOffsetY;\n    }\n\n    get pixiOffsetY(): number {\n        const tex = this.texture;\n\n        return tex.trim ? tex.trim.y : 0;\n    }\n\n    get spineOffsetY(): number {\n        const tex = this.texture;\n\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n    }\n\n    get originalWidth(): number {\n        return this.texture.orig.width;\n    }\n\n    get originalHeight(): number {\n        return this.texture.orig.height;\n    }\n\n    get x(): number {\n        return this.texture.frame.x;\n    }\n\n    get y(): number {\n        return this.texture.frame.y;\n    }\n\n    get rotate(): boolean {\n        return this.texture.rotate !== 0;\n    }\n\n    get degrees() {\n        return (360 - this.texture.rotate * 45) % 360;\n    }\n}\n","import { Texture, SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle } from '@pixi/core';\nimport { TextureRegion, TextureWrap, TextureFilter, filterFromString } from './TextureRegion';\nimport type { Map, Disposable } from './Utils';\nimport type { BaseTexture } from '@pixi/core';\n\nclass RegionFields {\n    x = 0;\n    y = 0;\n    width = 0;\n    height = 0;\n    offsetX = 0;\n    offsetY = 0;\n    originalWidth = 0;\n    originalHeight = 0;\n    rotate = 0;\n    index = 0;\n}\n/**\n * @public\n */\nexport class TextureAtlas implements Disposable {\n    pages = new Array<TextureAtlasPage>();\n    regions = new Array<TextureAtlasRegion>();\n\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\n        if (atlasText) {\n            this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n    }\n\n    addTexture(name: string, texture: Texture) {\n        const pages = this.pages;\n        let page: TextureAtlasPage = null;\n\n        for (let i = 0; i < pages.length; i++) {\n            if (pages[i].baseTexture === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new TextureAtlasPage();\n            page.name = 'texturePage';\n            const baseTexture = texture.baseTexture;\n\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.baseTexture = baseTexture;\n            // those fields are not relevant in Pixi\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\n            page.uWrap = TextureWrap.ClampToEdge;\n            page.vWrap = TextureWrap.ClampToEdge;\n            pages.push(page);\n        }\n        const region = new TextureAtlasRegion();\n\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n\n        return region;\n    }\n\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\n        for (const key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    }\n\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        return this.load(atlasText, textureLoader, callback);\n    }\n\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (textureLoader == null) {\n            throw new Error('textureLoader cannot be null.');\n        }\n\n        const reader = new TextureAtlasReader(atlasText);\n        const entry = new Array<string>(4);\n        let page: TextureAtlasPage = null;\n        const pageFields: Map<Function> = {};\n        let region: RegionFields = null;\n\n        pageFields.size = () => {\n            page.width = parseInt(entry[1]);\n            page.height = parseInt(entry[2]);\n        };\n        pageFields.format = () => {\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\n        };\n        pageFields.filter = () => {\n            page.minFilter = filterFromString(entry[1]);\n            page.magFilter = filterFromString(entry[2]);\n        };\n        pageFields.repeat = () => {\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\n        };\n        pageFields.pma = () => {\n            page.pma = entry[1] == 'true';\n        };\n\n        const regionFields: Map<Function> = {};\n\n        regionFields.xy = () => {\n            // Deprecated, use bounds.\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n        };\n        regionFields.size = () => {\n            // Deprecated, use bounds.\n            region.width = parseInt(entry[1]);\n            region.height = parseInt(entry[2]);\n        };\n        regionFields.bounds = () => {\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n            region.width = parseInt(entry[3]);\n            region.height = parseInt(entry[4]);\n        };\n        regionFields.offset = () => {\n            // Deprecated, use offsets.\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n        };\n        regionFields.orig = () => {\n            // Deprecated, use offsets.\n            region.originalWidth = parseInt(entry[1]);\n            region.originalHeight = parseInt(entry[2]);\n        };\n        regionFields.offsets = () => {\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n            region.originalWidth = parseInt(entry[3]);\n            region.originalHeight = parseInt(entry[4]);\n        };\n        regionFields.rotate = () => {\n            const rotateValue = entry[1];\n            let rotate = 0;\n\n            if (rotateValue.toLocaleLowerCase() == 'true') {\n                rotate = 6;\n            } else if (rotateValue.toLocaleLowerCase() == 'false') {\n                rotate = 0;\n            } else {\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\n            }\n            region.rotate = rotate;\n        };\n        regionFields.index = () => {\n            region.index = parseInt(entry[1]);\n        };\n\n        let line = reader.readLine();\n        // Ignore empty lines before first entry.\n\n        while (line != null && line.trim().length == 0) {\n            line = reader.readLine();\n        }\n        // Header entries.\n        while (true) {\n            if (line == null || line.trim().length == 0) break;\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n            line = reader.readLine();\n        }\n\n        const iterateParser = () => {\n            while (true) {\n                if (line == null) {\n                    return callback && callback(this);\n                }\n                if (line.trim().length == 0) {\n                    page = null;\n                    line = reader.readLine();\n                } else if (page === null) {\n                    page = new TextureAtlasPage();\n                    page.name = line.trim();\n\n                    while (true) {\n                        if (reader.readEntry(entry, (line = reader.readLine())) == 0) break;\n                        const field: Function = pageFields[entry[0]];\n\n                        if (field) field();\n                    }\n                    this.pages.push(page);\n\n                    textureLoader(page.name, (texture: BaseTexture) => {\n                        if (texture === null) {\n                            this.pages.splice(this.pages.indexOf(page), 1);\n\n                            return callback && callback(null);\n                        }\n                        page.baseTexture = texture;\n                        // TODO: set scaleMode and mipmapMode from spine\n                        if (page.pma) {\n                            texture.alphaMode = ALPHA_MODES.PMA;\n                        }\n                        if (!texture.valid) {\n                            texture.setSize(page.width, page.height);\n                        }\n                        page.setFilters();\n\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\n                                    `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`\n                                );\n                            }\n                        }\n                        iterateParser();\n                    });\n                    break;\n                } else {\n                    region = new RegionFields();\n                    const atlasRegion = new TextureAtlasRegion();\n\n                    atlasRegion.name = line;\n                    atlasRegion.page = page;\n                    let names: string[] = null;\n                    let values: number[][] = null;\n\n                    while (true) {\n                        const count = reader.readEntry(entry, (line = reader.readLine()));\n\n                        if (count == 0) break;\n                        const field: Function = regionFields[entry[0]];\n\n                        if (field) {\n                            field();\n                        } else {\n                            if (names == null) {\n                                names = [];\n                                values = [];\n                            }\n                            names.push(entry[0]);\n                            const entryValues: number[] = [];\n\n                            for (let i = 0; i < count; i++) {\n                                entryValues.push(parseInt(entry[i + 1]));\n                            }\n                            values.push(entryValues);\n                        }\n                    }\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\n                        region.originalWidth = region.width;\n                        region.originalHeight = region.height;\n                    }\n\n                    const resolution = page.baseTexture.resolution;\n\n                    region.x /= resolution;\n                    region.y /= resolution;\n                    region.width /= resolution;\n                    region.height /= resolution;\n                    region.originalWidth /= resolution;\n                    region.originalHeight /= resolution;\n                    region.offsetX /= resolution;\n                    region.offsetY /= resolution;\n\n                    const swapWH = region.rotate % 4 !== 0;\n                    const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n\n                    const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n                    const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n                    atlasRegion.index = region.index;\n                    atlasRegion.texture.updateUvs();\n\n                    this.regions.push(atlasRegion);\n                }\n            }\n        };\n\n        iterateParser();\n    }\n\n    findRegion(name: string): TextureAtlasRegion {\n        for (let i = 0; i < this.regions.length; i++) {\n            if (this.regions[i].name == name) {\n                return this.regions[i];\n            }\n        }\n\n        return null;\n    }\n\n    dispose() {\n        for (let i = 0; i < this.pages.length; i++) {\n            this.pages[i].baseTexture.dispose();\n        }\n    }\n}\n\n/**\n * @public\n */\nclass TextureAtlasReader {\n    lines: Array<string>;\n    index = 0;\n\n    constructor(text: string) {\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n    }\n\n    readLine(): string {\n        if (this.index >= this.lines.length) {\n            return null;\n        }\n\n        return this.lines[this.index++];\n    }\n\n    readEntry(entry: string[], line: string): number {\n        if (line == null) return 0;\n        line = line.trim();\n        if (line.length == 0) return 0;\n\n        const colon = line.indexOf(':');\n\n        if (colon == -1) return 0;\n        entry[0] = line.substr(0, colon).trim();\n        for (let i = 1, lastMatch = colon + 1; ; i++) {\n            const comma = line.indexOf(',', lastMatch);\n\n            if (comma == -1) {\n                entry[i] = line.substr(lastMatch).trim();\n\n                return i;\n            }\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n            lastMatch = comma + 1;\n            if (i == 4) return 4;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasPage {\n    name: string;\n    minFilter: TextureFilter = TextureFilter.Nearest;\n    magFilter: TextureFilter = TextureFilter.Nearest;\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\n    baseTexture: BaseTexture;\n    width: number;\n    height: number;\n    pma: boolean;\n\n    public setFilters() {\n        const tex = this.baseTexture;\n        const filter = this.minFilter;\n\n        if (filter == TextureFilter.Linear) {\n            tex.scaleMode = SCALE_MODES.LINEAR;\n        } else if (this.minFilter == TextureFilter.Nearest) {\n            tex.scaleMode = SCALE_MODES.NEAREST;\n        } else {\n            tex.mipmap = MIPMAP_MODES.POW2;\n            if (filter == TextureFilter.MipMapNearestNearest) {\n                tex.scaleMode = SCALE_MODES.NEAREST;\n            } else {\n                tex.scaleMode = SCALE_MODES.LINEAR;\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasRegion extends TextureRegion {\n    page: TextureAtlasPage;\n    name: string;\n    index: number;\n}\n","import type { ISkeleton } from './ISkeleton';\n\n/**\n * @public\n */\n\nexport interface Map<T> {\n    [key: string]: T;\n}\n\n/**\n * @public\n */\nexport interface StringMap<T> {\n    [key: string]: T;\n}\n\n/**\n * @public\n */\nexport class IntSet {\n    array = new Array<number>();\n\n    add(value: number): boolean {\n        const contains = this.contains(value);\n\n        this.array[value | 0] = value | 0;\n\n        return !contains;\n    }\n\n    contains(value: number) {\n        return this.array[value | 0] != undefined;\n    }\n\n    remove(value: number) {\n        this.array[value | 0] = undefined;\n    }\n\n    clear() {\n        this.array.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport class StringSet {\n    entries: StringMap<boolean> = {};\n    size = 0;\n\n    add(value: string): boolean {\n        const contains = this.entries[value];\n\n        this.entries[value] = true;\n        if (!contains) {\n            this.size++;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    addAll(values: string[]): boolean {\n        const oldSize = this.size;\n\n        for (let i = 0, n = values.length; i < n; i++) {\n            this.add(values[i]);\n        }\n\n        return oldSize != this.size;\n    }\n\n    contains(value: string) {\n        return this.entries[value];\n    }\n\n    clear() {\n        this.entries = {};\n        this.size = 0;\n    }\n}\n\n/**\n * @public\n */\nexport interface NumberArrayLike {\n    readonly length: number;\n    [n: number]: number;\n}\n\n/**\n * @public\n */\nexport interface Disposable {\n    dispose(): void;\n}\n\n/**\n * @public\n */\nexport interface Restorable {\n    restore(): void;\n}\n\n/**\n * @public\n */\nexport class Color {\n    public static WHITE = new Color(1, 1, 1, 1);\n    public static RED = new Color(1, 0, 0, 1);\n    public static GREEN = new Color(0, 1, 0, 1);\n    public static BLUE = new Color(0, 0, 1, 1);\n    public static MAGENTA = new Color(1, 0, 1, 1);\n\n    constructor(public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {}\n\n    set(r: number, g: number, b: number, a: number) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n\n        return this.clamp();\n    }\n\n    setFromColor(c: Color) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n\n        return this;\n    }\n\n    setFromString(hex: string) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n\n        return this;\n    }\n\n    add(r: number, g: number, b: number, a: number) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n\n        return this.clamp();\n    }\n\n    clamp() {\n        if (this.r < 0) this.r = 0;\n        else if (this.r > 1) this.r = 1;\n\n        if (this.g < 0) this.g = 0;\n        else if (this.g > 1) this.g = 1;\n\n        if (this.b < 0) this.b = 0;\n        else if (this.b > 1) this.b = 1;\n\n        if (this.a < 0) this.a = 0;\n        else if (this.a > 1) this.a = 1;\n\n        return this;\n    }\n\n    static rgba8888ToColor(color: Color, value: number) {\n        color.r = ((value & 0xff000000) >>> 24) / 255;\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\n        color.a = (value & 0x000000ff) / 255;\n    }\n\n    static rgb888ToColor(color: Color, value: number) {\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\n        color.b = (value & 0x000000ff) / 255;\n    }\n\n    static fromString(hex: string): Color {\n        return new Color().setFromString(hex);\n    }\n}\n\n/**\n * @public\n */\nexport class MathUtils {\n    static PI = 3.1415927;\n    static PI2 = MathUtils.PI * 2;\n    static radiansToDegrees = 180 / MathUtils.PI;\n    static radDeg = MathUtils.radiansToDegrees;\n    static degreesToRadians = MathUtils.PI / 180;\n    static degRad = MathUtils.degreesToRadians;\n\n    static clamp(value: number, min: number, max: number) {\n        if (value < min) return min;\n        if (value > max) return max;\n\n        return value;\n    }\n\n    static cosDeg(degrees: number) {\n        return Math.cos(degrees * MathUtils.degRad);\n    }\n\n    static sinDeg(degrees: number) {\n        return Math.sin(degrees * MathUtils.degRad);\n    }\n\n    static signum(value: number): number {\n        return Math.sign(value);\n    }\n\n    static toInt(x: number) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n    }\n\n    static cbrt(x: number) {\n        const y = Math.pow(Math.abs(x), 1 / 3);\n\n        return x < 0 ? -y : y;\n    }\n\n    static randomTriangular(min: number, max: number): number {\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n    }\n\n    static randomTriangularWith(min: number, max: number, mode: number): number {\n        const u = Math.random();\n        const d = max - min;\n\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n\n        return max - Math.sqrt((1 - u) * d * (max - mode));\n    }\n\n    static isPowerOfTwo(value: number) {\n        return value && (value & (value - 1)) === 0;\n    }\n}\n\n/**\n * @public\n */\nexport abstract class Interpolation {\n    protected abstract applyInternal(a: number): number;\n    apply(start: number, end: number, a: number): number {\n        return start + (end - start) * this.applyInternal(a);\n    }\n}\n\n/**\n * @public\n */\nexport class Pow extends Interpolation {\n    protected power = 2;\n\n    constructor(power: number) {\n        super();\n        this.power = power;\n    }\n\n    applyInternal(a: number): number {\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n    }\n}\n\n/**\n * @public\n */\nexport class PowOut extends Pow {\n    applyInternal(a: number): number {\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n    }\n}\n\n/**\n * @public\n */\nexport class Utils {\n    static SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== 'undefined';\n\n    static arrayCopy<T>(source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n            dest[j] = source[i];\n        }\n    }\n\n    static arrayFill<T>(array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\n        for (let i = fromIndex; i < toIndex; i++) {\n            array[i] = value;\n        }\n    }\n\n    static setArraySize<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n        const oldSize = array.length;\n\n        if (oldSize == size) return array;\n        array.length = size;\n        if (oldSize < size) {\n            for (let i = oldSize; i < size; i++) array[i] = value;\n        }\n\n        return array;\n    }\n\n    static ensureArrayCapacity<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n        if (array.length >= size) return array;\n\n        return Utils.setArraySize(array, size, value);\n    }\n\n    static newArray<T>(size: number, defaultValue: T): Array<T> {\n        const array = new Array<T>(size);\n\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\n\n        return array;\n    }\n\n    static newFloatArray(size: number): NumberArrayLike {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Float32Array(size);\n        }\n\n        const array = new Array<number>(size);\n\n        for (let i = 0; i < array.length; i++) array[i] = 0;\n\n        return array;\n    }\n\n    static newShortArray(size: number): NumberArrayLike {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Int16Array(size);\n        }\n\n        const array = new Array<number>(size);\n\n        for (let i = 0; i < array.length; i++) array[i] = 0;\n\n        return array;\n    }\n\n    static toFloatArray(array: Array<number>) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n    }\n\n    static toSinglePrecision(value: number) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n    }\n\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n    static webkit602BugfixHelper(alpha: number, blend: any) {}\n\n    static contains<T>(array: Array<T>, element: T, identity = true) {\n        for (let i = 0; i < array.length; i++) {\n            if (array[i] == element) return true;\n        }\n\n        return false;\n    }\n\n    static enumValue(type: any, name: string) {\n        return type[name[0].toUpperCase() + name.slice(1)];\n    }\n}\n\n/**\n * @public\n */\nexport class DebugUtils {\n    static logBones(skeleton: ISkeleton) {\n        for (let i = 0; i < skeleton.bones.length; i++) {\n            const bone = skeleton.bones[i];\n            const mat = bone.matrix;\n\n            console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class Pool<T> {\n    private items = new Array<T>();\n    private instantiator: () => T;\n\n    constructor(instantiator: () => T) {\n        this.instantiator = instantiator;\n    }\n\n    obtain() {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n    }\n\n    free(item: T) {\n        if ((item as any).reset) (item as any).reset();\n        this.items.push(item);\n    }\n\n    freeAll(items: ArrayLike<T>) {\n        for (let i = 0; i < items.length; i++) {\n            this.free(items[i]);\n        }\n    }\n\n    clear() {\n        this.items.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport class Vector2 {\n    constructor(public x = 0, public y = 0) {}\n\n    set(x: number, y: number): Vector2 {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    length() {\n        const x = this.x;\n        const y = this.y;\n\n        return Math.sqrt(x * x + y * y);\n    }\n\n    normalize() {\n        const len = this.length();\n\n        if (len != 0) {\n            this.x /= len;\n            this.y /= len;\n        }\n\n        return this;\n    }\n}\n\n/**\n * @public\n */\nexport class TimeKeeper {\n    maxDelta = 0.064;\n    framesPerSecond = 0;\n    delta = 0;\n    totalTime = 0;\n\n    private lastTime = Date.now() / 1000;\n    private frameCount = 0;\n    private frameTime = 0;\n\n    update() {\n        const now = Date.now() / 1000;\n\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n\n        this.frameCount++;\n        if (this.frameTime > 1) {\n            this.framesPerSecond = this.frameCount / this.frameTime;\n            this.frameTime = 0;\n            this.frameCount = 0;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport interface ArrayLike<T> {\n    length: number;\n    [n: number]: T;\n}\n\n/**\n * @public\n */\nexport class WindowedMean {\n    values: Array<number>;\n    addedValues = 0;\n    lastValue = 0;\n    mean = 0;\n    dirty = true;\n\n    constructor(windowSize = 32) {\n        this.values = new Array<number>(windowSize);\n    }\n\n    hasEnoughData() {\n        return this.addedValues >= this.values.length;\n    }\n\n    addValue(value: number) {\n        if (this.addedValues < this.values.length) this.addedValues++;\n        this.values[this.lastValue++] = value;\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n        this.dirty = true;\n    }\n\n    getMean() {\n        if (this.hasEnoughData()) {\n            if (this.dirty) {\n                let mean = 0;\n\n                for (let i = 0; i < this.values.length; i++) {\n                    mean += this.values[i];\n                }\n                this.mean = mean / this.values.length;\n                this.dirty = false;\n            }\n\n            return this.mean;\n        }\n\n        return 0;\n    }\n}\n","import { AttachmentType } from './AttachmentType';\nimport type { ISkeleton, IVertexAttachment } from './ISkeleton';\nimport { NumberArrayLike, Pool, Utils } from './Utils';\n\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBoundsBase<BoundingBoxAttachment extends IVertexAttachment> {\n    /** The left edge of the axis aligned bounding box. */\n    minX = 0;\n\n    /** The bottom edge of the axis aligned bounding box. */\n    minY = 0;\n\n    /** The right edge of the axis aligned bounding box. */\n    maxX = 0;\n\n    /** The top edge of the axis aligned bounding box. */\n    maxY = 0;\n\n    /** The visible bounding boxes. */\n    boundingBoxes = new Array<BoundingBoxAttachment>();\n\n    /** The world vertices for the bounding box polygons. */\n    polygons = new Array<NumberArrayLike>();\n\n    private polygonPool = new Pool<NumberArrayLike>(() => Utils.newFloatArray(16));\n\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n     * box's polygon.\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n     *           SkeletonBounds AABB methods will always return true. */\n    update(skeleton: ISkeleton, updateAabb: boolean) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        const boundingBoxes = this.boundingBoxes;\n        const polygons = this.polygons;\n        const polygonPool = this.polygonPool;\n        const slots = skeleton.slots;\n        const slotCount = slots.length;\n\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (let i = 0; i < slotCount; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) continue;\n            const attachment = slot.getAttachment();\n\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\n                const boundingBox = attachment as BoundingBoxAttachment;\n\n                boundingBoxes.push(boundingBox);\n\n                let polygon = polygonPool.obtain() as NumberArrayLike;\n\n                if (polygon.length != boundingBox.worldVerticesLength) {\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                }\n                polygons.push(polygon);\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n            }\n        }\n\n        if (updateAabb) {\n            this.aabbCompute();\n        } else {\n            this.minX = Number.POSITIVE_INFINITY;\n            this.minY = Number.POSITIVE_INFINITY;\n            this.maxX = Number.NEGATIVE_INFINITY;\n            this.maxY = Number.NEGATIVE_INFINITY;\n        }\n    }\n\n    aabbCompute() {\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            const polygon = polygons[i];\n            const vertices = polygon;\n\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                const x = vertices[ii];\n                const y = vertices[ii + 1];\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint(x: number, y: number) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {\n            return false;\n        }\n        const m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        let x = (minY - y1) / m + x1;\n\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n\n        return false;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton(bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    }\n\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\n    containsPoint(x: number, y: number): BoundingBoxAttachment | null {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains the point. */\n    containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        let prevIndex = nn - 2;\n        let inside = false;\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const vertexY = vertices[ii + 1];\n            const prevY = vertices[prevIndex + 1];\n\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                const vertexX = vertices[ii];\n\n                if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n\n        return inside;\n    }\n\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n     * true. */\n    intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains any part of the line segment. */\n    intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        const width12 = x1 - x2;\n        const height12 = y1 - y2;\n        const det1 = x1 * y2 - y1 * x2;\n        let x3 = vertices[nn - 2];\n        let y3 = vertices[nn - 1];\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const x4 = vertices[ii];\n            const y4 = vertices[ii + 1];\n            const det2 = x3 * y4 - y3 * x4;\n            const width34 = x3 - x4;\n            const height34 = y3 - y4;\n            const det3 = width12 * height34 - height12 * width34;\n            const x = (det1 * width34 - width12 * det2) / det3;\n\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                const y = (det1 * height34 - height12 * det2) / det3;\n\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n\n        return false;\n    }\n\n    /** Returns the polygon for the specified bounding box, or null. */\n    getPolygon(boundingBox: BoundingBoxAttachment) {\n        if (!boundingBox) throw new Error('boundingBox cannot be null.');\n        const index = this.boundingBoxes.indexOf(boundingBox);\n\n        return index == -1 ? null : this.polygons[index];\n    }\n\n    /** The width of the axis aligned bounding box. */\n    getWidth() {\n        return this.maxX - this.minX;\n    }\n\n    /** The height of the axis aligned bounding box. */\n    getHeight() {\n        return this.maxY - this.minY;\n    }\n}\n","/**\n * @public\n */\nexport const settings = {\n    yDown: true,\n    /**\n     * pixi-spine gives option to not fail at certain parsing errors\n     * spine-ts fails here\n     */\n    FAIL_ON_NON_EXISTING_SKIN: false,\n\n    /**\n     * past Spine.globalAutoUpdate\n     */\n    GLOBAL_AUTO_UPDATE: true,\n\n    /**\n     * past Spine.globalDelayLimit\n     */\n    GLOBAL_DELAY_LIMIT: 0,\n};\n","import { AttachmentType } from './core/AttachmentType';\nimport { TextureRegion } from './core/TextureRegion';\nimport { MathUtils } from './core/Utils';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IAttachment, IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, ISlot, IVertexAttachment } from './core/ISkeleton';\nimport { DRAW_MODES, Rectangle, Polygon, Transform, Texture, utils } from '@pixi/core';\nimport { Container, DisplayObject } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { settings } from './settings';\nimport type { ISpineDebugRenderer } from './SpineDebugRenderer';\n\nconst tempRgb = [0, 0, 0];\n\n/**\n * @public\n */\nexport interface ISpineDisplayObject extends DisplayObject {\n    region?: TextureRegion;\n    attachment?: IAttachment;\n}\n\n/**\n * @public\n */\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n}\n\n/**\n * @public\n */\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * let spineAnimation = new spine(spineData);\n * ```\n *\n * @public\n * @class\n * @extends Container\n * @memberof spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport abstract class SpineBase<\n        Skeleton extends ISkeleton,\n        SkeletonData extends ISkeletonData,\n        AnimationState extends IAnimationState,\n        AnimationStateData extends IAnimationStateData\n    >\n    extends Container\n    implements GlobalMixins.Spine\n{\n    tintRgb: ArrayLike<number>;\n    spineData: SkeletonData;\n    skeleton: Skeleton;\n    stateData: AnimationStateData;\n    state: AnimationState;\n    slotContainers: Array<Container>;\n    tempClipContainers: Array<Container>;\n    localDelayLimit: number;\n    private _autoUpdate: boolean;\n    protected _visible: boolean;\n    private _debug: ISpineDebugRenderer;\n    public get debug(): ISpineDebugRenderer {\n        return this._debug;\n    }\n    public set debug(value: ISpineDebugRenderer) {\n        if (value == this._debug) {\n            // soft equality allows null == undefined\n            return;\n        }\n        this._debug?.unregisterSpine(this);\n        value?.registerSpine(this);\n        this._debug = value;\n    }\n\n    abstract createSkeleton(spineData: ISkeletonData);\n\n    constructor(spineData: SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if (typeof spineData === 'string') {\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.createSkeleton(spineData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        this.tempClipContainers = [];\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n            const attachment: any = slot.getAttachment();\n            const slotContainer = this.newContainer();\n\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n            this.tempClipContainers.push(null);\n\n            if (!attachment) {\n                continue;\n            }\n            if (attachment.type === AttachmentType.Region) {\n                const spriteName = attachment.name;\n                const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            } else if (attachment.type === AttachmentType.Mesh) {\n                const mesh = this.createMesh(slot, attachment);\n\n                slot.currentMesh = mesh;\n                slot.currentMeshId = attachment.id;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            } else if (attachment.type === AttachmentType.Clipping) {\n                this.createGraphics(slot, attachment);\n                slotContainer.addChild(slot.clippingContainer);\n                slotContainer.addChild(slot.currentGraphics);\n            }\n        }\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        this.autoUpdate = true;\n        this.visible = true;\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be automatically updated every\n     * time the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoUpdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n        }\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return utils.rgb2hex(this.tintRgb as any);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = utils.hex2rgb(value, this.tintRgb as any);\n    }\n\n    /**\n     * Limit value for the update dt with Spine.globalDelayLimit\n     * that can be overridden with localDelayLimit\n     * @return {number} - Maximum processed dt value for the update\n     */\n    get delayLimit(): number {\n        const limit = typeof this.localDelayLimit !== 'undefined' ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\n\n        // If limit is 0, this means there is no limit for the delay\n        return limit || Number.MAX_VALUE;\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        // Limit delta value to avoid animation jumps\n        const delayLimit = this.delayLimit;\n\n        if (dt > delayLimit) dt = delayLimit;\n\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n\n        // check we haven't been destroyed via a spine event callback in state update\n        if (!this.skeleton) {\n            return;\n        }\n\n        this.skeleton.updateWorldTransform();\n\n        const slots = this.skeleton.slots;\n\n        // in case pixi has double tint\n        const globalClr = (this as any).color;\n        let light: ArrayLike<number> = null;\n        let dark: ArrayLike<number> = null;\n\n        if (globalClr) {\n            light = globalClr.light;\n            dark = globalClr.dark;\n        } else {\n            light = this.tintRgb;\n        }\n\n        // let thack = false;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n            const slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            let spriteColor: any = null;\n\n            if (attachment.sequence) {\n                attachment.sequence.apply(slot, attachment as any);\n            }\n            let region = (attachment as IRegionAttachment).region;\n\n            const attColor = (attachment as any).color;\n\n            switch (attachment != null && attachment.type) {\n                case AttachmentType.Region:\n                    const transform = slotContainer.transform;\n\n                    transform.setFromMatrix(slot.bone.matrix);\n\n                    region = (attachment as IRegionAttachment).region;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                        slot.currentMesh = null;\n                        slot.currentMeshId = undefined;\n                        slot.currentMeshName = undefined;\n                    }\n                    if (!region) {\n                        if (slot.currentSprite) {\n                            slot.currentSprite.renderable = false;\n                        }\n                        break;\n                    }\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\n                        const spriteName = attachment.name;\n\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        } else {\n                            const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n\n                        // force sprite update when attachment name is same.\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\n                    }\n                    slot.currentSprite.renderable = true;\n                    if (!slot.hackRegion) {\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\n                    }\n                    if (slot.currentSprite.color) {\n                        // YAY! double - tint!\n                        spriteColor = slot.currentSprite.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentSprite.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentSprite.blendMode = slot.blendMode;\n                    break;\n\n                case AttachmentType.Mesh:\n                    if (slot.currentSprite) {\n                        // TODO: refactor this thing, switch it on and off for container\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n\n                        // TODO: refactor this shit\n                        const transform = new Transform();\n\n                        (transform as any)._parentID = -1;\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\n                        slotContainer.transform = transform;\n                    }\n                    if (!region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.renderable = false;\n                        }\n                        break;\n                    }\n\n                    const id = (attachment as IVertexAttachment).id;\n\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\n                        const meshId = id;\n\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n\n                        slot.meshes = slot.meshes || {};\n\n                        if (slot.meshes[meshId] !== undefined) {\n                            slot.meshes[meshId].visible = true;\n                        } else {\n                            const mesh = this.createMesh(slot, attachment as IMeshAttachment);\n\n                            slotContainer.addChild(mesh);\n                        }\n\n                        slot.currentMesh = slot.meshes[meshId];\n                        slot.currentMeshName = attachment.name;\n                        slot.currentMeshId = meshId;\n                    }\n                    slot.currentMesh.renderable = true;\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (slot.currentMesh.color) {\n                        // pixi-heaven\n                        spriteColor = slot.currentMesh.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentMesh.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                    if (!slot.hackRegion) {\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\n                    }\n                    break;\n                case AttachmentType.Clipping:\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment as IClippingAttachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\n                    slotContainer.alpha = 1.0;\n                    slotContainer.visible = true;\n                    continue;\n                default:\n                    slotContainer.visible = false;\n                    continue;\n            }\n            slotContainer.visible = true;\n\n            // pixi has double tint\n            if (spriteColor) {\n                let r0 = slot.color.r * attColor.r;\n                let g0 = slot.color.g * attColor.g;\n                let b0 = slot.color.b * attColor.b;\n\n                // YAY! double-tint!\n                spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\n                if (slot.darkColor) {\n                    r0 = slot.darkColor.r;\n                    g0 = slot.darkColor.g;\n                    b0 = slot.darkColor.b;\n                } else {\n                    r0 = 0.0;\n                    g0 = 0.0;\n                    b0 = 0.0;\n                }\n                spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n            }\n\n            slotContainer.alpha = slot.color.a;\n        }\n\n        // == this is clipping implementation ===\n        // TODO: remove parent hacks when pixi masks allow it\n        const drawOrder = this.skeleton.drawOrder;\n        let clippingAttachment: IClippingAttachment = null;\n        let clippingContainer: Container = null;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = slots[drawOrder[i].data.index];\n            const slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n            if (!clippingContainer) {\n                // Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\n                    slotContainer.parent.removeChild(slotContainer);\n                    // silend add hack\n                    (slotContainer as any).parent = this;\n                }\n            }\n            if (slot.currentGraphics && slot.getAttachment()) {\n                clippingContainer = slot.clippingContainer;\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\n                clippingContainer.children.length = 0;\n                this.children[i] = slotContainer;\n\n                if (clippingAttachment.endSlot === slot.data) {\n                    clippingAttachment.endSlot = null;\n                }\n            } else if (clippingContainer) {\n                let c = this.tempClipContainers[i];\n\n                if (!c) {\n                    c = this.tempClipContainers[i] = this.newContainer();\n                    c.visible = false;\n                }\n                this.children[i] = c;\n\n                // silent remove hack\n                (slotContainer as any).parent = null;\n                clippingContainer.addChild(slotContainer);\n                if (clippingAttachment.endSlot == slot.data) {\n                    clippingContainer.renderable = true;\n                    clippingContainer = null;\n                    clippingAttachment = null;\n                }\n            } else {\n                this.children[i] = slotContainer;\n            }\n        }\n\n        // if you can debug, then debug!\n        this._debug?.renderDebug(this);\n    }\n\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\n        // prevent setters calling when attachment and region is same\n        if (sprite.attachment === attachment && sprite.region === region) {\n            return;\n        }\n\n        sprite.region = region;\n        sprite.attachment = attachment;\n\n        sprite.texture = region.texture;\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        if (!region.size) {\n            sprite.scale.x = (attachment.scaleX * attachment.width) / region.originalWidth;\n            sprite.scale.y = (-attachment.scaleY * attachment.height) / region.originalHeight;\n        } else {\n            // hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\n        if (mesh.attachment === attachment && mesh.region === region) {\n            return;\n        }\n\n        mesh.region = region;\n        mesh.attachment = attachment;\n        mesh.texture = region.texture;\n        region.texture.updateUvs();\n        mesh.uvBuffer.update(attachment.regionUVs);\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (settings.GLOBAL_AUTO_UPDATE) {\n            this.lastTime = this.lastTime || Date.now();\n            const timeDelta = (Date.now() - this.lastTime) * 0.001;\n\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        Container.prototype.updateTransform.call(this);\n    }\n\n    /**\n     * Create a new sprite to be used with core.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n        }\n        const texture = region ? region.texture : null;\n        const sprite = this.newSprite(texture);\n\n        sprite.anchor.set(0.5);\n        if (region) {\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n        }\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[defName] = sprite;\n\n        return sprite;\n    }\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n            slot.hackAttachment = null;\n            slot.hackRegion = null;\n        }\n        const strip = this.newMesh(\n            region ? region.texture : null,\n            new Float32Array(attachment.regionUVs.length),\n            attachment.regionUVs,\n            new Uint16Array(attachment.triangles),\n            DRAW_MODES.TRIANGLES\n        );\n\n        if (typeof (strip as any)._canvasPadding !== 'undefined') {\n            (strip as any)._canvasPadding = 1.5;\n        }\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        if (region) {\n            this.setMeshRegion(attachment, strip, region);\n        }\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.id] = strip;\n\n        return strip;\n    }\n\n    static clippingPolygon: Array<number> = [];\n\n    // @ts-ignore\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const graphics = this.newGraphics();\n        const poly = new Polygon([]);\n\n        graphics.clear();\n        graphics.beginFill(0xffffff, 1);\n        graphics.drawPolygon(poly as any);\n        graphics.renderable = false;\n        slot.currentGraphics = graphics;\n        slot.clippingContainer = this.newContainer();\n        slot.clippingContainer.mask = slot.currentGraphics;\n\n        return graphics;\n    }\n\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const geom = slot.currentGraphics.geometry;\n        const vertices = (geom.graphicsData[0].shape as Polygon).points;\n        const n = clip.worldVerticesLength;\n\n        vertices.length = n;\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n        geom.invalidate();\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n        const attachment: any = slot.getAttachment();\n        let region: TextureRegion = attachment.region;\n\n        if (texture) {\n            region = new TextureRegion();\n            region.texture = texture;\n            region.size = size;\n            slot.hackRegion = region;\n            slot.hackAttachment = attachment;\n        } else {\n            slot.hackRegion = null;\n            slot.hackAttachment = null;\n        }\n        if (slot.currentSprite) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n        } else if (slot.currentMesh) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        }\n\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\n        const index = this.skeleton.findSlotIndex(slotName);\n\n        if (index == -1) {\n            return false;\n        }\n\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n\n    /**\n     * Changes texture of an attachment\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param attachmentName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\n        // changes the texture of an attachment at the skeleton level\n        const slotIndex = this.skeleton.findSlotIndex(slotName);\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName);\n\n        attachment.region.texture = texture;\n\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n\n        // gets the currently active attachment in this slot\n        const currentAttachment: any = slot.getAttachment();\n\n        if (attachmentName === currentAttachment.name) {\n            // if the attachment we are changing is currently active, change the the live texture\n            let region: TextureRegion = attachment.region;\n\n            if (texture) {\n                region = new TextureRegion();\n                region.texture = texture;\n                region.size = size;\n                slot.hackRegion = region;\n                slot.hackAttachment = currentAttachment;\n            } else {\n                slot.hackRegion = null;\n                slot.hackAttachment = null;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // those methods can be overriden to spawn different classes\n    newContainer() {\n        return new Container();\n    }\n\n    newSprite(tex: Texture) {\n        return new SpineSprite(tex);\n    }\n\n    newGraphics() {\n        return new Graphics();\n    }\n\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n    }\n\n    transformHack() {\n        return 1;\n    }\n\n    /**\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\n     * @param nameSuffix\n     * @param group\n     * @param outGroup\n     */\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\n        if (!nameSuffix) {\n            return undefined;\n        }\n        const list_d = [];\n        const list_n = [];\n\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n            const slot = this.skeleton.slots[i];\n            const name = slot.currentSpriteName || slot.currentMeshName || '';\n            const target = slot.currentSprite || slot.currentMesh;\n\n            if (name.endsWith(nameSuffix)) {\n                target.parentGroup = group;\n                list_n.push(target);\n            } else if (outGroup && target) {\n                target.parentGroup = outGroup;\n                list_d.push(target);\n            }\n        }\n\n        return [list_d, list_n];\n    }\n\n    destroy(options?: any): void {\n        this.debug = null; // setter will do the cleanup\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n\n            for (const name in slot.meshes) {\n                slot.meshes[name].destroy(options);\n            }\n            slot.meshes = null;\n\n            for (const name in slot.sprites) {\n                slot.sprites[name].destroy(options);\n            }\n            slot.sprites = null;\n        }\n\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n            this.slotContainers[i].destroy(options);\n        }\n        this.spineData = null;\n        this.skeleton = null;\n        this.slotContainers = null;\n        this.stateData = null;\n        this.state = null;\n        this.tempClipContainers = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * The visibility of the spine object. If false the object will not be drawn,\n * the updateTransform function will not be called, and the spine will not be automatically updated.\n *\n * @member {boolean}\n * @memberof spine.Spine#\n * @default true\n */\nObject.defineProperty(SpineBase.prototype, 'visible', {\n    get() {\n        return this._visible;\n    },\n    set(value: boolean) {\n        if (value !== this._visible) {\n            this._visible = value;\n            if (value) {\n                this.lastTime = 0;\n            }\n        }\n    },\n});\n","import { Container } from '@pixi/display';\nimport { Graphics } from '@pixi/graphics';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, IVertexAttachment } from './core/ISkeleton';\nimport type { SpineBase } from './SpineBase';\nimport { AttachmentType } from './core/AttachmentType';\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase';\n\n/**\n * Make a class that extends from this interface to create your own debug renderer.\n * @public\n */\nexport interface ISpineDebugRenderer {\n    /**\n     * This will be called every frame, after the spine has been updated.\n     */\n    renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\n     */\n    unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\n     */\n    registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n}\n\ntype DebugDisplayObjects = {\n    bones: Container;\n    skeletonXY: Graphics;\n    regionAttachmentsShape: Graphics;\n    meshTrianglesLine: Graphics;\n    meshHullLine: Graphics;\n    clippingPolygon: Graphics;\n    boundingBoxesRect: Graphics;\n    boundingBoxesCircle: Graphics;\n    boundingBoxesPolygon: Graphics;\n    pathsCurve: Graphics;\n    pathsLine: Graphics;\n    parentDebugContainer: Container;\n};\n\n/**\n * This is a debug renderer that uses PixiJS Graphics under the hood.\n * @public\n */\nexport class SpineDebugRenderer implements ISpineDebugRenderer {\n    private registeredSpines: Map<SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, DebugDisplayObjects> = new Map();\n\n    public drawDebug = true;\n    public drawMeshHull = true;\n    public drawMeshTriangles = true;\n    public drawBones = true;\n    public drawPaths = true;\n    public drawBoundingBoxes = true;\n    public drawClipping = true;\n    public drawRegionAttachments = true;\n\n    public lineWidth = 1;\n    public regionAttachmentsColor = 0x0078ff;\n    public meshHullColor = 0x0078ff;\n    public meshTrianglesColor = 0xffcc00;\n    public clippingPolygonColor = 0xff00ff;\n    public boundingBoxesRectColor = 0x00ff00;\n    public boundingBoxesPolygonColor = 0x00ff00;\n    public boundingBoxesCircleColor = 0x00ff00;\n    public pathsCurveColor = 0xff0000;\n    public pathsLineColor = 0xff00ff;\n    public skeletonXYColor = 0xff0000;\n    public bonesColor = 0x00eecc;\n\n    /**\n     * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\n     */\n    public registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>) {\n        if (this.registeredSpines.has(spine)) {\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\n        }\n        const debugDisplayObjects = {\n            parentDebugContainer: new Container(),\n            bones: new Container(),\n            skeletonXY: new Graphics(),\n            regionAttachmentsShape: new Graphics(),\n            meshTrianglesLine: new Graphics(),\n            meshHullLine: new Graphics(),\n            clippingPolygon: new Graphics(),\n            boundingBoxesRect: new Graphics(),\n            boundingBoxesCircle: new Graphics(),\n            boundingBoxesPolygon: new Graphics(),\n            pathsCurve: new Graphics(),\n            pathsLine: new Graphics(),\n        };\n\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        this.registeredSpines.set(spine, debugDisplayObjects);\n    }\n    public renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            // This should never happen. Spines are registered when you assign spine.debug\n            this.registerSpine(spine);\n        }\n\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.skeletonXY.clear();\n        debugDisplayObjects.regionAttachmentsShape.clear();\n        debugDisplayObjects.meshTrianglesLine.clear();\n        debugDisplayObjects.meshHullLine.clear();\n        debugDisplayObjects.clippingPolygon.clear();\n        debugDisplayObjects.boundingBoxesRect.clear();\n        debugDisplayObjects.boundingBoxesCircle.clear();\n        debugDisplayObjects.boundingBoxesPolygon.clear();\n        debugDisplayObjects.pathsCurve.clear();\n        debugDisplayObjects.pathsLine.clear();\n\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\n        }\n\n        const scale = spine.scale.x || spine.scale.y || 1;\n        const lineWidth = this.lineWidth / scale;\n\n        if (this.drawBones) {\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n        }\n\n        if (this.drawPaths) {\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawBoundingBoxes) {\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawClipping) {\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawMeshHull || this.drawMeshTriangles) {\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawRegionAttachments) {\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n    }\n\n    private drawBonesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number,\n        scale: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const skeletonX = skeleton.x;\n        const skeletonY = skeleton.y;\n        const bones = skeleton.bones;\n\n        debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\n\n        for (let i = 0, len = bones.length; i < len; i++) {\n            const bone = bones[i];\n            const boneLen = bone.data.length;\n            const starX = skeletonX + bone.matrix.tx;\n            const starY = skeletonY + bone.matrix.ty;\n            const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\n            const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\n\n            if (bone.data.name === 'root' || bone.data.parent === null) {\n                continue;\n            }\n\n            // Triangle calculation formula\n            // area: A=sqrt((a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c))/4\n            // alpha: alpha=acos((pow(b, 2)+pow(c, 2)-pow(a, 2))/(2*b*c))\n            // beta: beta=acos((pow(a, 2)+pow(c, 2)-pow(b, 2))/(2*a*c))\n            // gamma: gamma=acos((pow(a, 2)+pow(b, 2)-pow(c, 2))/(2*a*b))\n\n            const w = Math.abs(starX - endX);\n            const h = Math.abs(starY - endY);\n            // a = w, // side length a\n            const a2 = Math.pow(w, 2); // square root of side length a\n            const b = h; // side length b\n            const b2 = Math.pow(h, 2); // square root of side length b\n            const c = Math.sqrt(a2 + b2); // side length c\n            const c2 = Math.pow(c, 2); // square root of side length c\n            const rad = Math.PI / 180;\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\n\n            if (c === 0) {\n                continue;\n            }\n\n            const gp = new Graphics();\n\n            debugDisplayObjects.bones.addChild(gp);\n\n            // draw bone\n            const refRation = c / 50 / scale;\n\n            gp.beginFill(this.bonesColor, 1);\n            gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\n            gp.endFill();\n            gp.x = starX;\n            gp.y = starY;\n            gp.pivot.y = c;\n\n            // Calculate bone rotation angle\n            let rotation = 0;\n\n            if (starX < endX && starY < endY) {\n                // bottom right\n                rotation = -B + 180 * rad;\n            } else if (starX > endX && starY < endY) {\n                // bottom left\n                rotation = 180 * rad + B;\n            } else if (starX > endX && starY > endY) {\n                // top left\n                rotation = -B;\n            } else if (starX < endX && starY > endY) {\n                // bottom left\n                rotation = B;\n            } else if (starY === endY && starX < endX) {\n                // To the right\n                rotation = 90 * rad;\n            } else if (starY === endY && starX > endX) {\n                // go left\n                rotation = -90 * rad;\n            } else if (starX === endX && starY < endY) {\n                // down\n                rotation = 180 * rad;\n            } else if (starX === endX && starY > endY) {\n                // up\n                rotation = 0;\n            }\n            gp.rotation = rotation;\n\n            // Draw the starting rotation point of the bone\n            gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\n            gp.beginFill(0x000000, 0.6);\n            gp.drawCircle(0, c, refRation * 1.2);\n            gp.endFill();\n        }\n\n        // Draw the skeleton starting point \"X\" form\n        const startDotSize = lineWidth * 3;\n\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\n    }\n\n    private drawRegionAttachmentsFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Region) {\n                continue;\n            }\n\n            const regionAttachment = attachment as IRegionAttachment & {\n                computeWorldVertices: (slot: unknown, worldVertices: unknown, offset: unknown, stride: unknown) => void;\n                updateOffset?: () => void;\n            };\n\n            const vertices = new Float32Array(8);\n\n            if (regionAttachment.updateOffset) regionAttachment.updateOffset(); // We don't need this on all versions\n\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n            debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\n        }\n    }\n\n    private drawMeshHullAndMeshTriangles(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\n        debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Mesh) {\n                continue;\n            }\n\n            const meshAttachment: IMeshAttachment = attachment as IMeshAttachment;\n\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n            const triangles = meshAttachment.triangles;\n            let hullLength = meshAttachment.hullLength;\n\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n            // draw the skinned mesh (triangle)\n            if (this.drawMeshTriangles) {\n                for (let i = 0, len = triangles.length; i < len; i += 3) {\n                    const v1 = triangles[i] * 2;\n                    const v2 = triangles[i + 1] * 2;\n                    const v3 = triangles[i + 2] * 2;\n\n                    debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\n                }\n            }\n\n            // draw skin border\n            if (this.drawMeshHull && hullLength > 0) {\n                hullLength = (hullLength >> 1) * 2;\n                let lastX = vertices[hullLength - 2];\n                let lastY = vertices[hullLength - 1];\n\n                for (let i = 0, len = hullLength; i < len; i += 2) {\n                    const x = vertices[i];\n                    const y = vertices[i + 1];\n\n                    debugDisplayObjects.meshHullLine.moveTo(x, y);\n                    debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n        }\n    }\n\n    private drawClippingFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Clipping) {\n                continue;\n            }\n\n            const clippingAttachment: IClippingAttachment = attachment as IClippingAttachment;\n\n            const nn = clippingAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\n        }\n    }\n\n    private drawBoundingBoxesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        // draw the total outline of the bounding box\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n\n        const bounds = new SkeletonBoundsBase();\n\n        bounds.update(spine.skeleton, true);\n        debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n\n        const polygons = bounds.polygons;\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void => {\n            debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\n            debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\n\n            if (count < 3) {\n                throw new Error('Polygon must contain at least 3 vertices');\n            }\n            const paths = [];\n            const dotSize = lineWidth * 2;\n\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n                const x1 = polygonVertices[i];\n                const y1 = polygonVertices[i + 1];\n\n                // draw the bounding box node\n                debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n                debugDisplayObjects.boundingBoxesCircle.endFill();\n\n                paths.push(x1, y1);\n            }\n\n            // draw the bounding box area\n            debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\n            debugDisplayObjects.boundingBoxesPolygon.endFill();\n        };\n\n        for (let i = 0, len = polygons.length; i < len; i++) {\n            const polygon = polygons[i];\n\n            drawPolygon(polygon, 0, polygon.length);\n        }\n    }\n\n    private drawPathsFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\n        debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Path) {\n                continue;\n            }\n\n            const pathAttachment = attachment as IVertexAttachment & { closed: boolean };\n            let nn = pathAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            let x1 = world[2];\n            let y1 = world[3];\n            let x2 = 0;\n            let y2 = 0;\n\n            if (pathAttachment.closed) {\n                const cx1 = world[0];\n                const cy1 = world[1];\n                const cx2 = world[nn - 2];\n                const cy2 = world[nn - 1];\n\n                x2 = world[nn - 4];\n                y2 = world[nn - 3];\n\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n            }\n            nn -= 4;\n            for (let ii = 4; ii < nn; ii += 6) {\n                const cx1 = world[ii];\n                const cy1 = world[ii + 1];\n                const cx2 = world[ii + 2];\n                const cy2 = world[ii + 3];\n\n                x2 = world[ii + 4];\n                y2 = world[ii + 5];\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n                x1 = x2;\n                y1 = y2;\n            }\n        }\n    }\n\n    public unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n        }\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });\n        this.registeredSpines.delete(spine);\n    }\n}\n"],"names":["AttachmentType","i","BinaryInput","data","strings","index","buffer","value","optimizePositive","b","result","byteCount","chars","MixBlend","t","MixDirection","PositionMode","RotateMode","TransformMode","filterFromString","text","TextureFilter","wrapFromString","TextureWrap","n","TextureRegion","tex","RegionFields","TextureAtlas","atlasText","textureLoader","callback","name","texture","pages","page","TextureAtlasPage","baseTexture","region","TextureAtlasRegion","textures","stripExtension","key","reader","TextureAtlasReader","entry","pageFields","regionFields","rotateValue","rotate","line","iterateParser","field","ALPHA_MODES","atlasRegion","names","values","count","entryValues","resolution","swapWH","frame","Rectangle","orig","trim","Texture","colon","lastMatch","comma","filter","SCALE_MODES","MIPMAP_MODES","IntSet","contains","StringSet","oldSize","_Color","r","g","a","c","hex","color","Color","_MathUtils","min","max","degrees","x","y","mode","u","d","MathUtils","Interpolation","start","end","Pow","power","PowOut","_Utils","source","sourceStart","dest","destStart","numElements","j","array","fromIndex","toIndex","size","defaultValue","alpha","blend","element","identity","type","Utils","DebugUtils","skeleton","bone","mat","Pool","instantiator","item","items","Vector2","len","TimeKeeper","now","WindowedMean","windowSize","mean","SkeletonBoundsBase","updateAabb","boundingBoxes","polygons","polygonPool","slots","slotCount","slot","attachment","boundingBox","polygon","minX","minY","maxX","maxY","vertices","ii","nn","x1","y1","x2","y2","m","bounds","prevIndex","inside","vertexY","prevY","vertexX","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","settings","tempRgb","SpineSprite","Sprite","SpineMesh","SimpleMesh","uvs","indices","drawMode","_SpineBase","Container","spineData","slotContainer","spriteName","sprite","mesh","_a","utils","dt","delayLimit","globalClr","light","dark","spriteColor","attColor","transform","Transform","id","meshId","r0","g0","b0","drawOrder","clippingAttachment","clippingContainer","timeDelta","defName","strip","DRAW_MODES","clip","graphics","poly","Polygon","geom","slotIndex","slotName","attachmentName","currentAttachment","Graphics","nameSuffix","group","outGroup","list_d","list_n","target","options","SpineBase","SpineDebugRenderer","spine","debugDisplayObjects","scale","lineWidth","skeletonX","skeletonY","bones","boneLen","starX","starY","endX","endY","w","h","a2","b2","c2","rad","B","gp","refRation","rotation","startDotSize","regionAttachment","meshAttachment","triangles","hullLength","v1","v2","v3","lastX","lastY","world","drawPolygon","polygonVertices","_offset","paths","dotSize","pathAttachment","cx1","cy1","cx2","cy2"],"mappings":"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"}