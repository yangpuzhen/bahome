{"version":3,"file":"IAnimation.mjs","sources":["../../src/core/IAnimation.ts"],"sourcesContent":["import type { ISkeleton, ISkeletonData } from './ISkeleton';\nimport type { Map } from './Utils';\n\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixBlend {\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n     * value is set. */\n    setup,\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\n     * AttachmentTimeline, use the setup value before the first key.\n     *\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\n    first,\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n     * kept until the first key).\n     *\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n    replace,\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n     * (the current value is kept until the first key).\n     *\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n     * the property values will increase continually. */\n    add,\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixDirection {\n    mixIn,\n    mixOut,\n}\n\n/**\n * @public\n */\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\n    name: string;\n    timelines: Timeline[];\n    duration: number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\n    data: AnimationStateData;\n    tracks: ITrackEntry[];\n    listeners: IAnimationStateListener[];\n    timeScale: number;\n\n    update(dt: number): void;\n    apply(skeleton: ISkeleton): boolean;\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\n    setEmptyAnimation(trackIndex: number, mixDuration: number): ITrackEntry;\n    setEmptyAnimations(mixDuration: number): void;\n    hasAnimation(animationName: string): boolean;\n    addListener(listener: IAnimationStateListener): void;\n    removeListener(listener: IAnimationStateListener): void;\n    clearListeners(): void;\n    clearTracks(): void;\n    clearTrack(index: number): void;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number>;\n    defaultMix: number;\n    setMix(fromName: string, toName: string, duration: number): void;\n    setMixWith(from: Animation, to: Animation, duration: number): void;\n    getMix(from: Animation, to: Animation): number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateListener {\n    start?(entry: ITrackEntry): void;\n    interrupt?(entry: ITrackEntry): void;\n    end?(entry: ITrackEntry): void;\n    dispose?(entry: ITrackEntry): void;\n    complete?(entry: ITrackEntry): void;\n    event?(entry: ITrackEntry, event: IEvent): void;\n}\n\n/**\n * @public\n */\nexport interface ITimeline {}\n\n/**\n * @public\n */\nexport interface ITrackEntry {\n    trackIndex: number;\n    loop: boolean;\n    animationEnd: number;\n    listener: IAnimationStateListener;\n\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n}\n\n/**\n * @public\n */\nexport interface IEventData {\n    name: string;\n}\n\n/**\n * @public\n */\nexport interface IEvent {\n    time: number;\n    data: IEventData;\n}\n"],"names":["MixBlend","MixDirection"],"mappings":"AAWY,IAAA,QAAA,qBAAAA,SAAL,KAAA;AAGH,EAAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AAMA,EAAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AAKA,EAAAA,SAAA,CAAA,SAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA;AAOA,EAAAA,SAAA,CAAA,SAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA,CAAA;AArBQ,EAAAA,OAAAA,SAAAA,CAAAA;AAAA,CAAA,EAAA,QAAA,IAAA,EAAA,EAAA;AA8BA,IAAA,YAAA,qBAAAC,aAAL,KAAA;AACH,EAAAA,aAAA,CAAA,aAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA,CAAA;AACA,EAAAA,aAAA,CAAA,aAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA,CAAA;AAFQ,EAAAA,OAAAA,aAAAA,CAAAA;AAAA,CAAA,EAAA,YAAA,IAAA,EAAA;;;;"}