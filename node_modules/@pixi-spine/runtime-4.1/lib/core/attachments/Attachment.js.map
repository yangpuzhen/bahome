{"version":3,"file":"Attachment.js","sources":["../../../src/core/attachments/Attachment.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\nimport type { IAttachment, NumberArrayLike } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * The base class for all attachments.\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    abstract copy(): Attachment;\n}\n\n/**\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}.\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    /** The unique ID for this attachment. */\n    id = VertexAttachment.nextID++;\n\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    bones: Array<number> | null = null;\n\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    vertices: NumberArrayLike = [];\n\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    worldVerticesLength = 0;\n\n    /** Timelines for the timeline attachment are also applied to this attachment.\n     * May be null if no attachment-specific timelines should be applied. */\n    timelineAttachment: Attachment = this;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n     * not empty, it is used to deform the vertices.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide.\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n     *           `stride` / 2.\n     * @param offset The `worldVertices` index to begin writing values.\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.deform;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (!bones) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Does not copy id (generated) or name (set on construction). **/\n    copyTo(attachment: VertexAttachment) {\n        if (this.bones) {\n            attachment.bones = new Array<number>(this.bones.length);\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n        } else attachment.bones = null;\n\n        if (this.vertices) {\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n        }\n\n        attachment.worldVerticesLength = this.worldVerticesLength;\n        attachment.timelineAttachment = this.timelineAttachment;\n    }\n}\n"],"names":["v","Utils"],"mappings":"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"}