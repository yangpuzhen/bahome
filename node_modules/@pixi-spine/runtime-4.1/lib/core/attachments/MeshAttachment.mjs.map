{"version":3,"file":"MeshAttachment.mjs","sources":["../../../src/core/attachments/MeshAttachment.ts"],"sourcesContent":["import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, IHasTextureRegion, NumberArrayLike, TextureRegion, Utils } from '@pixi-spine/base';\nimport type { Sequence } from './Sequence';\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion | null = null;\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    /** The UV pair for each vertex, normalized within the texture region. */\n    regionUVs: Float32Array;\n\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    triangles: Array<number> = [];\n\n    /** The color to tint the mesh. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    width = 0;\n\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    height = 0;\n\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    hullLength = 0;\n\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    edges: Array<number> = [];\n\n    private parentMesh: MeshAttachment | null = null;\n\n    sequence: Sequence | null = null;\n\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string, path: string) {\n        super(name);\n        this.path = path;\n    }\n\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n        // Nonessential.\n        if (this.edges) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        if (this.sequence != null) this.sequence.apply(slot, this);\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n    }\n\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n        copy.timelineAttachment = this.timelineAttachment;\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n        // if (copy.region != null) copy.updateRegion();\n\n        return copy;\n    }\n}\n"],"names":[],"mappings":"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"}