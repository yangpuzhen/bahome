/*!
 * @pixi-spine/runtime-4.1 - v4.0.3
 * Compiled Thu, 19 Jan 2023 18:41:37 UTC
 *
 * @pixi-spine/runtime-4.1 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */import{Utils as E,AttachmentType as et,Color as L,MathUtils as X,StringSet as Oe,MixBlend as Y,MixDirection as st,Pool as is,settings as Tt,TransformMode as nt,PositionMode as wt,RotateMode as Bt,Vector2 as Jt,BinaryInput as rs,SkeletonBoundsBase as os,SpineBase as hs}from"@pixi-spine/base";import{Matrix as ls,BLEND_MODES as gt}from"@pixi/core";class Qt{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const ze=class extends Qt{constructor(l){super(l),this.id=ze.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(l,t){this.computeWorldVertices(l,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(l,t,n,e,a,r){n=a+(n>>1)*r;const d=l.bone.skeleton,h=l.deform;let s=this.vertices;const i=this.bones;if(!i){h.length>0&&(s=h);const f=l.bone.matrix,u=f.tx,g=f.ty,w=f.a,y=f.c,p=f.b,k=f.d;for(let x=t,b=a;b<n;x+=2,b+=r){const S=s[x],A=s[x+1];e[b]=S*w+A*y+u,e[b+1]=S*p+A*k+g}return}let o=0,c=0;for(let f=0;f<t;f+=2){const u=i[o];o+=u+1,c+=u}const m=d.bones;if(h.length==0)for(let f=a,u=c*3;f<n;f+=r){let g=0,w=0,y=i[o++];for(y+=o;o<y;o++,u+=3){const p=m[i[o]].matrix,k=s[u],x=s[u+1],b=s[u+2];g+=(k*p.a+x*p.c+p.tx)*b,w+=(k*p.b+x*p.d+p.ty)*b}e[f]=g,e[f+1]=w}else{const f=h;for(let u=a,g=c*3,w=c<<1;u<n;u+=r){let y=0,p=0,k=i[o++];for(k+=o;o<k;o++,g+=3,w+=2){const x=m[i[o]].matrix,b=s[g]+f[w],S=s[g+1]+f[w+1],A=s[g+2];y+=(b*x.a+S*x.c+x.tx)*A,p+=(b*x.b+S*x.d+x.ty)*A}e[u]=y,e[u+1]=p}}}copyTo(l){this.bones?(l.bones=new Array(this.bones.length),E.arrayCopy(this.bones,0,l.bones,0,this.bones.length)):l.bones=null,this.vertices&&(l.vertices=E.newFloatArray(this.vertices.length),E.arrayCopy(this.vertices,0,l.vertices,0,this.vertices.length)),l.worldVerticesLength=this.worldVerticesLength,l.timelineAttachment=this.timelineAttachment}};let it=ze;it.nextID=0;class _t extends it{constructor(t){super(t),this.type=et.BoundingBox,this.color=new L(1,1,1,1)}copy(){const t=new _t(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class jt extends it{constructor(t){super(t),this.type=et.Clipping,this.endSlot=null,this.color=new L(.2275,.2275,.8078,1)}copy(){const t=new jt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class It extends it{constructor(t,n){super(t),this.type=et.Mesh,this.region=null,this.triangles=[],this.color=new L(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new L(0,0,0,0),this.path=n}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new It(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),E.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),E.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),E.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,n,e,a,r,d){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,n,e,a,r,d)}newLinkedMesh(){const t=new It(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class At extends it{constructor(t){super(t),this.type=et.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new L(1,1,1,1)}copy(){const t=new At(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),E.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Gt extends it{constructor(t){super(t),this.type=et.Point,this.x=0,this.y=0,this.rotation=0,this.color=new L(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=X.cosDeg(this.rotation),a=X.sinDeg(this.rotation),r=e*n.a+a*n.c,d=e*n.b+a*n.d;return Math.atan2(d,r)*X.radDeg}copy(){const t=new Gt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const _e=class extends Qt{constructor(l,t){super(l),this.type=et.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new L(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=E.newFloatArray(8),this.uvs=E.newFloatArray(8),this.tempColor=new L(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const l=this.region,t=this.width/this.region.originalWidth*this.scaleX,n=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,a=-this.height/2*this.scaleY+this.region.offsetY*n,r=e+this.region.width*t,d=a+this.region.height*n,h=this.rotation*Math.PI/180,s=Math.cos(h),i=Math.sin(h),o=this.x,c=this.y,m=e*s+o,f=e*i,u=a*s+c,g=a*i,w=r*s+o,y=r*i,p=d*s+c,k=d*i,x=this.offset;x[0]=m-g,x[1]=u+f,x[2]=m-k,x[3]=p+f,x[4]=w-k,x[5]=p+y,x[6]=w-g,x[7]=u+y;const b=this.uvs;l.degrees==90?(b[2]=l.u,b[3]=l.v2,b[4]=l.u,b[5]=l.v,b[6]=l.u2,b[7]=l.v,b[0]=l.u2,b[1]=l.v2):(b[0]=l.u,b[1]=l.v2,b[2]=l.u,b[3]=l.v,b[4]=l.u2,b[5]=l.v,b[6]=l.u2,b[7]=l.v2)}computeWorldVertices(l,t,n,e){this.sequence!=null&&this.sequence.apply(l,this);const a=l.bone,r=this.offset,d=a.matrix,h=d.tx,s=d.ty,i=d.a,o=d.c,c=d.b,m=d.d;let f=0,u=0;f=r[0],u=r[1],t[n]=f*i+u*o+h,t[n+1]=f*c+u*m+s,n+=e,f=r[2],u=r[3],t[n]=f*i+u*o+h,t[n+1]=f*c+u*m+s,n+=e,f=r[4],u=r[5],t[n]=f*i+u*o+h,t[n+1]=f*c+u*m+s,n+=e,f=r[6],u=r[7],t[n]=f*i+u*o+h,t[n+1]=f*c+u*m+s}copy(){const l=new _e(this.name,this.path);return l.region=this.region,l.rendererObject=this.rendererObject,l.x=this.x,l.y=this.y,l.scaleX=this.scaleX,l.scaleY=this.scaleY,l.rotation=this.rotation,l.width=this.width,l.height=this.height,E.arrayCopy(this.uvs,0,l.uvs,0,8),E.arrayCopy(this.offset,0,l.offset,0,8),l.color.setFromColor(this.color),l.sequence=this.sequence!=null?this.sequence.copy():null,l}};let U=_e;U.X1=0,U.Y1=1,U.C1R=2,U.C1G=3,U.C1B=4,U.C1A=5,U.U1=6,U.V1=7,U.X2=8,U.Y2=9,U.C2R=10,U.C2G=11,U.C2B=12,U.C2A=13,U.U2=14,U.V2=15,U.X3=16,U.Y3=17,U.C3R=18,U.C3G=19,U.C3B=20,U.C3A=21,U.U3=22,U.V3=23,U.X4=24,U.Y4=25,U.C4R=26,U.C4G=27,U.C4B=28,U.C4A=29,U.U4=30,U.V4=31;const qt=class{constructor(t){this.id=qt.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(t)}copy(){const t=new qt(this.regions.length);return E.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,n){let e=t.sequenceIndex;e==-1&&(e=this.setupIndex),e>=this.regions.length&&(e=this.regions.length-1);const a=this.regions[e];n.region!=a&&(n.region=a)}getPath(t,n){let e=t;const a=(this.start+n).toString();for(let r=this.digits-a.length;r>0;r--)e+="0";return e+=a,e}static nextID(){return qt._nextID++}};let Lt=qt;Lt._nextID=0;var ct=(l=>(l[l.hold=0]="hold",l[l.once=1]="once",l[l.loop=2]="loop",l[l.pingpong=3]="pingpong",l[l.onceReverse=4]="onceReverse",l[l.loopReverse=5]="loopReverse",l[l.pingpongReverse=6]="pingpongReverse",l))(ct||{});const Zt=[0,1,2,3,4,5,6];class Wt{constructor(t,n,e){if(this.timelines=[],this.timelineIds=new Oe,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(n),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let n=0;n<t.length;n++)this.timelineIds.addAll(t[n].getPropertyIds())}hasTimeline(t){for(let n=0;n<t.length;n++)if(this.timelineIds.contains(t[n]))return!0;return!1}apply(t,n,e,a,r,d,h,s){if(!t)throw new Error("skeleton cannot be null.");a&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const i=this.timelines;for(let o=0,c=i.length;o<c;o++)i[o].apply(t,n,e,r,d,h,s)}}const j={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class H{constructor(t,n){this.propertyIds=n,this.frames=E.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,n){const e=t.length;for(let a=1;a<e;a++)if(t[a]>n)return a-1;return e-1}static search(t,n,e){const a=t.length;for(let r=e;r<a;r+=e)if(t[r]>n)return r-e;return a-e}}class rt extends H{constructor(t,n,e){super(t,e),this.curves=E.newFloatArray(t+n*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const n=this.getFrameCount()+t*18;if(this.curves.length>n){const e=E.newFloatArray(n);E.arrayCopy(this.curves,0,e,0,n),this.curves=e}}setBezier(t,n,e,a,r,d,h,s,i,o,c){const m=this.curves;let f=this.getFrameCount()+t*18;e==0&&(m[n]=2+f);const u=(a-d*2+s)*.03,g=(r-h*2+i)*.03,w=((d-s)*3-a+o)*.006,y=((h-i)*3-r+c)*.006;let p=u*2+w,k=g*2+y,x=(d-a)*.3+u+w*.16666667,b=(h-r)*.3+g+y*.16666667,S=a+x,A=r+b;for(let v=f+18;f<v;f+=2)m[f]=S,m[f+1]=A,x+=p,b+=k,p+=w,k+=y,S+=x,A+=b}getBezierValue(t,n,e,a){const r=this.curves;if(r[a]>t){const i=this.frames[n],o=this.frames[n+e];return o+(t-i)/(r[a]-i)*(r[a+1]-o)}const d=a+18;for(a+=2;a<d;a+=2)if(r[a]>=t){const i=r[a-2],o=r[a-1];return o+(t-i)/(r[a]-i)*(r[a+1]-o)}n+=this.getFrameEntries();const h=r[d-2],s=r[d-1];return s+(t-h)/(this.frames[n]-h)*(this.frames[n+e]-s)}}class ot extends rt{constructor(t,n,e){super(t,n,[e])}getFrameEntries(){return 2}setFrame(t,n,e){t<<=1,this.frames[t]=n,this.frames[t+1]=e}getCurveValue(t){const n=this.frames;let e=n.length-2;for(let r=2;r<=e;r+=2)if(n[r]>t){e=r-2;break}const a=this.curves[e>>1];switch(a){case 0:const r=n[e],d=n[e+1];return d+(t-r)/(n[e+2]-r)*(n[e+2+1]-d);case 1:return n[e+1]}return this.getBezierValue(t,e,1,a-2)}}class Nt extends rt{constructor(t,n,e,a){super(t,n,[e,a])}getFrameEntries(){return 3}setFrame(t,n,e,a){t*=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a}}class Et extends ot{constructor(t,n,e){super(t,n,`${j.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.rotation=s.data.rotation;return;case Y.first:s.rotation+=(s.data.rotation-s.rotation)*r}return}let o=this.getCurveValue(e);switch(d){case Y.setup:s.rotation=s.data.rotation+o*r;break;case Y.first:case Y.replace:o+=s.data.rotation-s.rotation;case Y.add:s.rotation+=o*r}}}class te extends Nt{constructor(t,n,e){super(t,n,`${j.x}|${e}`,`${j.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.x=s.data.x,s.y=s.data.y;return;case Y.first:s.x+=(s.data.x-s.x)*r,s.y+=(s.data.y-s.y)*r}return}let o=0,c=0;const m=H.search(i,e,3),f=this.curves[m/3];switch(f){case 0:const u=i[m];o=i[m+1],c=i[m+2];const g=(e-u)/(i[m+3]-u);o+=(i[m+3+1]-o)*g,c+=(i[m+3+2]-c)*g;break;case 1:o=i[m+1],c=i[m+2];break;default:o=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}switch(d){case Y.setup:s.x=s.data.x+o*r,s.y=s.data.y+c*r;break;case Y.first:case Y.replace:s.x+=(s.data.x+o-s.x)*r,s.y+=(s.data.y+c-s.y)*r;break;case Y.add:s.x+=o*r,s.y+=c*r}}}class ee extends ot{constructor(t,n,e){super(t,n,`${j.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.x=s.data.x;return;case Y.first:s.x+=(s.data.x-s.x)*r}return}const o=this.getCurveValue(e);switch(d){case Y.setup:s.x=s.data.x+o*r;break;case Y.first:case Y.replace:s.x+=(s.data.x+o-s.x)*r;break;case Y.add:s.x+=o*r}}}class se extends ot{constructor(t,n,e){super(t,n,`${j.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.y=s.data.y;return;case Y.first:s.y+=(s.data.y-s.y)*r}return}const o=this.getCurveValue(e);switch(d){case Y.setup:s.y=s.data.y+o*r;break;case Y.first:case Y.replace:s.y+=(s.data.y+o-s.y)*r;break;case Y.add:s.y+=o*r}}}class ne extends Nt{constructor(t,n,e){super(t,n,`${j.scaleX}|${e}`,`${j.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.scaleX=s.data.scaleX,s.scaleY=s.data.scaleY;return;case Y.first:s.scaleX+=(s.data.scaleX-s.scaleX)*r,s.scaleY+=(s.data.scaleY-s.scaleY)*r}return}let o,c;const m=H.search(i,e,3),f=this.curves[m/3];switch(f){case 0:const u=i[m];o=i[m+1],c=i[m+2];const g=(e-u)/(i[m+3]-u);o+=(i[m+3+1]-o)*g,c+=(i[m+3+2]-c)*g;break;case 1:o=i[m+1],c=i[m+2];break;default:o=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}if(o*=s.data.scaleX,c*=s.data.scaleY,r==1)d==Y.add?(s.scaleX+=o-s.data.scaleX,s.scaleY+=c-s.data.scaleY):(s.scaleX=o,s.scaleY=c);else{let u=0,g=0;if(h==st.mixOut)switch(d){case Y.setup:u=s.data.scaleX,g=s.data.scaleY,s.scaleX=u+(Math.abs(o)*X.signum(u)-u)*r,s.scaleY=g+(Math.abs(c)*X.signum(g)-g)*r;break;case Y.first:case Y.replace:u=s.scaleX,g=s.scaleY,s.scaleX=u+(Math.abs(o)*X.signum(u)-u)*r,s.scaleY=g+(Math.abs(c)*X.signum(g)-g)*r;break;case Y.add:s.scaleX+=(o-s.data.scaleX)*r,s.scaleY+=(c-s.data.scaleY)*r}else switch(d){case Y.setup:u=Math.abs(s.data.scaleX)*X.signum(o),g=Math.abs(s.data.scaleY)*X.signum(c),s.scaleX=u+(o-u)*r,s.scaleY=g+(c-g)*r;break;case Y.first:case Y.replace:u=Math.abs(s.scaleX)*X.signum(o),g=Math.abs(s.scaleY)*X.signum(c),s.scaleX=u+(o-u)*r,s.scaleY=g+(c-g)*r;break;case Y.add:s.scaleX+=(o-s.data.scaleX)*r,s.scaleY+=(c-s.data.scaleY)*r}}}}class ae extends ot{constructor(t,n,e){super(t,n,`${j.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.scaleX=s.data.scaleX;return;case Y.first:s.scaleX+=(s.data.scaleX-s.scaleX)*r}return}const o=this.getCurveValue(e)*s.data.scaleX;if(r==1)d==Y.add?s.scaleX+=o-s.data.scaleX:s.scaleX=o;else{let c=0;if(h==st.mixOut)switch(d){case Y.setup:c=s.data.scaleX,s.scaleX=c+(Math.abs(o)*X.signum(c)-c)*r;break;case Y.first:case Y.replace:c=s.scaleX,s.scaleX=c+(Math.abs(o)*X.signum(c)-c)*r;break;case Y.add:s.scaleX+=(o-s.data.scaleX)*r}else switch(d){case Y.setup:c=Math.abs(s.data.scaleX)*X.signum(o),s.scaleX=c+(o-c)*r;break;case Y.first:case Y.replace:c=Math.abs(s.scaleX)*X.signum(o),s.scaleX=c+(o-c)*r;break;case Y.add:s.scaleX+=(o-s.data.scaleX)*r}}}}class ie extends ot{constructor(t,n,e){super(t,n,`${j.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.scaleY=s.data.scaleY;return;case Y.first:s.scaleY+=(s.data.scaleY-s.scaleY)*r}return}const o=this.getCurveValue(e)*s.data.scaleY;if(r==1)d==Y.add?s.scaleY+=o-s.data.scaleY:s.scaleY=o;else{let c=0;if(h==st.mixOut)switch(d){case Y.setup:c=s.data.scaleY,s.scaleY=c+(Math.abs(o)*X.signum(c)-c)*r;break;case Y.first:case Y.replace:c=s.scaleY,s.scaleY=c+(Math.abs(o)*X.signum(c)-c)*r;break;case Y.add:s.scaleY+=(o-s.data.scaleY)*r}else switch(d){case Y.setup:c=Math.abs(s.data.scaleY)*X.signum(o),s.scaleY=c+(o-c)*r;break;case Y.first:case Y.replace:c=Math.abs(s.scaleY)*X.signum(o),s.scaleY=c+(o-c)*r;break;case Y.add:s.scaleY+=(o-s.data.scaleY)*r}}}}class re extends Nt{constructor(t,n,e){super(t,n,`${j.shearX}|${e}`,`${j.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.shearX=s.data.shearX,s.shearY=s.data.shearY;return;case Y.first:s.shearX+=(s.data.shearX-s.shearX)*r,s.shearY+=(s.data.shearY-s.shearY)*r}return}let o=0,c=0;const m=H.search(i,e,3),f=this.curves[m/3];switch(f){case 0:const u=i[m];o=i[m+1],c=i[m+2];const g=(e-u)/(i[m+3]-u);o+=(i[m+3+1]-o)*g,c+=(i[m+3+2]-c)*g;break;case 1:o=i[m+1],c=i[m+2];break;default:o=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}switch(d){case Y.setup:s.shearX=s.data.shearX+o*r,s.shearY=s.data.shearY+c*r;break;case Y.first:case Y.replace:s.shearX+=(s.data.shearX+o-s.shearX)*r,s.shearY+=(s.data.shearY+c-s.shearY)*r;break;case Y.add:s.shearX+=o*r,s.shearY+=c*r}}}class oe extends ot{constructor(t,n,e){super(t,n,`${j.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.shearX=s.data.shearX;return;case Y.first:s.shearX+=(s.data.shearX-s.shearX)*r}return}const o=this.getCurveValue(e);switch(d){case Y.setup:s.shearX=s.data.shearX+o*r;break;case Y.first:case Y.replace:s.shearX+=(s.data.shearX+o-s.shearX)*r;break;case Y.add:s.shearX+=o*r}}}class he extends ot{constructor(t,n,e){super(t,n,`${j.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,a,r,d,h){const s=t.bones[this.boneIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.shearY=s.data.shearY;return;case Y.first:s.shearY+=(s.data.shearY-s.shearY)*r}return}const o=this.getCurveValue(e);switch(d){case Y.setup:s.shearY=s.data.shearY+o*r;break;case Y.first:case Y.replace:s.shearY+=(s.data.shearY+o-s.shearY)*r;break;case Y.add:s.shearY+=o*r}}}class le extends rt{constructor(t,n,e){super(t,n,[`${j.rgb}|${e}`,`${j.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,n,e,a,r,d){t*=5,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,o=s.color;if(e<i[0]){const y=s.data.color;switch(d){case Y.setup:o.setFromColor(y);return;case Y.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let c=0,m=0,f=0,u=0;const g=H.search(i,e,5),w=this.curves[g/5];switch(w){case 0:const y=i[g];c=i[g+1],m=i[g+2],f=i[g+3],u=i[g+4];const p=(e-y)/(i[g+5]-y);c+=(i[g+5+1]-c)*p,m+=(i[g+5+2]-m)*p,f+=(i[g+5+3]-f)*p,u+=(i[g+5+4]-u)*p;break;case 1:c=i[g+1],m=i[g+2],f=i[g+3],u=i[g+4];break;default:c=this.getBezierValue(e,g,1,w-2),m=this.getBezierValue(e,g,2,w+18-2),f=this.getBezierValue(e,g,3,w+18*2-2),u=this.getBezierValue(e,g,4,w+18*3-2)}r==1?o.set(c,m,f,u):(d==Y.setup&&o.setFromColor(s.data.color),o.add((c-o.r)*r,(m-o.g)*r,(f-o.b)*r,(u-o.a)*r))}}class ce extends rt{constructor(t,n,e){super(t,n,[`${j.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,a,r){t<<=2,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,o=s.color;if(e<i[0]){const w=s.data.color;switch(d){case Y.setup:o.r=w.r,o.g=w.g,o.b=w.b;return;case Y.first:o.r+=(w.r-o.r)*r,o.g+=(w.g-o.g)*r,o.b+=(w.b-o.b)*r}return}let c=0,m=0,f=0;const u=H.search(i,e,4),g=this.curves[u>>2];switch(g){case 0:const w=i[u];c=i[u+1],m=i[u+2],f=i[u+3];const y=(e-w)/(i[u+4]-w);c+=(i[u+4+1]-c)*y,m+=(i[u+4+2]-m)*y,f+=(i[u+4+3]-f)*y;break;case 1:c=i[u+1],m=i[u+2],f=i[u+3];break;default:c=this.getBezierValue(e,u,1,g-2),m=this.getBezierValue(e,u,2,g+18-2),f=this.getBezierValue(e,u,3,g+18*2-2)}if(r==1)o.r=c,o.g=m,o.b=f;else{if(d==Y.setup){const w=s.data.color;o.r=w.r,o.g=w.g,o.b=w.b}o.r+=(c-o.r)*r,o.g+=(m-o.g)*r,o.b+=(f-o.b)*r}}}class de extends ot{constructor(t,n,e){super(t,n,`${j.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=s.color;if(e<this.frames[0]){const c=s.data.color;switch(d){case Y.setup:i.a=c.a;return;case Y.first:i.a+=(c.a-i.a)*r}return}const o=this.getCurveValue(e);r==1?i.a=o:(d==Y.setup&&(i.a=s.data.color.a),i.a+=(o-i.a)*r)}}class me extends rt{constructor(t,n,e){super(t,n,[`${j.rgb}|${e}`,`${j.alpha}|${e}`,`${j.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,n,e,a,r,d,h,s,i){t<<=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=s,this.frames[t+7]=i}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,o=s.color,c=s.darkColor;if(e<i[0]){const b=s.data.color,S=s.data.darkColor;switch(d){case Y.setup:o.setFromColor(b),c.r=S.r,c.g=S.g,c.b=S.b;return;case Y.first:o.add((b.r-o.r)*r,(b.g-o.g)*r,(b.b-o.b)*r,(b.a-o.a)*r),c.r+=(S.r-c.r)*r,c.g+=(S.g-c.g)*r,c.b+=(S.b-c.b)*r}return}let m=0,f=0,u=0,g=0,w=0,y=0,p=0;const k=H.search(i,e,8),x=this.curves[k>>3];switch(x){case 0:const b=i[k];m=i[k+1],f=i[k+2],u=i[k+3],g=i[k+4],w=i[k+5],y=i[k+6],p=i[k+7];const S=(e-b)/(i[k+8]-b);m+=(i[k+8+1]-m)*S,f+=(i[k+8+2]-f)*S,u+=(i[k+8+3]-u)*S,g+=(i[k+8+4]-g)*S,w+=(i[k+8+5]-w)*S,y+=(i[k+8+6]-y)*S,p+=(i[k+8+7]-p)*S;break;case 1:m=i[k+1],f=i[k+2],u=i[k+3],g=i[k+4],w=i[k+5],y=i[k+6],p=i[k+7];break;default:m=this.getBezierValue(e,k,1,x-2),f=this.getBezierValue(e,k,2,x+18-2),u=this.getBezierValue(e,k,3,x+18*2-2),g=this.getBezierValue(e,k,4,x+18*3-2),w=this.getBezierValue(e,k,5,x+18*4-2),y=this.getBezierValue(e,k,6,x+18*5-2),p=this.getBezierValue(e,k,7,x+18*6-2)}if(r==1)o.set(m,f,u,g),c.r=w,c.g=y,c.b=p;else{if(d==Y.setup){o.setFromColor(s.data.color);const b=s.data.darkColor;c.r=b.r,c.g=b.g,c.b=b.b}o.add((m-o.r)*r,(f-o.g)*r,(u-o.b)*r,(g-o.a)*r),c.r+=(w-c.r)*r,c.g+=(y-c.g)*r,c.b+=(p-c.b)*r}}}class ue extends rt{constructor(t,n,e){super(t,n,[`${j.rgb}|${e}`,`${j.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,a,r,d,h,s){t*=7,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d,this.frames[t+5]=h,this.frames[t+6]=s}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=this.frames,o=s.color,c=s.darkColor;if(e<i[0]){const x=s.data.color,b=s.data.darkColor;switch(d){case Y.setup:o.r=x.r,o.g=x.g,o.b=x.b,c.r=b.r,c.g=b.g,c.b=b.b;return;case Y.first:o.r+=(x.r-o.r)*r,o.g+=(x.g-o.g)*r,o.b+=(x.b-o.b)*r,c.r+=(b.r-c.r)*r,c.g+=(b.g-c.g)*r,c.b+=(b.b-c.b)*r}return}let m=0,f=0,u=0,g=0,w=0,y=0;const p=H.search(i,e,7),k=this.curves[p/7];switch(k){case 0:const x=i[p];m=i[p+1],f=i[p+2],u=i[p+3],g=i[p+4],w=i[p+5],y=i[p+6];const b=(e-x)/(i[p+7]-x);m+=(i[p+7+1]-m)*b,f+=(i[p+7+2]-f)*b,u+=(i[p+7+3]-u)*b,g+=(i[p+7+4]-g)*b,w+=(i[p+7+5]-w)*b,y+=(i[p+7+6]-y)*b;break;case 1:m=i[p+1],f=i[p+2],u=i[p+3],g=i[p+4],w=i[p+5],y=i[p+6];break;default:m=this.getBezierValue(e,p,1,k-2),f=this.getBezierValue(e,p,2,k+18-2),u=this.getBezierValue(e,p,3,k+18*2-2),g=this.getBezierValue(e,p,4,k+18*3-2),w=this.getBezierValue(e,p,5,k+18*4-2),y=this.getBezierValue(e,p,6,k+18*5-2)}if(r==1)o.r=m,o.g=f,o.b=u,c.r=g,c.g=w,c.b=y;else{if(d==Y.setup){const x=s.data.color,b=s.data.darkColor;o.r=x.r,o.g=x.g,o.b=x.b,c.r=b.r,c.g=b.g,c.b=b.b}o.r+=(m-o.r)*r,o.g+=(f-o.g)*r,o.b+=(u-o.b)*r,c.r+=(g-c.r)*r,c.g+=(w-c.g)*r,c.b+=(y-c.b)*r}}}class yt extends H{constructor(t,n){super(t,[`${j.attachment}|${n}`]),this.slotIndex=0,this.slotIndex=n,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(s.bone.active){if(h==st.mixOut){d==Y.setup&&this.setAttachment(t,s,s.data.attachmentName);return}if(e<this.frames[0]){(d==Y.setup||d==Y.first)&&this.setAttachment(t,s,s.data.attachmentName);return}this.setAttachment(t,s,this.attachmentNames[H.search1(this.frames,e)])}}setAttachment(t,n,e){n.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class fe extends rt{constructor(t,n,e,a){super(t,n,[`${j.deform}|${e}|${a.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=a,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.vertices[t]=e}setBezier(t,n,e,a,r,d,h,s,i,o,c){const m=this.curves;let f=this.getFrameCount()+t*18;e==0&&(m[n]=2+f);const u=(a-d*2+s)*.03,g=i*.03-h*.06,w=((d-s)*3-a+o)*.006,y=(h-i+.33333333)*.018;let p=u*2+w,k=g*2+y,x=(d-a)*.3+u+w*.16666667,b=h*.3+g+y*.16666667,S=a+x,A=b;for(let v=f+18;f<v;f+=2)m[f]=S,m[f+1]=A,x+=p,b+=k,p+=w,k+=y,S+=x,A+=b}getCurvePercent(t,n){const e=this.curves;let a=e[n];switch(a){case 0:const s=this.frames[n];return(t-s)/(this.frames[n+this.getFrameEntries()]-s);case 1:return 0}if(a-=2,e[a]>t){const s=this.frames[n];return e[a+1]*(t-s)/(e[a]-s)}const r=a+18;for(a+=2;a<r;a+=2)if(e[a]>=t){const s=e[a-2],i=e[a-1];return i+(t-s)/(e[a]-s)*(e[a+1]-i)}const d=e[r-2],h=e[r-1];return h+(1-h)*(t-d)/(this.frames[n+this.getFrameEntries()]-d)}apply(t,n,e,a,r,d,h){const s=t.slots[this.slotIndex];if(!s.bone.active)return;const i=s.getAttachment();if(!i||!(i instanceof it)||i.timelineAttachment!=this.attachment)return;const o=s.deform;o.length==0&&(d=Y.setup);const c=this.vertices,m=c[0].length,f=this.frames;if(e<f[0]){switch(d){case Y.setup:o.length=0;return;case Y.first:if(r==1){o.length=0;return}o.length=m;const p=i;if(p.bones){r=1-r;for(let k=0;k<m;k++)o[k]*=r}else{const k=p.vertices;for(let x=0;x<m;x++)o[x]+=(k[x]-o[x])*r}}return}if(o.length=m,e>=f[f.length-1]){const p=c[f.length-1];if(r==1)if(d==Y.add){const k=i;if(k.bones)for(let x=0;x<m;x++)o[x]+=p[x];else{const x=k.vertices;for(let b=0;b<m;b++)o[b]+=p[b]-x[b]}}else E.arrayCopy(p,0,o,0,m);else switch(d){case Y.setup:{const x=i;if(x.bones)for(let b=0;b<m;b++)o[b]=p[b]*r;else{const b=x.vertices;for(let S=0;S<m;S++){const A=b[S];o[S]=A+(p[S]-A)*r}}break}case Y.first:case Y.replace:for(let x=0;x<m;x++)o[x]+=(p[x]-o[x])*r;break;case Y.add:const k=i;if(k.bones)for(let x=0;x<m;x++)o[x]+=p[x]*r;else{const x=k.vertices;for(let b=0;b<m;b++)o[b]+=(p[b]-x[b])*r}}return}const u=H.search1(f,e),g=this.getCurvePercent(e,u),w=c[u],y=c[u+1];if(r==1)if(d==Y.add){const p=i;if(p.bones)for(let k=0;k<m;k++){const x=w[k];o[k]+=x+(y[k]-x)*g}else{const k=p.vertices;for(let x=0;x<m;x++){const b=w[x];o[x]+=b+(y[x]-b)*g-k[x]}}}else for(let p=0;p<m;p++){const k=w[p];o[p]=k+(y[p]-k)*g}else switch(d){case Y.setup:{const k=i;if(k.bones)for(let x=0;x<m;x++){const b=w[x];o[x]=(b+(y[x]-b)*g)*r}else{const x=k.vertices;for(let b=0;b<m;b++){const S=w[b],A=x[b];o[b]=A+(S+(y[b]-S)*g-A)*r}}break}case Y.first:case Y.replace:for(let k=0;k<m;k++){const x=w[k];o[k]+=(x+(y[k]-x)*g-o[k])*r}break;case Y.add:const p=i;if(p.bones)for(let k=0;k<m;k++){const x=w[k];o[k]+=(x+(y[k]-x)*g)*r}else{const k=p.vertices;for(let x=0;x<m;x++){const b=w[x];o[x]+=(b+(y[x]-b)*g-k[x])*r}}}}}const je=class extends H{constructor(l){super(l,je.propertyIds),this.events=new Array(l)}getFrameCount(){return this.frames.length}setFrame(l,t){this.frames[l]=t.time,this.events[l]=t}apply(l,t,n,e,a,r,d){if(!e)return;const h=this.frames,s=this.frames.length;if(t>n)this.apply(l,t,Number.MAX_VALUE,e,a,r,d),t=-1;else if(t>=h[s-1])return;if(n<h[0])return;let i=0;if(t<h[0])i=0;else{i=H.search1(h,t)+1;const o=h[i];for(;i>0&&h[i-1]==o;)i--}for(;i<s&&n>=h[i];i++)e.push(this.events[i])}};let Rt=je;Rt.propertyIds=[`${j.event}`];const Ge=class extends H{constructor(t){super(t,Ge.propertyIds),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.drawOrders[t]=e}apply(t,n,e,a,r,d,h){if(h==st.mixOut){d==Y.setup&&E.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(e<this.frames[0]){(d==Y.setup||d==Y.first)&&E.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const s=H.search1(this.frames,e),i=this.drawOrders[s];if(!i)E.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,c=t.slots;for(let m=0,f=i.length;m<f;m++)o[m]=c[i[m]]}}};let St=Ge;St.propertyIds=[`${j.drawOrder}`];class ge extends rt{constructor(t,n,e){super(t,n,[`${j.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,n,e,a,r,d,h){t*=6,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=a,this.frames[t+3]=r,this.frames[t+4]=d?1:0,this.frames[t+5]=h?1:0}apply(t,n,e,a,r,d,h){const s=t.ikConstraints[this.ikConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.mix=s.data.mix,s.softness=s.data.softness,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch;return;case Y.first:s.mix+=(s.data.mix-s.mix)*r,s.softness+=(s.data.softness-s.softness)*r,s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch}return}let o=0,c=0;const m=H.search(i,e,6),f=this.curves[m/6];switch(f){case 0:const u=i[m];o=i[m+1],c=i[m+2];const g=(e-u)/(i[m+6]-u);o+=(i[m+6+1]-o)*g,c+=(i[m+6+2]-c)*g;break;case 1:o=i[m+1],c=i[m+2];break;default:o=this.getBezierValue(e,m,1,f-2),c=this.getBezierValue(e,m,2,f+18-2)}d==Y.setup?(s.mix=s.data.mix+(o-s.data.mix)*r,s.softness=s.data.softness+(c-s.data.softness)*r,h==st.mixOut?(s.bendDirection=s.data.bendDirection,s.compress=s.data.compress,s.stretch=s.data.stretch):(s.bendDirection=i[m+3],s.compress=i[m+4]!=0,s.stretch=i[m+5]!=0)):(s.mix+=(o-s.mix)*r,s.softness+=(c-s.softness)*r,h==st.mixIn&&(s.bendDirection=i[m+3],s.compress=i[m+4]!=0,s.stretch=i[m+5]!=0))}}class pe extends rt{constructor(t,n,e){super(t,n,[`${j.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,a,r,d,h,s){const i=this.frames;t*=7,i[t]=n,i[t+1]=e,i[t+2]=a,i[t+3]=r,i[t+4]=d,i[t+5]=h,i[t+6]=s}apply(t,n,e,a,r,d,h){const s=t.transformConstraints[this.transformConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){const p=s.data;switch(d){case Y.setup:s.mixRotate=p.mixRotate,s.mixX=p.mixX,s.mixY=p.mixY,s.mixScaleX=p.mixScaleX,s.mixScaleY=p.mixScaleY,s.mixShearY=p.mixShearY;return;case Y.first:s.mixRotate+=(p.mixRotate-s.mixRotate)*r,s.mixX+=(p.mixX-s.mixX)*r,s.mixY+=(p.mixY-s.mixY)*r,s.mixScaleX+=(p.mixScaleX-s.mixScaleX)*r,s.mixScaleY+=(p.mixScaleY-s.mixScaleY)*r,s.mixShearY+=(p.mixShearY-s.mixShearY)*r}return}let o,c,m,f,u,g;const w=H.search(i,e,7),y=this.curves[w/7];switch(y){case 0:const p=i[w];o=i[w+1],c=i[w+2],m=i[w+3],f=i[w+4],u=i[w+5],g=i[w+6];const k=(e-p)/(i[w+7]-p);o+=(i[w+7+1]-o)*k,c+=(i[w+7+2]-c)*k,m+=(i[w+7+3]-m)*k,f+=(i[w+7+4]-f)*k,u+=(i[w+7+5]-u)*k,g+=(i[w+7+6]-g)*k;break;case 1:o=i[w+1],c=i[w+2],m=i[w+3],f=i[w+4],u=i[w+5],g=i[w+6];break;default:o=this.getBezierValue(e,w,1,y-2),c=this.getBezierValue(e,w,2,y+18-2),m=this.getBezierValue(e,w,3,y+18*2-2),f=this.getBezierValue(e,w,4,y+18*3-2),u=this.getBezierValue(e,w,5,y+18*4-2),g=this.getBezierValue(e,w,6,y+18*5-2)}if(d==Y.setup){const p=s.data;s.mixRotate=p.mixRotate+(o-p.mixRotate)*r,s.mixX=p.mixX+(c-p.mixX)*r,s.mixY=p.mixY+(m-p.mixY)*r,s.mixScaleX=p.mixScaleX+(f-p.mixScaleX)*r,s.mixScaleY=p.mixScaleY+(u-p.mixScaleY)*r,s.mixShearY=p.mixShearY+(g-p.mixShearY)*r}else s.mixRotate+=(o-s.mixRotate)*r,s.mixX+=(c-s.mixX)*r,s.mixY+=(m-s.mixY)*r,s.mixScaleX+=(f-s.mixScaleX)*r,s.mixScaleY+=(u-s.mixScaleY)*r,s.mixShearY+=(g-s.mixShearY)*r}}class xe extends ot{constructor(t,n,e){super(t,n,`${j.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,a,r,d,h){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.position=s.data.position;return;case Y.first:s.position+=(s.data.position-s.position)*r}return}const o=this.getCurveValue(e);d==Y.setup?s.position=s.data.position+(o-s.data.position)*r:s.position+=(o-s.position)*r}}class be extends ot{constructor(t,n,e){super(t,n,`${j.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,a,r,d,h){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.spacing=s.data.spacing;return;case Y.first:s.spacing+=(s.data.spacing-s.spacing)*r}return}const o=this.getCurveValue(e);d==Y.setup?s.spacing=s.data.spacing+(o-s.data.spacing)*r:s.spacing+=(o-s.spacing)*r}}class we extends rt{constructor(t,n,e){super(t,n,[`${j.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,a,r){const d=this.frames;t<<=2,d[t]=n,d[t+1]=e,d[t+2]=a,d[t+3]=r}apply(t,n,e,a,r,d,h){const s=t.pathConstraints[this.pathConstraintIndex];if(!s.active)return;const i=this.frames;if(e<i[0]){switch(d){case Y.setup:s.mixRotate=s.data.mixRotate,s.mixX=s.data.mixX,s.mixY=s.data.mixY;return;case Y.first:s.mixRotate+=(s.data.mixRotate-s.mixRotate)*r,s.mixX+=(s.data.mixX-s.mixX)*r,s.mixY+=(s.data.mixY-s.mixY)*r}return}let o,c,m;const f=H.search(i,e,4),u=this.curves[f>>2];switch(u){case 0:const g=i[f];o=i[f+1],c=i[f+2],m=i[f+3];const w=(e-g)/(i[f+4]-g);o+=(i[f+4+1]-o)*w,c+=(i[f+4+2]-c)*w,m+=(i[f+4+3]-m)*w;break;case 1:o=i[f+1],c=i[f+2],m=i[f+3];break;default:o=this.getBezierValue(e,f,1,u-2),c=this.getBezierValue(e,f,2,u+18-2),m=this.getBezierValue(e,f,3,u+18*2-2)}if(d==Y.setup){const g=s.data;s.mixRotate=g.mixRotate+(o-g.mixRotate)*r,s.mixX=g.mixX+(c-g.mixX)*r,s.mixY=g.mixY+(m-g.mixY)*r}else s.mixRotate+=(o-s.mixRotate)*r,s.mixX+=(c-s.mixX)*r,s.mixY+=(m-s.mixY)*r}}const kt=class extends H{constructor(l,t,n){super(l,[`${j.sequence}|${t}|${n.sequence.id}`]),this.slotIndex=t,this.attachment=n}getFrameEntries(){return kt.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(l,t,n,e,a){const r=this.frames;l*=kt.ENTRIES,r[l]=t,r[l+kt.MODE]=n|e<<4,r[l+kt.DELAY]=a}apply(l,t,n,e,a,r,d){const h=l.slots[this.slotIndex];if(!h.bone.active)return;const s=h.attachment,i=this.attachment;if(s!=i&&(!(s instanceof it)||s.timelineAttachment!=i))return;const o=this.frames;if(n<o[0]){(r==Y.setup||r==Y.first)&&(h.sequenceIndex=-1);return}const c=H.search(o,n,kt.ENTRIES),m=o[c],f=o[c+kt.MODE],u=o[c+kt.DELAY];if(!this.attachment.sequence)return;let g=f>>4;const w=this.attachment.sequence.regions.length,y=Zt[f&15];if(y!=ct.hold)switch(g+=(n-m)/u+1e-5|0,y){case ct.once:g=Math.min(w-1,g);break;case ct.loop:g%=w;break;case ct.pingpong:{const p=(w<<1)-2;g=p==0?0:g%p,g>=w&&(g=p-g);break}case ct.onceReverse:g=Math.max(w-1-g,0);break;case ct.loopReverse:g=w-1-g%w;break;case ct.pingpongReverse:{const p=(w<<1)-2;g=p==0?0:(g+w-1)%p,g>=w&&(g=p-g)}}h.sequenceIndex=g}};let vt=kt;vt.ENTRIES=3,vt.MODE=1,vt.DELAY=2;const dt=class{constructor(l){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new He(this),this.propertyIDs=new Oe,this.animationsChanged=!1,this.trackEntryPool=new is(()=>new Ut),this.data=l}static emptyAnimation(){return dt._emptyAnimation}update(l){l*=this.timeScale;const t=this.tracks;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(!a)continue;a.animationLast=a.nextAnimationLast,a.trackLast=a.nextTrackLast;let r=l*a.timeScale;if(a.delay>0){if(a.delay-=r,a.delay>0)continue;r=-a.delay,a.delay=0}let d=a.next;if(d){const h=a.trackLast-d.delay;if(h>=0){for(d.delay=0,d.trackTime+=a.timeScale==0?0:(h/a.timeScale+l)*d.timeScale,a.trackTime+=r,this.setCurrent(n,d,!0);d.mixingFrom;)d.mixTime+=l,d=d.mixingFrom;continue}}else if(a.trackLast>=a.trackEnd&&!a.mixingFrom){t[n]=null,this.queue.end(a),this.clearNext(a);continue}if(a.mixingFrom&&this.updateMixingFrom(a,l)){let h=a.mixingFrom;for(a.mixingFrom=null,h&&(h.mixingTo=null);h;)this.queue.end(h),h=h.mixingFrom}a.trackTime+=r}this.queue.drain()}updateMixingFrom(l,t){const n=l.mixingFrom;if(!n)return!0;const e=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,l.mixTime>0&&l.mixTime>=l.mixDuration?((n.totalAlpha==0||l.mixDuration==0)&&(l.mixingFrom=n.mixingFrom,n.mixingFrom&&(n.mixingFrom.mixingTo=l),l.interruptAlpha=n.interruptAlpha,this.queue.end(n)),e):(n.trackTime+=t*n.timeScale,l.mixTime+=t,!1)}apply(l){if(!l)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let e=!1;for(let d=0,h=n.length;d<h;d++){const s=n[d];if(!s||s.delay>0)continue;e=!0;const i=d==0?Y.first:s.mixBlend;let o=s.alpha;s.mixingFrom?o*=this.applyMixingFrom(s,l,i):s.trackTime>=s.trackEnd&&!s.next&&(o=0);const c=s.animationLast,m=s.getAnimationTime();let f=m,u=t;s.reverse&&(f=s.animation.duration-f,u=null);const g=s.animation.timelines,w=g.length;if(d==0&&o==1||i==Y.add)for(let y=0;y<w;y++){E.webkit602BugfixHelper(o,i);const p=g[y];p instanceof yt?this.applyAttachmentTimeline(p,l,f,i,!0):p.apply(l,c,f,u,o,i,st.mixIn)}else{const y=s.timelineMode,p=s.shortestRotation,k=!p&&s.timelinesRotation.length!=w<<1;k&&(s.timelinesRotation.length=w<<1);for(let x=0;x<w;x++){const b=g[x],S=y[x]==ke?i:Y.setup;!p&&b instanceof Et?this.applyRotateTimeline(b,l,f,o,S,s.timelinesRotation,x<<1,k):b instanceof yt?this.applyAttachmentTimeline(b,l,f,i,!0):(E.webkit602BugfixHelper(o,i),b.apply(l,c,f,u,o,S,st.mixIn))}}this.queueEvents(s,m),t.length=0,s.nextAnimationLast=m,s.nextTrackLast=s.trackTime}const a=this.unkeyedState+Qe,r=l.slots;for(let d=0,h=l.slots.length;d<h;d++){const s=r[d];if(s.attachmentState==a){const i=s.data.attachmentName;s.setAttachment(i?l.getAttachment(s.data.index,i):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(l,t,n){const e=l.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,n);let a=0;l.mixDuration==0?(a=1,n==Y.first&&(n=Y.setup)):(a=l.mixTime/l.mixDuration,a>1&&(a=1),n!=Y.first&&(n=e.mixBlend));const r=a<e.attachmentThreshold,d=a<e.drawOrderThreshold,h=e.animation.timelines,s=h.length,i=e.alpha*l.interruptAlpha,o=i*(1-a),c=e.animationLast,m=e.getAnimationTime();let f=m,u=null;if(e.reverse?f=e.animation.duration-f:a<e.eventThreshold&&(u=this.events),n==Y.add)for(let g=0;g<s;g++)h[g].apply(t,c,f,u,o,n,st.mixOut);else{const g=e.timelineMode,w=e.timelineHoldMix,y=e.shortestRotation,p=!y&&e.timelinesRotation.length!=s<<1;p&&(e.timelinesRotation.length=s<<1),e.totalAlpha=0;for(let k=0;k<s;k++){const x=h[k];let b=st.mixOut,S,A=0;switch(g[k]){case ke:if(!d&&x instanceof St)continue;S=n,A=o;break;case Ke:S=Y.setup,A=o;break;case Je:S=n,A=i;break;case ye:S=Y.setup,A=i;break;default:S=Y.setup;const v=w[k];A=i*Math.max(0,1-v.mixTime/v.mixDuration);break}e.totalAlpha+=A,!y&&x instanceof Et?this.applyRotateTimeline(x,t,f,A,S,e.timelinesRotation,k<<1,p):x instanceof yt?this.applyAttachmentTimeline(x,t,f,S,r):(E.webkit602BugfixHelper(A,n),d&&x instanceof St&&S==Y.setup&&(b=st.mixIn),x.apply(t,c,f,u,A,S,b))}}return l.mixDuration>0&&this.queueEvents(e,m),this.events.length=0,e.nextAnimationLast=m,e.nextTrackLast=e.trackTime,a}applyAttachmentTimeline(l,t,n,e,a){const r=t.slots[l.slotIndex];r.bone.active&&(n<l.frames[0]?(e==Y.setup||e==Y.first)&&this.setAttachment(t,r,r.data.attachmentName,a):this.setAttachment(t,r,l.attachmentNames[H.search1(l.frames,n)],a),r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+Qe))}setAttachment(l,t,n,e){t.setAttachment(n?l.getAttachment(t.data.index,n):null),e&&(t.attachmentState=this.unkeyedState+ms)}applyRotateTimeline(l,t,n,e,a,r,d,h){if(h&&(r[d]=0),e==1){l.apply(t,0,n,null,1,a,st.mixIn);return}const s=t.bones[l.boneIndex];if(!s.active)return;const i=l.frames;let o=0,c=0;if(n<i[0])switch(a){case Y.setup:s.rotation=s.data.rotation;default:return;case Y.first:o=s.rotation,c=s.data.rotation}else o=a==Y.setup?s.data.rotation:s.rotation,c=s.data.rotation+l.getCurveValue(n);let m=0,f=c-o;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)m=r[d];else{let u=0,g=0;h?(u=0,g=f):(u=r[d],g=r[d+1]);const w=f>0;let y=u>=0;X.signum(g)!=X.signum(f)&&Math.abs(g)<=90&&(Math.abs(u)>180&&(u+=360*X.signum(u)),y=w),m=f+u-u%360,y!=w&&(m+=360*X.signum(u)),r[d]=m}r[d+1]=f,s.rotation=o+m*e}queueEvents(l,t){const n=l.animationStart,e=l.animationEnd,a=e-n,r=l.trackLast%a,d=this.events;let h=0;const s=d.length;for(;h<s;h++){const o=d[h];if(o.time<r)break;o.time>e||this.queue.event(l,o)}let i=!1;for(l.loop?i=a==0||r>l.trackTime%a:i=t>=e&&l.animationLast<e,i&&this.queue.complete(l);h<s;h++){const o=d[h];o.time<n||this.queue.event(l,o)}}clearTracks(){const l=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=l,this.queue.drain()}clearTrack(l){if(l>=this.tracks.length)return;const t=this.tracks[l];if(!t)return;this.queue.end(t),this.clearNext(t);let n=t;for(;;){const e=n.mixingFrom;if(!e)break;this.queue.end(e),n.mixingFrom=null,n.mixingTo=null,n=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(l,t,n){const e=this.expandToIndex(l);this.tracks[l]=t,t.previous=null,e&&(n&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(l,t,n=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(l,e,n)}setAnimationWith(l,t,n=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,a=this.expandToIndex(l);a&&(a.nextTrackLast==-1?(this.tracks[l]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.clearNext(a),a=a.mixingFrom,e=!1):this.clearNext(a));const r=this.trackEntry(l,t,n,a);return this.setCurrent(l,r,e),this.queue.drain(),r}addAnimation(l,t,n=!1,e=0){const a=this.data.skeletonData.findAnimation(t);if(!a)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(l,a,n,e)}addAnimationWith(l,t,n=!1,e=0){if(!t)throw new Error("animation cannot be null.");let a=this.expandToIndex(l);if(a)for(;a.next;)a=a.next;const r=this.trackEntry(l,t,n,a);return a?(a.next=r,r.previous=a,e<=0&&(e+=a.getTrackComplete()-r.mixDuration)):(this.setCurrent(l,r,!0),this.queue.drain()),r.delay=e,r}setEmptyAnimation(l,t=0){const n=this.setAnimationWith(l,dt.emptyAnimation(),!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(l,t=0,n=0){const e=this.addAnimationWith(l,dt.emptyAnimation(),!1,n);return n<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(l=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++){const a=this.tracks[n];a&&this.setEmptyAnimation(a.trackIndex,l)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(l){return l<this.tracks.length?this.tracks[l]:(E.ensureArrayCapacity(this.tracks,l+1,null),this.tracks.length=l+1,null)}trackEntry(l,t,n,e){const a=this.trackEntryPool.obtain();return a.reset(),a.trackIndex=l,a.animation=t,a.loop=n,a.holdPrevious=!1,a.reverse=!1,a.shortestRotation=!1,a.eventThreshold=0,a.attachmentThreshold=0,a.drawOrderThreshold=0,a.animationStart=0,a.animationEnd=t.duration,a.animationLast=-1,a.nextAnimationLast=-1,a.delay=0,a.trackTime=0,a.trackLast=-1,a.nextTrackLast=-1,a.trackEnd=Number.MAX_VALUE,a.timeScale=1,a.alpha=1,a.mixTime=0,a.mixDuration=e?this.data.getMix(e.animation,t):0,a.interruptAlpha=1,a.totalAlpha=0,a.mixBlend=Y.replace,a}clearNext(l){let t=l.next;for(;t;)this.queue.dispose(t),t=t.next;l.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const l=this.tracks;for(let t=0,n=l.length;t<n;t++){let e=l[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=Y.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(l){const t=l.mixingTo,n=l.animation.timelines,e=l.animation.timelines.length,a=l.timelineMode;a.length=e;const r=l.timelineHoldMix;r.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let h=0;h<e;h++)a[h]=d.addAll(n[h].getPropertyIds())?ye:Je;return}t:for(let h=0;h<e;h++){const s=n[h],i=s.getPropertyIds();if(!d.addAll(i))a[h]=ke;else if(!t||s instanceof yt||s instanceof St||s instanceof Rt||!t.animation.hasTimeline(i))a[h]=Ke;else{for(let o=t.mixingTo;o;o=o.mixingTo)if(!o.animation.hasTimeline(i)){if(l.mixDuration>0){a[h]=ds,r[h]=o;continue t}break}a[h]=ye}}}getCurrent(l){return l>=this.tracks.length?null:this.tracks[l]}addListener(l){if(!l)throw new Error("listener cannot be null.");this.listeners.push(l)}removeListener(l){const t=this.listeners.indexOf(l);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(l,t,n){dt.deprecatedWarning1||(dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(l,t,n)}addAnimationByName(l,t,n,e){dt.deprecatedWarning2||(dt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(l,t,n,e)}hasAnimation(l){return this.data.skeletonData.findAnimation(l)!==null}hasAnimationByName(l){return dt.deprecatedWarning3||(dt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(l)}};let Mt=dt;Mt._emptyAnimation=new Wt("<empty>",[],0),Mt.deprecatedWarning1=!1,Mt.deprecatedWarning2=!1,Mt.deprecatedWarning3=!1;const pt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=Y.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return pt.deprecatedWarning1||(pt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){pt.deprecatedWarning1||(pt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return pt.deprecatedWarning2||(pt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){pt.deprecatedWarning2||(pt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Ut=pt;Ut.deprecatedWarning1=!1,Ut.deprecatedWarning2=!1;class He{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(Z.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(Z.interrupt),this.objects.push(t)}end(t){this.objects.push(Z.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(Z.dispose),this.objects.push(t)}complete(t){this.objects.push(Z.complete),this.objects.push(t)}event(t,n){this.objects.push(Z.event),this.objects.push(t),this.objects.push(n)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const a=t[e],r=t[e+1];switch(a){case Z.start:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<n.length;h++){const s=n[h];s.start&&s.start(r)}break;case Z.interrupt:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<n.length;h++){const s=n[h];s.interrupt&&s.interrupt(r)}break;case Z.end:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<n.length;h++){const s=n[h];s.end&&s.end(r)}case Z.dispose:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<n.length;h++){const s=n[h];s.dispose&&s.dispose(r)}this.animState.trackEntryPool.free(r);break;case Z.complete:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<n.length;h++){const s=n[h];s.complete&&s.complete(r)}break;case Z.event:const d=t[e+++2];r.listener&&r.listener.event&&r.listener.event(r,d);for(let h=0;h<n.length;h++){const s=n[h];s.event&&s.event(r,d)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var Z=(l=>(l[l.start=0]="start",l[l.interrupt=1]="interrupt",l[l.end=2]="end",l[l.dispose=3]="dispose",l[l.complete=4]="complete",l[l.event=5]="event",l))(Z||{});class cs{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const ke=0,Ke=1,Je=2,ye=3,ds=4,Qe=1,ms=2;class Ze{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const a=this.skeletonData.findAnimation(t);if(!a)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(n);if(!r)throw new Error(`Animation not found: ${n}`);this.setMixWith(a,r,e)}setMixWith(t,n,e){if(!t)throw new Error("from cannot be null.");if(!n)throw new Error("to cannot be null.");const a=`${t.name}.${n.name}`;this.animationToMixTime[a]=e}getMix(t,n){const e=`${t.name}.${n.name}`,a=this.animationToMixTime[e];return a===void 0?this.defaultMix:a}}class us{constructor(t){this.atlas=t}loadSequence(t,n,e){const a=e.regions;for(let r=0,d=a.length;r<d;r++){const h=e.getPath(n,r),s=this.atlas.findRegion(h);if(s==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);a[r]=s,a[r].renderObject=a[r]}}newRegionAttachment(t,n,e,a){const r=new U(n,e);if(a!=null)this.loadSequence(n,e,a);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);d.renderObject=d,r.region=d}return r}newMeshAttachment(t,n,e,a){const r=new It(n,e);if(a!=null)this.loadSequence(n,e,a);else{const d=this.atlas.findRegion(e);if(!d)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);d.renderObject=d,r.region=d}return r}newBoundingBoxAttachment(t,n){return new _t(n)}newPathAttachment(t,n){return new At(n)}newPointAttachment(t,n){return new Gt(n)}newClippingAttachment(t,n){return new jt(n)}}class Se{constructor(t,n,e){if(this.matrix=new ls,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,a,r,d,h){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=a,this.ascaleY=r,this.ashearX=d,this.ashearY=h;const s=this.parent,i=this.matrix,o=this.skeleton.scaleX,c=Tt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!s){const w=this.skeleton,y=e+90+h;i.a=X.cosDeg(e+d)*a*o,i.c=X.cosDeg(y)*r*o,i.b=X.sinDeg(e+d)*a*c,i.d=X.sinDeg(y)*r*c,i.tx=t*o+w.x,i.ty=n*c+w.y;return}let m=s.matrix.a,f=s.matrix.c,u=s.matrix.b,g=s.matrix.d;switch(i.tx=m*t+f*n+s.matrix.tx,i.ty=u*t+g*n+s.matrix.ty,this.data.transformMode){case nt.Normal:{const w=e+90+h,y=X.cosDeg(e+d)*a,p=X.cosDeg(w)*r,k=X.sinDeg(e+d)*a,x=X.sinDeg(w)*r;i.a=m*y+f*k,i.c=m*p+f*x,i.b=u*y+g*k,i.d=u*p+g*x;return}case nt.OnlyTranslation:{const w=e+90+h;i.a=X.cosDeg(e+d)*a,i.c=X.cosDeg(w)*r,i.b=X.sinDeg(e+d)*a,i.d=X.sinDeg(w)*r;break}case nt.NoRotationOrReflection:{let w=m*m+u*u,y=0;w>1e-4?(w=Math.abs(m*g-f*u)/w,m/=o,u/=c,f=u*w,g=m*w,y=Math.atan2(u,m)*X.radDeg):(m=0,u=0,y=90-Math.atan2(g,f)*X.radDeg);const p=e+d-y,k=e+h-y+90,x=X.cosDeg(p)*a,b=X.cosDeg(k)*r,S=X.sinDeg(p)*a,A=X.sinDeg(k)*r;i.a=m*x-f*S,i.c=m*b-f*A,i.b=u*x+g*S,i.d=u*b+g*A;break}case nt.NoScale:case nt.NoScaleOrReflection:{const w=X.cosDeg(e),y=X.sinDeg(e);let p=(m*w+f*y)/o,k=(u*w+g*y)/c,x=Math.sqrt(p*p+k*k);x>1e-5&&(x=1/x),p*=x,k*=x,x=Math.sqrt(p*p+k*k),this.data.transformMode==nt.NoScale&&m*g-f*u<0!=(o<0!=c<0)&&(x=-x);const b=Math.PI/2+Math.atan2(k,p),S=Math.cos(b)*x,A=Math.sin(b)*x,v=X.cosDeg(d)*a,C=X.cosDeg(90+h)*r,M=X.sinDeg(d)*a,F=X.sinDeg(90+h)*r;i.a=p*v+S*M,i.c=p*C+S*F,i.b=k*v+A*M,i.d=k*C+A*F;break}}i.a*=o,i.c*=o,i.b*=c,i.d*=c}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*X.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*X.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,n=this.matrix;if(!t){this.ax=n.tx-this.skeleton.x,this.ay=n.ty-this.skeleton.y,this.arotation=Math.atan2(n.b,n.a)*X.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*X.radDeg;return}const e=t.matrix,a=1/(e.a*e.d-e.b*e.c),r=n.tx-e.tx,d=n.ty-e.ty;this.ax=r*e.d*a-d*e.c*a,this.ay=d*e.a*a-r*e.b*a;const h=a*e.d,s=a*e.a,i=a*e.c,o=a*e.b,c=h*n.a-i*n.b,m=h*n.c-i*n.d,f=s*n.b-o*n.a,u=s*n.d-o*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(c*c+f*f),this.ascaleX>1e-4){const g=c*u-m*f;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(c*m+f*u,g)*X.radDeg,this.arotation=Math.atan2(f,c)*X.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(m*m+u*u),this.ashearY=0,this.arotation=90-Math.atan2(u,m)*X.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,a=n.c,r=n.b,d=n.d,h=1/(e*d-a*r),s=t.x-n.tx,i=t.y-n.ty;return t.x=s*d*h-i*a*h,t.y=i*e*h-s*r*h,t}localToWorld(t){const n=this.matrix,e=t.x,a=t.y;return t.x=e*n.a+a*n.c+n.tx,t.y=e*n.b+a*n.d+n.ty,t}worldToLocalRotation(t){const n=X.sinDeg(t),e=X.cosDeg(t),a=this.matrix;return Math.atan2(a.a*n-a.b*e,a.d*e-a.c*n)*X.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const n=X.sinDeg(t),e=X.cosDeg(t),a=this.matrix;return Math.atan2(e*a.b+n*a.d,e*a.a+n*a.c)*X.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,a=n.c,r=n.b,d=n.d,h=X.cosDeg(t),s=X.sinDeg(t);n.a=h*e-s*r,n.c=h*a-s*d,n.b=s*e+h*r,n.d=s*a+h*d}}class Ae{constructor(t,n,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=nt.Normal,this.skinRequired=!1,this.color=new L,t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}}class Ot{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}}class Ie{constructor(t,n){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!n)throw new Error("data cannot be null.");this.time=t,this.data=n}}class Ye{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class ts{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let a=0;a<t.bones.length;a++){const r=n.findBone(t.bones[a].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[a].name}`);this.bones.push(r)}const e=n.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,n,e,a,r,d,h){const s=t.parent.matrix;if(!s)throw new Error("IK bone must have parent.");const i=s.a;let o=s.c;const c=s.b;let m=s.d,f=-t.ashearX-t.arotation,u=0,g=0;const w=t.skeleton.scaleX,y=Tt.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case nt.OnlyTranslation:u=n-t.worldX,g=e-t.worldY,Tt.yDown&&(g=-g);break;case nt.NoRotationOrReflection:const x=Math.abs(i*m-o*c)/(i*i+c*c),b=i/w,S=c/y;o=-S*x*w,m=b*x*y,f+=Math.atan2(S,b)*X.radDeg;default:const A=n-s.tx,v=e-s.ty,C=i*m-o*c;u=(A*m-v*o)/C-t.ax,g=(v*i-A*c)/C-t.ay}f+=Math.atan2(g,u)*X.radDeg,t.ascaleX<0&&(f+=180),f>180?f-=360:f<-180&&(f+=360);let p=t.ascaleX,k=t.ascaleY;if(a||r){switch(t.data.transformMode){case nt.NoScale:case nt.NoScaleOrReflection:u=n-t.worldX,g=e-t.worldY}const x=t.data.length*p,b=Math.sqrt(u*u+g*g);if(a&&b<x||r&&b>x&&x>1e-4){const S=(b/x-1)*h+1;p*=S,d&&(k*=S)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+f*h,p,k,t.ashearX,t.ashearY)}apply2(t,n,e,a,r,d,h,s,i){const o=t.ax,c=t.ay;let m=t.ascaleX,f=t.ascaleY,u=m,g=f,w=n.ascaleX;const y=t.matrix;let p=0,k=0,x=0;m<0?(m=-m,p=180,x=-1):(p=0,x=1),f<0&&(f=-f,x=-x),w<0?(w=-w,k=180):k=0;const b=n.ax;let S=0,A=0,v=0,C=y.a,M=y.c,F=y.b,T=y.d;const B=Math.abs(m-f)<=1e-4;!B||d?(S=0,A=C*b+y.tx,v=F*b+y.ty):(S=n.ay,A=C*b+M*S+y.tx,v=F*b+T*S+y.ty);const R=t.parent.matrix;if(!R)throw new Error("IK parent must itself have a parent.");C=R.a,M=R.c,F=R.b,T=R.d;const q=1/(C*T-M*F);let V=A-R.tx,D=v-R.ty;const N=(V*T-D*M)*q-o,z=(D*C-V*F)*q-c,_=Math.sqrt(N*N+z*z);let J=n.data.length*w,P,$;if(_<1e-4){this.apply1(t,e,a,!1,d,!1,i),n.updateWorldTransformWith(b,S,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}V=e-R.tx,D=a-R.ty;let G=(V*T-D*M)*q-o,tt=(D*C-V*F)*q-c,at=G*G+tt*tt;if(s!=0){s*=m*(w+1)*.5;const Q=Math.sqrt(at),ut=Q-_-J*m+s;if(ut>0){let ft=Math.min(1,ut/(s*2))-1;ft=(ut-s*(1-ft*ft))/Q,G-=ft*G,tt-=ft*tt,at=G*G+tt*tt}}t:if(B){J*=m;let Q=(at-_*_-J*J)/(2*_*J);Q<-1?(Q=-1,$=Math.PI*r):Q>1?(Q=1,$=0,d&&(C=(Math.sqrt(at)/(_+J)-1)*i+1,u*=C,h&&(g*=C))):$=Math.acos(Q)*r,C=_+J*Q,M=J*Math.sin($),P=Math.atan2(tt*C-G*M,G*C+tt*M)}else{C=m*J,M=f*J;const Q=C*C,ut=M*M,ft=Math.atan2(tt,G);F=ut*_*_+Q*at-Q*ut;const Vt=-2*ut*_,Pe=ut-Q;if(T=Vt*Vt-4*Pe*F,T>=0){let Yt=Math.sqrt(T);Vt<0&&(Yt=-Yt),Yt=-(Vt+Yt)*.5;const Ne=Yt/Pe,Ue=F/Yt,Ct=Math.abs(Ne)<Math.abs(Ue)?Ne:Ue;if(Ct*Ct<=at){D=Math.sqrt(at-Ct*Ct)*r,P=ft-Math.atan2(D,Ct),$=Math.atan2(D/f,(Ct-_)/m);break t}}let $e=X.PI,Pt=_-C,Ht=Pt*Pt,qe=0,Le=0,$t=_+C,Kt=$t*$t,We=0;F=-C*_/(Q-ut),F>=-1&&F<=1&&(F=Math.acos(F),V=C*Math.cos(F)+_,D=M*Math.sin(F),T=V*V+D*D,T<Ht&&($e=F,Ht=T,Pt=V,qe=D),T>Kt&&(Le=F,Kt=T,$t=V,We=D)),at<=(Ht+Kt)*.5?(P=ft-Math.atan2(qe*r,Pt),$=$e*r):(P=ft-Math.atan2(We*r,$t),$=Le*r)}const Ve=Math.atan2(S,b)*x;let Xt=t.arotation;P=(P-Ve)*X.radDeg+p-Xt,P>180?P-=360:P<-180&&(P+=360),t.updateWorldTransformWith(o,c,Xt+P*i,u,g,0,0),Xt=n.arotation,$=(($+Ve)*X.radDeg-n.ashearX)*x+k-Xt,$>180?$-=360:$<-180&&($+=360),n.updateWorldTransformWith(b,S,Xt+$*i,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class Ce extends Ot{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ve extends Ot{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=wt.Fixed,this.spacingMode=K.Fixed,this.rotateMode=Bt.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var K=(l=>(l[l.Length=0]="Length",l[l.Fixed=1]="Fixed",l[l.Percent=2]="Percent",l[l.Proportional=3]="Proportional",l))(K||{});const xt=class{constructor(l,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!l)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=l,this.bones=new Array;for(let e=0,a=l.bones.length;e<a;e++){const r=t.findBone(l.bones[e].name);if(!r)throw new Error(`Couldn't find bone ${l.bones[e].name}.`);this.bones.push(r)}const n=t.findSlot(l.target.name);if(!n)throw new Error(`Couldn't find target bone ${l.target.name}`);this.target=n,this.position=l.position,this.spacing=l.spacing,this.mixRotate=l.mixRotate,this.mixX=l.mixX,this.mixY=l.mixY}isActive(){return this.active}update(){const l=this.target.getAttachment();if(!(l instanceof At))return;const t=this.mixRotate,n=this.mixX,e=this.mixY;if(t==0&&n==0&&e==0)return;const a=this.data,r=a.rotateMode==Bt.Tangent,d=a.rotateMode==Bt.ChainScale,h=this.bones,s=h.length,i=r?s:s+1,o=E.setArraySize(this.spaces,i),c=d?this.lengths=E.setArraySize(this.lengths,s):[],m=this.spacing;switch(a.spacingMode){case K.Percent:if(d)for(let x=0,b=i-1;x<b;x++){const S=h[x],A=S.data.length;if(A<xt.epsilon)c[x]=0;else{const v=A*S.matrix.a,C=A*S.matrix.b;c[x]=Math.sqrt(v*v+C*C)}}E.arrayFill(o,1,i,m);break;case K.Proportional:let p=0;for(let x=0,b=i-1;x<b;){const S=h[x],A=S.data.length;if(A<xt.epsilon)d&&(c[x]=0),o[++x]=m;else{const v=A*S.matrix.a,C=A*S.matrix.b,M=Math.sqrt(v*v+C*C);d&&(c[x]=M),o[++x]=M,p+=M}}if(p>0){p=i/p*m;for(let x=1;x<i;x++)o[x]*=p}break;default:const k=a.spacingMode==K.Length;for(let x=0,b=i-1;x<b;){const S=h[x],A=S.data.length;if(A<xt.epsilon)d&&(c[x]=0),o[++x]=m;else{const v=A*S.matrix.a,C=A*S.matrix.b,M=Math.sqrt(v*v+C*C);d&&(c[x]=M),o[++x]=(k?A+m:m)*M/A}}}const f=this.computeWorldPositions(l,i,r);let u=f[0],g=f[1],w=a.offsetRotation,y=!1;if(w==0)y=a.rotateMode==Bt.Chain;else{y=!1;const p=this.target.bone.matrix;w*=p.a*p.d-p.b*p.c>0?X.degRad:-X.degRad}for(let p=0,k=3;p<s;p++,k+=3){const x=h[p],b=x.matrix;b.tx+=(u-b.tx)*n,b.ty+=(g-b.ty)*e;const S=f[k],A=f[k+1],v=S-u,C=A-g;if(d){const M=c[p];if(M!=0){const F=(Math.sqrt(v*v+C*C)/M-1)*t+1;b.a*=F,b.b*=F}}if(u=S,g=A,t>0){const M=b.a,F=b.c,T=b.b,B=b.d;let R=0,q=0,V=0;if(r?R=f[k-1]:o[p+1]==0?R=f[k+2]:R=Math.atan2(C,v),R-=Math.atan2(T,M),y){q=Math.cos(R),V=Math.sin(R);const D=x.data.length;u+=(D*(q*M-V*T)-v)*t,g+=(D*(V*M+q*T)-C)*t}else R+=w;R>X.PI?R-=X.PI2:R<-X.PI&&(R+=X.PI2),R*=t,q=Math.cos(R),V=Math.sin(R),b.a=q*M-V*T,b.c=q*F-V*B,b.b=V*M+q*T,b.d=V*F+q*B}x.updateAppliedTransform()}}computeWorldPositions(l,t,n){const e=this.target;let a=this.position;const r=this.spaces,d=E.setArraySize(this.positions,t*3+2);let h=this.world;const s=l.closed;let i=l.worldVerticesLength,o=i/6,c=xt.NONE;if(!l.constantSpeed){const D=l.lengths;o-=s?1:2;const N=D[o];this.data.positionMode==wt.Percent&&(a*=N);let z;switch(this.data.spacingMode){case K.Percent:z=N;break;case K.Proportional:z=N/t;break;default:z=1}h=E.setArraySize(this.world,8);for(let _=0,J=0,P=0;_<t;_++,J+=3){const $=r[_]*z;a+=$;let G=a;if(s)G%=N,G<0&&(G+=N),P=0;else if(G<0){c!=xt.BEFORE&&(c=xt.BEFORE,l.computeWorldVertices(e,2,4,h,0,2)),this.addBeforePosition(G,h,0,d,J);continue}else if(G>N){c!=xt.AFTER&&(c=xt.AFTER,l.computeWorldVertices(e,i-6,4,h,0,2)),this.addAfterPosition(G-N,h,0,d,J);continue}for(;;P++){const tt=D[P];if(!(G>tt)){if(P==0)G/=tt;else{const at=D[P-1];G=(G-at)/(tt-at)}break}}P!=c&&(c=P,s&&P==o?(l.computeWorldVertices(e,i-4,4,h,0,2),l.computeWorldVertices(e,0,4,h,4,2)):l.computeWorldVertices(e,P*6+2,8,h,0,2)),this.addCurvePosition(G,h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],d,J,n||_>0&&$==0)}return d}s?(i+=2,h=E.setArraySize(this.world,i),l.computeWorldVertices(e,2,i-4,h,0,2),l.computeWorldVertices(e,0,2,h,i-4,2),h[i-2]=h[0],h[i-1]=h[1]):(o--,i-=4,h=E.setArraySize(this.world,i),l.computeWorldVertices(e,2,i,h,0,2));const m=E.setArraySize(this.curves,o);let f=0,u=h[0],g=h[1],w=0,y=0,p=0,k=0,x=0,b=0,S=0,A=0,v=0,C=0,M=0,F=0,T=0,B=0;for(let D=0,N=2;D<o;D++,N+=6)w=h[N],y=h[N+1],p=h[N+2],k=h[N+3],x=h[N+4],b=h[N+5],S=(u-w*2+p)*.1875,A=(g-y*2+k)*.1875,v=((w-p)*3-u+x)*.09375,C=((y-k)*3-g+b)*.09375,M=S*2+v,F=A*2+C,T=(w-u)*.75+S+v*.16666667,B=(y-g)*.75+A+C*.16666667,f+=Math.sqrt(T*T+B*B),T+=M,B+=F,M+=v,F+=C,f+=Math.sqrt(T*T+B*B),T+=M,B+=F,f+=Math.sqrt(T*T+B*B),T+=M+v,B+=F+C,f+=Math.sqrt(T*T+B*B),m[D]=f,u=x,g=b;this.data.positionMode==wt.Percent&&(a*=f);let R;switch(this.data.spacingMode){case K.Percent:R=f;break;case K.Proportional:R=f/t;break;default:R=1}const q=this.segments;let V=0;for(let D=0,N=0,z=0,_=0;D<t;D++,N+=3){const J=r[D]*R;a+=J;let P=a;if(s)P%=f,P<0&&(P+=f),z=0;else if(P<0){this.addBeforePosition(P,h,0,d,N);continue}else if(P>f){this.addAfterPosition(P-f,h,i-4,d,N);continue}for(;;z++){const $=m[z];if(!(P>$)){if(z==0)P/=$;else{const G=m[z-1];P=(P-G)/($-G)}break}}if(z!=c){c=z;let $=z*6;for(u=h[$],g=h[$+1],w=h[$+2],y=h[$+3],p=h[$+4],k=h[$+5],x=h[$+6],b=h[$+7],S=(u-w*2+p)*.03,A=(g-y*2+k)*.03,v=((w-p)*3-u+x)*.006,C=((y-k)*3-g+b)*.006,M=S*2+v,F=A*2+C,T=(w-u)*.3+S+v*.16666667,B=(y-g)*.3+A+C*.16666667,V=Math.sqrt(T*T+B*B),q[0]=V,$=1;$<8;$++)T+=M,B+=F,M+=v,F+=C,V+=Math.sqrt(T*T+B*B),q[$]=V;T+=M,B+=F,V+=Math.sqrt(T*T+B*B),q[8]=V,T+=M+v,B+=F+C,V+=Math.sqrt(T*T+B*B),q[9]=V,_=0}for(P*=V;;_++){const $=q[_];if(!(P>$)){if(_==0)P/=$;else{const G=q[_-1];P=_+(P-G)/($-G)}break}}this.addCurvePosition(P*.1,u,g,w,y,p,k,x,b,d,N,n||D>0&&J==0)}return d}addBeforePosition(l,t,n,e,a){const r=t[n],d=t[n+1],h=t[n+2]-r,s=t[n+3]-d,i=Math.atan2(s,h);e[a]=r+l*Math.cos(i),e[a+1]=d+l*Math.sin(i),e[a+2]=i}addAfterPosition(l,t,n,e,a){const r=t[n+2],d=t[n+3],h=r-t[n],s=d-t[n+1],i=Math.atan2(s,h);e[a]=r+l*Math.cos(i),e[a+1]=d+l*Math.sin(i),e[a+2]=i}addCurvePosition(l,t,n,e,a,r,d,h,s,i,o,c){if(l==0||isNaN(l)){i[o]=t,i[o+1]=n,i[o+2]=Math.atan2(a-n,e-t);return}const m=l*l,f=m*l,u=1-l,g=u*u,w=g*u,y=u*l,p=y*3,k=u*p,x=p*l,b=t*w+e*k+r*x+h*f,S=n*w+a*k+d*x+s*f;i[o]=b,i[o+1]=S,c&&(l<.001?i[o+2]=Math.atan2(a-n,e-t):i[o+2]=Math.atan2(S-(n*g+a*y*2+d*m),b-(t*g+e*y*2+r*m)))}};let Ft=xt;Ft.NONE=-1,Ft.BEFORE=-2,Ft.AFTER=-3,Ft.epsilon=1e-5;class es{constructor(t,n){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!n)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new L,this.darkColor=t.darkColor?new L:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof it)||!(this.attachment instanceof it)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class ss{constructor(t,n){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new Jt,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let a=0;a<t.bones.length;a++){const r=n.findBone(t.bones[a].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[a].name}.`);this.bones.push(r)}const e=n.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=n!=0||e!=0,s=this.target,i=s.matrix,o=i.a,c=i.c,m=i.b,f=i.d,u=o*f-c*m>0?X.degRad:-X.degRad,g=this.data.offsetRotation*u,w=this.data.offsetShearY*u,y=this.bones;for(let p=0,k=y.length;p<k;p++){const x=y[p],b=x.matrix;if(t!=0){const S=b.a,A=b.c,v=b.b,C=b.d;let M=Math.atan2(m,o)-Math.atan2(v,S)+g;M>X.PI?M-=X.PI2:M<-X.PI&&(M+=X.PI2),M*=t;const F=Math.cos(M),T=Math.sin(M);b.a=F*S-T*v,b.c=F*A-T*C,b.b=T*S+F*v,b.d=T*A+F*C}if(h){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),b.tx+=(S.x-b.tx)*n,b.ty+=(S.y-b.ty)*e}if(a!=0){let S=Math.sqrt(b.a*b.a+b.b*b.b);S!=0&&(S=(S+(Math.sqrt(o*o+m*m)-S+this.data.offsetScaleX)*a)/S),b.a*=S,b.b*=S}if(r!=0){let S=Math.sqrt(b.c*b.c+b.d*b.d);S!=0&&(S=(S+(Math.sqrt(c*c+f*f)-S+this.data.offsetScaleY)*r)/S),b.c*=S,b.d*=S}if(d>0){const S=b.c,A=b.d,v=Math.atan2(A,S);let C=Math.atan2(f,c)-Math.atan2(m,o)-(v-Math.atan2(b.b,b.a));C>X.PI?C-=X.PI2:C<-X.PI&&(C+=X.PI2),C=v+(C+w)*d;const M=Math.sqrt(S*S+A*A);b.c=Math.cos(C)*M,b.d=Math.sin(C)*M}x.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=n!=0||e!=0,s=this.target,i=s.matrix,o=i.a,c=i.c,m=i.b,f=i.d,u=o*f-c*m>0?X.degRad:-X.degRad,g=this.data.offsetRotation*u,w=this.data.offsetShearY*u,y=this.bones;for(let p=0,k=y.length;p<k;p++){const x=y[p],b=x.matrix;if(t!=0){const S=b.a,A=b.c,v=b.b,C=b.d;let M=Math.atan2(m,o)+g;M>X.PI?M-=X.PI2:M<-X.PI&&(M+=X.PI2),M*=t;const F=Math.cos(M),T=Math.sin(M);b.a=F*S-T*v,b.c=F*A-T*C,b.b=T*S+F*v,b.d=T*A+F*C}if(h){const S=this.temp;s.localToWorld(S.set(this.data.offsetX,this.data.offsetY)),b.tx+=S.x*n,b.ty+=S.y*e}if(a!=0){const S=(Math.sqrt(o*o+m*m)-1+this.data.offsetScaleX)*a+1;b.a*=S,b.b*=S}if(r!=0){const S=(Math.sqrt(c*c+f*f)-1+this.data.offsetScaleY)*r+1;b.c*=S,b.d*=S}if(d>0){let S=Math.atan2(f,c)-Math.atan2(m,o);S>X.PI?S-=X.PI2:S<-X.PI&&(S+=X.PI2);const A=b.c,v=b.d;S=Math.atan2(v,A)+(S-X.PI/2+w)*d;const C=Math.sqrt(A*A+v*v);b.c=Math.cos(S)*C,b.d=Math.sin(S)*C}x.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=this.target,s=this.bones;for(let i=0,o=s.length;i<o;i++){const c=s[i];let m=c.arotation;if(t!=0){let p=h.arotation-m+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,m+=p*t}let f=c.ax,u=c.ay;f+=(h.ax-f+this.data.offsetX)*n,u+=(h.ay-u+this.data.offsetY)*e;let g=c.ascaleX,w=c.ascaleY;a!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*a)/g),r!=0&&w!=0&&(w=(w+(h.ascaleY-w+this.data.offsetScaleY)*r)/w);let y=c.ashearY;if(d!=0){let p=h.ashearY-y+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,y+=p*d}c.updateWorldTransformWith(f,u,m,g,w,c.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,a=this.mixScaleX,r=this.mixScaleY,d=this.mixShearY,h=this.target,s=this.bones;for(let i=0,o=s.length;i<o;i++){const c=s[i],m=c.arotation+(h.arotation+this.data.offsetRotation)*t,f=c.ax+(h.ax+this.data.offsetX)*n,u=c.ay+(h.ay+this.data.offsetY)*e,g=c.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*a+1),w=c.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=c.ashearY+(h.ashearY+this.data.offsetShearY)*d;c.updateWorldTransformWith(f,u,m,g,w,c.ashearX,y)}}}const Dt=class{constructor(l){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!l)throw new Error("data cannot be null.");this.data=l,this.bones=new Array;for(let t=0;t<l.bones.length;t++){const n=l.bones[t];let e;if(!n.parent)e=new Se(n,this,null);else{const a=this.bones[n.parent.index];e=new Se(n,this,a),a.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<l.slots.length;t++){const n=l.slots[t],e=this.bones[n.boneData.index],a=new es(n,e);this.slots.push(a),this.drawOrder.push(a)}this.ikConstraints=new Array;for(let t=0;t<l.ikConstraints.length;t++){const n=l.ikConstraints[t];this.ikConstraints.push(new ts(n,this))}this.transformConstraints=new Array;for(let t=0;t<l.transformConstraints.length;t++){const n=l.transformConstraints[t];this.transformConstraints.push(new ss(n,this))}this.pathConstraints=new Array;for(let t=0;t<l.pathConstraints.length;t++){const n=l.pathConstraints[t];this.pathConstraints.push(new Ft(n,this))}this.color=new L(1,1,1,1),this.updateCache()}updateCache(){const l=this._updateCache;l.length=0;const t=this.bones;for(let i=0,o=t.length;i<o;i++){const c=t[i];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){const i=this.skin.bones;for(let o=0,c=this.skin.bones.length;o<c;o++){let m=this.bones[i[o].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const n=this.ikConstraints,e=this.transformConstraints,a=this.pathConstraints,r=n.length,d=e.length,h=a.length,s=r+d+h;t:for(let i=0;i<s;i++){for(let o=0;o<r;o++){const c=n[o];if(c.data.order==i){this.sortIkConstraint(c);continue t}}for(let o=0;o<d;o++){const c=e[o];if(c.data.order==i){this.sortTransformConstraint(c);continue t}}for(let o=0;o<h;o++){const c=a[o];if(c.data.order==i){this.sortPathConstraint(c);continue t}}}for(let i=0,o=t.length;i<o;i++)this.sortBone(t[i])}sortIkConstraint(l){if(l.active=l.target.isActive()&&(!l.data.skinRequired||this.skin&&E.contains(this.skin.constraints,l.data,!0)),!l.active)return;const t=l.target;this.sortBone(t);const n=l.bones,e=n[0];if(this.sortBone(e),n.length==1)this._updateCache.push(l),this.sortReset(e.children);else{const a=n[n.length-1];this.sortBone(a),this._updateCache.push(l),this.sortReset(e.children),a.sorted=!0}}sortPathConstraint(l){if(l.active=l.target.bone.isActive()&&(!l.data.skinRequired||this.skin&&E.contains(this.skin.constraints,l.data,!0)),!l.active)return;const t=l.target,n=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,n,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,e);for(let h=0,s=this.data.skins.length;h<s;h++)this.sortPathConstraintAttachment(this.data.skins[h],n,e);const a=t.getAttachment();a instanceof At&&this.sortPathConstraintAttachmentWith(a,e);const r=l.bones,d=r.length;for(let h=0;h<d;h++)this.sortBone(r[h]);this._updateCache.push(l);for(let h=0;h<d;h++)this.sortReset(r[h].children);for(let h=0;h<d;h++)r[h].sorted=!0}sortTransformConstraint(l){if(l.active=l.target.isActive()&&(!l.data.skinRequired||this.skin&&E.contains(this.skin.constraints,l.data,!0)),!l.active)return;this.sortBone(l.target);const t=l.bones,n=t.length;if(l.data.local)for(let e=0;e<n;e++){const a=t[e];this.sortBone(a.parent),this.sortBone(a)}else for(let e=0;e<n;e++)this.sortBone(t[e]);this._updateCache.push(l);for(let e=0;e<n;e++)this.sortReset(t[e].children);for(let e=0;e<n;e++)t[e].sorted=!0}sortPathConstraintAttachment(l,t,n){const e=l.attachments[t];if(e)for(const a in e)this.sortPathConstraintAttachmentWith(e[a],n)}sortPathConstraintAttachmentWith(l,t){if(!(l instanceof At))return;const n=l.bones;if(!n)this.sortBone(t);else{const e=this.bones;for(let a=0,r=n.length;a<r;){let d=n[a++];for(d+=a;a<d;)this.sortBone(e[n[a++]])}}}sortBone(l){if(!l||l.sorted)return;const t=l.parent;t&&this.sortBone(t),l.sorted=!0,this._updateCache.push(l)}sortReset(l){for(let t=0,n=l.length;t<n;t++){const e=l[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const l=this.bones;for(let n=0,e=l.length;n<e;n++){const a=l[n];a.ax=a.x,a.ay=a.y,a.arotation=a.rotation,a.ascaleX=a.scaleX,a.ascaleY=a.scaleY,a.ashearX=a.shearX,a.ashearY=a.shearY}const t=this._updateCache;for(let n=0,e=t.length;n<e;n++)t[n].update()}updateWorldTransformWith(l){const t=this.getRootBone(),n=l.matrix.a,e=l.matrix.c,a=l.matrix.b,r=l.matrix.d;t.matrix.tx=n*this.x+e*this.y+l.worldX,t.matrix.ty=a*this.x+r*this.y+l.worldY;const d=t.rotation+90+t.shearY,h=X.cosDeg(t.rotation+t.shearX)*t.scaleX,s=X.cosDeg(d)*t.scaleY,i=X.sinDeg(t.rotation+t.shearX)*t.scaleX,o=X.sinDeg(d)*t.scaleY,c=this.scaleX,m=Tt.yDown?-this.scaleY:this.scaleY;t.matrix.a=(n*h+e*i)*c,t.matrix.c=(n*s+e*o)*c,t.matrix.b=(a*h+r*i)*m,t.matrix.d=(a*s+r*o)*m;const f=this._updateCache;for(let u=0,g=f.length;u<g;u++){const w=f[u];w!=t&&w.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const l=this.bones;for(let a=0,r=l.length;a<r;a++)l[a].setToSetupPose();const t=this.ikConstraints;for(let a=0,r=t.length;a<r;a++){const d=t[a];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let a=0,r=n.length;a<r;a++){const d=n[a],h=d.data;d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY,d.mixScaleX=h.mixScaleX,d.mixScaleY=h.mixScaleY,d.mixShearY=h.mixShearY}const e=this.pathConstraints;for(let a=0,r=e.length;a<r;a++){const d=e[a],h=d.data;d.position=h.position,d.spacing=h.spacing,d.mixRotate=h.mixRotate,d.mixX=h.mixX,d.mixY=h.mixY}}setSlotsToSetupPose(){const l=this.slots;E.arrayCopy(l,0,this.drawOrder,0,l.length);for(let t=0,n=l.length;t<n;t++)l[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(l){if(!l)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(a.data.name==l)return a}return null}findBoneIndex(l){if(!l)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==l)return n;return-1}findSlot(l){if(!l)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(a.data.name==l)return a}return null}findSlotIndex(l){if(!l)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==l)return n;return-1}setSkinByName(l){const t=this.data.findSkin(l);if(!t)throw new Error(`Skin not found: ${l}`);this.setSkin(t)}setSkin(l){if(l!=this.skin){if(l)if(this.skin)l.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,e=t.length;n<e;n++){const a=t[n],r=a.data.attachmentName;if(r){const d=l.getAttachment(n,r);d&&a.setAttachment(d)}}}this.skin=l,this.updateCache()}}getAttachmentByName(l,t){const n=this.data.findSlot(l);if(!n)throw new Error(`Can't find slot with name ${l}`);return this.getAttachment(n.index,t)}getAttachment(l,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const n=this.skin.getAttachment(l,t);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(l,t):null}setAttachment(l,t){if(!l)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.data.name==l){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${l}`);r.setAttachment(d);return}}throw new Error(`Slot not found: ${l}`)}findIkConstraint(l){if(!l)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(a.data.name==l)return a}return null}findTransformConstraint(l){if(!l)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(a.data.name==l)return a}return null}findPathConstraint(l){if(!l)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,e=t.length;n<e;n++){const a=t[n];if(a.data.name==l)return a}return null}getBoundsRect(){const l=new Jt,t=new Jt;return this.getBounds(l,t),{x:l.x,y:l.y,width:t.x,height:t.y}}getBounds(l,t,n=new Array(2)){if(!l)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let s=0,i=e.length;s<i;s++){const o=e[s];if(!o.bone.active)continue;let c=0,m=null;const f=o.getAttachment();if(f instanceof U)c=8,m=E.setArraySize(n,c,0),f.computeWorldVertices(o,m,0,2);else if(f instanceof It){const u=f;c=u.worldVerticesLength,m=E.setArraySize(n,c,0),u.computeWorldVertices(o,0,c,m,0,2)}if(m)for(let u=0,g=m.length;u<g;u+=2){const w=m[u],y=m[u+1];a=Math.min(a,w),r=Math.min(r,y),d=Math.max(d,w),h=Math.max(h,y)}}l.set(a,r),t.set(d-a,h-r)}get flipX(){return this.scaleX==-1}set flipX(l){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=l?1:-1}get flipY(){return this.scaleY==-1}set flipY(l){Dt.deprecatedWarning1||(Dt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=l?1:-1}};let Me=Dt;Me.deprecatedWarning1=!1;class Fe{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,a=n.length;e<a;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,a=n.length;e<a;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,a=n.length;e<a;e++){const r=n[e];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,a=n.length;e<a;e++)if(n[e].name==t)return e;return-1}}class Xe{constructor(t,n,e){if(this.index=0,this.color=new L(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=gt.NORMAL,t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}}class Te extends Ot{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Be{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}}class zt{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(!e)throw new Error("attachment cannot be null.");const a=this.attachments;t>=a.length&&(a.length=t+1),a[t]||(a[t]={}),a[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const a=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){r=!0;break}r||this.bones.push(a)}for(let e=0;e<t.constraints.length;e++){const a=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){r=!0;break}r||this.constraints.push(a)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const a=n[e];this.setAttachment(a.slotIndex,a.name,a.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const a=t.bones[e];let r=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==a){r=!0;break}r||this.bones.push(a)}for(let e=0;e<t.constraints.length;e++){const a=t.constraints[e];let r=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==a){r=!0;break}r||this.constraints.push(a)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const a=n[e];a.attachment&&(a.attachment instanceof It?(a.attachment=a.attachment.newLinkedMesh(),this.setAttachment(a.slotIndex,a.name,a.attachment)):(a.attachment=a.attachment.copy(),this.setAttachment(a.slotIndex,a.name,a.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&delete e[n]}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const a in e){const r=e[a];r&&t.push(new Be(n,a,r))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const a in e){const r=e[a];r&&n.push(new Be(t,a,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let a=0;a<t.slots.length;a++){const r=t.slots[a],d=r.getAttachment();if(d&&e<n.attachments.length){const h=n.attachments[e];for(const s in h){const i=h[s];if(d==i){const o=this.getAttachment(e,s);o&&r.setAttachment(o);break}}}e++}}}class ns{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Fe;e.name="";const a=new rs(t),r=a.readInt32(),d=a.readInt32();e.hash=d==0&&r==0?null:d.toString(16)+r.toString(16),e.version=a.readString();const h=e.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const c=`Spine 4.1 loader cant load version ${e.version}. Please configure your pixi-spine bundle`;console.error(c)}this.ver40=h==="4.0",e.x=a.readFloat(),e.y=a.readFloat(),e.width=a.readFloat(),e.height=a.readFloat();const s=a.readBoolean();s&&(e.fps=a.readFloat(),e.imagesPath=a.readString(),e.audioPath=a.readString());let i=0;i=a.readInt(!0);for(let c=0;c<i;c++){const m=a.readString();if(!m)throw new Error("String in string table must not be null.");a.strings.push(m)}i=a.readInt(!0);for(let c=0;c<i;c++){const m=a.readString();if(!m)throw new Error("Bone name must not be null.");const f=c==0?null:e.bones[a.readInt(!0)],u=new Ae(c,m,f);u.rotation=a.readFloat(),u.x=a.readFloat()*n,u.y=a.readFloat()*n,u.scaleX=a.readFloat(),u.scaleY=a.readFloat(),u.shearX=a.readFloat(),u.shearY=a.readFloat(),u.length=a.readFloat()*n,u.transformMode=a.readInt(!0),u.skinRequired=a.readBoolean(),s&&L.rgba8888ToColor(u.color,a.readInt32()),e.bones.push(u)}i=a.readInt(!0);for(let c=0;c<i;c++){const m=a.readString();if(!m)throw new Error("Slot name must not be null.");const f=e.bones[a.readInt(!0)],u=new Xe(c,m,f);L.rgba8888ToColor(u.color,a.readInt32());const g=a.readInt32();g!=-1&&L.rgb888ToColor(u.darkColor=new L,g),u.attachmentName=a.readStringRef(),u.blendMode=a.readInt(!0),e.slots.push(u)}i=a.readInt(!0);for(let c=0,m;c<i;c++){const f=a.readString();if(!f)throw new Error("IK constraint data name must not be null.");const u=new Ce(f);u.order=a.readInt(!0),u.skinRequired=a.readBoolean(),m=a.readInt(!0);for(let g=0;g<m;g++)u.bones.push(e.bones[a.readInt(!0)]);u.target=e.bones[a.readInt(!0)],u.mix=a.readFloat(),u.softness=a.readFloat()*n,u.bendDirection=a.readByte(),u.compress=a.readBoolean(),u.stretch=a.readBoolean(),u.uniform=a.readBoolean(),e.ikConstraints.push(u)}i=a.readInt(!0);for(let c=0,m;c<i;c++){const f=a.readString();if(!f)throw new Error("Transform constraint data name must not be null.");const u=new Te(f);u.order=a.readInt(!0),u.skinRequired=a.readBoolean(),m=a.readInt(!0);for(let g=0;g<m;g++)u.bones.push(e.bones[a.readInt(!0)]);u.target=e.bones[a.readInt(!0)],u.local=a.readBoolean(),u.relative=a.readBoolean(),u.offsetRotation=a.readFloat(),u.offsetX=a.readFloat()*n,u.offsetY=a.readFloat()*n,u.offsetScaleX=a.readFloat(),u.offsetScaleY=a.readFloat(),u.offsetShearY=a.readFloat(),u.mixRotate=a.readFloat(),u.mixX=a.readFloat(),u.mixY=a.readFloat(),u.mixScaleX=a.readFloat(),u.mixScaleY=a.readFloat(),u.mixShearY=a.readFloat(),e.transformConstraints.push(u)}i=a.readInt(!0);for(let c=0,m;c<i;c++){const f=a.readString();if(!f)throw new Error("Path constraint data name must not be null.");const u=new ve(f);u.order=a.readInt(!0),u.skinRequired=a.readBoolean(),m=a.readInt(!0);for(let g=0;g<m;g++)u.bones.push(e.bones[a.readInt(!0)]);u.target=e.slots[a.readInt(!0)],u.positionMode=a.readInt(!0),u.spacingMode=a.readInt(!0),u.rotateMode=a.readInt(!0),u.offsetRotation=a.readFloat(),u.position=a.readFloat(),u.positionMode==wt.Fixed&&(u.position*=n),u.spacing=a.readFloat(),(u.spacingMode==K.Length||u.spacingMode==K.Fixed)&&(u.spacing*=n),u.mixRotate=a.readFloat(),u.mixX=a.readFloat(),u.mixY=a.readFloat(),e.pathConstraints.push(u)}const o=this.readSkin(a,e,!0,s);o&&(e.defaultSkin=o,e.skins.push(o));{let c=e.skins.length;for(E.setArraySize(e.skins,i=c+a.readInt(!0));c<i;c++){const m=this.readSkin(a,e,!1,s);if(!m)throw new Error("readSkin() should not have returned null.");e.skins[c]=m}}i=this.linkedMeshes.length;for(let c=0;c<i;c++){const m=this.linkedMeshes[c],f=m.skin?e.findSkin(m.skin):e.defaultSkin;if(!f)throw new Error("Not skin found for linked mesh.");if(!m.parent)throw new Error("Linked mesh parent must not be null");const u=f.getAttachment(m.slotIndex,m.parent);if(!u)throw new Error(`Parent mesh not found: ${m.parent}`);m.mesh.timelineAttachment=m.inheritTimeline?u:m.mesh,m.mesh.setParentMesh(u)}this.linkedMeshes.length=0,i=a.readInt(!0);for(let c=0;c<i;c++){const m=a.readStringRef();if(!m)throw new Error;const f=new Ye(m);f.intValue=a.readInt(!1),f.floatValue=a.readFloat(),f.stringValue=a.readString(),f.audioPath=a.readString(),f.audioPath&&(f.volume=a.readFloat(),f.balance=a.readFloat()),e.events.push(f)}i=a.readInt(!0);for(let c=0;c<i;c++){const m=a.readString();if(!m)throw new Error("Animatio name must not be null.");e.animations.push(this.readAnimation(a,m,e))}return e}readSkin(t,n,e,a){let r=null,d=0;if(e){if(d=t.readInt(!0),d==0)return null;r=new zt("default")}else{const h=t.readStringRef();if(!h)throw new Error("Skin name must not be null.");r=new zt(h),r.bones.length=t.readInt(!0);for(let s=0,i=r.bones.length;s<i;s++)r.bones[s]=n.bones[t.readInt(!0)];for(let s=0,i=t.readInt(!0);s<i;s++)r.constraints.push(n.ikConstraints[t.readInt(!0)]);for(let s=0,i=t.readInt(!0);s<i;s++)r.constraints.push(n.transformConstraints[t.readInt(!0)]);for(let s=0,i=t.readInt(!0);s<i;s++)r.constraints.push(n.pathConstraints[t.readInt(!0)]);d=t.readInt(!0)}for(let h=0;h<d;h++){const s=t.readInt(!0);for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readStringRef();if(!c)throw new Error("Attachment name must not be null");const m=this.readAttachment(t,n,r,s,c,a);m&&r.setAttachment(s,c,m)}}return r}readAttachment(t,n,e,a,r,d){const h=this.scale;let s=t.readStringRef();switch(s||(s=r),t.readByte()){case et.Region:{let i=t.readStringRef();const o=t.readFloat(),c=t.readFloat(),m=t.readFloat(),f=t.readFloat(),u=t.readFloat(),g=t.readFloat(),w=t.readFloat(),y=t.readInt32(),p=this.readSequence(t);i||(i=s);const k=this.attachmentLoader.newRegionAttachment(e,s,i,p);return k?(k.path=i,k.x=c*h,k.y=m*h,k.scaleX=f,k.scaleY=u,k.rotation=o,k.width=g*h,k.height=w*h,L.rgba8888ToColor(k.color,y),k.sequence=p,p==null&&k.updateRegion(),k):null}case et.BoundingBox:{const i=t.readInt(!0),o=this.readVertices(t,i),c=d?t.readInt32():0,m=this.attachmentLoader.newBoundingBoxAttachment(e,s);return m?(m.worldVerticesLength=i<<1,m.vertices=o.vertices,m.bones=o.bones,d&&L.rgba8888ToColor(m.color,c),m):null}case et.Mesh:{let i=t.readStringRef();const o=t.readInt32(),c=t.readInt(!0),m=this.readFloatArray(t,c<<1,1),f=this.readShortArray(t),u=this.readVertices(t,c),g=t.readInt(!0),w=this.readSequence(t);let y=[],p=0,k=0;d&&(y=this.readShortArray(t),p=t.readFloat(),k=t.readFloat()),i||(i=s);const x=this.attachmentLoader.newMeshAttachment(e,s,i,w);return x?(x.path=i,L.rgba8888ToColor(x.color,o),x.bones=u.bones,x.vertices=u.vertices,x.worldVerticesLength=c<<1,x.triangles=f,x.regionUVs=new Float32Array(m),x.hullLength=g<<1,x.sequence=w,d&&(x.edges=y,x.width=p*h,x.height=k*h),x):null}case et.LinkedMesh:{let i=t.readStringRef();const o=t.readInt32(),c=t.readStringRef(),m=t.readStringRef(),f=t.readBoolean(),u=this.readSequence(t);let g=0,w=0;d&&(g=t.readFloat(),w=t.readFloat()),i||(i=s);const y=this.attachmentLoader.newMeshAttachment(e,s,i,u);return y?(y.path=i,L.rgba8888ToColor(y.color,o),y.sequence=u,d&&(y.width=g*h,y.height=w*h),this.linkedMeshes.push(new fs(y,c,a,m,f)),y):null}case et.Path:{const i=t.readBoolean(),o=t.readBoolean(),c=t.readInt(!0),m=this.readVertices(t,c),f=E.newArray(c/3,0);for(let w=0,y=f.length;w<y;w++)f[w]=t.readFloat()*h;const u=d?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(e,s);return g?(g.closed=i,g.constantSpeed=o,g.worldVerticesLength=c<<1,g.vertices=m.vertices,g.bones=m.bones,g.lengths=f,d&&L.rgba8888ToColor(g.color,u),g):null}case et.Point:{const i=t.readFloat(),o=t.readFloat(),c=t.readFloat(),m=d?t.readInt32():0,f=this.attachmentLoader.newPointAttachment(e,s);return f?(f.x=o*h,f.y=c*h,f.rotation=i,d&&L.rgba8888ToColor(f.color,m),f):null}case et.Clipping:{const i=t.readInt(!0),o=t.readInt(!0),c=this.readVertices(t,o),m=d?t.readInt32():0,f=this.attachmentLoader.newClippingAttachment(e,s);return f?(f.endSlot=n.slots[i],f.worldVerticesLength=o<<1,f.vertices=c.vertices,f.bones=c.bones,d&&L.rgba8888ToColor(f.color,m),f):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const n=new Lt(t.readInt(!0));return n.start=t.readInt(!0),n.digits=t.readInt(!0),n.setupIndex=t.readInt(!0),n}readDeformTimelineType(t){return this.ver40?as:t.readByte()}readVertices(t,n){const e=this.scale,a=n<<1,r=new gs;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,a,e),r;const d=new Array,h=new Array;for(let s=0;s<n;s++){const i=t.readInt(!0);h.push(i);for(let o=0;o<i;o++)h.push(t.readInt(!0)),d.push(t.readFloat()*e),d.push(t.readFloat()*e),d.push(t.readFloat())}return r.vertices=E.toFloatArray(d),r.bones=h,r}readFloatArray(t,n,e){const a=new Array(n);if(e==1)for(let r=0;r<n;r++)a[r]=t.readFloat();else for(let r=0;r<n;r++)a[r]=t.readFloat()*e;return a}readShortArray(t){const n=t.readInt(!0),e=new Array(n);for(let a=0;a<n;a++)e[a]=t.readShort();return e}readAnimation(t,n,e){t.readInt(!0);const a=new Array,r=this.scale;for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readInt(!0);for(let m=0,f=t.readInt(!0);m<f;m++){const u=t.readByte(),g=t.readInt(!0),w=g-1;switch(u){case Cs:{const y=new yt(g,c);for(let p=0;p<g;p++)y.setFrame(p,t.readFloat(),t.readStringRef());a.push(y);break}case vs:{const y=t.readInt(!0),p=new le(g,y,c);let k=t.readFloat(),x=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255;for(let v=0,C=0;p.setFrame(v,k,x,b,S,A),v!=w;v++){const M=t.readFloat(),F=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255;switch(t.readByte()){case ht:p.setStepped(v);break;case lt:W(t,p,C++,v,0,k,M,x,F,1),W(t,p,C++,v,1,k,M,b,T,1),W(t,p,C++,v,2,k,M,S,B,1),W(t,p,C++,v,3,k,M,A,R,1)}k=M,x=F,b=T,S=B,A=R}a.push(p);break}case Ms:{const y=t.readInt(!0),p=new ce(g,y,c);let k=t.readFloat(),x=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255;for(let A=0,v=0;p.setFrame(A,k,x,b,S),A!=w;A++){const C=t.readFloat(),M=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255;switch(t.readByte()){case ht:p.setStepped(A);break;case lt:W(t,p,v++,A,0,k,C,x,M,1),W(t,p,v++,A,1,k,C,b,F,1),W(t,p,v++,A,2,k,C,S,T,1)}k=C,x=M,b=F,S=T}a.push(p);break}case Fs:{const y=t.readInt(!0),p=new me(g,y,c);let k=t.readFloat(),x=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let F=0,T=0;p.setFrame(F,k,x,b,S,A,v,C,M),F!=w;F++){const B=t.readFloat(),R=t.readUnsignedByte()/255,q=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255,z=t.readUnsignedByte()/255,_=t.readUnsignedByte()/255;switch(t.readByte()){case ht:p.setStepped(F);break;case lt:W(t,p,T++,F,0,k,B,x,R,1),W(t,p,T++,F,1,k,B,b,q,1),W(t,p,T++,F,2,k,B,S,V,1),W(t,p,T++,F,3,k,B,A,D,1),W(t,p,T++,F,4,k,B,v,N,1),W(t,p,T++,F,5,k,B,C,z,1),W(t,p,T++,F,6,k,B,M,_,1)}k=B,x=R,b=q,S=V,A=D,v=N,C=z,M=_}a.push(p);break}case Xs:{const y=t.readInt(!0),p=new ue(g,y,c);let k=t.readFloat(),x=t.readUnsignedByte()/255,b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let M=0,F=0;p.setFrame(M,k,x,b,S,A,v,C),M!=w;M++){const T=t.readFloat(),B=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,q=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,D=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case ht:p.setStepped(M);break;case lt:W(t,p,F++,M,0,k,T,x,B,1),W(t,p,F++,M,1,k,T,b,R,1),W(t,p,F++,M,2,k,T,S,q,1),W(t,p,F++,M,3,k,T,A,V,1),W(t,p,F++,M,4,k,T,v,D,1),W(t,p,F++,M,5,k,T,C,N,1)}k=T,x=B,b=R,S=q,A=V,v=D,C=N}a.push(p);break}case Ts:{const y=new de(g,t.readInt(!0),c);let p=t.readFloat(),k=t.readUnsignedByte()/255;for(let x=0,b=0;y.setFrame(x,p,k),x!=w;x++){const S=t.readFloat(),A=t.readUnsignedByte()/255;switch(t.readByte()){case ht:y.setStepped(x);break;case lt:W(t,y,b++,x,0,p,S,k,A,1)}p=S,k=A}a.push(y)}}}}for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readInt(!0);for(let m=0,f=t.readInt(!0);m<f;m++){const u=t.readByte(),g=t.readInt(!0),w=t.readInt(!0);switch(u){case ps:a.push(bt(t,new Et(g,w,c),1));break;case xs:a.push(Ee(t,new te(g,w,c),r));break;case bs:a.push(bt(t,new ee(g,w,c),r));break;case ws:a.push(bt(t,new se(g,w,c),r));break;case ks:a.push(Ee(t,new ne(g,w,c),1));break;case ys:a.push(bt(t,new ae(g,w,c),1));break;case Ss:a.push(bt(t,new ie(g,w,c),1));break;case As:a.push(Ee(t,new re(g,w,c),1));break;case Is:a.push(bt(t,new oe(g,w,c),1));break;case Ys:a.push(bt(t,new he(g,w,c),1))}}}for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readInt(!0),m=t.readInt(!0),f=m-1,u=new ge(m,t.readInt(!0),c);let g=t.readFloat(),w=t.readFloat(),y=t.readFloat()*r;for(let p=0,k=0;u.setFrame(p,g,w,y,t.readByte(),t.readBoolean(),t.readBoolean()),p!=f;p++){const x=t.readFloat(),b=t.readFloat(),S=t.readFloat()*r;switch(t.readByte()){case ht:u.setStepped(p);break;case lt:W(t,u,k++,p,0,g,x,w,b,1),W(t,u,k++,p,1,g,x,y,S,r)}g=x,w=b,y=S}a.push(u)}for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readInt(!0),m=t.readInt(!0),f=m-1,u=new pe(m,t.readInt(!0),c);let g=t.readFloat(),w=t.readFloat(),y=t.readFloat(),p=t.readFloat(),k=t.readFloat(),x=t.readFloat(),b=t.readFloat();for(let S=0,A=0;u.setFrame(S,g,w,y,p,k,x,b),S!=f;S++){const v=t.readFloat(),C=t.readFloat(),M=t.readFloat(),F=t.readFloat(),T=t.readFloat(),B=t.readFloat(),R=t.readFloat();switch(t.readByte()){case ht:u.setStepped(S);break;case lt:W(t,u,A++,S,0,g,v,w,C,1),W(t,u,A++,S,1,g,v,y,M,1),W(t,u,A++,S,2,g,v,p,F,1),W(t,u,A++,S,3,g,v,k,T,1),W(t,u,A++,S,4,g,v,x,B,1),W(t,u,A++,S,5,g,v,b,R,1)}g=v,w=C,y=M,p=F,k=T,x=B,b=R}a.push(u)}for(let i=0,o=t.readInt(!0);i<o;i++){const c=t.readInt(!0),m=e.pathConstraints[c];for(let f=0,u=t.readInt(!0);f<u;f++)switch(t.readByte()){case Es:a.push(bt(t,new xe(t.readInt(!0),t.readInt(!0),c),m.positionMode==wt.Fixed?r:1));break;case Rs:a.push(bt(t,new be(t.readInt(!0),t.readInt(!0),c),m.spacingMode==K.Length||m.spacingMode==K.Fixed?r:1));break;case Ds:const g=new we(t.readInt(!0),t.readInt(!0),c);let w=t.readFloat(),y=t.readFloat(),p=t.readFloat(),k=t.readFloat();for(let x=0,b=0,S=g.getFrameCount()-1;g.setFrame(x,w,y,p,k),x!=S;x++){const A=t.readFloat(),v=t.readFloat(),C=t.readFloat(),M=t.readFloat();switch(t.readByte()){case ht:g.setStepped(x);break;case lt:W(t,g,b++,x,0,w,A,y,v,1),W(t,g,b++,x,1,w,A,p,C,1),W(t,g,b++,x,2,w,A,k,M,1)}w=A,y=v,p=C,k=M}a.push(g)}}for(let i=0,o=t.readInt(!0);i<o;i++){const c=e.skins[t.readInt(!0)];for(let m=0,f=t.readInt(!0);m<f;m++){const u=t.readInt(!0);for(let g=0,w=t.readInt(!0);g<w;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const p=c.getAttachment(u,y),k=this.readDeformTimelineType(t),x=t.readInt(!0),b=x-1;switch(k){case as:{const S=p,A=S.bones,v=S.vertices,C=A?v.length/3*2:v.length,M=t.readInt(!0),F=new fe(x,M,u,S);let T=t.readFloat();for(let B=0,R=0;;B++){let q,V=t.readInt(!0);if(V==0)q=A?E.newFloatArray(C):v;else{q=E.newFloatArray(C);const N=t.readInt(!0);if(V+=N,r==1)for(let z=N;z<V;z++)q[z]=t.readFloat();else for(let z=N;z<V;z++)q[z]=t.readFloat()*r;if(!A)for(let z=0,_=q.length;z<_;z++)q[z]+=v[z]}if(F.setFrame(B,T,q),B==b)break;const D=t.readFloat();switch(t.readByte()){case ht:F.setStepped(B);break;case lt:W(t,F,R++,B,0,T,D,0,1,1)}T=D}a.push(F);break}case Bs:{const S=new vt(x,u,p);for(let A=0;A<x;A++){const v=t.readFloat(),C=t.readInt32();S.setFrame(A,v,Zt[C&15],C>>4,t.readFloat())}a.push(S);break}}}}}const d=t.readInt(!0);if(d>0){const i=new St(d),o=e.slots.length;for(let c=0;c<d;c++){const m=t.readFloat(),f=t.readInt(!0),u=E.newArray(o,0);for(let p=o-1;p>=0;p--)u[p]=-1;const g=E.newArray(o-f,0);let w=0,y=0;for(let p=0;p<f;p++){const k=t.readInt(!0);for(;w!=k;)g[y++]=w++;u[w+t.readInt(!0)]=w++}for(;w<o;)g[y++]=w++;for(let p=o-1;p>=0;p--)u[p]==-1&&(u[p]=g[--y]);i.setFrame(c,m,u)}a.push(i)}const h=t.readInt(!0);if(h>0){const i=new Rt(h);for(let o=0;o<h;o++){const c=t.readFloat(),m=e.events[t.readInt(!0)],f=new Ie(c,m);f.intValue=t.readInt(!1),f.floatValue=t.readFloat(),f.stringValue=t.readBoolean()?t.readString():m.stringValue,f.data.audioPath&&(f.volume=t.readFloat(),f.balance=t.readFloat()),i.setFrame(o,f)}a.push(i)}let s=0;for(let i=0,o=a.length;i<o;i++)s=Math.max(s,a[i].getDuration());return new Wt(n,a,s)}}ns.BlendModeValues=[gt.NORMAL,gt.ADD,gt.MULTIPLY,gt.SCREEN];class fs{constructor(t,n,e,a,r){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=a,this.inheritTimeline=r}}class gs{constructor(t=null,n=null){this.bones=t,this.vertices=n}}function bt(l,t,n){let e=l.readFloat(),a=l.readFloat()*n;for(let r=0,d=0,h=t.getFrameCount()-1;t.setFrame(r,e,a),r!=h;r++){const s=l.readFloat(),i=l.readFloat()*n;switch(l.readByte()){case ht:t.setStepped(r);break;case lt:W(l,t,d++,r,0,e,s,a,i,n)}e=s,a=i}return t}function Ee(l,t,n){let e=l.readFloat(),a=l.readFloat()*n,r=l.readFloat()*n;for(let d=0,h=0,s=t.getFrameCount()-1;t.setFrame(d,e,a,r),d!=s;d++){const i=l.readFloat(),o=l.readFloat()*n,c=l.readFloat()*n;switch(l.readByte()){case ht:t.setStepped(d);break;case lt:W(l,t,h++,d,0,e,i,a,o,n),W(l,t,h++,d,1,e,i,r,c,n)}e=i,a=o,r=c}return t}function W(l,t,n,e,a,r,d,h,s,i){t.setBezier(n,e,a,r,h,l.readFloat(),l.readFloat()*i,l.readFloat(),l.readFloat()*i,d,s)}const ps=0,xs=1,bs=2,ws=3,ks=4,ys=5,Ss=6,As=7,Is=8,Ys=9,Cs=0,vs=1,Ms=2,Fs=3,Xs=4,Ts=5,as=0,Bs=1,Es=0,Rs=1,Ds=2,ht=1,lt=2;class Vs extends os{}class De{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Fe,a=typeof t=="string"?JSON.parse(t):t,r=a.skeleton;if(r){e.hash=r.hash,e.version=r.spine;const d=e.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}e.x=r.x,e.y=r.y,e.width=r.width,e.height=r.height,e.fps=r.fps,e.imagesPath=r.images}if(a.bones)for(let d=0;d<a.bones.length;d++){const h=a.bones[d];let s=null;const i=I(h,"parent",null);if(i!=null&&(s=e.findBone(i),s==null))throw new Error(`Parent bone not found: ${i}`);const o=new Ae(e.bones.length,h.name,s);o.length=I(h,"length",0)*n,o.x=I(h,"x",0)*n,o.y=I(h,"y",0)*n,o.rotation=I(h,"rotation",0),o.scaleX=I(h,"scaleX",1),o.scaleY=I(h,"scaleY",1),o.shearX=I(h,"shearX",0),o.shearY=I(h,"shearY",0),o.transformMode=E.enumValue(nt,I(h,"transform","Normal")),o.skinRequired=I(h,"skin",!1);const c=I(h,"color",null);c&&o.color.setFromString(c),e.bones.push(o)}if(a.slots)for(let d=0;d<a.slots.length;d++){const h=a.slots[d],s=e.findBone(h.bone);if(!s)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const i=new Xe(e.slots.length,h.name,s),o=I(h,"color",null);o&&i.color.setFromString(o);const c=I(h,"dark",null);c&&(i.darkColor=L.fromString(c)),i.attachmentName=I(h,"attachment",null),i.blendMode=De.blendModeFromString(I(h,"blend","normal")),e.slots.push(i)}if(a.ik)for(let d=0;d<a.ik.length;d++){const h=a.ik[d],s=new Ce(h.name);s.order=I(h,"order",0),s.skinRequired=I(h,"skin",!1);for(let i=0;i<h.bones.length;i++){const o=h.bones[i],c=e.findBone(o);if(c==null)throw new Error(`IK bone not found: ${o}`);s.bones.push(c)}s.target=e.findBone(h.target),s.mix=I(h,"mix",1),s.softness=I(h,"softness",0)*n,s.bendDirection=I(h,"bendPositive",!0)?1:-1,s.compress=I(h,"compress",!1),s.stretch=I(h,"stretch",!1),s.uniform=I(h,"uniform",!1),e.ikConstraints.push(s)}if(a.transform)for(let d=0;d<a.transform.length;d++){const h=a.transform[d],s=new Te(h.name);s.order=I(h,"order",0),s.skinRequired=I(h,"skin",!1);for(let c=0;c<h.bones.length;c++){const m=h.bones[c],f=e.findBone(m);if(!f)throw new Error(`Couldn't find bone ${m} for transform constraint ${h.name}.`);s.bones.push(f)}const i=h.target,o=e.findBone(i);if(!o)throw new Error(`Couldn't find target bone ${i} for transform constraint ${h.name}.`);s.target=o,s.local=I(h,"local",!1),s.relative=I(h,"relative",!1),s.offsetRotation=I(h,"rotation",0),s.offsetX=I(h,"x",0)*n,s.offsetY=I(h,"y",0)*n,s.offsetScaleX=I(h,"scaleX",0),s.offsetScaleY=I(h,"scaleY",0),s.offsetShearY=I(h,"shearY",0),s.mixRotate=I(h,"mixRotate",1),s.mixX=I(h,"mixX",1),s.mixY=I(h,"mixY",s.mixX),s.mixScaleX=I(h,"mixScaleX",1),s.mixScaleY=I(h,"mixScaleY",s.mixScaleX),s.mixShearY=I(h,"mixShearY",1),e.transformConstraints.push(s)}if(a.path)for(let d=0;d<a.path.length;d++){const h=a.path[d],s=new ve(h.name);s.order=I(h,"order",0),s.skinRequired=I(h,"skin",!1);for(let c=0;c<h.bones.length;c++){const m=h.bones[c],f=e.findBone(m);if(!f)throw new Error(`Couldn't find bone ${m} for path constraint ${h.name}.`);s.bones.push(f)}const i=h.target,o=e.findSlot(i);if(!o)throw new Error(`Couldn't find target slot ${i} for path constraint ${h.name}.`);s.target=o,s.positionMode=E.enumValue(wt,I(h,"positionMode","Percent")),s.spacingMode=E.enumValue(K,I(h,"spacingMode","Length")),s.rotateMode=E.enumValue(Bt,I(h,"rotateMode","Tangent")),s.offsetRotation=I(h,"rotation",0),s.position=I(h,"position",0),s.positionMode==wt.Fixed&&(s.position*=n),s.spacing=I(h,"spacing",0),(s.spacingMode==K.Length||s.spacingMode==K.Fixed)&&(s.spacing*=n),s.mixRotate=I(h,"mixRotate",1),s.mixX=I(h,"mixX",1),s.mixY=I(h,"mixY",s.mixX),e.pathConstraints.push(s)}if(a.skins)for(let d=0;d<a.skins.length;d++){const h=a.skins[d],s=new zt(h.name);if(h.bones)for(let i=0;i<h.bones.length;i++){const o=h.bones[i],c=e.findBone(o);if(!c)throw new Error(`Couldn't find bone ${o} for skin ${h.name}.`);s.bones.push(c)}if(h.ik)for(let i=0;i<h.ik.length;i++){const o=h.ik[i],c=e.findIkConstraint(o);if(!c)throw new Error(`Couldn't find IK constraint ${o} for skin ${h.name}.`);s.constraints.push(c)}if(h.transform)for(let i=0;i<h.transform.length;i++){const o=h.transform[i],c=e.findTransformConstraint(o);if(!c)throw new Error(`Couldn't find transform constraint ${o} for skin ${h.name}.`);s.constraints.push(c)}if(h.path)for(let i=0;i<h.path.length;i++){const o=h.path[i],c=e.findPathConstraint(o);if(!c)throw new Error(`Couldn't find path constraint ${o} for skin ${h.name}.`);s.constraints.push(c)}for(const i in h.attachments){const o=e.findSlot(i);if(!o)throw new Error(`Couldn't find slot ${i} for skin ${h.name}.`);const c=h.attachments[i];for(const m in c){const f=this.readAttachment(c[m],s,o.index,m,e);f&&s.setAttachment(o.index,m,f)}}e.skins.push(s),s.name=="default"&&(e.defaultSkin=s)}for(let d=0,h=this.linkedMeshes.length;d<h;d++){const s=this.linkedMeshes[d],i=s.skin?e.findSkin(s.skin):e.defaultSkin;if(!i)throw new Error(`Skin not found: ${s.skin}`);const o=i.getAttachment(s.slotIndex,s.parent);if(!o)throw new Error(`Parent mesh not found: ${s.parent}`);s.mesh.timelineAttachment=s.inheritTimeline?o:s.mesh,s.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,a.events)for(const d in a.events){const h=a.events[d],s=new Ye(d);s.intValue=I(h,"int",0),s.floatValue=I(h,"float",0),s.stringValue=I(h,"string",""),s.audioPath=I(h,"audio",null),s.audioPath&&(s.volume=I(h,"volume",1),s.balance=I(h,"balance",0)),e.events.push(s)}if(a.animations)for(const d in a.animations){const h=a.animations[d];this.readAnimation(h,d,e)}return e}readAttachment(t,n,e,a,r){const d=this.scale;switch(a=I(t,"name",a),I(t,"type","region")){case"region":{const h=I(t,"path",a),s=this.readSequence(I(t,"sequence",null)),i=this.attachmentLoader.newRegionAttachment(n,a,h,s);if(!i)return null;i.path=h,i.x=I(t,"x",0)*d,i.y=I(t,"y",0)*d,i.scaleX=I(t,"scaleX",1),i.scaleY=I(t,"scaleY",1),i.rotation=I(t,"rotation",0),i.width=t.width*d,i.height=t.height*d,i.sequence=s;const o=I(t,"color",null);return o&&i.color.setFromString(o),i}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(n,a);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const s=I(t,"color",null);return s&&h.color.setFromString(s),h}case"mesh":case"linkedmesh":{const h=I(t,"path",a),s=this.readSequence(I(t,"sequence",null)),i=this.attachmentLoader.newMeshAttachment(n,a,h,s);if(!i)return null;i.path=h;const o=I(t,"color",null);o&&i.color.setFromString(o),i.width=I(t,"width",0)*d,i.height=I(t,"height",0)*d,i.sequence=s;const c=I(t,"parent",null);if(c)return this.linkedMeshes.push(new Ps(i,I(t,"skin",null),e,c,I(t,"timelines",!0))),i;const m=t.uvs;return this.readVertices(t,i,m.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(m),i.edges=I(t,"edges",null),i.hullLength=I(t,"hull",0)*2,i}case"path":{const h=this.attachmentLoader.newPathAttachment(n,a);if(!h)return null;h.closed=I(t,"closed",!1),h.constantSpeed=I(t,"constantSpeed",!0);const s=t.vertexCount;this.readVertices(t,h,s<<1);const i=E.newArray(s/3,0);for(let c=0;c<t.lengths.length;c++)i[c]=t.lengths[c]*d;h.lengths=i;const o=I(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(n,a);if(!h)return null;h.x=I(t,"x",0)*d,h.y=I(t,"y",0)*d,h.rotation=I(t,"rotation",0);const s=I(t,"color",null);return s&&h.color.setFromString(s),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(n,a);if(!h)return null;const s=I(t,"end",null);if(s!=null){const c=r.findSlot(s);if(c==null)throw new Error(`Clipping end slot not found: ${s}`);h.endSlot=c}const i=t.vertexCount;this.readVertices(t,h,i<<1);const o=I(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const n=new Lt(I(t,"count",0));return n.start=I(t,"start",1),n.digits=I(t,"digits",0),n.setupIndex=I(t,"setup",0),n}readVertices(t,n,e){const a=this.scale;n.worldVerticesLength=e;const r=t.vertices;if(e==r.length){const s=E.toFloatArray(r);if(a!=1)for(let i=0,o=r.length;i<o;i++)s[i]*=a;n.vertices=s;return}const d=new Array,h=new Array;for(let s=0,i=r.length;s<i;){const o=r[s++];h.push(o);for(let c=s+o*4;s<c;s+=4)h.push(r[s]),d.push(r[s+1]*a),d.push(r[s+2]*a),d.push(r[s+3])}n.bones=h,n.vertices=E.toFloatArray(d)}readAnimation(t,n,e){const a=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const s=t.slots[h],i=e.findSlot(h);if(!i)throw new Error(`Slot not found: ${h}`);const o=i.index;for(const c in s){const m=s[c];if(!m)continue;const f=m.length;if(c=="attachment"){const u=new yt(f,o);for(let g=0;g<f;g++){const w=m[g];u.setFrame(g,I(w,"time",0),I(w,"name",null))}r.push(u)}else if(c=="rgba"){const u=new le(f,f<<2,o);let g=m[0],w=I(g,"time",0),y=L.fromString(g.color);for(let p=0,k=0;;p++){u.setFrame(p,w,y.r,y.g,y.b,y.a);const x=m[p+1];if(!x){u.shrink(k);break}const b=I(x,"time",0),S=L.fromString(x.color),A=g.curve;A&&(k=O(A,u,k,p,0,w,b,y.r,S.r,1),k=O(A,u,k,p,1,w,b,y.g,S.g,1),k=O(A,u,k,p,2,w,b,y.b,S.b,1),k=O(A,u,k,p,3,w,b,y.a,S.a,1)),w=b,y=S,g=x}r.push(u)}else if(c=="rgb"){const u=new ce(f,f*3,o);let g=m[0],w=I(g,"time",0),y=L.fromString(g.color);for(let p=0,k=0;;p++){u.setFrame(p,w,y.r,y.g,y.b);const x=m[p+1];if(!x){u.shrink(k);break}const b=I(x,"time",0),S=L.fromString(x.color),A=g.curve;A&&(k=O(A,u,k,p,0,w,b,y.r,S.r,1),k=O(A,u,k,p,1,w,b,y.g,S.g,1),k=O(A,u,k,p,2,w,b,y.b,S.b,1)),w=b,y=S,g=x}r.push(u)}else if(c=="alpha")r.push(mt(m,new de(f,f,o),0,1));else if(c=="rgba2"){const u=new me(f,f*7,o);let g=m[0],w=I(g,"time",0),y=L.fromString(g.light),p=L.fromString(g.dark);for(let k=0,x=0;;k++){u.setFrame(k,w,y.r,y.g,y.b,y.a,p.r,p.g,p.b);const b=m[k+1];if(!b){u.shrink(x);break}const S=I(b,"time",0),A=L.fromString(b.light),v=L.fromString(b.dark),C=g.curve;C&&(x=O(C,u,x,k,0,w,S,y.r,A.r,1),x=O(C,u,x,k,1,w,S,y.g,A.g,1),x=O(C,u,x,k,2,w,S,y.b,A.b,1),x=O(C,u,x,k,3,w,S,y.a,A.a,1),x=O(C,u,x,k,4,w,S,p.r,v.r,1),x=O(C,u,x,k,5,w,S,p.g,v.g,1),x=O(C,u,x,k,6,w,S,p.b,v.b,1)),w=S,y=A,p=v,g=b}r.push(u)}else if(c=="rgb2"){const u=new ue(f,f*6,o);let g=m[0],w=I(g,"time",0),y=L.fromString(g.light),p=L.fromString(g.dark);for(let k=0,x=0;;k++){u.setFrame(k,w,y.r,y.g,y.b,p.r,p.g,p.b);const b=m[k+1];if(!b){u.shrink(x);break}const S=I(b,"time",0),A=L.fromString(b.light),v=L.fromString(b.dark),C=g.curve;C&&(x=O(C,u,x,k,0,w,S,y.r,A.r,1),x=O(C,u,x,k,1,w,S,y.g,A.g,1),x=O(C,u,x,k,2,w,S,y.b,A.b,1),x=O(C,u,x,k,3,w,S,p.r,v.r,1),x=O(C,u,x,k,4,w,S,p.g,v.g,1),x=O(C,u,x,k,5,w,S,p.b,v.b,1)),w=S,y=A,p=v,g=b}r.push(u)}}}if(t.bones)for(const h in t.bones){const s=t.bones[h],i=e.findBone(h);if(!i)throw new Error(`Bone not found: ${h}`);const o=i.index;for(const c in s){const m=s[c],f=m.length;if(f!=0){if(c==="rotate")r.push(mt(m,new Et(f,f,o),0,1));else if(c==="translate"){const u=new te(f,f<<1,o);r.push(Re(m,u,"x","y",0,a))}else if(c==="translatex"){const u=new ee(f,f,o);r.push(mt(m,u,0,a))}else if(c==="translatey"){const u=new se(f,f,o);r.push(mt(m,u,0,a))}else if(c==="scale"){const u=new ne(f,f<<1,o);r.push(Re(m,u,"x","y",1,1))}else if(c==="scalex"){const u=new ae(f,f,o);r.push(mt(m,u,1,1))}else if(c==="scaley"){const u=new ie(f,f,o);r.push(mt(m,u,1,1))}else if(c==="shear"){const u=new re(f,f<<1,o);r.push(Re(m,u,"x","y",0,1))}else if(c==="shearx"){const u=new oe(f,f,o);r.push(mt(m,u,0,1))}else if(c==="sheary"){const u=new he(f,f,o);r.push(mt(m,u,0,1))}}}}if(t.ik)for(const h in t.ik){const s=t.ik[h];let i=s[0];if(!i)continue;const o=e.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const c=e.ikConstraints.indexOf(o),m=new ge(s.length,s.length<<1,c);let f=I(i,"time",0),u=I(i,"mix",1),g=I(i,"softness",0)*a;for(let w=0,y=0;;w++){m.setFrame(w,f,u,g,I(i,"bendPositive",!0)?1:-1,I(i,"compress",!1),I(i,"stretch",!1));const p=s[w+1];if(!p){m.shrink(y);break}const k=I(p,"time",0),x=I(p,"mix",1),b=I(p,"softness",0)*a,S=i.curve;S&&(y=O(S,m,y,w,0,f,k,u,x,1),y=O(S,m,y,w,1,f,k,g,b,a)),f=k,u=x,g=b,i=p}r.push(m)}if(t.transform)for(const h in t.transform){const s=t.transform[h];let i=s[0];if(!i)continue;const o=e.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const c=e.transformConstraints.indexOf(o),m=new pe(s.length,s.length*6,c);let f=I(i,"time",0),u=I(i,"mixRotate",1),g=I(i,"mixX",1),w=I(i,"mixY",g),y=I(i,"mixScaleX",1),p=I(i,"mixScaleY",y);const k=I(i,"mixShearY",1);for(let x=0,b=0;;x++){m.setFrame(x,f,u,g,w,y,p,k);const S=s[x+1];if(!S){m.shrink(b);break}const A=I(S,"time",0),v=I(S,"mixRotate",1),C=I(S,"mixX",1),M=I(S,"mixY",C),F=I(S,"mixScaleX",1),T=I(S,"mixScaleY",F),B=I(S,"mixShearY",1),R=i.curve;R&&(b=O(R,m,b,x,0,f,A,u,v,1),b=O(R,m,b,x,1,f,A,g,C,1),b=O(R,m,b,x,2,f,A,w,M,1),b=O(R,m,b,x,3,f,A,y,F,1),b=O(R,m,b,x,4,f,A,p,T,1),b=O(R,m,b,x,5,f,A,k,B,1)),f=A,u=v,g=C,w=M,y=F,p=T,y=F,i=S}r.push(m)}if(t.path)for(const h in t.path){const s=t.path[h],i=e.findPathConstraint(h);if(!i)throw new Error(`Path constraint not found: ${h}`);const o=e.pathConstraints.indexOf(i);for(const c in s){const m=s[c];let f=m[0];if(!f)continue;const u=m.length;if(c==="position"){const g=new xe(u,u,o);r.push(mt(m,g,0,i.positionMode==wt.Fixed?a:1))}else if(c==="spacing"){const g=new be(u,u,o);r.push(mt(m,g,0,i.spacingMode==K.Length||i.spacingMode==K.Fixed?a:1))}else if(c==="mix"){const g=new we(u,u*3,o);let w=I(f,"time",0),y=I(f,"mixRotate",1),p=I(f,"mixX",1),k=I(f,"mixY",p);for(let x=0,b=0;;x++){g.setFrame(x,w,y,p,k);const S=m[x+1];if(!S){g.shrink(b);break}const A=I(S,"time",0),v=I(S,"mixRotate",1),C=I(S,"mixX",1),M=I(S,"mixY",C),F=f.curve;F&&(b=O(F,g,b,x,0,w,A,y,v,1),b=O(F,g,b,x,1,w,A,p,C,1),b=O(F,g,b,x,2,w,A,k,M,1)),w=A,y=v,p=C,k=M,f=S}r.push(g)}}}if(t.deform){t.attachments={};for(const h in t.deform){const s=t.deform[h],i=t.attachments[h]={};for(const o in s){const c=s[o],m=i[o]={};for(const f in c)m[f]={deform:c[f]}}}}if(t.attachments)for(const h in t.attachments){const s=t.attachments[h],i=e.findSkin(h);if(i==null){if(Tt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${h}`);continue}for(const o in s){const c=s[o],m=e.findSlot(o);if(!m)throw new Error(`Slot not found: ${o}`);const f=m.index;for(const u in c){const g=c[u],w=i.getAttachment(f,u);for(const y in g){const p=g[y];let k=p[0];if(k){if(y=="deform"){const x=w.bones,b=w.vertices,S=x?b.length/3*2:b.length,A=new fe(p.length,p.length,f,w);let v=I(k,"time",0);for(let C=0,M=0;;C++){let F;const T=I(k,"vertices",null);if(!T)F=x?E.newFloatArray(S):b;else{F=E.newFloatArray(S);const V=I(k,"offset",0);if(E.arrayCopy(T,0,F,V,T.length),a!=1)for(let D=V,N=D+T.length;D<N;D++)F[D]*=a;if(!x)for(let D=0;D<S;D++)F[D]+=b[D]}A.setFrame(C,v,F);const B=p[C+1];if(!B){A.shrink(M);break}const R=I(B,"time",0),q=k.curve;q&&(M=O(q,A,M,C,0,v,R,0,1,1)),v=R,k=B}r.push(A)}else if(y=="sequence"){const x=new vt(p.length,f,w);let b=0;for(let S=0;S<p.length;S++){const A=I(k,"delay",b),v=I(k,"time",0),C=ct[I(k,"mode","hold")],M=I(k,"index",0);x.setFrame(S,v,C,M,A),b=A,k=p[S+1]}r.push(x)}}}}}}if(t.drawOrder){const h=new St(t.drawOrder.length),s=e.slots.length;let i=0;for(let o=0;o<t.drawOrder.length;o++,i++){const c=t.drawOrder[o];let m=null;const f=I(c,"offsets",null);if(f){m=E.newArray(s,-1);const u=E.newArray(s-f.length,0);let g=0,w=0;for(let y=0;y<f.length;y++){const p=f[y],k=e.findSlot(p.slot);if(!k)throw new Error(`Slot not found: ${k}`);const x=k.index;for(;g!=x;)u[w++]=g++;m[g+p.offset]=g++}for(;g<s;)u[w++]=g++;for(let y=s-1;y>=0;y--)m[y]==-1&&(m[y]=u[--w])}h.setFrame(i,I(c,"time",0),m)}r.push(h)}if(t.events){const h=new Rt(t.events.length);let s=0;for(let i=0;i<t.events.length;i++,s++){const o=t.events[i],c=e.findEvent(o.name);if(!c)throw new Error(`Event not found: ${o.name}`);const m=new Ie(E.toSinglePrecision(I(o,"time",0)),c);m.intValue=I(o,"int",c.intValue),m.floatValue=I(o,"float",c.floatValue),m.stringValue=I(o,"string",c.stringValue),m.data.audioPath&&(m.volume=I(o,"volume",1),m.balance=I(o,"balance",0)),h.setFrame(s,m)}r.push(h)}let d=0;for(let h=0,s=r.length;h<s;h++)d=Math.max(d,r[h].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new Wt(n,r,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return gt.NORMAL;if(t=="additive")return gt.ADD;if(t=="multiply")return gt.MULTIPLY;if(t=="screen")return gt.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class Ps{constructor(t,n,e,a,r){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=a,this.inheritTimeline=r}}function mt(l,t,n,e){let a=l[0],r=I(a,"time",0),d=I(a,"value",n)*e,h=0;for(let s=0;;s++){t.setFrame(s,r,d);const i=l[s+1];if(!i)return t.shrink(h),t;const o=I(i,"time",0),c=I(i,"value",n)*e;a.curve&&(h=O(a.curve,t,h,s,0,r,o,d,c,e)),r=o,d=c,a=i}}function Re(l,t,n,e,a,r){let d=l[0],h=I(d,"time",0),s=I(d,n,a)*r,i=I(d,e,a)*r,o=0;for(let c=0;;c++){t.setFrame(c,h,s,i);const m=l[c+1];if(!m)return t.shrink(o),t;const f=I(m,"time",0),u=I(m,n,a)*r,g=I(m,e,a)*r,w=d.curve;w&&(o=O(w,t,o,c,0,h,f,s,u,r),o=O(w,t,o,c,1,h,f,i,g,r)),h=f,s=u,i=g,d=m}}function O(l,t,n,e,a,r,d,h,s,i){if(l=="stepped")return t.setStepped(e),n;const o=a<<2,c=l[o],m=l[o+1]*i,f=l[o+2],u=l[o+3]*i;return t.setBezier(n,e,a,r,h,c,m,f,u,d,s),n+1}function I(l,t,n){return l[t]!==void 0?l[t]:n}class $s extends hs{createSkeleton(t){this.skeleton=new Me(t),this.skeleton.updateWorldTransform(),this.stateData=new Ze(t),this.state=new Mt(this.stateData)}}export{de as AlphaTimeline,Wt as Animation,Mt as AnimationState,cs as AnimationStateAdapter,Ze as AnimationStateData,us as AtlasAttachmentLoader,Qt as Attachment,yt as AttachmentTimeline,Se as Bone,Ae as BoneData,_t as BoundingBoxAttachment,jt as ClippingAttachment,Ot as ConstraintData,rt as CurveTimeline,ot as CurveTimeline1,Nt as CurveTimeline2,fe as DeformTimeline,St as DrawOrderTimeline,Ie as Event,Ye as EventData,He as EventQueue,Rt as EventTimeline,Z as EventType,ts as IkConstraint,Ce as IkConstraintData,ge as IkConstraintTimeline,It as MeshAttachment,At as PathAttachment,Ft as PathConstraint,ve as PathConstraintData,we as PathConstraintMixTimeline,xe as PathConstraintPositionTimeline,be as PathConstraintSpacingTimeline,Gt as PointAttachment,ue as RGB2Timeline,me as RGBA2Timeline,le as RGBATimeline,ce as RGBTimeline,U as RegionAttachment,Et as RotateTimeline,ne as ScaleTimeline,ae as ScaleXTimeline,ie as ScaleYTimeline,Lt as Sequence,ct as SequenceMode,Zt as SequenceModeValues,vt as SequenceTimeline,re as ShearTimeline,oe as ShearXTimeline,he as ShearYTimeline,Me as Skeleton,ns as SkeletonBinary,Vs as SkeletonBounds,Fe as SkeletonData,De as SkeletonJson,zt as Skin,Be as SkinEntry,es as Slot,Xe as SlotData,K as SpacingMode,$s as Spine,H as Timeline,Ut as TrackEntry,ss as TransformConstraint,Te as TransformConstraintData,pe as TransformConstraintTimeline,te as TranslateTimeline,ee as TranslateXTimeline,se as TranslateYTimeline,it as VertexAttachment};
//# sourceMappingURL=runtime-4.1.mjs.map
