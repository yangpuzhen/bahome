import {
  Container,
  Graphics,
  SimpleMesh,
  Sprite
} from "./chunk-IMJPPDTD.js";
import {
  ALPHA_MODES,
  BLEND_MODES,
  DRAW_MODES,
  ExtensionType,
  LoaderParserPriority,
  MIPMAP_MODES,
  Matrix,
  Polygon,
  Rectangle,
  SCALE_MODES,
  Texture,
  Transform,
  checkExtension,
  extensions,
  lib_exports,
  settings
} from "./chunk-DSWJHRJ6.js";
import {
  __export
} from "./chunk-5WWUZCGV.js";

// node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs
var AttachmentType = ((AttachmentType2) => {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
  return AttachmentType2;
})(AttachmentType || {});

// node_modules/@pixi-spine/base/lib/core/BinaryInput.mjs
var BinaryInput = class {
  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {
    this.strings = strings;
    this.index = index;
    this.buffer = buffer;
  }
  readByte() {
    return this.buffer.getInt8(this.index++);
  }
  readUnsignedByte() {
    return this.buffer.getUint8(this.index++);
  }
  readShort() {
    const value = this.buffer.getInt16(this.index);
    this.index += 2;
    return value;
  }
  readInt32() {
    const value = this.buffer.getInt32(this.index);
    this.index += 4;
    return value;
  }
  readInt(optimizePositive) {
    let b = this.readByte();
    let result = b & 127;
    if ((b & 128) != 0) {
      b = this.readByte();
      result |= (b & 127) << 7;
      if ((b & 128) != 0) {
        b = this.readByte();
        result |= (b & 127) << 14;
        if ((b & 128) != 0) {
          b = this.readByte();
          result |= (b & 127) << 21;
          if ((b & 128) != 0) {
            b = this.readByte();
            result |= (b & 127) << 28;
          }
        }
      }
    }
    return optimizePositive ? result : result >>> 1 ^ -(result & 1);
  }
  readStringRef() {
    const index = this.readInt(true);
    return index == 0 ? null : this.strings[index - 1];
  }
  readString() {
    let byteCount = this.readInt(true);
    switch (byteCount) {
      case 0:
        return null;
      case 1:
        return "";
    }
    byteCount--;
    let chars = "";
    for (let i = 0; i < byteCount; ) {
      const b = this.readUnsignedByte();
      switch (b >> 4) {
        case 12:
        case 13:
          chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);
          i += 2;
          break;
        case 14:
          chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
          i += 3;
          break;
        default:
          chars += String.fromCharCode(b);
          i++;
      }
    }
    return chars;
  }
  readFloat() {
    const value = this.buffer.getFloat32(this.index);
    this.index += 4;
    return value;
  }
  readBoolean() {
    return this.readByte() != 0;
  }
};

// node_modules/@pixi-spine/base/lib/core/IAnimation.mjs
var MixBlend = ((MixBlend2) => {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
  return MixBlend2;
})(MixBlend || {});
var MixDirection = ((MixDirection2) => {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
  return MixDirection2;
})(MixDirection || {});

// node_modules/@pixi-spine/base/lib/core/IConstraint.mjs
var PositionMode = ((PositionMode2) => {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
  return PositionMode2;
})(PositionMode || {});
var RotateMode = ((RotateMode2) => {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
  return RotateMode2;
})(RotateMode || {});

// node_modules/@pixi-spine/base/lib/core/ISkeleton.mjs
var TransformMode = ((TransformMode2) => {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
  return TransformMode2;
})(TransformMode || {});

// node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs
function filterFromString(text) {
  switch (text.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error(`Unknown texture filter ${text}`);
  }
}
function wrapFromString(text) {
  switch (text.toLowerCase()) {
    case "mirroredtepeat":
      return TextureWrap.MirroredRepeat;
    case "clamptoedge":
      return TextureWrap.ClampToEdge;
    case "repeat":
      return TextureWrap.Repeat;
    default:
      throw new Error(`Unknown texture wrap ${text}`);
  }
}
var TextureFilter = ((TextureFilter2) => {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
  return TextureFilter2;
})(TextureFilter || {});
var TextureWrap = ((TextureWrap2) => {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
  return TextureWrap2;
})(TextureWrap || {});
var TextureRegion = class {
  constructor() {
    this.size = null;
    this.names = null;
    this.values = null;
    this.renderObject = null;
  }
  get width() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.width;
    }
    return tex.orig.width;
  }
  get height() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.height;
    }
    return tex.orig.height;
  }
  get u() {
    return this.texture._uvs.x0;
  }
  get v() {
    return this.texture._uvs.y0;
  }
  get u2() {
    return this.texture._uvs.x2;
  }
  get v2() {
    return this.texture._uvs.y2;
  }
  get offsetX() {
    const tex = this.texture;
    return tex.trim ? tex.trim.x : 0;
  }
  get offsetY() {
    return this.spineOffsetY;
  }
  get pixiOffsetY() {
    const tex = this.texture;
    return tex.trim ? tex.trim.y : 0;
  }
  get spineOffsetY() {
    const tex = this.texture;
    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
  }
  get originalWidth() {
    return this.texture.orig.width;
  }
  get originalHeight() {
    return this.texture.orig.height;
  }
  get x() {
    return this.texture.frame.x;
  }
  get y() {
    return this.texture.frame.y;
  }
  get rotate() {
    return this.texture.rotate !== 0;
  }
  get degrees() {
    return (360 - this.texture.rotate * 45) % 360;
  }
};

// node_modules/@pixi-spine/base/lib/core/TextureAtlas.mjs
var RegionFields = class {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.originalWidth = 0;
    this.originalHeight = 0;
    this.rotate = 0;
    this.index = 0;
  }
};
var TextureAtlas = class {
  constructor(atlasText, textureLoader, callback) {
    this.pages = new Array();
    this.regions = new Array();
    if (atlasText) {
      this.addSpineAtlas(atlasText, textureLoader, callback);
    }
  }
  addTexture(name, texture) {
    const pages = this.pages;
    let page = null;
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].baseTexture === texture.baseTexture) {
        page = pages[i];
        break;
      }
    }
    if (page === null) {
      page = new TextureAtlasPage();
      page.name = "texturePage";
      const baseTexture = texture.baseTexture;
      page.width = baseTexture.realWidth;
      page.height = baseTexture.realHeight;
      page.baseTexture = baseTexture;
      page.minFilter = page.magFilter = TextureFilter.Nearest;
      page.uWrap = TextureWrap.ClampToEdge;
      page.vWrap = TextureWrap.ClampToEdge;
      pages.push(page);
    }
    const region = new TextureAtlasRegion();
    region.name = name;
    region.page = page;
    region.texture = texture;
    region.index = -1;
    this.regions.push(region);
    return region;
  }
  addTextureHash(textures, stripExtension) {
    for (const key in textures) {
      if (textures.hasOwnProperty(key)) {
        this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
      }
    }
  }
  addSpineAtlas(atlasText, textureLoader, callback) {
    return this.load(atlasText, textureLoader, callback);
  }
  load(atlasText, textureLoader, callback) {
    if (textureLoader == null) {
      throw new Error("textureLoader cannot be null.");
    }
    const reader = new TextureAtlasReader(atlasText);
    const entry = new Array(4);
    let page = null;
    const pageFields = {};
    let region = null;
    pageFields.size = () => {
      page.width = parseInt(entry[1]);
      page.height = parseInt(entry[2]);
    };
    pageFields.format = () => {
    };
    pageFields.filter = () => {
      page.minFilter = filterFromString(entry[1]);
      page.magFilter = filterFromString(entry[2]);
    };
    pageFields.repeat = () => {
      if (entry[1].indexOf("x") != -1)
        page.uWrap = TextureWrap.Repeat;
      if (entry[1].indexOf("y") != -1)
        page.vWrap = TextureWrap.Repeat;
    };
    pageFields.pma = () => {
      page.pma = entry[1] == "true";
    };
    const regionFields = {};
    regionFields.xy = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
    };
    regionFields.size = () => {
      region.width = parseInt(entry[1]);
      region.height = parseInt(entry[2]);
    };
    regionFields.bounds = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
      region.width = parseInt(entry[3]);
      region.height = parseInt(entry[4]);
    };
    regionFields.offset = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
    };
    regionFields.orig = () => {
      region.originalWidth = parseInt(entry[1]);
      region.originalHeight = parseInt(entry[2]);
    };
    regionFields.offsets = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
      region.originalWidth = parseInt(entry[3]);
      region.originalHeight = parseInt(entry[4]);
    };
    regionFields.rotate = () => {
      const rotateValue = entry[1];
      let rotate = 0;
      if (rotateValue.toLocaleLowerCase() == "true") {
        rotate = 6;
      } else if (rotateValue.toLocaleLowerCase() == "false") {
        rotate = 0;
      } else {
        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
      }
      region.rotate = rotate;
    };
    regionFields.index = () => {
      region.index = parseInt(entry[1]);
    };
    let line = reader.readLine();
    while (line != null && line.trim().length == 0) {
      line = reader.readLine();
    }
    while (true) {
      if (line == null || line.trim().length == 0)
        break;
      if (reader.readEntry(entry, line) == 0)
        break;
      line = reader.readLine();
    }
    const iterateParser = () => {
      while (true) {
        if (line == null) {
          return callback && callback(this);
        }
        if (line.trim().length == 0) {
          page = null;
          line = reader.readLine();
        } else if (page === null) {
          page = new TextureAtlasPage();
          page.name = line.trim();
          while (true) {
            if (reader.readEntry(entry, line = reader.readLine()) == 0)
              break;
            const field = pageFields[entry[0]];
            if (field)
              field();
          }
          this.pages.push(page);
          textureLoader(page.name, (texture) => {
            if (texture === null) {
              this.pages.splice(this.pages.indexOf(page), 1);
              return callback && callback(null);
            }
            page.baseTexture = texture;
            if (page.pma) {
              texture.alphaMode = ALPHA_MODES.PMA;
            }
            if (!texture.valid) {
              texture.setSize(page.width, page.height);
            }
            page.setFilters();
            if (!page.width || !page.height) {
              page.width = texture.realWidth;
              page.height = texture.realHeight;
              if (!page.width || !page.height) {
                console.log(
                  `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`
                );
              }
            }
            iterateParser();
          });
          break;
        } else {
          region = new RegionFields();
          const atlasRegion = new TextureAtlasRegion();
          atlasRegion.name = line;
          atlasRegion.page = page;
          let names = null;
          let values = null;
          while (true) {
            const count = reader.readEntry(entry, line = reader.readLine());
            if (count == 0)
              break;
            const field = regionFields[entry[0]];
            if (field) {
              field();
            } else {
              if (names == null) {
                names = [];
                values = [];
              }
              names.push(entry[0]);
              const entryValues = [];
              for (let i = 0; i < count; i++) {
                entryValues.push(parseInt(entry[i + 1]));
              }
              values.push(entryValues);
            }
          }
          if (region.originalWidth == 0 && region.originalHeight == 0) {
            region.originalWidth = region.width;
            region.originalHeight = region.height;
          }
          const resolution = page.baseTexture.resolution;
          region.x /= resolution;
          region.y /= resolution;
          region.width /= resolution;
          region.height /= resolution;
          region.originalWidth /= resolution;
          region.originalHeight /= resolution;
          region.offsetX /= resolution;
          region.offsetY /= resolution;
          const swapWH = region.rotate % 4 !== 0;
          const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
          const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);
          const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
          atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);
          atlasRegion.index = region.index;
          atlasRegion.texture.updateUvs();
          this.regions.push(atlasRegion);
        }
      }
    };
    iterateParser();
  }
  findRegion(name) {
    for (let i = 0; i < this.regions.length; i++) {
      if (this.regions[i].name == name) {
        return this.regions[i];
      }
    }
    return null;
  }
  dispose() {
    for (let i = 0; i < this.pages.length; i++) {
      this.pages[i].baseTexture.dispose();
    }
  }
};
var TextureAtlasReader = class {
  constructor(text) {
    this.index = 0;
    this.lines = text.split(/\r\n|\r|\n/);
  }
  readLine() {
    if (this.index >= this.lines.length) {
      return null;
    }
    return this.lines[this.index++];
  }
  readEntry(entry, line) {
    if (line == null)
      return 0;
    line = line.trim();
    if (line.length == 0)
      return 0;
    const colon = line.indexOf(":");
    if (colon == -1)
      return 0;
    entry[0] = line.substr(0, colon).trim();
    for (let i = 1, lastMatch = colon + 1; ; i++) {
      const comma = line.indexOf(",", lastMatch);
      if (comma == -1) {
        entry[i] = line.substr(lastMatch).trim();
        return i;
      }
      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();
      lastMatch = comma + 1;
      if (i == 4)
        return 4;
    }
  }
};
var TextureAtlasPage = class {
  constructor() {
    this.minFilter = TextureFilter.Nearest;
    this.magFilter = TextureFilter.Nearest;
    this.uWrap = TextureWrap.ClampToEdge;
    this.vWrap = TextureWrap.ClampToEdge;
  }
  setFilters() {
    const tex = this.baseTexture;
    const filter = this.minFilter;
    if (filter == TextureFilter.Linear) {
      tex.scaleMode = SCALE_MODES.LINEAR;
    } else if (this.minFilter == TextureFilter.Nearest) {
      tex.scaleMode = SCALE_MODES.NEAREST;
    } else {
      tex.mipmap = MIPMAP_MODES.POW2;
      if (filter == TextureFilter.MipMapNearestNearest) {
        tex.scaleMode = SCALE_MODES.NEAREST;
      } else {
        tex.scaleMode = SCALE_MODES.LINEAR;
      }
    }
  }
};
var TextureAtlasRegion = class extends TextureRegion {
};

// node_modules/@pixi-spine/base/lib/core/Utils.mjs
var IntSet = class {
  constructor() {
    this.array = new Array();
  }
  add(value) {
    const contains = this.contains(value);
    this.array[value | 0] = value | 0;
    return !contains;
  }
  contains(value) {
    return this.array[value | 0] != void 0;
  }
  remove(value) {
    this.array[value | 0] = void 0;
  }
  clear() {
    this.array.length = 0;
  }
};
var StringSet = class {
  constructor() {
    this.entries = {};
    this.size = 0;
  }
  add(value) {
    const contains = this.entries[value];
    this.entries[value] = true;
    if (!contains) {
      this.size++;
      return true;
    }
    return false;
  }
  addAll(values) {
    const oldSize = this.size;
    for (let i = 0, n = values.length; i < n; i++) {
      this.add(values[i]);
    }
    return oldSize != this.size;
  }
  contains(value) {
    return this.entries[value];
  }
  clear() {
    this.entries = {};
    this.size = 0;
  }
};
var _Color = class {
  constructor(r = 0, g = 0, b = 0, a = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this.clamp();
  }
  setFromColor(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }
  setFromString(hex) {
    hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
    this.r = parseInt(hex.substr(0, 2), 16) / 255;
    this.g = parseInt(hex.substr(2, 2), 16) / 255;
    this.b = parseInt(hex.substr(4, 2), 16) / 255;
    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
    return this;
  }
  add(r, g, b, a) {
    this.r += r;
    this.g += g;
    this.b += b;
    this.a += a;
    return this.clamp();
  }
  clamp() {
    if (this.r < 0)
      this.r = 0;
    else if (this.r > 1)
      this.r = 1;
    if (this.g < 0)
      this.g = 0;
    else if (this.g > 1)
      this.g = 1;
    if (this.b < 0)
      this.b = 0;
    else if (this.b > 1)
      this.b = 1;
    if (this.a < 0)
      this.a = 0;
    else if (this.a > 1)
      this.a = 1;
    return this;
  }
  static rgba8888ToColor(color, value) {
    color.r = ((value & 4278190080) >>> 24) / 255;
    color.g = ((value & 16711680) >>> 16) / 255;
    color.b = ((value & 65280) >>> 8) / 255;
    color.a = (value & 255) / 255;
  }
  static rgb888ToColor(color, value) {
    color.r = ((value & 16711680) >>> 16) / 255;
    color.g = ((value & 65280) >>> 8) / 255;
    color.b = (value & 255) / 255;
  }
  static fromString(hex) {
    return new _Color().setFromString(hex);
  }
};
var Color = _Color;
Color.WHITE = new _Color(1, 1, 1, 1);
Color.RED = new _Color(1, 0, 0, 1);
Color.GREEN = new _Color(0, 1, 0, 1);
Color.BLUE = new _Color(0, 0, 1, 1);
Color.MAGENTA = new _Color(1, 0, 1, 1);
var _MathUtils = class {
  static clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
  static cosDeg(degrees) {
    return Math.cos(degrees * _MathUtils.degRad);
  }
  static sinDeg(degrees) {
    return Math.sin(degrees * _MathUtils.degRad);
  }
  static signum(value) {
    return Math.sign(value);
  }
  static toInt(x) {
    return x > 0 ? Math.floor(x) : Math.ceil(x);
  }
  static cbrt(x) {
    const y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  }
  static randomTriangular(min, max) {
    return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
  }
  static randomTriangularWith(min, max, mode) {
    const u = Math.random();
    const d = max - min;
    if (u <= (mode - min) / d)
      return min + Math.sqrt(u * d * (mode - min));
    return max - Math.sqrt((1 - u) * d * (max - mode));
  }
  static isPowerOfTwo(value) {
    return value && (value & value - 1) === 0;
  }
};
var MathUtils = _MathUtils;
MathUtils.PI = 3.1415927;
MathUtils.PI2 = _MathUtils.PI * 2;
MathUtils.radiansToDegrees = 180 / _MathUtils.PI;
MathUtils.radDeg = _MathUtils.radiansToDegrees;
MathUtils.degreesToRadians = _MathUtils.PI / 180;
MathUtils.degRad = _MathUtils.degreesToRadians;
var Interpolation = class {
  apply(start, end, a) {
    return start + (end - start) * this.applyInternal(a);
  }
};
var Pow = class extends Interpolation {
  constructor(power) {
    super();
    this.power = 2;
    this.power = power;
  }
  applyInternal(a) {
    if (a <= 0.5)
      return Math.pow(a * 2, this.power) / 2;
    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
  }
};
var PowOut = class extends Pow {
  applyInternal(a) {
    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
  }
};
var _Utils = class {
  static arrayCopy(source, sourceStart, dest, destStart, numElements) {
    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
      dest[j] = source[i];
    }
  }
  static arrayFill(array, fromIndex, toIndex, value) {
    for (let i = fromIndex; i < toIndex; i++) {
      array[i] = value;
    }
  }
  static setArraySize(array, size, value = 0) {
    const oldSize = array.length;
    if (oldSize == size)
      return array;
    array.length = size;
    if (oldSize < size) {
      for (let i = oldSize; i < size; i++)
        array[i] = value;
    }
    return array;
  }
  static ensureArrayCapacity(array, size, value = 0) {
    if (array.length >= size)
      return array;
    return _Utils.setArraySize(array, size, value);
  }
  static newArray(size, defaultValue) {
    const array = new Array(size);
    for (let i = 0; i < size; i++)
      array[i] = defaultValue;
    return array;
  }
  static newFloatArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Float32Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static newShortArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Int16Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static toFloatArray(array) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
  }
  static toSinglePrecision(value) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
  }
  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109
  static webkit602BugfixHelper(alpha, blend) {
  }
  static contains(array, element, identity = true) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == element)
        return true;
    }
    return false;
  }
  static enumValue(type, name) {
    return type[name[0].toUpperCase() + name.slice(1)];
  }
};
var Utils = _Utils;
Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
var DebugUtils = class {
  static logBones(skeleton) {
    for (let i = 0; i < skeleton.bones.length; i++) {
      const bone = skeleton.bones[i];
      const mat = bone.matrix;
      console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);
    }
  }
};
var Pool = class {
  constructor(instantiator) {
    this.items = new Array();
    this.instantiator = instantiator;
  }
  obtain() {
    return this.items.length > 0 ? this.items.pop() : this.instantiator();
  }
  free(item) {
    if (item.reset)
      item.reset();
    this.items.push(item);
  }
  freeAll(items) {
    for (let i = 0; i < items.length; i++) {
      this.free(items[i]);
    }
  }
  clear() {
    this.items.length = 0;
  }
};
var Vector2 = class {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  length() {
    const x = this.x;
    const y = this.y;
    return Math.sqrt(x * x + y * y);
  }
  normalize() {
    const len = this.length();
    if (len != 0) {
      this.x /= len;
      this.y /= len;
    }
    return this;
  }
};
var TimeKeeper = class {
  constructor() {
    this.maxDelta = 0.064;
    this.framesPerSecond = 0;
    this.delta = 0;
    this.totalTime = 0;
    this.lastTime = Date.now() / 1e3;
    this.frameCount = 0;
    this.frameTime = 0;
  }
  update() {
    const now = Date.now() / 1e3;
    this.delta = now - this.lastTime;
    this.frameTime += this.delta;
    this.totalTime += this.delta;
    if (this.delta > this.maxDelta)
      this.delta = this.maxDelta;
    this.lastTime = now;
    this.frameCount++;
    if (this.frameTime > 1) {
      this.framesPerSecond = this.frameCount / this.frameTime;
      this.frameTime = 0;
      this.frameCount = 0;
    }
  }
};
var WindowedMean = class {
  constructor(windowSize = 32) {
    this.addedValues = 0;
    this.lastValue = 0;
    this.mean = 0;
    this.dirty = true;
    this.values = new Array(windowSize);
  }
  hasEnoughData() {
    return this.addedValues >= this.values.length;
  }
  addValue(value) {
    if (this.addedValues < this.values.length)
      this.addedValues++;
    this.values[this.lastValue++] = value;
    if (this.lastValue > this.values.length - 1)
      this.lastValue = 0;
    this.dirty = true;
  }
  getMean() {
    if (this.hasEnoughData()) {
      if (this.dirty) {
        let mean = 0;
        for (let i = 0; i < this.values.length; i++) {
          mean += this.values[i];
        }
        this.mean = mean / this.values.length;
        this.dirty = false;
      }
      return this.mean;
    }
    return 0;
  }
};

// node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs
var SkeletonBoundsBase = class {
  constructor() {
    this.minX = 0;
    this.minY = 0;
    this.maxX = 0;
    this.maxY = 0;
    this.boundingBoxes = new Array();
    this.polygons = new Array();
    this.polygonPool = new Pool(() => Utils.newFloatArray(16));
  }
  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding
   * box's polygon.
   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the
   *           SkeletonBounds AABB methods will always return true. */
  update(skeleton, updateAabb) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    const boundingBoxes = this.boundingBoxes;
    const polygons = this.polygons;
    const polygonPool = this.polygonPool;
    const slots = skeleton.slots;
    const slotCount = slots.length;
    boundingBoxes.length = 0;
    polygonPool.freeAll(polygons);
    polygons.length = 0;
    for (let i = 0; i < slotCount; i++) {
      const slot = slots[i];
      if (!slot.bone.active)
        continue;
      const attachment = slot.getAttachment();
      if (attachment != null && attachment.type === AttachmentType.BoundingBox) {
        const boundingBox = attachment;
        boundingBoxes.push(boundingBox);
        let polygon = polygonPool.obtain();
        if (polygon.length != boundingBox.worldVerticesLength) {
          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);
        }
        polygons.push(polygon);
        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
      }
    }
    if (updateAabb) {
      this.aabbCompute();
    } else {
      this.minX = Number.POSITIVE_INFINITY;
      this.minY = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.maxY = Number.NEGATIVE_INFINITY;
    }
  }
  aabbCompute() {
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      const polygon = polygons[i];
      const vertices = polygon;
      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {
        const x = vertices[ii];
        const y = vertices[ii + 1];
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /** Returns true if the axis aligned bounding box contains the point. */
  aabbContainsPoint(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }
  /** Returns true if the axis aligned bounding box intersects the line segment. */
  aabbIntersectsSegment(x1, y1, x2, y2) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
      return false;
    }
    const m = (y2 - y1) / (x2 - x1);
    let y = m * (minX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    y = m * (maxX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    let x = (minY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    x = (maxY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    return false;
  }
  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
  aabbIntersectsSkeleton(bounds) {
    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
  }
  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/
  containsPoint(x, y) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.containsPointPolygon(polygons[i], x, y))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains the point. */
  containsPointPolygon(polygon, x, y) {
    const vertices = polygon;
    const nn = polygon.length;
    let prevIndex = nn - 2;
    let inside = false;
    for (let ii = 0; ii < nn; ii += 2) {
      const vertexY = vertices[ii + 1];
      const prevY = vertices[prevIndex + 1];
      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
        const vertexX = vertices[ii];
        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
          inside = !inside;
      }
      prevIndex = ii;
    }
    return inside;
  }
  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns
   * true. */
  intersectsSegment(x1, y1, x2, y2) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains any part of the line segment. */
  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {
    const vertices = polygon;
    const nn = polygon.length;
    const width12 = x1 - x2;
    const height12 = y1 - y2;
    const det1 = x1 * y2 - y1 * x2;
    let x3 = vertices[nn - 2];
    let y3 = vertices[nn - 1];
    for (let ii = 0; ii < nn; ii += 2) {
      const x4 = vertices[ii];
      const y4 = vertices[ii + 1];
      const det2 = x3 * y4 - y3 * x4;
      const width34 = x3 - x4;
      const height34 = y3 - y4;
      const det3 = width12 * height34 - height12 * width34;
      const x = (det1 * width34 - width12 * det2) / det3;
      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
        const y = (det1 * height34 - height12 * det2) / det3;
        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))
          return true;
      }
      x3 = x4;
      y3 = y4;
    }
    return false;
  }
  /** Returns the polygon for the specified bounding box, or null. */
  getPolygon(boundingBox) {
    if (!boundingBox)
      throw new Error("boundingBox cannot be null.");
    const index = this.boundingBoxes.indexOf(boundingBox);
    return index == -1 ? null : this.polygons[index];
  }
  /** The width of the axis aligned bounding box. */
  getWidth() {
    return this.maxX - this.minX;
  }
  /** The height of the axis aligned bounding box. */
  getHeight() {
    return this.maxY - this.minY;
  }
};

// node_modules/@pixi-spine/base/lib/settings.mjs
var settings2 = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0
};

// node_modules/@pixi-spine/base/lib/SpineBase.mjs
var tempRgb = [0, 0, 0];
var SpineSprite = class extends Sprite {
  constructor() {
    super(...arguments);
    this.region = null;
    this.attachment = null;
  }
};
var SpineMesh = class extends SimpleMesh {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(texture, vertices, uvs, indices, drawMode);
    this.region = null;
    this.attachment = null;
  }
};
var _SpineBase = class extends Container {
  constructor(spineData) {
    super();
    if (!spineData) {
      throw new Error("The spineData param is required.");
    }
    if (typeof spineData === "string") {
      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
    }
    this.spineData = spineData;
    this.createSkeleton(spineData);
    this.slotContainers = [];
    this.tempClipContainers = [];
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.newContainer();
      this.slotContainers.push(slotContainer);
      this.addChild(slotContainer);
      this.tempClipContainers.push(null);
      if (!attachment) {
        continue;
      }
      if (attachment.type === AttachmentType.Region) {
        const spriteName = attachment.name;
        const sprite = this.createSprite(slot, attachment, spriteName);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
      } else if (attachment.type === AttachmentType.Mesh) {
        const mesh = this.createMesh(slot, attachment);
        slot.currentMesh = mesh;
        slot.currentMeshId = attachment.id;
        slot.currentMeshName = attachment.name;
        slotContainer.addChild(mesh);
      } else if (attachment.type === AttachmentType.Clipping) {
        this.createGraphics(slot, attachment);
        slotContainer.addChild(slot.clippingContainer);
        slotContainer.addChild(slot.currentGraphics);
      }
    }
    this.tintRgb = new Float32Array([1, 1, 1]);
    this.autoUpdate = true;
    this.visible = true;
  }
  get debug() {
    return this._debug;
  }
  set debug(value) {
    var _a;
    if (value == this._debug) {
      return;
    }
    (_a = this._debug) == null ? void 0 : _a.unregisterSpine(this);
    value == null ? void 0 : value.registerSpine(this);
    this._debug = value;
  }
  /**
   * If this flag is set to true, the spine animation will be automatically updated every
   * time the object id drawn. The down side of this approach is that the delta time is
   * automatically calculated and you could miss out on cool effects like slow motion,
   * pause, skip ahead and the sorts. Most of these effects can be achieved even with
   * autoUpdate enabled but are harder to achieve.
   *
   * @member {boolean}
   * @memberof spine.Spine#
   * @default true
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;
    }
  }
  /**
   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
   *
   * @member {number}
   * @memberof spine.Spine#
   * @default 0xFFFFFF
   */
  get tint() {
    return lib_exports.rgb2hex(this.tintRgb);
  }
  set tint(value) {
    this.tintRgb = lib_exports.hex2rgb(value, this.tintRgb);
  }
  /**
   * Limit value for the update dt with Spine.globalDelayLimit
   * that can be overridden with localDelayLimit
   * @return {number} - Maximum processed dt value for the update
   */
  get delayLimit() {
    const limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : settings2.GLOBAL_DELAY_LIMIT;
    return limit || Number.MAX_VALUE;
  }
  /**
   * Update the spine skeleton and its animations by delta time (dt)
   *
   * @param dt {number} Delta time. Time by which the animation should be updated
   */
  update(dt) {
    var _a;
    const delayLimit = this.delayLimit;
    if (dt > delayLimit)
      dt = delayLimit;
    this.state.update(dt);
    this.state.apply(this.skeleton);
    if (!this.skeleton) {
      return;
    }
    this.skeleton.updateWorldTransform();
    const slots = this.skeleton.slots;
    const globalClr = this.color;
    let light = null;
    let dark = null;
    if (globalClr) {
      light = globalClr.light;
      dark = globalClr.dark;
    } else {
      light = this.tintRgb;
    }
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.slotContainers[i];
      if (!attachment) {
        slotContainer.visible = false;
        continue;
      }
      let spriteColor = null;
      if (attachment.sequence) {
        attachment.sequence.apply(slot, attachment);
      }
      let region = attachment.region;
      const attColor = attachment.color;
      switch (attachment != null && attachment.type) {
        case AttachmentType.Region:
          const transform = slotContainer.transform;
          transform.setFromMatrix(slot.bone.matrix);
          region = attachment.region;
          if (slot.currentMesh) {
            slot.currentMesh.visible = false;
            slot.currentMesh = null;
            slot.currentMeshId = void 0;
            slot.currentMeshName = void 0;
          }
          if (!region) {
            if (slot.currentSprite) {
              slot.currentSprite.renderable = false;
            }
            break;
          }
          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
            const spriteName = attachment.name;
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
            }
            slot.sprites = slot.sprites || {};
            if (slot.sprites[spriteName] !== void 0) {
              slot.sprites[spriteName].visible = true;
            } else {
              const sprite = this.createSprite(slot, attachment, spriteName);
              slotContainer.addChild(sprite);
            }
            slot.currentSprite = slot.sprites[spriteName];
            slot.currentSpriteName = spriteName;
          }
          slot.currentSprite.renderable = true;
          if (!slot.hackRegion) {
            this.setSpriteRegion(attachment, slot.currentSprite, region);
          }
          if (slot.currentSprite.color) {
            spriteColor = slot.currentSprite.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentSprite.tint = lib_exports.rgb2hex(tempRgb);
          }
          slot.currentSprite.blendMode = slot.blendMode;
          break;
        case AttachmentType.Mesh:
          if (slot.currentSprite) {
            slot.currentSprite.visible = false;
            slot.currentSprite = null;
            slot.currentSpriteName = void 0;
            const transform2 = new Transform();
            transform2._parentID = -1;
            transform2._worldID = slotContainer.transform._worldID;
            slotContainer.transform = transform2;
          }
          if (!region) {
            if (slot.currentMesh) {
              slot.currentMesh.renderable = false;
            }
            break;
          }
          const id = attachment.id;
          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {
            const meshId = id;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
            }
            slot.meshes = slot.meshes || {};
            if (slot.meshes[meshId] !== void 0) {
              slot.meshes[meshId].visible = true;
            } else {
              const mesh = this.createMesh(slot, attachment);
              slotContainer.addChild(mesh);
            }
            slot.currentMesh = slot.meshes[meshId];
            slot.currentMeshName = attachment.name;
            slot.currentMeshId = meshId;
          }
          slot.currentMesh.renderable = true;
          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
          if (slot.currentMesh.color) {
            spriteColor = slot.currentMesh.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentMesh.tint = lib_exports.rgb2hex(tempRgb);
          }
          slot.currentMesh.blendMode = slot.blendMode;
          if (!slot.hackRegion) {
            this.setMeshRegion(attachment, slot.currentMesh, region);
          }
          break;
        case AttachmentType.Clipping:
          if (!slot.currentGraphics) {
            this.createGraphics(slot, attachment);
            slotContainer.addChild(slot.clippingContainer);
            slotContainer.addChild(slot.currentGraphics);
          }
          this.updateGraphics(slot, attachment);
          slotContainer.alpha = 1;
          slotContainer.visible = true;
          continue;
        default:
          slotContainer.visible = false;
          continue;
      }
      slotContainer.visible = true;
      if (spriteColor) {
        let r0 = slot.color.r * attColor.r;
        let g0 = slot.color.g * attColor.g;
        let b0 = slot.color.b * attColor.b;
        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        if (slot.darkColor) {
          r0 = slot.darkColor.r;
          g0 = slot.darkColor.g;
          b0 = slot.darkColor.b;
        } else {
          r0 = 0;
          g0 = 0;
          b0 = 0;
        }
        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
      }
      slotContainer.alpha = slot.color.a;
    }
    const drawOrder = this.skeleton.drawOrder;
    let clippingAttachment = null;
    let clippingContainer = null;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = slots[drawOrder[i].data.index];
      const slotContainer = this.slotContainers[drawOrder[i].data.index];
      if (!clippingContainer) {
        if (slotContainer.parent !== null && slotContainer.parent !== this) {
          slotContainer.parent.removeChild(slotContainer);
          slotContainer.parent = this;
        }
      }
      if (slot.currentGraphics && slot.getAttachment()) {
        clippingContainer = slot.clippingContainer;
        clippingAttachment = slot.getAttachment();
        clippingContainer.children.length = 0;
        this.children[i] = slotContainer;
        if (clippingAttachment.endSlot === slot.data) {
          clippingAttachment.endSlot = null;
        }
      } else if (clippingContainer) {
        let c = this.tempClipContainers[i];
        if (!c) {
          c = this.tempClipContainers[i] = this.newContainer();
          c.visible = false;
        }
        this.children[i] = c;
        slotContainer.parent = null;
        clippingContainer.addChild(slotContainer);
        if (clippingAttachment.endSlot == slot.data) {
          clippingContainer.renderable = true;
          clippingContainer = null;
          clippingAttachment = null;
        }
      } else {
        this.children[i] = slotContainer;
      }
    }
    (_a = this._debug) == null ? void 0 : _a.renderDebug(this);
  }
  setSpriteRegion(attachment, sprite, region) {
    if (sprite.attachment === attachment && sprite.region === region) {
      return;
    }
    sprite.region = region;
    sprite.attachment = attachment;
    sprite.texture = region.texture;
    sprite.rotation = attachment.rotation * MathUtils.degRad;
    sprite.position.x = attachment.x;
    sprite.position.y = attachment.y;
    sprite.alpha = attachment.color.a;
    if (!region.size) {
      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
    } else {
      sprite.scale.x = region.size.width / region.originalWidth;
      sprite.scale.y = -region.size.height / region.originalHeight;
    }
  }
  setMeshRegion(attachment, mesh, region) {
    if (mesh.attachment === attachment && mesh.region === region) {
      return;
    }
    mesh.region = region;
    mesh.attachment = attachment;
    mesh.texture = region.texture;
    region.texture.updateUvs();
    mesh.uvBuffer.update(attachment.regionUVs);
  }
  /**
   * When autoupdate is set to yes this function is used as pixi's updateTransform function
   *
   * @private
   */
  autoUpdateTransform() {
    if (settings2.GLOBAL_AUTO_UPDATE) {
      this.lastTime = this.lastTime || Date.now();
      const timeDelta = (Date.now() - this.lastTime) * 1e-3;
      this.lastTime = Date.now();
      this.update(timeDelta);
    } else {
      this.lastTime = 0;
    }
    Container.prototype.updateTransform.call(this);
  }
  /**
   * Create a new sprite to be used with core.RegionAttachment
   *
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createSprite(slot, attachment, defName) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
    }
    const texture = region ? region.texture : null;
    const sprite = this.newSprite(texture);
    sprite.anchor.set(0.5);
    if (region) {
      this.setSpriteRegion(attachment, sprite, attachment.region);
    }
    slot.sprites = slot.sprites || {};
    slot.sprites[defName] = sprite;
    return sprite;
  }
  /**
   * Creates a Strip from the spine data
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createMesh(slot, attachment) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
      slot.hackAttachment = null;
      slot.hackRegion = null;
    }
    const strip = this.newMesh(
      region ? region.texture : null,
      new Float32Array(attachment.regionUVs.length),
      attachment.regionUVs,
      new Uint16Array(attachment.triangles),
      DRAW_MODES.TRIANGLES
    );
    if (typeof strip._canvasPadding !== "undefined") {
      strip._canvasPadding = 1.5;
    }
    strip.alpha = attachment.color.a;
    strip.region = attachment.region;
    if (region) {
      this.setMeshRegion(attachment, strip, region);
    }
    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.id] = strip;
    return strip;
  }
  // @ts-ignore
  createGraphics(slot, clip) {
    const graphics = this.newGraphics();
    const poly = new Polygon([]);
    graphics.clear();
    graphics.beginFill(16777215, 1);
    graphics.drawPolygon(poly);
    graphics.renderable = false;
    slot.currentGraphics = graphics;
    slot.clippingContainer = this.newContainer();
    slot.clippingContainer.mask = slot.currentGraphics;
    return graphics;
  }
  updateGraphics(slot, clip) {
    const geom = slot.currentGraphics.geometry;
    const vertices = geom.graphicsData[0].shape.points;
    const n = clip.worldVerticesLength;
    vertices.length = n;
    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
    geom.invalidate();
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotIndex {number}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const attachment = slot.getAttachment();
    let region = attachment.region;
    if (texture) {
      region = new TextureRegion();
      region.texture = texture;
      region.size = size;
      slot.hackRegion = region;
      slot.hackAttachment = attachment;
    } else {
      slot.hackRegion = null;
      slot.hackAttachment = null;
    }
    if (slot.currentSprite) {
      this.setSpriteRegion(attachment, slot.currentSprite, region);
    } else if (slot.currentMesh) {
      this.setMeshRegion(attachment, slot.currentMesh, region);
    }
    return true;
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotName(slotName, texture = null, size = null) {
    const index = this.skeleton.findSlotIndex(slotName);
    if (index == -1) {
      return false;
    }
    return this.hackTextureBySlotIndex(index, texture, size);
  }
  /**
   * Changes texture of an attachment
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param attachmentName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureAttachment(slotName, attachmentName, texture, size = null) {
    const slotIndex = this.skeleton.findSlotIndex(slotName);
    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
    attachment.region.texture = texture;
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const currentAttachment = slot.getAttachment();
    if (attachmentName === currentAttachment.name) {
      let region = attachment.region;
      if (texture) {
        region = new TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = currentAttachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite && slot.currentSprite.region != region) {
        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
        slot.currentSprite.region = region;
      } else if (slot.currentMesh && slot.currentMesh.region != region) {
        this.setMeshRegion(currentAttachment, slot.currentMesh, region);
      }
      return true;
    }
    return false;
  }
  // those methods can be overriden to spawn different classes
  newContainer() {
    return new Container();
  }
  newSprite(tex) {
    return new SpineSprite(tex);
  }
  newGraphics() {
    return new Graphics();
  }
  newMesh(texture, vertices, uvs, indices, drawMode) {
    return new SpineMesh(texture, vertices, uvs, indices, drawMode);
  }
  transformHack() {
    return 1;
  }
  /**
   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer
   * @param nameSuffix
   * @param group
   * @param outGroup
   */
  hackAttachmentGroups(nameSuffix, group, outGroup) {
    if (!nameSuffix) {
      return void 0;
    }
    const list_d = [];
    const list_n = [];
    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {
      const slot = this.skeleton.slots[i];
      const name = slot.currentSpriteName || slot.currentMeshName || "";
      const target = slot.currentSprite || slot.currentMesh;
      if (name.endsWith(nameSuffix)) {
        target.parentGroup = group;
        list_n.push(target);
      } else if (outGroup && target) {
        target.parentGroup = outGroup;
        list_d.push(target);
      }
    }
    return [list_d, list_n];
  }
  destroy(options) {
    this.debug = null;
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      for (const name in slot.meshes) {
        slot.meshes[name].destroy(options);
      }
      slot.meshes = null;
      for (const name in slot.sprites) {
        slot.sprites[name].destroy(options);
      }
      slot.sprites = null;
    }
    for (let i = 0, n = this.slotContainers.length; i < n; i++) {
      this.slotContainers[i].destroy(options);
    }
    this.spineData = null;
    this.skeleton = null;
    this.slotContainers = null;
    this.stateData = null;
    this.state = null;
    this.tempClipContainers = null;
    super.destroy(options);
  }
};
var SpineBase = _SpineBase;
SpineBase.clippingPolygon = [];
Object.defineProperty(SpineBase.prototype, "visible", {
  get() {
    return this._visible;
  },
  set(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});

// node_modules/@pixi-spine/base/lib/SpineDebugRenderer.mjs
var SpineDebugRenderer = class {
  constructor() {
    this.registeredSpines = /* @__PURE__ */ new Map();
    this.drawDebug = true;
    this.drawMeshHull = true;
    this.drawMeshTriangles = true;
    this.drawBones = true;
    this.drawPaths = true;
    this.drawBoundingBoxes = true;
    this.drawClipping = true;
    this.drawRegionAttachments = true;
    this.lineWidth = 1;
    this.regionAttachmentsColor = 30975;
    this.meshHullColor = 30975;
    this.meshTrianglesColor = 16763904;
    this.clippingPolygonColor = 16711935;
    this.boundingBoxesRectColor = 65280;
    this.boundingBoxesPolygonColor = 65280;
    this.boundingBoxesCircleColor = 65280;
    this.pathsCurveColor = 16711680;
    this.pathsLineColor = 16711935;
    this.skeletonXYColor = 16711680;
    this.bonesColor = 61132;
  }
  /**
   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update
   */
  registerSpine(spine) {
    if (this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", spine);
    }
    const debugDisplayObjects = {
      parentDebugContainer: new Container(),
      bones: new Container(),
      skeletonXY: new Graphics(),
      regionAttachmentsShape: new Graphics(),
      meshTrianglesLine: new Graphics(),
      meshHullLine: new Graphics(),
      clippingPolygon: new Graphics(),
      boundingBoxesRect: new Graphics(),
      boundingBoxesCircle: new Graphics(),
      boundingBoxesPolygon: new Graphics(),
      pathsCurve: new Graphics(),
      pathsLine: new Graphics()
    };
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);
    spine.addChild(debugDisplayObjects.parentDebugContainer);
    this.registeredSpines.set(spine, debugDisplayObjects);
  }
  renderDebug(spine) {
    if (!this.registeredSpines.has(spine)) {
      this.registerSpine(spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.skeletonXY.clear();
    debugDisplayObjects.regionAttachmentsShape.clear();
    debugDisplayObjects.meshTrianglesLine.clear();
    debugDisplayObjects.meshHullLine.clear();
    debugDisplayObjects.clippingPolygon.clear();
    debugDisplayObjects.boundingBoxesRect.clear();
    debugDisplayObjects.boundingBoxesCircle.clear();
    debugDisplayObjects.boundingBoxesPolygon.clear();
    debugDisplayObjects.pathsCurve.clear();
    debugDisplayObjects.pathsLine.clear();
    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
      debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });
    }
    const scale = spine.scale.x || spine.scale.y || 1;
    const lineWidth = this.lineWidth / scale;
    if (this.drawBones) {
      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);
    }
    if (this.drawPaths) {
      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawBoundingBoxes) {
      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawClipping) {
      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawMeshHull || this.drawMeshTriangles) {
      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawRegionAttachments) {
      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);
    }
  }
  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {
    const skeleton = spine.skeleton;
    const skeletonX = skeleton.x;
    const skeletonY = skeleton.y;
    const bones = skeleton.bones;
    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);
    for (let i = 0, len = bones.length; i < len; i++) {
      const bone = bones[i];
      const boneLen = bone.data.length;
      const starX = skeletonX + bone.matrix.tx;
      const starY = skeletonY + bone.matrix.ty;
      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;
      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;
      if (bone.data.name === "root" || bone.data.parent === null) {
        continue;
      }
      const w = Math.abs(starX - endX);
      const h = Math.abs(starY - endY);
      const a2 = Math.pow(w, 2);
      const b = h;
      const b2 = Math.pow(h, 2);
      const c = Math.sqrt(a2 + b2);
      const c2 = Math.pow(c, 2);
      const rad = Math.PI / 180;
      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;
      if (c === 0) {
        continue;
      }
      const gp = new Graphics();
      debugDisplayObjects.bones.addChild(gp);
      const refRation = c / 50 / scale;
      gp.beginFill(this.bonesColor, 1);
      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);
      gp.endFill();
      gp.x = starX;
      gp.y = starY;
      gp.pivot.y = c;
      let rotation = 0;
      if (starX < endX && starY < endY) {
        rotation = -B + 180 * rad;
      } else if (starX > endX && starY < endY) {
        rotation = 180 * rad + B;
      } else if (starX > endX && starY > endY) {
        rotation = -B;
      } else if (starX < endX && starY > endY) {
        rotation = B;
      } else if (starY === endY && starX < endX) {
        rotation = 90 * rad;
      } else if (starY === endY && starX > endX) {
        rotation = -90 * rad;
      } else if (starX === endX && starY < endY) {
        rotation = 180 * rad;
      } else if (starX === endX && starY > endY) {
        rotation = 0;
      }
      gp.rotation = rotation;
      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);
      gp.beginFill(0, 0.6);
      gp.drawCircle(0, c, refRation * 1.2);
      gp.endFill();
    }
    const startDotSize = lineWidth * 3;
    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);
    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);
  }
  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Region) {
        continue;
      }
      const regionAttachment = attachment;
      const vertices = new Float32Array(8);
      if (regionAttachment.updateOffset)
        regionAttachment.updateOffset();
      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);
      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));
    }
  }
  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);
    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Mesh) {
        continue;
      }
      const meshAttachment = attachment;
      const vertices = new Float32Array(meshAttachment.worldVerticesLength);
      const triangles = meshAttachment.triangles;
      let hullLength = meshAttachment.hullLength;
      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);
      if (this.drawMeshTriangles) {
        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {
          const v1 = triangles[i2] * 2;
          const v2 = triangles[i2 + 1] * 2;
          const v3 = triangles[i2 + 2] * 2;
          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);
        }
      }
      if (this.drawMeshHull && hullLength > 0) {
        hullLength = (hullLength >> 1) * 2;
        let lastX = vertices[hullLength - 2];
        let lastY = vertices[hullLength - 1];
        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {
          const x = vertices[i2];
          const y = vertices[i2 + 1];
          debugDisplayObjects.meshHullLine.moveTo(x, y);
          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);
          lastX = x;
          lastY = y;
        }
      }
    }
  }
  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Clipping) {
        continue;
      }
      const clippingAttachment = attachment;
      const nn = clippingAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));
    }
  }
  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {
    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);
    const bounds = new SkeletonBoundsBase();
    bounds.update(spine.skeleton, true);
    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
    const polygons = bounds.polygons;
    const drawPolygon = (polygonVertices, _offset, count) => {
      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);
      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);
      if (count < 3) {
        throw new Error("Polygon must contain at least 3 vertices");
      }
      const paths = [];
      const dotSize = lineWidth * 2;
      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {
        const x1 = polygonVertices[i];
        const y1 = polygonVertices[i + 1];
        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);
        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);
        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);
        debugDisplayObjects.boundingBoxesCircle.endFill();
        paths.push(x1, y1);
      }
      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);
      debugDisplayObjects.boundingBoxesPolygon.endFill();
    };
    for (let i = 0, len = polygons.length; i < len; i++) {
      const polygon = polygons[i];
      drawPolygon(polygon, 0, polygon.length);
    }
  }
  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);
    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== AttachmentType.Path) {
        continue;
      }
      const pathAttachment = attachment;
      let nn = pathAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      let x1 = world[2];
      let y1 = world[3];
      let x2 = 0;
      let y2 = 0;
      if (pathAttachment.closed) {
        const cx1 = world[0];
        const cy1 = world[1];
        const cx2 = world[nn - 2];
        const cy2 = world[nn - 1];
        x2 = world[nn - 4];
        y2 = world[nn - 3];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
      }
      nn -= 4;
      for (let ii = 4; ii < nn; ii += 6) {
        const cx1 = world[ii];
        const cy1 = world[ii + 1];
        const cx2 = world[ii + 2];
        const cy2 = world[ii + 3];
        x2 = world[ii + 4];
        y2 = world[ii + 5];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
        x1 = x2;
        y1 = y2;
      }
    }
  }
  unregisterSpine(spine) {
    if (!this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });
    this.registeredSpines.delete(spine);
  }
};

// node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs
var spineTextureAtlasLoader = {
  extension: ExtensionType.Asset,
  // cache: {
  //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,
  //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),
  // },
  loader: {
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal
    },
    test(url) {
      return checkExtension(url, ".atlas");
    },
    async load(url) {
      const response = await settings.ADAPTER.fetch(url);
      const txt = await response.text();
      return txt;
    },
    testParse(asset, options) {
      const isExtensionRight = checkExtension(options.src, ".atlas");
      const isString = typeof asset === "string";
      return Promise.resolve(isExtensionRight && isString);
    },
    async parse(asset, options, loader) {
      const metadata = options.data;
      let basePath = lib_exports.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let resolve = null;
      let reject = null;
      const retPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      let retval;
      const resolveCallback = (newAtlas) => {
        if (!newAtlas) {
          reject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
        }
        resolve(retval);
      };
      if (metadata.image || metadata.images) {
        const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);
        retval = new TextureAtlas(
          asset,
          (line, callback) => {
            const page = pages[line] || pages.default;
            if (page && page.baseTexture)
              callback(page.baseTexture);
            else
              callback(page);
          },
          resolveCallback
        );
      } else {
        retval = new TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
      }
      return await retPromise;
    },
    unload(atlas) {
      atlas.dispose();
    }
  }
};
var makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
  return async (pageName, textureLoadedCallback) => {
    const url = lib_exports.path.normalize([...atlasBasePath.split(lib_exports.path.sep), pageName].join(lib_exports.path.sep));
    const texture = await loader.load({ src: url, data: imageMetadata });
    textureLoadedCallback(texture.baseTexture);
  };
};
extensions.add(spineTextureAtlasLoader);

// node_modules/@pixi-spine/loader-base/lib/SpineLoaderAbstract.mjs
function isJson(resource) {
  return resource.hasOwnProperty("bones");
}
function isBuffer(resource) {
  return resource instanceof ArrayBuffer;
}
var SpineLoaderAbstract = class {
  constructor() {
  }
  installLoader() {
    const spineAdapter = this;
    const spineLoaderExtension = {
      extension: ExtensionType.Asset,
      loader: {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        // #region Downloading skel buffer data
        test(url) {
          return checkExtension(url, ".skel");
        },
        async load(url) {
          const response = await settings.ADAPTER.fetch(url);
          const buffer = await response.arrayBuffer();
          return buffer;
        },
        // #endregion
        // #region Parsing spine data
        testParse(asset, options) {
          var _a;
          const isJsonSpineModel = checkExtension(options.src, ".json") && isJson(asset);
          const isBinarySpineModel = checkExtension(options.src, ".skel") && isBuffer(asset);
          const isMetadataAngry = ((_a = options.data) == null ? void 0 : _a.spineAtlas) === false;
          return Promise.resolve(isJsonSpineModel && !isMetadataAngry || isBinarySpineModel);
        },
        async parse(asset, loadAsset, loader) {
          const fileExt = lib_exports.path.extname(loadAsset.src).toLowerCase();
          const fileName = lib_exports.path.basename(loadAsset.src, fileExt);
          let basePath = lib_exports.path.dirname(loadAsset.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          const isJsonSpineModel = checkExtension(loadAsset.src, ".json") && isJson(asset);
          let parser = null;
          let dataToParse = asset;
          if (isJsonSpineModel) {
            parser = spineAdapter.createJsonParser();
          } else {
            parser = spineAdapter.createBinaryParser();
            dataToParse = new Uint8Array(asset);
          }
          const metadata = loadAsset.data || {};
          const metadataSkeletonScale = (metadata == null ? void 0 : metadata.spineSkeletonScale) ?? null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          const metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas && metadataAtlas.pages) {
            return spineAdapter.parseData(parser, metadataAtlas, dataToParse);
          }
          const textAtlas = metadata.atlasRawData;
          if (textAtlas) {
            let auxResolve = null;
            let auxReject = null;
            const atlasPromise = new Promise((resolve, reject) => {
              auxResolve = resolve;
              auxReject = reject;
            });
            const atlas = new TextureAtlas(textAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), (newAtlas) => {
              if (!newAtlas) {
                auxReject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
              }
              auxResolve(atlas);
            });
            const textureAtlas2 = await atlasPromise;
            return spineAdapter.parseData(parser, textureAtlas2, dataToParse);
          }
          let atlasPath = metadata.spineAtlasFile;
          if (!atlasPath) {
            atlasPath = `${basePath + fileName}.atlas`;
          }
          const textureAtlas = await loader.load({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });
          return spineAdapter.parseData(parser, textureAtlas, dataToParse);
        }
        // #endregion
        // unload(asset: ISpineResource<SKD>, loadAsset, loader) {
        // 	???
        // },
      }
    };
    extensions.add(spineLoaderExtension);
    return spineLoaderExtension;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/index.mjs
var lib_exports2 = {};
__export(lib_exports2, {
  Animation: () => Animation,
  AnimationState: () => AnimationState,
  AnimationStateAdapter: () => AnimationStateAdapter,
  AnimationStateData: () => AnimationStateData,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader,
  Attachment: () => Attachment,
  AttachmentTimeline: () => AttachmentTimeline,
  Bone: () => Bone,
  BoneData: () => BoneData,
  BoundingBoxAttachment: () => BoundingBoxAttachment,
  ClippingAttachment: () => ClippingAttachment,
  ColorTimeline: () => ColorTimeline,
  ConstraintData: () => ConstraintData,
  CurveTimeline: () => CurveTimeline,
  DeformTimeline: () => DeformTimeline,
  DrawOrderTimeline: () => DrawOrderTimeline,
  Event: () => Event,
  EventData: () => EventData,
  EventQueue: () => EventQueue,
  EventTimeline: () => EventTimeline,
  EventType: () => EventType,
  IkConstraint: () => IkConstraint,
  IkConstraintData: () => IkConstraintData,
  IkConstraintTimeline: () => IkConstraintTimeline,
  JitterEffect: () => JitterEffect,
  MeshAttachment: () => MeshAttachment,
  PathAttachment: () => PathAttachment,
  PathConstraint: () => PathConstraint,
  PathConstraintData: () => PathConstraintData,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline,
  PointAttachment: () => PointAttachment,
  RegionAttachment: () => RegionAttachment,
  RotateTimeline: () => RotateTimeline,
  ScaleTimeline: () => ScaleTimeline,
  ShearTimeline: () => ShearTimeline,
  Skeleton: () => Skeleton,
  SkeletonBinary: () => SkeletonBinary,
  SkeletonBounds: () => SkeletonBounds,
  SkeletonData: () => SkeletonData,
  SkeletonJson: () => SkeletonJson,
  Skin: () => Skin,
  SkinEntry: () => SkinEntry,
  Slot: () => Slot,
  SlotData: () => SlotData,
  SpacingMode: () => SpacingMode,
  Spine: () => Spine,
  SwirlEffect: () => SwirlEffect,
  TimelineType: () => TimelineType,
  TrackEntry: () => TrackEntry,
  TransformConstraint: () => TransformConstraint,
  TransformConstraintData: () => TransformConstraintData,
  TransformConstraintTimeline: () => TransformConstraintTimeline,
  TranslateTimeline: () => TranslateTimeline,
  TwoColorTimeline: () => TwoColorTimeline,
  VertexAttachment: () => VertexAttachment
});

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs
var Attachment = class {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
};
var _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
    this.deformAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  copyTo(attachment) {
    if (this.bones != null) {
      attachment.bones = new Array(this.bones.length);
      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices != null) {
      attachment.vertices = Utils.newFloatArray(this.vertices.length);
      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    } else
      attachment.vertices = null;
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.deformAttachment = this.deformAttachment;
  }
};
var VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs
var BoundingBoxAttachment = class _BoundingBoxAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType.BoundingBox;
    this.color = new Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new _BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs
var ClippingAttachment = class _ClippingAttachment extends VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = AttachmentType.Clipping;
    this.color = new Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new _ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs
var MeshAttachment = class _MeshAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Mesh;
    this.color = new Color(1, 1, 1, 1);
    this.tempColor = new Color(0, 0, 0, 0);
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh != null)
      return this.newLinkedMesh();
    const copy = new _MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    if (this.edges != null) {
      copy.edges = new Array(this.edges.length);
      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  newLinkedMesh() {
    const copy = new _MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    copy.deformAttachment = this.deformAttachment;
    copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs
var PathAttachment = class _PathAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new _PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PointAttachment.mjs
var PointAttachment = class _PointAttachment extends VertexAttachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Point;
    this.color = new Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = MathUtils.cosDeg(this.rotation);
    const sin = MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * MathUtils.radDeg;
  }
  copy() {
    const copy = new _PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs
var Slot = class {
  constructor(data, bone) {
    this.deform = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new Color();
    this.darkColor = data.darkColor == null ? null : new Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.deform.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs
var _RegionAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new Color(1, 1, 1, 1);
    this.offset = Utils.newFloatArray(8);
    this.uvs = Utils.newFloatArray(8);
    this.tempColor = new Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment.OX1] = localXCos - localYSin;
    offset[_RegionAttachment.OY1] = localYCos + localXSin;
    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment.OX1];
    offsetY = vertexOffset[_RegionAttachment.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX2];
    offsetY = vertexOffset[_RegionAttachment.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX3];
    offsetY = vertexOffset[_RegionAttachment.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX4];
    offsetY = vertexOffset[_RegionAttachment.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.path = this.path;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    return copy;
  }
};
var RegionAttachment = _RegionAttachment;
RegionAttachment.OX1 = 0;
RegionAttachment.OY1 = 1;
RegionAttachment.OX2 = 2;
RegionAttachment.OY2 = 3;
RegionAttachment.OX3 = 4;
RegionAttachment.OY3 = 5;
RegionAttachment.OX4 = 6;
RegionAttachment.OY4 = 7;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;

// node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/JitterEffect.mjs
var JitterEffect = class {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/SwirlEffect.mjs
var _SwirlEffect = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
var SwirlEffect = _SwirlEffect;
SwirlEffect.interpolation = new PowOut(2);

// node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs
var Animation = class {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.timelineIds = [];
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds[timelines[i].getPropertyId()] = true;
    this.duration = duration;
  }
  hasTimeline(id) {
    return this.timelineIds[id] == true;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  /** @param target After the first and before the last value.
   * @returns index of first value greater than the target. */
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
};
var TimelineType = ((TimelineType22) => {
  TimelineType22[TimelineType22["rotate"] = 0] = "rotate";
  TimelineType22[TimelineType22["translate"] = 1] = "translate";
  TimelineType22[TimelineType22["scale"] = 2] = "scale";
  TimelineType22[TimelineType22["shear"] = 3] = "shear";
  TimelineType22[TimelineType22["attachment"] = 4] = "attachment";
  TimelineType22[TimelineType22["color"] = 5] = "color";
  TimelineType22[TimelineType22["deform"] = 6] = "deform";
  TimelineType22[TimelineType22["event"] = 7] = "event";
  TimelineType22[TimelineType22["drawOrder"] = 8] = "drawOrder";
  TimelineType22[TimelineType22["ikConstraint"] = 9] = "ikConstraint";
  TimelineType22[TimelineType22["transformConstraint"] = 10] = "transformConstraint";
  TimelineType22[TimelineType22["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType22[TimelineType22["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType22[TimelineType22["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType22[TimelineType22["twoColor"] = 14] = "twoColor";
  return TimelineType22;
})(TimelineType || {});
var _CurveTimeline = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;
  }
  /** Returns the interpolation type for the specified key frame.
   * @returns Linear is 0, stepped is 1, Bezier is 2. */
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline.LINEAR)
      return _CurveTimeline.LINEAR;
    if (type == _CurveTimeline.STEPPED)
      return _CurveTimeline.STEPPED;
    return _CurveTimeline.BEZIER;
  }
  /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,
   * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the
   * difference between the key frame's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  /** Returns the interpolated percentage for the specified key frame and linear percentage. */
  getCurvePercent(frameIndex, percent) {
    percent = MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline.LINEAR)
      return percent;
    if (type == _CurveTimeline.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
var CurveTimeline = _CurveTimeline;
CurveTimeline.LINEAR = 0;
CurveTimeline.STEPPED = 1;
CurveTimeline.BEZIER = 2;
CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
var _RotateTimeline = class extends CurveTimeline {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
var RotateTimeline = _RotateTimeline;
RotateTimeline.ENTRIES = 2;
RotateTimeline.PREV_TIME = -2;
RotateTimeline.PREV_ROTATION = -1;
RotateTimeline.ROTATION = 1;
var _TranslateTimeline = class extends CurveTimeline {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);
  }
  getPropertyId() {
    return (1 << 24) + this.boneIndex;
  }
  /** Sets the time in seconds, x, and y values for the specified key frame. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline.X] = x;
    this.frames[frameIndex + _TranslateTimeline.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline.PREV_X];
      y = frames[frames.length + _TranslateTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);
      x = frames[frame + _TranslateTimeline.PREV_X];
      y = frames[frame + _TranslateTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
var TranslateTimeline = _TranslateTimeline;
TranslateTimeline.ENTRIES = 3;
TranslateTimeline.PREV_TIME = -3;
TranslateTimeline.PREV_X = -2;
TranslateTimeline.PREV_Y = -1;
TranslateTimeline.X = 1;
TranslateTimeline.Y = 2;
var ScaleTimeline = class _ScaleTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + _ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + _ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation.binarySearch(frames, time, _ScaleTimeline.ENTRIES);
      x = frames[frame + _ScaleTimeline.PREV_X];
      y = frames[frame + _ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + _ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + _ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bx = MathUtils.signum(x);
            by = MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
};
var ShearTimeline = class _ShearTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _ShearTimeline.ENTRIES]) {
      x = frames[frames.length + _ShearTimeline.PREV_X];
      y = frames[frames.length + _ShearTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _ShearTimeline.ENTRIES);
      x = frames[frame + _ShearTimeline.PREV_X];
      y = frames[frame + _ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + _ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + _ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
};
var _ColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (5 << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline.R] = r;
    this.frames[frameIndex + _ColorTimeline.G] = g;
    this.frames[frameIndex + _ColorTimeline.B] = b;
    this.frames[frameIndex + _ColorTimeline.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline.PREV_R];
      g = frames[i + _ColorTimeline.PREV_G];
      b = frames[i + _ColorTimeline.PREV_B];
      a = frames[i + _ColorTimeline.PREV_A];
    } else {
      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);
      r = frames[frame + _ColorTimeline.PREV_R];
      g = frames[frame + _ColorTimeline.PREV_G];
      b = frames[frame + _ColorTimeline.PREV_B];
      a = frames[frame + _ColorTimeline.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline.R] - r) * percent;
      g += (frames[frame + _ColorTimeline.G] - g) * percent;
      b += (frames[frame + _ColorTimeline.B] - b) * percent;
      a += (frames[frame + _ColorTimeline.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
var ColorTimeline = _ColorTimeline;
ColorTimeline.ENTRIES = 5;
ColorTimeline.PREV_TIME = -5;
ColorTimeline.PREV_R = -4;
ColorTimeline.PREV_G = -3;
ColorTimeline.PREV_B = -2;
ColorTimeline.PREV_A = -1;
ColorTimeline.R = 1;
ColorTimeline.G = 2;
ColorTimeline.B = 3;
ColorTimeline.A = 4;
var _TwoColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (14 << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline.R] = r;
    this.frames[frameIndex + _TwoColorTimeline.G] = g;
    this.frames[frameIndex + _TwoColorTimeline.B] = b;
    this.frames[frameIndex + _TwoColorTimeline.A] = a;
    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline.PREV_R];
      g = frames[i + _TwoColorTimeline.PREV_G];
      b = frames[i + _TwoColorTimeline.PREV_B];
      a = frames[i + _TwoColorTimeline.PREV_A];
      r2 = frames[i + _TwoColorTimeline.PREV_R2];
      g2 = frames[i + _TwoColorTimeline.PREV_G2];
      b2 = frames[i + _TwoColorTimeline.PREV_B2];
    } else {
      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);
      r = frames[frame + _TwoColorTimeline.PREV_R];
      g = frames[frame + _TwoColorTimeline.PREV_G];
      b = frames[frame + _TwoColorTimeline.PREV_B];
      a = frames[frame + _TwoColorTimeline.PREV_A];
      r2 = frames[frame + _TwoColorTimeline.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
var TwoColorTimeline = _TwoColorTimeline;
TwoColorTimeline.ENTRIES = 8;
TwoColorTimeline.PREV_TIME = -8;
TwoColorTimeline.PREV_R = -7;
TwoColorTimeline.PREV_G = -6;
TwoColorTimeline.PREV_B = -5;
TwoColorTimeline.PREV_A = -4;
TwoColorTimeline.PREV_R2 = -3;
TwoColorTimeline.PREV_G2 = -2;
TwoColorTimeline.PREV_B2 = -1;
TwoColorTimeline.R = 1;
TwoColorTimeline.G = 2;
TwoColorTimeline.B = 3;
TwoColorTimeline.A = 4;
TwoColorTimeline.R2 = 5;
TwoColorTimeline.G2 = 6;
TwoColorTimeline.B2 = 7;
var AttachmentTimeline = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 << 24) + this.slotIndex;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == MixDirection.mixOut) {
      if (blend == MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
};
var zeros = null;
var DeformTimeline = class extends CurveTimeline {
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros == null)
      zeros = Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))
      return;
    const deformArray = slot.deform;
    if (deformArray.length == 0)
      blend = MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case MixBlend.setup:
          deformArray.length = 0;
          return;
        case MixBlend.first:
          if (alpha == 1) {
            deformArray.length = 0;
            break;
          }
          const deform2 = Utils.setArraySize(deformArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] += (setupVertices[i] - deform2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] *= alpha;
          }
      }
      return;
    }
    const deform = Utils.setArraySize(deformArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              deform[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else {
          Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case MixBlend.first:
        case MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
};
var EventTimeline = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
};
var DrawOrderTimeline = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
var _IkConstraintTimeline = class extends CurveTimeline {
  // time, mix, softness, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (9 << 24) + this.ikConstraintIndex;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frameIndex, time, mix, softness, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline.SOFTNESS] = softness;
    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
        constraint.softness += (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];
    const softness = frames[frame + _IkConstraintTimeline.PREV_SOFTNESS];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));
    if (blend == MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;
      if (direction == MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
      constraint.softness += (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;
      if (direction == MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    }
  }
};
var IkConstraintTimeline = _IkConstraintTimeline;
IkConstraintTimeline.ENTRIES = 6;
IkConstraintTimeline.PREV_TIME = -6;
IkConstraintTimeline.PREV_MIX = -5;
IkConstraintTimeline.PREV_SOFTNESS = -4;
IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline.PREV_COMPRESS = -2;
IkConstraintTimeline.PREV_STRETCH = -1;
IkConstraintTimeline.MIX = 1;
IkConstraintTimeline.SOFTNESS = 2;
IkConstraintTimeline.BEND_DIRECTION = 3;
IkConstraintTimeline.COMPRESS = 4;
IkConstraintTimeline.STRETCH = 5;
var _TransformConstraintTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (10 << 24) + this.transformConstraintIndex;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];
    } else {
      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
var TransformConstraintTimeline = _TransformConstraintTimeline;
TransformConstraintTimeline.ENTRIES = 5;
TransformConstraintTimeline.PREV_TIME = -5;
TransformConstraintTimeline.PREV_ROTATE = -4;
TransformConstraintTimeline.PREV_TRANSLATE = -3;
TransformConstraintTimeline.PREV_SCALE = -2;
TransformConstraintTimeline.PREV_SHEAR = -1;
TransformConstraintTimeline.ROTATE = 1;
TransformConstraintTimeline.TRANSLATE = 2;
TransformConstraintTimeline.SCALE = 3;
TransformConstraintTimeline.SHEAR = 4;
var _PathConstraintPositionTimeline = class extends CurveTimeline {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);
  }
  getPropertyId() {
    return (11 << 24) + this.pathConstraintIndex;
  }
  /** Sets the time in seconds and path constraint position for the specified key frame. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;
    }
    if (blend == MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
var PathConstraintPositionTimeline = _PathConstraintPositionTimeline;
PathConstraintPositionTimeline.ENTRIES = 2;
PathConstraintPositionTimeline.PREV_TIME = -2;
PathConstraintPositionTimeline.PREV_VALUE = -1;
PathConstraintPositionTimeline.VALUE = 1;
var PathConstraintSpacingTimeline = class _PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - _PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + _PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + _PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + _PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
};
var _PathConstraintMixTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);
  }
  getPropertyId() {
    return (13 << 24) + this.pathConstraintIndex;
  }
  /** The time in seconds, rotate mix, and translate mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];
    } else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
    }
    if (blend == MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
var PathConstraintMixTimeline = _PathConstraintMixTimeline;
PathConstraintMixTimeline.ENTRIES = 3;
PathConstraintMixTimeline.PREV_TIME = -3;
PathConstraintMixTimeline.PREV_ROTATE = -2;
PathConstraintMixTimeline.PREV_TRANSLATE = -1;
PathConstraintMixTimeline.ROTATE = 1;
PathConstraintMixTimeline.TRANSLATE = 2;

// node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationState.mjs
var _AnimationState = class {
  constructor(data) {
    this.tracks = new Array();
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new IntSet();
    this.animationsChanged = false;
    this.trackEntryPool = new Pool(() => new TrackEntry());
    this.data = data;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : MixBlend.setup;
          if (timeline instanceof RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          } else {
            Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + _AnimationState.SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == MixBlend.first)
        blend = MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState.SUBSEQUENT:
            if (!drawOrder && timeline instanceof DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState.FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState.HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case _AnimationState.HOLD_FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);
        else {
          Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)
            direction = MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = timeline.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else {
      let frameIndex;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = Animation.binarySearch(frames, time) - 1;
      this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
    }
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + _AnimationState.SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + _AnimationState.CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    if (!bone.active)
      return;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - RotateTimeline.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];
      else {
        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
        r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * {@link #setAnimationWith(}. */
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    entry.mixBlend = MixBlend.replace;
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? _AnimationState.HOLD_FIRST : _AnimationState.HOLD_SUBSEQUENT;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const id = timeline.getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState.SUBSEQUENT;
        else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {
          timelineMode[i] = _AnimationState.FIRST;
        } else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (next.animation.hasTimeline(id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState.HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
var AnimationState = _AnimationState;
AnimationState.emptyAnimation = new Animation("<empty>", [], 0);
AnimationState.SUBSEQUENT = 0;
AnimationState.FIRST = 1;
AnimationState.HOLD_SUBSEQUENT = 2;
AnimationState.HOLD_FIRST = 3;
AnimationState.HOLD_MIX = 4;
AnimationState.SETUP = 1;
AnimationState.CURRENT = 2;
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
var _TrackEntry = class {
  constructor() {
    this.mixBlend = MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
var TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
var _EventQueue = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue.deprecatedWarning1) {
      _EventQueue.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
var EventQueue = _EventQueue;
EventQueue.deprecatedWarning1 = false;
var EventType = ((EventType22) => {
  EventType22[EventType22["start"] = 0] = "start";
  EventType22[EventType22["interrupt"] = 1] = "interrupt";
  EventType22[EventType22["end"] = 2] = "end";
  EventType22[EventType22["dispose"] = 3] = "dispose";
  EventType22[EventType22["complete"] = 4] = "complete";
  EventType22[EventType22["event"] = 5] = "event";
  return EventType22;
})(EventType || {});
var AnimationStateAdapter = class {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationStateData.mjs
var _AnimationStateData = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData.deprecatedWarning1) {
      _AnimationStateData.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
var AnimationStateData = _AnimationStateData;
AnimationStateData.deprecatedWarning1 = false;

// node_modules/@pixi-spine/runtime-3.8/lib/core/AtlasAttachmentLoader.mjs
var AtlasAttachmentLoader = class {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new RegionAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new MeshAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment(name);
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Bone.mjs
var Bone = class {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    this.matrix = new Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  isActive() {
    return this.active;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = settings2.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = MathUtils.cosDeg(rotationY) * scaleY;
        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = MathUtils.cosDeg(rotationY) * scaleY;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= this.skeleton.scaleX;
          pc /= this.skeleton.scaleY;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = MathUtils.cosDeg(rx) * scaleX;
        const lb = MathUtils.cosDeg(ry) * scaleY;
        const lc = MathUtils.sinDeg(rx) * scaleX;
        const ld = MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case TransformMode.NoScale:
      case TransformMode.NoScaleOrReflection: {
        const cos = MathUtils.cosDeg(rotation);
        const sin = MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings2.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = MathUtils.cosDeg(shearX) * scaleX;
        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = MathUtils.sinDeg(shearX) * scaleX;
        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = MathUtils.sinDeg(worldRotation);
    const cos = MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = MathUtils.sinDeg(localRotation);
    const cos = MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = MathUtils.cosDeg(degrees);
    const sin = MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs
var BoneData = class {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = TransformMode.Normal;
    this.skinRequired = false;
    this.color = new Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs
var ConstraintData = class {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs
var Event = class {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs
var EventData = class {
  constructor(name) {
    this.name = name;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraint.mjs
var IkConstraint = class {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    this.softness = 0;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    switch (bone.data.transformMode) {
      case TransformMode.OnlyTranslation:
        tx = targetX - bone.worldX;
        ty = targetY - bone.worldY;
        break;
      case TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / bone.skeleton.scaleX;
        const sc = pc / bone.skeleton.scaleY;
        pb = -sc * s * bone.skeleton.scaleX;
        pd = sa * s * bone.skeleton.scaleY;
        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) / 2;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs
var IkConstraintData = class extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.softness = 0;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs
var PathConstraintData = class extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
  }
};
var SpacingMode = ((SpacingMode22) => {
  SpacingMode22[SpacingMode22["Length"] = 0] = "Length";
  SpacingMode22[SpacingMode22["Fixed"] = 1] = "Fixed";
  SpacingMode22[SpacingMode22["Percent"] = 2] = "Percent";
  return SpacingMode22;
})(SpacingMode || {});

// node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraint.mjs
var _PathConstraint = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == SpacingMode.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == RotateMode.Tangent;
    const scale = rotateMode == RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == PositionMode.Percent,
      spacingMode == SpacingMode.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed2 = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed2 ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed2) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed2 && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed2) {
      verticesLength += 2;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed2) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
};
var PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;

// node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraint.mjs
var TransformConstraint = class {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new Vector2();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Skeleton.mjs
var _Skeleton = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));
    }
    this.color = new Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin != null) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone != null);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp = new Array(2)) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment) {
        verticesLength = 8;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
var Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;

// node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs
var SkeletonData = class {
  constructor() {
    this.bones = new Array();
    this.slots = new Array();
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs
var SlotData = class {
  constructor(index, name, boneData) {
    this.color = new Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs
var TransformConstraintData = class extends ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs
var SkinEntry = class {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
};
var Skin = class {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  setAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (attachment.attachment == null)
        continue;
      if (attachment.attachment instanceof MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      dictionary[name] = null;
  }
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBinary.mjs
var _SkeletonBinary = class {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new SkeletonData();
    skeletonData.name = "";
    const input = new BinaryInput(binary);
    skeletonData.hash = input.readString();
    skeletonData.version = input.readString();
    if (skeletonData.version === "3.8.75") {
      const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
      console.error(error);
    }
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      input.strings.push(input.readString());
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = _SkeletonBinary.TransformModeValues[input.readInt(true)];
      data.skinRequired = input.readBoolean();
      if (nonessential)
        Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new SlotData(i, slotName, boneData);
      Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        Color.rgb888ToColor(data.darkColor = new Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = _SkeletonBinary.BlendModeValues[input.readInt(true)];
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new IkConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new TransformConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      data.scaleMix = input.readFloat();
      data.shearMix = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new PathConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = _SkeletonBinary.PositionModeValues[input.readInt(true)];
      data.spacingMode = _SkeletonBinary.SpacingModeValues[input.readInt(true)];
      data.rotateMode = _SkeletonBinary.RotateModeValues[input.readInt(true)];
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
        data.spacing *= scale;
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin != null) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++)
        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const data = new EventData(input.readStringRef());
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath != null) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new Skin("default");
    } else {
      skin = new Skin(input.readStringRef());
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment != null)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (name == null)
      name = attachmentName;
    const typeIndex = input.readByte();
    const type = _SkeletonBinary.AttachmentTypeValues[typeIndex];
    switch (type) {
      case AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        if (path == null)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        Color.rgba8888ToColor(region.color, color);
        return region;
      }
      case AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        let edges = null;
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritDeform = input.readBoolean();
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        Color.rgba8888ToColor(mesh.color, color);
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));
        return mesh;
      }
      case AttachmentType.Path: {
        const closed2 = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = closed2;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readVertices(input, vertexCount) {
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    const scale = this.scale;
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    const timelines = new Array();
    const scale = this.scale;
    let duration = 0;
    const tempColor1 = new Color();
    const tempColor2 = new Color();
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.SLOT_ATTACHMENT: {
            const timeline = new AttachmentTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++)
              timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[frameCount - 1]);
            break;
          }
          case _SkeletonBinary.SLOT_COLOR: {
            const timeline = new ColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              Color.rgba8888ToColor(tempColor1, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.SLOT_TWO_COLOR: {
            const timeline = new TwoColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              Color.rgba8888ToColor(tempColor1, input.readInt32());
              Color.rgb888ToColor(tempColor2, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.BONE_ROTATE: {
            const timeline = new RotateTimeline(frameCount);
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.BONE_TRANSLATE:
          case _SkeletonBinary.BONE_SCALE:
          case _SkeletonBinary.BONE_SHEAR: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.BONE_SCALE)
              timeline = new ScaleTimeline(frameCount);
            else if (timelineType == _SkeletonBinary.BONE_SHEAR)
              timeline = new ShearTimeline(frameCount);
            else {
              timeline = new TranslateTimeline(frameCount);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new IkConstraintTimeline(frameCount);
      timeline.ikConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new TransformConstraintTimeline(frameCount);
      timeline.transformConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.PATH_POSITION:
          case _SkeletonBinary.PATH_SPACING: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.PATH_SPACING) {
              timeline = new PathConstraintSpacingTimeline(frameCount);
              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new PathConstraintPositionTimeline(frameCount);
              if (data.positionMode == PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.PATH_MIX: {
            const timeline = new PathConstraintMixTimeline(frameCount);
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachment = skin.getAttachment(slotIndex, input.readStringRef());
          const weighted = attachment.bones != null;
          const vertices = attachment.vertices;
          const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
          const frameCount = input.readInt(true);
          const timeline = new DeformTimeline(frameCount);
          timeline.slotIndex = slotIndex;
          timeline.attachment = attachment;
          for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
            const time = input.readFloat();
            let deform;
            let end = input.readInt(true);
            if (end == 0)
              deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
            else {
              deform = Utils.newFloatArray(deformLength);
              const start = input.readInt(true);
              end += start;
              if (scale == 1) {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat();
              } else {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat() * scale;
              }
              if (!weighted) {
                for (let v = 0, vn = deform.length; v < vn; v++)
                  deform[v] += vertices[v];
              }
            }
            timeline.setFrame(frameIndex, time, deform);
            if (frameIndex < frameCount - 1)
              this.readCurve(input, frameIndex, timeline);
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[frameCount - 1]);
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath != null) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[eventCount - 1]);
    }
    return new Animation(name, timelines, duration);
  }
  readCurve(input, frameIndex, timeline) {
    switch (input.readByte()) {
      case _SkeletonBinary.CURVE_STEPPED:
        timeline.setStepped(frameIndex);
        break;
      case _SkeletonBinary.CURVE_BEZIER:
        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        break;
    }
  }
  setCurve(timeline, frameIndex, cx1, cy1, cx2, cy2) {
    timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
  }
};
var SkeletonBinary = _SkeletonBinary;
SkeletonBinary.AttachmentTypeValues = [
  0,
  1,
  2,
  3,
  4,
  5,
  6
];
SkeletonBinary.TransformModeValues = [
  TransformMode.Normal,
  TransformMode.OnlyTranslation,
  TransformMode.NoRotationOrReflection,
  TransformMode.NoScale,
  TransformMode.NoScaleOrReflection
];
SkeletonBinary.PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];
SkeletonBinary.SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];
SkeletonBinary.RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];
SkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];
SkeletonBinary.BONE_ROTATE = 0;
SkeletonBinary.BONE_TRANSLATE = 1;
SkeletonBinary.BONE_SCALE = 2;
SkeletonBinary.BONE_SHEAR = 3;
SkeletonBinary.SLOT_ATTACHMENT = 0;
SkeletonBinary.SLOT_COLOR = 1;
SkeletonBinary.SLOT_TWO_COLOR = 2;
SkeletonBinary.PATH_POSITION = 0;
SkeletonBinary.PATH_SPACING = 1;
SkeletonBinary.PATH_MIX = 2;
SkeletonBinary.CURVE_LINEAR = 0;
SkeletonBinary.CURVE_STEPPED = 1;
SkeletonBinary.CURVE_BEZIER = 2;
var LinkedMesh = class {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
};
var Vertices = class {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBounds.mjs
var SkeletonBounds = class extends SkeletonBoundsBase {
};

// node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonJson.mjs
var SkeletonJson = class _SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      if (skeletonData.version.substr(0, 3) !== "3.8") {
        const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      if (skeletonData.version === "3.8.75") {
        const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = _SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        data.skinRequired = this.getValue(boneMap, "skin", false);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new SlotData(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = _SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.mix = this.getValue(constraintMap, "mix", 1);
        data.softness = this.getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = this.getValue(constraintMap, "compress", false);
        data.stretch = this.getValue(constraintMap, "stretch", false);
        data.uniform = this.getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = _SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = _SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = _SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const bone = skeletonData.findBone(skinMap.bones[ii]);
            if (bone == null)
              throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
            if (constraint == null)
              throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
            if (constraint == null)
              throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
            if (constraint == null)
              throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (slot == null)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment != null)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        mesh.width = this.getValue(map, "width", 0) * scale;
        mesh.height = this.getValue(map, "height", 0) * scale;
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          this.linkedMeshes.push(new LinkedMesh2(mesh, this.getValue(map, "skin", null), slotIndex, parent, this.getValue(map, "deform", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = this.getValue(map, "edges", null);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new AttachmentTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new ColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new TwoColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new Color();
              const dark = new Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new RotateTimeline(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            let defaultValue = 0;
            if (timelineName === "scale") {
              timeline = new ScaleTimeline(timelineMap.length);
              defaultValue = 1;
            } else if (timelineName === "shear")
              timeline = new ShearTimeline(timelineMap.length);
            else {
              timeline = new TranslateTimeline(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", defaultValue);
              const y = this.getValue(valueMap, "y", defaultValue);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new IkConstraintTimeline(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "softness", 0) * scale,
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new TransformConstraintTimeline(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new PathConstraintSpacingTimeline(timelineMap.length);
              if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new PathConstraintPositionTimeline(timelineMap.length);
              if (data.positionMode == PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new PathConstraintMixTimeline(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (settings2.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new DeformTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new DrawOrderTimeline(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = Utils.newArray(slotCount, -1);
          const unchanged = Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new EventTimeline(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.hasOwnProperty("curve"))
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return BLEND_MODES.NORMAL;
    if (str == "additive")
      return BLEND_MODES.ADD;
    if (str == "multiply")
      return BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return PositionMode.Fixed;
    if (str == "percent")
      return PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return SpacingMode.Length;
    if (str == "fixed")
      return SpacingMode.Fixed;
    if (str == "percent")
      return SpacingMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return RotateMode.Tangent;
    if (str == "chain")
      return RotateMode.Chain;
    if (str == "chainscale")
      return RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return TransformMode.Normal;
    if (str == "onlytranslation")
      return TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
};
var LinkedMesh2 = class {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
};

// node_modules/@pixi-spine/runtime-3.8/lib/Spine.mjs
var Spine = class extends SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData(spineData);
    this.state = new AnimationState(this.stateData);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/index.mjs
var lib_exports3 = {};
__export(lib_exports3, {
  Animation: () => Animation2,
  AnimationState: () => AnimationState2,
  AnimationStateAdapter2: () => AnimationStateAdapter2,
  AnimationStateData: () => AnimationStateData2,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader2,
  Attachment: () => Attachment2,
  AttachmentTimeline: () => AttachmentTimeline2,
  Bone: () => Bone2,
  BoneData: () => BoneData2,
  BoundingBoxAttachment: () => BoundingBoxAttachment2,
  ClippingAttachment: () => ClippingAttachment2,
  ColorTimeline: () => ColorTimeline2,
  CurveTimeline: () => CurveTimeline2,
  DeformTimeline: () => DeformTimeline2,
  DrawOrderTimeline: () => DrawOrderTimeline2,
  Event: () => Event2,
  EventData: () => EventData2,
  EventQueue: () => EventQueue2,
  EventTimeline: () => EventTimeline2,
  EventType: () => EventType2,
  IkConstraint: () => IkConstraint2,
  IkConstraintData: () => IkConstraintData2,
  IkConstraintTimeline: () => IkConstraintTimeline2,
  JitterEffect: () => JitterEffect2,
  MeshAttachment: () => MeshAttachment2,
  PathAttachment: () => PathAttachment2,
  PathConstraint: () => PathConstraint2,
  PathConstraintData: () => PathConstraintData2,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline2,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline2,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline2,
  PointAttachment: () => PointAttachment2,
  RegionAttachment: () => RegionAttachment2,
  RotateTimeline: () => RotateTimeline2,
  ScaleTimeline: () => ScaleTimeline2,
  ShearTimeline: () => ShearTimeline2,
  Skeleton: () => Skeleton2,
  SkeletonBounds: () => SkeletonBounds2,
  SkeletonData: () => SkeletonData2,
  SkeletonJson: () => SkeletonJson2,
  Skin: () => Skin2,
  Slot: () => Slot2,
  SlotData: () => SlotData2,
  SpacingMode: () => SpacingMode2,
  Spine: () => Spine2,
  SwirlEffect: () => SwirlEffect2,
  TimelineType: () => TimelineType2,
  TrackEntry: () => TrackEntry2,
  TransformConstraint: () => TransformConstraint2,
  TransformConstraintData: () => TransformConstraintData2,
  TransformConstraintTimeline: () => TransformConstraintTimeline2,
  TranslateTimeline: () => TranslateTimeline2,
  TwoColorTimeline: () => TwoColorTimeline2,
  VertexAttachment: () => VertexAttachment2
});

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs
var Attachment2 = class {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
};
var _VertexAttachment2 = class extends Attachment2 {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment2.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.attachmentVertices;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */
  applyDeform(sourceAttachment) {
    return this == sourceAttachment;
  }
};
var VertexAttachment2 = _VertexAttachment2;
VertexAttachment2.nextID = 0;

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs
var BoundingBoxAttachment2 = class extends VertexAttachment2 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.BoundingBox;
    this.color = new Color(1, 1, 1, 1);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs
var ClippingAttachment2 = class extends VertexAttachment2 {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = AttachmentType.Clipping;
    this.color = new Color(0.2275, 0.2275, 0.8078, 1);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs
var MeshAttachment2 = class extends VertexAttachment2 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Mesh;
    this.color = new Color(1, 1, 1, 1);
    this.inheritDeform = false;
    this.tempColor = new Color(0, 0, 0, 0);
  }
  applyDeform(sourceAttachment) {
    return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs
var PathAttachment2 = class extends VertexAttachment2 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new Color(1, 1, 1, 1);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PointAttachment.mjs
var PointAttachment2 = class extends VertexAttachment2 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Point;
    this.color = new Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = MathUtils.cosDeg(this.rotation);
    const sin = MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * MathUtils.radDeg;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs
var Slot2 = class {
  constructor(data, bone) {
    this.attachmentVertices = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new Color();
    this.darkColor = data.darkColor == null ? null : new Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.attachmentVertices.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs
var _RegionAttachment2 = class extends Attachment2 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new Color(1, 1, 1, 1);
    this.offset = Utils.newFloatArray(8);
    this.uvs = Utils.newFloatArray(8);
    this.tempColor = new Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment2.OX1] = localXCos - localYSin;
    offset[_RegionAttachment2.OY1] = localYCos + localXSin;
    offset[_RegionAttachment2.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment2.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment2.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment2.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment2.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment2.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof Slot2 ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment2.OX1];
    offsetY = vertexOffset[_RegionAttachment2.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment2.OX2];
    offsetY = vertexOffset[_RegionAttachment2.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment2.OX3];
    offsetY = vertexOffset[_RegionAttachment2.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment2.OX4];
    offsetY = vertexOffset[_RegionAttachment2.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
};
var RegionAttachment2 = _RegionAttachment2;
RegionAttachment2.OX1 = 0;
RegionAttachment2.OY1 = 1;
RegionAttachment2.OX2 = 2;
RegionAttachment2.OY2 = 3;
RegionAttachment2.OX3 = 4;
RegionAttachment2.OY3 = 5;
RegionAttachment2.OX4 = 6;
RegionAttachment2.OY4 = 7;
RegionAttachment2.X1 = 0;
RegionAttachment2.Y1 = 1;
RegionAttachment2.C1R = 2;
RegionAttachment2.C1G = 3;
RegionAttachment2.C1B = 4;
RegionAttachment2.C1A = 5;
RegionAttachment2.U1 = 6;
RegionAttachment2.V1 = 7;
RegionAttachment2.X2 = 8;
RegionAttachment2.Y2 = 9;
RegionAttachment2.C2R = 10;
RegionAttachment2.C2G = 11;
RegionAttachment2.C2B = 12;
RegionAttachment2.C2A = 13;
RegionAttachment2.U2 = 14;
RegionAttachment2.V2 = 15;
RegionAttachment2.X3 = 16;
RegionAttachment2.Y3 = 17;
RegionAttachment2.C3R = 18;
RegionAttachment2.C3G = 19;
RegionAttachment2.C3B = 20;
RegionAttachment2.C3A = 21;
RegionAttachment2.U3 = 22;
RegionAttachment2.V3 = 23;
RegionAttachment2.X4 = 24;
RegionAttachment2.Y4 = 25;
RegionAttachment2.C4R = 26;
RegionAttachment2.C4G = 27;
RegionAttachment2.C4B = 28;
RegionAttachment2.C4A = 29;
RegionAttachment2.U4 = 30;
RegionAttachment2.V4 = 31;

// node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/JitterEffect.mjs
var JitterEffect2 = class {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/SwirlEffect.mjs
var _SwirlEffect2 = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect2.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
var SwirlEffect2 = _SwirlEffect2;
SwirlEffect2.interpolation = new PowOut(2);

// node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs
var Animation2 = class {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
  }
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
};
var TimelineType2 = ((TimelineType22) => {
  TimelineType22[TimelineType22["rotate"] = 0] = "rotate";
  TimelineType22[TimelineType22["translate"] = 1] = "translate";
  TimelineType22[TimelineType22["scale"] = 2] = "scale";
  TimelineType22[TimelineType22["shear"] = 3] = "shear";
  TimelineType22[TimelineType22["attachment"] = 4] = "attachment";
  TimelineType22[TimelineType22["color"] = 5] = "color";
  TimelineType22[TimelineType22["deform"] = 6] = "deform";
  TimelineType22[TimelineType22["event"] = 7] = "event";
  TimelineType22[TimelineType22["drawOrder"] = 8] = "drawOrder";
  TimelineType22[TimelineType22["ikConstraint"] = 9] = "ikConstraint";
  TimelineType22[TimelineType22["transformConstraint"] = 10] = "transformConstraint";
  TimelineType22[TimelineType22["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType22[TimelineType22["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType22[TimelineType22["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType22[TimelineType22["twoColor"] = 14] = "twoColor";
  return TimelineType22;
})(TimelineType2 || {});
var _CurveTimeline2 = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = Utils.newFloatArray((frameCount - 1) * _CurveTimeline2.BEZIER_SIZE);
  }
  getFrameCount() {
    return this.curves.length / _CurveTimeline2.BEZIER_SIZE + 1;
  }
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline2.BEZIER_SIZE] = _CurveTimeline2.LINEAR;
  }
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline2.BEZIER_SIZE] = _CurveTimeline2.STEPPED;
  }
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline2.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline2.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline2.LINEAR)
      return _CurveTimeline2.LINEAR;
    if (type == _CurveTimeline2.STEPPED)
      return _CurveTimeline2.STEPPED;
    return _CurveTimeline2.BEZIER;
  }
  /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
   * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
   * the difference between the keyframe's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline2.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline2.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline2.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  getCurvePercent(frameIndex, percent) {
    percent = MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline2.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline2.LINEAR)
      return percent;
    if (type == _CurveTimeline2.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline2.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
var CurveTimeline2 = _CurveTimeline2;
CurveTimeline2.LINEAR = 0;
CurveTimeline2.STEPPED = 1;
CurveTimeline2.BEZIER = 2;
CurveTimeline2.BEZIER_SIZE = 10 * 2 - 1;
var _RotateTimeline2 = class extends CurveTimeline2 {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline2.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline2.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline2.PREV_ROTATION];
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case MixBlend.first:
        case MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation2.binarySearch(frames, time, _RotateTimeline2.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline2.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline2.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline2.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
var RotateTimeline2 = _RotateTimeline2;
RotateTimeline2.ENTRIES = 2;
RotateTimeline2.PREV_TIME = -2;
RotateTimeline2.PREV_ROTATION = -1;
RotateTimeline2.ROTATION = 1;
var _TranslateTimeline2 = class extends CurveTimeline2 {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TranslateTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (1 << 24) + this.boneIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline2.X] = x;
    this.frames[frameIndex + _TranslateTimeline2.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline2.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline2.PREV_X];
      y = frames[frames.length + _TranslateTimeline2.PREV_Y];
    } else {
      const frame = Animation2.binarySearch(frames, time, _TranslateTimeline2.ENTRIES);
      x = frames[frame + _TranslateTimeline2.PREV_X];
      y = frames[frame + _TranslateTimeline2.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline2.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline2.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline2.Y] - y) * percent;
    }
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
var TranslateTimeline2 = _TranslateTimeline2;
TranslateTimeline2.ENTRIES = 3;
TranslateTimeline2.PREV_TIME = -3;
TranslateTimeline2.PREV_X = -2;
TranslateTimeline2.PREV_Y = -1;
TranslateTimeline2.X = 1;
TranslateTimeline2.Y = 2;
var ScaleTimeline2 = class _ScaleTimeline extends TranslateTimeline2 {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + _ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + _ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation2.binarySearch(frames, time, _ScaleTimeline.ENTRIES);
      x = frames[frame + _ScaleTimeline.PREV_X];
      y = frames[frame + _ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + _ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + _ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bx = MathUtils.signum(x);
            by = MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
};
var ShearTimeline2 = class _ShearTimeline extends TranslateTimeline2 {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _ShearTimeline.ENTRIES]) {
      x = frames[frames.length + _ShearTimeline.PREV_X];
      y = frames[frames.length + _ShearTimeline.PREV_Y];
    } else {
      const frame = Animation2.binarySearch(frames, time, _ShearTimeline.ENTRIES);
      x = frames[frame + _ShearTimeline.PREV_X];
      y = frames[frame + _ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + _ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + _ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
};
var _ColorTimeline2 = class extends CurveTimeline2 {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _ColorTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (5 << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline2.R] = r;
    this.frames[frameIndex + _ColorTimeline2.G] = g;
    this.frames[frameIndex + _ColorTimeline2.B] = b;
    this.frames[frameIndex + _ColorTimeline2.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline2.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline2.PREV_R];
      g = frames[i + _ColorTimeline2.PREV_G];
      b = frames[i + _ColorTimeline2.PREV_B];
      a = frames[i + _ColorTimeline2.PREV_A];
    } else {
      const frame = Animation2.binarySearch(frames, time, _ColorTimeline2.ENTRIES);
      r = frames[frame + _ColorTimeline2.PREV_R];
      g = frames[frame + _ColorTimeline2.PREV_G];
      b = frames[frame + _ColorTimeline2.PREV_B];
      a = frames[frame + _ColorTimeline2.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline2.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline2.R] - r) * percent;
      g += (frames[frame + _ColorTimeline2.G] - g) * percent;
      b += (frames[frame + _ColorTimeline2.B] - b) * percent;
      a += (frames[frame + _ColorTimeline2.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
var ColorTimeline2 = _ColorTimeline2;
ColorTimeline2.ENTRIES = 5;
ColorTimeline2.PREV_TIME = -5;
ColorTimeline2.PREV_R = -4;
ColorTimeline2.PREV_G = -3;
ColorTimeline2.PREV_B = -2;
ColorTimeline2.PREV_A = -1;
ColorTimeline2.R = 1;
ColorTimeline2.G = 2;
ColorTimeline2.B = 3;
ColorTimeline2.A = 4;
var _TwoColorTimeline2 = class extends CurveTimeline2 {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TwoColorTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (14 << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline2.R] = r;
    this.frames[frameIndex + _TwoColorTimeline2.G] = g;
    this.frames[frameIndex + _TwoColorTimeline2.B] = b;
    this.frames[frameIndex + _TwoColorTimeline2.A] = a;
    this.frames[frameIndex + _TwoColorTimeline2.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline2.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline2.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline2.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline2.PREV_R];
      g = frames[i + _TwoColorTimeline2.PREV_G];
      b = frames[i + _TwoColorTimeline2.PREV_B];
      a = frames[i + _TwoColorTimeline2.PREV_A];
      r2 = frames[i + _TwoColorTimeline2.PREV_R2];
      g2 = frames[i + _TwoColorTimeline2.PREV_G2];
      b2 = frames[i + _TwoColorTimeline2.PREV_B2];
    } else {
      const frame = Animation2.binarySearch(frames, time, _TwoColorTimeline2.ENTRIES);
      r = frames[frame + _TwoColorTimeline2.PREV_R];
      g = frames[frame + _TwoColorTimeline2.PREV_G];
      b = frames[frame + _TwoColorTimeline2.PREV_B];
      a = frames[frame + _TwoColorTimeline2.PREV_A];
      r2 = frames[frame + _TwoColorTimeline2.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline2.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline2.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline2.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline2.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline2.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline2.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline2.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline2.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline2.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline2.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
var TwoColorTimeline2 = _TwoColorTimeline2;
TwoColorTimeline2.ENTRIES = 8;
TwoColorTimeline2.PREV_TIME = -8;
TwoColorTimeline2.PREV_R = -7;
TwoColorTimeline2.PREV_G = -6;
TwoColorTimeline2.PREV_B = -5;
TwoColorTimeline2.PREV_A = -4;
TwoColorTimeline2.PREV_R2 = -3;
TwoColorTimeline2.PREV_G2 = -2;
TwoColorTimeline2.PREV_B2 = -1;
TwoColorTimeline2.R = 1;
TwoColorTimeline2.G = 2;
TwoColorTimeline2.B = 3;
TwoColorTimeline2.A = 4;
TwoColorTimeline2.R2 = 5;
TwoColorTimeline2.G2 = 6;
TwoColorTimeline2.B2 = 7;
var AttachmentTimeline2 = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 << 24) + this.slotIndex;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
      const attachmentName2 = slot.data.attachmentName;
      slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first) {
        const attachmentName2 = slot.data.attachmentName;
        slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      }
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation2.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
};
var zeros2 = null;
var DeformTimeline2 = class extends CurveTimeline2 {
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros2 == null)
      zeros2 = Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof VertexAttachment2) || !slotAttachment.applyDeform(this.attachment))
      return;
    const verticesArray = slot.attachmentVertices;
    if (verticesArray.length == 0)
      blend = MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case MixBlend.setup:
          verticesArray.length = 0;
          return;
        case MixBlend.first:
          if (alpha == 1) {
            verticesArray.length = 0;
            break;
          }
          const vertices2 = Utils.setArraySize(verticesArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] += (setupVertices[i] - vertices2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] *= alpha;
          }
      }
      return;
    }
    const vertices = Utils.setArraySize(verticesArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              vertices[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += lastVertices[i];
          }
        } else {
          Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                vertices[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
          case MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation2.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          vertices[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case MixBlend.first:
        case MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
          }
          break;
        case MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
};
var EventTimeline2 = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > lastTime and <= time. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation2.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
};
var DrawOrderTimeline2 = class {
  constructor(frameCount) {
    this.frames = Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe.
   * @param drawOrder May be null to use bind pose draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation2.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
var _IkConstraintTimeline2 = class extends CurveTimeline2 {
  // time, mix, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _IkConstraintTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (9 << 24) + this.ikConstraintIndex;
  }
  /** Sets the time, mix and bend direction of the specified keyframe. */
  setFrame(frameIndex, time, mix, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline2.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline2.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline2.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline2.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline2.ENTRIES]) {
      if (blend == MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline2.PREV_MIX] - constraint.data.mix) * alpha;
        if (direction == MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline2.PREV_MIX] - constraint.mix) * alpha;
        if (direction == MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline2.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline2.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline2.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation2.binarySearch(frames, time, _IkConstraintTimeline2.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline2.PREV_MIX];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline2.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline2.PREV_TIME] - frameTime));
    if (blend == MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline2.MIX] - mix) * percent - constraint.data.mix) * alpha;
      if (direction == MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline2.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline2.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline2.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline2.MIX] - mix) * percent - constraint.mix) * alpha;
      if (direction == MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline2.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline2.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline2.PREV_STRETCH] != 0;
      }
    }
  }
};
var IkConstraintTimeline2 = _IkConstraintTimeline2;
IkConstraintTimeline2.ENTRIES = 5;
IkConstraintTimeline2.PREV_TIME = -5;
IkConstraintTimeline2.PREV_MIX = -4;
IkConstraintTimeline2.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline2.PREV_COMPRESS = -2;
IkConstraintTimeline2.PREV_STRETCH = -1;
IkConstraintTimeline2.MIX = 1;
IkConstraintTimeline2.BEND_DIRECTION = 2;
IkConstraintTimeline2.COMPRESS = 3;
IkConstraintTimeline2.STRETCH = 4;
var _TransformConstraintTimeline2 = class extends CurveTimeline2 {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _TransformConstraintTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (10 << 24) + this.transformConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline2.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline2.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline2.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline2.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline2.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline2.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline2.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline2.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline2.PREV_SHEAR];
    } else {
      const frame = Animation2.binarySearch(frames, time, _TransformConstraintTimeline2.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline2.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline2.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline2.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline2.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline2.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline2.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline2.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline2.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline2.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline2.SHEAR] - shear) * percent;
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
var TransformConstraintTimeline2 = _TransformConstraintTimeline2;
TransformConstraintTimeline2.ENTRIES = 5;
TransformConstraintTimeline2.PREV_TIME = -5;
TransformConstraintTimeline2.PREV_ROTATE = -4;
TransformConstraintTimeline2.PREV_TRANSLATE = -3;
TransformConstraintTimeline2.PREV_SCALE = -2;
TransformConstraintTimeline2.PREV_SHEAR = -1;
TransformConstraintTimeline2.ROTATE = 1;
TransformConstraintTimeline2.TRANSLATE = 2;
TransformConstraintTimeline2.SCALE = 3;
TransformConstraintTimeline2.SHEAR = 4;
var _PathConstraintPositionTimeline2 = class extends CurveTimeline2 {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (11 << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline2.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline2.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline2.PREV_VALUE];
    else {
      const frame = Animation2.binarySearch(frames, time, _PathConstraintPositionTimeline2.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline2.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline2.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline2.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline2.VALUE] - position) * percent;
    }
    if (blend == MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
var PathConstraintPositionTimeline2 = _PathConstraintPositionTimeline2;
PathConstraintPositionTimeline2.ENTRIES = 2;
PathConstraintPositionTimeline2.PREV_TIME = -2;
PathConstraintPositionTimeline2.PREV_VALUE = -1;
PathConstraintPositionTimeline2.VALUE = 1;
var PathConstraintSpacingTimeline2 = class _PathConstraintSpacingTimeline extends PathConstraintPositionTimeline2 {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - _PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + _PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation2.binarySearch(frames, time, _PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + _PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + _PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
};
var _PathConstraintMixTimeline2 = class extends CurveTimeline2 {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = Utils.newFloatArray(frameCount * _PathConstraintMixTimeline2.ENTRIES);
  }
  getPropertyId() {
    return (13 << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline2.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline2.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline2.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline2.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline2.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline2.PREV_TRANSLATE];
    } else {
      const frame = Animation2.binarySearch(frames, time, _PathConstraintMixTimeline2.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline2.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline2.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline2.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline2.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline2.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline2.TRANSLATE] - translate) * percent;
    }
    if (blend == MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
var PathConstraintMixTimeline2 = _PathConstraintMixTimeline2;
PathConstraintMixTimeline2.ENTRIES = 3;
PathConstraintMixTimeline2.PREV_TIME = -3;
PathConstraintMixTimeline2.PREV_ROTATE = -2;
PathConstraintMixTimeline2.PREV_TRANSLATE = -1;
PathConstraintMixTimeline2.ROTATE = 1;
PathConstraintMixTimeline2.TRANSLATE = 2;

// node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationState.mjs
var _AnimationState2 = class {
  constructor(data) {
    this.tracks = new Array();
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue2(this);
    this.propertyIDs = new IntSet();
    this.animationsChanged = false;
    this.timeScale = 1;
    this.trackEntryPool = new Pool(() => new TrackEntry2());
    this.data = data;
  }
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          Utils.webkit602BugfixHelper(mix, blend);
          timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState2.SUBSEQUENT ? blend : MixBlend.setup;
          if (timeline instanceof RotateTimeline2) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else {
            Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == MixBlend.first)
        blend = MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState2.SUBSEQUENT:
            if (!attachments && timeline instanceof AttachmentTimeline2)
              continue;
            if (!drawOrder && timeline instanceof DrawOrderTimeline2)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState2.FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState2.HOLD:
            timelineBlend = MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof RotateTimeline2)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else {
          Utils.webkit602BugfixHelper(alpha, blend);
          if (timelineBlend == MixBlend.setup) {
            if (timeline instanceof AttachmentTimeline2) {
              if (attachments)
                direction = MixDirection.mixOut;
            } else if (timeline instanceof DrawOrderTimeline2) {
              if (drawOrder)
                direction = MixDirection.mixOut;
            }
          }
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - RotateTimeline2.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + RotateTimeline2.PREV_ROTATION];
      else {
        const frame = Animation2.binarySearch(frames, time, RotateTimeline2.ENTRIES);
        const prevRotation = frames[frame + RotateTimeline2.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline2.PREV_TIME] - frameTime));
        r2 = frames[frame + RotateTimeline2.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState2.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState2.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add)
          this.setTimelineModes(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  setTimelineModes(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        propertyIDs.add(timelines[i].getPropertyId());
        timelineMode[i] = _AnimationState2.HOLD;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const id = timelines[i].getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState2.SUBSEQUENT;
        else if (to == null || !this.hasTimeline(to, id))
          timelineMode[i] = _AnimationState2.FIRST;
        else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (this.hasTimeline(next, id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState2.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState2.HOLD;
        }
      }
  }
  hasTimeline(entry, id) {
    const timelines = entry.animation.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      if (timelines[i].getPropertyId() == id)
        return true;
    return false;
  }
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  clearListeners() {
    this.listeners.length = 0;
  }
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState2.deprecatedWarning1) {
      _AnimationState2.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState2.deprecatedWarning2) {
      _AnimationState2.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState2.deprecatedWarning3) {
      _AnimationState2.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
var AnimationState2 = _AnimationState2;
AnimationState2.emptyAnimation = new Animation2("<empty>", [], 0);
AnimationState2.SUBSEQUENT = 0;
AnimationState2.FIRST = 1;
AnimationState2.HOLD = 2;
AnimationState2.HOLD_MIX = 3;
AnimationState2.deprecatedWarning1 = false;
AnimationState2.deprecatedWarning2 = false;
AnimationState2.deprecatedWarning3 = false;
var _TrackEntry2 = class {
  constructor() {
    this.mixBlend = MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry2.deprecatedWarning1) {
      _TrackEntry2.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry2.deprecatedWarning1) {
      _TrackEntry2.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry2.deprecatedWarning2) {
      _TrackEntry2.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry2.deprecatedWarning2) {
      _TrackEntry2.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
var TrackEntry2 = _TrackEntry2;
TrackEntry2.deprecatedWarning1 = false;
TrackEntry2.deprecatedWarning2 = false;
var _EventQueue2 = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType2.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType2.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType2.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType2.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType2.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType2.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue2.deprecatedWarning1) {
      _EventQueue2.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType2.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType2.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType2.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType2.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType2.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType2.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
var EventQueue2 = _EventQueue2;
EventQueue2.deprecatedWarning1 = false;
var EventType2 = ((EventType22) => {
  EventType22[EventType22["start"] = 0] = "start";
  EventType22[EventType22["interrupt"] = 1] = "interrupt";
  EventType22[EventType22["end"] = 2] = "end";
  EventType22[EventType22["dispose"] = 3] = "dispose";
  EventType22[EventType22["complete"] = 4] = "complete";
  EventType22[EventType22["event"] = 5] = "event";
  return EventType22;
})(EventType2 || {});
var AnimationStateAdapter2 = class {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationStateData.mjs
var _AnimationStateData2 = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData2.deprecatedWarning1) {
      _AnimationStateData2.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
var AnimationStateData2 = _AnimationStateData2;
AnimationStateData2.deprecatedWarning1 = false;

// node_modules/@pixi-spine/runtime-3.7/lib/core/AtlasAttachmentLoader.mjs
var AtlasAttachmentLoader2 = class {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new RegionAttachment2(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new MeshAttachment2(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment2(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new PathAttachment2(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment2(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment2(name);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/Bone.mjs
var Bone2 = class {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    this.matrix = new Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    this.active = true;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = settings2.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = MathUtils.cosDeg(rotationY) * scaleY;
        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = MathUtils.cosDeg(rotationY) * scaleY;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = MathUtils.cosDeg(rx) * scaleX;
        const lb = MathUtils.cosDeg(ry) * scaleY;
        const lc = MathUtils.sinDeg(rx) * scaleX;
        const ld = MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case TransformMode.NoScale:
      case TransformMode.NoScaleOrReflection: {
        const cos = MathUtils.cosDeg(rotation);
        const sin = MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (settings2.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = MathUtils.cosDeg(shearX) * scaleX;
        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = MathUtils.sinDeg(shearX) * scaleX;
        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = MathUtils.sinDeg(worldRotation);
    const cos = MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = MathUtils.sinDeg(localRotation);
    const cos = MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = MathUtils.cosDeg(degrees);
    const sin = MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/BoneData.mjs
var BoneData2 = class {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = TransformMode.Normal;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/Event.mjs
var Event2 = class {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/EventData.mjs
var EventData2 = class {
  constructor(name) {
    this.name = name;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraint.mjs
var IkConstraint2 = class {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  getOrder() {
    return this.data.order;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const id = 1 / (p.a * p.d - p.b * p.c);
    const x = targetX - p.tx;
    const y = targetY - p.ty;
    const tx = (x * p.d - y * p.c) * id - bone.ax;
    const ty = (y * p.a - x * p.b) * id - bone.ay;
    let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = targetX - pp.tx;
    let y = targetY - pp.ty;
    const tx = (x * d - y * b) * id - px;
    const ty = (y * a - x * c) * id - py;
    const dd = tx * tx + ty * ty;
    x = cwx - pp.tx;
    y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1 = 0;
    let a2 = 0;
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch && l1 + l2 > 1e-4)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraintData.mjs
var IkConstraintData2 = class {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.name = name;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs
var PathConstraintData2 = class {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.name = name;
  }
};
var SpacingMode2 = ((SpacingMode22) => {
  SpacingMode22[SpacingMode22["Length"] = 0] = "Length";
  SpacingMode22[SpacingMode22["Fixed"] = 1] = "Fixed";
  SpacingMode22[SpacingMode22["Percent"] = 2] = "Percent";
  return SpacingMode22;
})(SpacingMode2 || {});

// node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraint.mjs
var _PathConstraint2 = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment2))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == SpacingMode2.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == RotateMode.Tangent;
    const scale = rotateMode == RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint2.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == PositionMode.Percent,
      spacingMode == SpacingMode2.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed2 = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint2.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed2 ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed2) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint2.BEFORE) {
            prevCurve = _PathConstraint2.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint2.AFTER) {
            prevCurve = _PathConstraint2.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed2 && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed2) {
      verticesLength += 2;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed2) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
  getOrder() {
    return this.data.order;
  }
};
var PathConstraint2 = _PathConstraint2;
PathConstraint2.NONE = -1;
PathConstraint2.BEFORE = -2;
PathConstraint2.AFTER = -3;
PathConstraint2.epsilon = 1e-5;

// node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraint.mjs
var TransformConstraint2 = class {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new Vector2();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  getOrder() {
    return this.data.order;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/Skeleton.mjs
var _Skeleton2 = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new Bone2(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone2(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot2(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint2(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint2(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint2(pathConstraintData, this));
    }
    this.color = new Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].sorted = false;
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment2)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment2))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.mix = constraint.data.mix;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment2) {
        verticesLength = 8;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment2) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton2.deprecatedWarning1) {
      _Skeleton2.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton2.deprecatedWarning1) {
      _Skeleton2.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
var Skeleton2 = _Skeleton2;
Skeleton2.deprecatedWarning1 = false;

// node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonBounds.mjs
var SkeletonBounds2 = class extends SkeletonBoundsBase {
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonData.mjs
var SkeletonData2 = class {
  constructor() {
    this.bones = new Array();
    this.slots = new Array();
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/SlotData.mjs
var SlotData2 = class {
  constructor(index, name, boneData) {
    this.color = new Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraintData.mjs
var TransformConstraintData2 = class {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/Skin.mjs
var Skin2 = class {
  constructor(name) {
    this.attachments = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  addAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonJson.mjs
var SkeletonJson2 = class _SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData2();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData2(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = _SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new SlotData2(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = _SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData2(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.mix = this.getValue(constraintMap, "mix", 1);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData2(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData2(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = _SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = _SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = _SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == SpacingMode2.Length || data.spacingMode == SpacingMode2.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (const skinName in root.skins) {
        const skinMap = root.skins[skinName];
        const skin = new Skin2(skinName);
        for (const slotName in skinMap) {
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
            if (attachment != null)
              skin.addAttachment(slotIndex, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData2(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          mesh.inheritDeform = this.getValue(map, "deform", true);
          this.linkedMeshes.push(new LinkedMesh3(mesh, this.getValue(map, "skin", null), slotIndex, parent));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new AttachmentTimeline2(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new ColorTimeline2(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline2.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new TwoColorTimeline2(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new Color();
              const dark = new Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline2.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new RotateTimeline2(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline2.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "scale")
              timeline = new ScaleTimeline2(timelineMap.length);
            else if (timelineName === "shear")
              timeline = new ShearTimeline2(timelineMap.length);
            else {
              timeline = new TranslateTimeline2(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", 0);
              const y = this.getValue(valueMap, "y", 0);
              timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline2.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new IkConstraintTimeline2(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline2.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new TransformConstraintTimeline2(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline2.ENTRIES]);
      }
    }
    if (map.paths) {
      for (const constraintName in map.paths) {
        const constraintMap = map.paths[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new PathConstraintSpacingTimeline2(timelineMap.length);
              if (data.spacingMode == SpacingMode2.Length || data.spacingMode == SpacingMode2.Fixed)
                timelineScale = scale;
            } else {
              timeline = new PathConstraintPositionTimeline2(timelineMap.length);
              if (data.positionMode == PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline2.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new PathConstraintMixTimeline2(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline2.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (settings2.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new DeformTimeline2(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, valueMap.time, deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new DrawOrderTimeline2(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = Utils.newArray(slotCount, -1);
          const unchanged = Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new EventTimeline2(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event2(Utils.toSinglePrecision(eventMap.time), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation2(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.curve)
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else if (Object.prototype.toString.call(map.curve) === "[object Array]") {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return BLEND_MODES.NORMAL;
    if (str == "additive")
      return BLEND_MODES.ADD;
    if (str == "multiply")
      return BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return PositionMode.Fixed;
    if (str == "percent")
      return PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return SpacingMode2.Length;
    if (str == "fixed")
      return SpacingMode2.Fixed;
    if (str == "percent")
      return SpacingMode2.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return RotateMode.Tangent;
    if (str == "chain")
      return RotateMode.Chain;
    if (str == "chainscale")
      return RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return TransformMode.Normal;
    if (str == "onlytranslation")
      return TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
};
var LinkedMesh3 = class {
  constructor(mesh, skin, slotIndex, parent) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
  }
};

// node_modules/@pixi-spine/runtime-3.7/lib/Spine.mjs
var Spine2 = class extends SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton2(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData2(spineData);
    this.state = new AnimationState2(this.stateData);
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/index.mjs
var lib_exports4 = {};
__export(lib_exports4, {
  AlphaTimeline: () => AlphaTimeline,
  Animation: () => Animation3,
  AnimationState: () => AnimationState3,
  AnimationStateAdapter: () => AnimationStateAdapter3,
  AnimationStateData: () => AnimationStateData3,
  AtlasAttachmentLoader: () => AtlasAttachmentLoader3,
  Attachment: () => Attachment3,
  AttachmentTimeline: () => AttachmentTimeline3,
  Bone: () => Bone3,
  BoneData: () => BoneData3,
  BoundingBoxAttachment: () => BoundingBoxAttachment3,
  ClippingAttachment: () => ClippingAttachment3,
  ConstraintData: () => ConstraintData2,
  CurveTimeline: () => CurveTimeline3,
  CurveTimeline1: () => CurveTimeline1,
  CurveTimeline2: () => CurveTimeline22,
  DeformTimeline: () => DeformTimeline3,
  DrawOrderTimeline: () => DrawOrderTimeline3,
  Event: () => Event3,
  EventData: () => EventData3,
  EventQueue: () => EventQueue3,
  EventTimeline: () => EventTimeline3,
  EventType: () => EventType3,
  IkConstraint: () => IkConstraint3,
  IkConstraintData: () => IkConstraintData3,
  IkConstraintTimeline: () => IkConstraintTimeline3,
  MeshAttachment: () => MeshAttachment3,
  PathAttachment: () => PathAttachment3,
  PathConstraint: () => PathConstraint3,
  PathConstraintData: () => PathConstraintData3,
  PathConstraintMixTimeline: () => PathConstraintMixTimeline3,
  PathConstraintPositionTimeline: () => PathConstraintPositionTimeline3,
  PathConstraintSpacingTimeline: () => PathConstraintSpacingTimeline3,
  PointAttachment: () => PointAttachment3,
  RGB2Timeline: () => RGB2Timeline,
  RGBA2Timeline: () => RGBA2Timeline,
  RGBATimeline: () => RGBATimeline,
  RGBTimeline: () => RGBTimeline,
  RegionAttachment: () => RegionAttachment3,
  RotateTimeline: () => RotateTimeline3,
  ScaleTimeline: () => ScaleTimeline3,
  ScaleXTimeline: () => ScaleXTimeline,
  ScaleYTimeline: () => ScaleYTimeline,
  Sequence: () => Sequence,
  SequenceMode: () => SequenceMode,
  SequenceModeValues: () => SequenceModeValues,
  SequenceTimeline: () => SequenceTimeline,
  ShearTimeline: () => ShearTimeline3,
  ShearXTimeline: () => ShearXTimeline,
  ShearYTimeline: () => ShearYTimeline,
  Skeleton: () => Skeleton3,
  SkeletonBinary: () => SkeletonBinary2,
  SkeletonBounds: () => SkeletonBounds3,
  SkeletonData: () => SkeletonData3,
  SkeletonJson: () => SkeletonJson3,
  Skin: () => Skin3,
  SkinEntry: () => SkinEntry2,
  Slot: () => Slot3,
  SlotData: () => SlotData3,
  SpacingMode: () => SpacingMode3,
  Spine: () => Spine3,
  Timeline: () => Timeline,
  TrackEntry: () => TrackEntry3,
  TransformConstraint: () => TransformConstraint3,
  TransformConstraintData: () => TransformConstraintData3,
  TransformConstraintTimeline: () => TransformConstraintTimeline3,
  TranslateTimeline: () => TranslateTimeline3,
  TranslateXTimeline: () => TranslateXTimeline,
  TranslateYTimeline: () => TranslateYTimeline,
  VertexAttachment: () => VertexAttachment3
});

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs
var Attachment3 = class {
  constructor(name) {
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
};
var _VertexAttachment3 = class extends Attachment3 {
  constructor(name) {
    super(name);
    this.id = _VertexAttachment3.nextID++;
    this.bones = null;
    this.vertices = [];
    this.worldVerticesLength = 0;
    this.timelineAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is
   * not empty, it is used to deform the vertices.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide.
   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.
   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *
   *           `stride` / 2.
   * @param offset The `worldVertices` index to begin writing values.
   * @param stride The number of `worldVertices` entries between the value pairs written. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (!bones) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Does not copy id (generated) or name (set on construction). **/
  copyTo(attachment) {
    if (this.bones) {
      attachment.bones = new Array(this.bones.length);
      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices) {
      attachment.vertices = Utils.newFloatArray(this.vertices.length);
      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    }
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.timelineAttachment = this.timelineAttachment;
  }
};
var VertexAttachment3 = _VertexAttachment3;
VertexAttachment3.nextID = 0;

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs
var BoundingBoxAttachment3 = class _BoundingBoxAttachment extends VertexAttachment3 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.BoundingBox;
    this.color = new Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new _BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs
var ClippingAttachment3 = class _ClippingAttachment extends VertexAttachment3 {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = AttachmentType.Clipping;
    this.endSlot = null;
    this.color = new Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new _ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs
var MeshAttachment3 = class _MeshAttachment extends VertexAttachment3 {
  constructor(name, path) {
    super(name);
    this.type = AttachmentType.Mesh;
    this.region = null;
    this.triangles = [];
    this.color = new Color(1, 1, 1, 1);
    this.width = 0;
    this.height = 0;
    this.hullLength = 0;
    this.edges = [];
    this.parentMesh = null;
    this.sequence = null;
    this.tempColor = new Color(0, 0, 0, 0);
    this.path = path;
  }
  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},
   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the
   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh)
      return this.newLinkedMesh();
    const copy = new _MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    if (this.edges) {
      copy.edges = new Array(this.edges.length);
      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);
  }
  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/
  newLinkedMesh() {
    const copy = new _MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    copy.timelineAttachment = this.timelineAttachment;
    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs
var PathAttachment3 = class _PathAttachment extends VertexAttachment3 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Path;
    this.lengths = [];
    this.closed = false;
    this.constantSpeed = false;
    this.color = new Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new _PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs
var PointAttachment3 = class _PointAttachment extends VertexAttachment3 {
  constructor(name) {
    super(name);
    this.type = AttachmentType.Point;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.color = new Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = MathUtils.cosDeg(this.rotation);
    const sin = MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * MathUtils.radDeg;
  }
  copy() {
    const copy = new _PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs
var _RegionAttachment3 = class extends Attachment3 {
  constructor(name, path) {
    super(name);
    this.type = AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new Color(1, 1, 1, 1);
    this.rendererObject = null;
    this.region = null;
    this.sequence = null;
    this.offset = Utils.newFloatArray(8);
    this.uvs = Utils.newFloatArray(8);
    this.tempColor = new Color(1, 1, 1, 1);
    this.path = path;
  }
  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */
  updateRegion() {
    if (!this.region)
      throw new Error("Region not set.");
    const region = this.region;
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const x = this.x;
    const y = this.y;
    const localXCos = localX * cos + x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[0] = localXCos - localYSin;
    offset[1] = localYCos + localXSin;
    offset[2] = localXCos - localY2Sin;
    offset[3] = localY2Cos + localXSin;
    offset[4] = localX2Cos - localY2Sin;
    offset[5] = localY2Cos + localX2Sin;
    offset[6] = localX2Cos - localYSin;
    offset[7] = localYCos + localX2Sin;
    const uvs = this.uvs;
    if (region.degrees == 90) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may
   * be changed.
   * <p>
   * See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
   * Runtimes Guide.
   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.
   * @param offset The <code>worldVertices</code> index to begin writing values.
   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */
  computeWorldVertices(slot, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    const bone = slot.bone;
    const vertexOffset = this.offset;
    const mat = bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[0];
    offsetY = vertexOffset[1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[2];
    offsetY = vertexOffset[3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[4];
    offsetY = vertexOffset[5];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[6];
    offsetY = vertexOffset[7];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment3(this.name, this.path);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    return copy;
  }
};
var RegionAttachment3 = _RegionAttachment3;
RegionAttachment3.X1 = 0;
RegionAttachment3.Y1 = 1;
RegionAttachment3.C1R = 2;
RegionAttachment3.C1G = 3;
RegionAttachment3.C1B = 4;
RegionAttachment3.C1A = 5;
RegionAttachment3.U1 = 6;
RegionAttachment3.V1 = 7;
RegionAttachment3.X2 = 8;
RegionAttachment3.Y2 = 9;
RegionAttachment3.C2R = 10;
RegionAttachment3.C2G = 11;
RegionAttachment3.C2B = 12;
RegionAttachment3.C2A = 13;
RegionAttachment3.U2 = 14;
RegionAttachment3.V2 = 15;
RegionAttachment3.X3 = 16;
RegionAttachment3.Y3 = 17;
RegionAttachment3.C3R = 18;
RegionAttachment3.C3G = 19;
RegionAttachment3.C3B = 20;
RegionAttachment3.C3A = 21;
RegionAttachment3.U3 = 22;
RegionAttachment3.V3 = 23;
RegionAttachment3.X4 = 24;
RegionAttachment3.Y4 = 25;
RegionAttachment3.C4R = 26;
RegionAttachment3.C4G = 27;
RegionAttachment3.C4B = 28;
RegionAttachment3.C4A = 29;
RegionAttachment3.U4 = 30;
RegionAttachment3.V4 = 31;

// node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs
var _Sequence = class {
  constructor(count) {
    this.id = _Sequence.nextID();
    this.start = 0;
    this.digits = 0;
    this.setupIndex = 0;
    this.regions = new Array(count);
  }
  copy() {
    const copy = new _Sequence(this.regions.length);
    Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
    copy.start = this.start;
    copy.digits = this.digits;
    copy.setupIndex = this.setupIndex;
    return copy;
  }
  apply(slot, attachment) {
    let index = slot.sequenceIndex;
    if (index == -1)
      index = this.setupIndex;
    if (index >= this.regions.length)
      index = this.regions.length - 1;
    const region = this.regions[index];
    if (attachment.region != region) {
      attachment.region = region;
    }
  }
  getPath(basePath, index) {
    let result = basePath;
    const frame = (this.start + index).toString();
    for (let i = this.digits - frame.length; i > 0; i--)
      result += "0";
    result += frame;
    return result;
  }
  static nextID() {
    return _Sequence._nextID++;
  }
};
var Sequence = _Sequence;
Sequence._nextID = 0;
var SequenceMode = ((SequenceMode2) => {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
  return SequenceMode2;
})(SequenceMode || {});
var SequenceModeValues = [
  0,
  1,
  2,
  3,
  4,
  5,
  6
  /* pingpongReverse */
];

// node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs
var Animation3 = class {
  constructor(name, timelines, duration) {
    this.timelines = [];
    this.timelineIds = new StringSet();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
    this.setTimelines(timelines);
    this.duration = duration;
  }
  setTimelines(timelines) {
    if (!timelines)
      throw new Error("timelines cannot be null.");
    this.timelines = timelines;
    this.timelineIds.clear();
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds.addAll(timelines[i].getPropertyIds());
  }
  hasTimeline(ids) {
    for (let i = 0; i < ids.length; i++)
      if (this.timelineIds.contains(ids[i]))
        return true;
    return false;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
};
var Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
var Timeline = class {
  constructor(frameCount, propertyIds) {
    this.propertyIds = propertyIds;
    this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());
  }
  getPropertyIds() {
    return this.propertyIds;
  }
  getFrameEntries() {
    return 1;
  }
  getFrameCount() {
    return this.frames.length / this.getFrameEntries();
  }
  getDuration() {
    return this.frames[this.frames.length - this.getFrameEntries()];
  }
  static search1(frames, time) {
    const n = frames.length;
    for (let i = 1; i < n; i++)
      if (frames[i] > time)
        return i - 1;
    return n - 1;
  }
  static search(frames, time, step) {
    const n = frames.length;
    for (let i = step; i < n; i += step)
      if (frames[i] > time)
        return i - step;
    return n - step;
  }
};
var CurveTimeline3 = class extends Timeline {
  // type, x, y, ...
  constructor(frameCount, bezierCount, propertyIds) {
    super(frameCount, propertyIds);
    this.curves = Utils.newFloatArray(
      frameCount + bezierCount * 18
      /* BEZIER_SIZE*/
    );
    this.curves[frameCount - 1] = 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frame) {
    this.curves[frame] = 0;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frame) {
    this.curves[frame] = 1;
  }
  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger
   * than the actual number of Bezier curves. */
  shrink(bezierCount) {
    const size = this.getFrameCount() + bezierCount * 18;
    if (this.curves.length > size) {
      const newCurves = Utils.newFloatArray(size);
      Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
      this.curves = newCurves;
    }
  }
  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
   * one curve per frame.
   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified
   *           in the constructor), inclusive.
   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.
   * @param value The index of the value for this frame that this curve is used for.
   * @param time1 The time for the first key.
   * @param value1 The value for the first key.
   * @param cx1 The time for the first Bezier handle.
   * @param cy1 The value for the first Bezier handle.
   * @param cx2 The time of the second Bezier handle.
   * @param cy2 The value for the second Bezier handle.
   * @param time2 The time for the second key.
   * @param value2 The value for the second key. */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = value1 + dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  /** Returns the Bezier interpolated value for the specified time.
   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.
   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.
   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */
  getBezierValue(time, frameIndex, valueOffset, i) {
    const curves = this.curves;
    if (curves[i] > time) {
      const x2 = this.frames[frameIndex];
      const y2 = this.frames[frameIndex + valueOffset];
      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    frameIndex += this.getFrameEntries();
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);
  }
};
var CurveTimeline1 = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, propertyId) {
    super(frameCount, bezierCount, [propertyId]);
  }
  getFrameEntries() {
    return 2;
  }
  /** Sets the time and value for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value) {
    frame <<= 1;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE*/
    ] = value;
  }
  /** Returns the interpolated value for the specified time. */
  getCurveValue(time) {
    const frames = this.frames;
    let i = frames.length - 2;
    for (let ii = 2; ii <= i; ii += 2) {
      if (frames[ii] > time) {
        i = ii - 2;
        break;
      }
    }
    const curveType = this.curves[i >> 1];
    switch (curveType) {
      case 0:
        const before = frames[i];
        const value = frames[
          i + 1
          /* VALUE*/
        ];
        return value + (time - before) / (frames[
          i + 2
          /* ENTRIES*/
        ] - before) * (frames[
          i + 2 + 1
          /* VALUE*/
        ] - value);
      case 1:
        return frames[
          i + 1
          /* VALUE*/
        ];
    }
    return this.getBezierValue(
      time,
      i,
      1,
      curveType - 2
      /* BEZIER*/
    );
  }
};
var CurveTimeline22 = class extends CurveTimeline3 {
  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.
   * @param propertyIds Unique identifiers for the properties the timeline modifies. */
  constructor(frameCount, bezierCount, propertyId1, propertyId2) {
    super(frameCount, bezierCount, [propertyId1, propertyId2]);
  }
  getFrameEntries() {
    return 3;
  }
  /** Sets the time and values for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value1, value2) {
    frame *= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE1*/
    ] = value1;
    this.frames[
      frame + 2
      /* VALUE2*/
    ] = value2;
  }
};
var RotateTimeline3 = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case MixBlend.first:
          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
      }
      return;
    }
    let r = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.rotation = bone.data.rotation + r * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case MixBlend.add:
        bone.rotation += r * alpha;
    }
  }
};
var TranslateTimeline3 = class extends CurveTimeline22 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
var TranslateXTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.x = bone.data.x;
          return;
        case MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        break;
      case MixBlend.add:
        bone.x += x * alpha;
    }
  }
};
var TranslateYTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.y = bone.data.y;
          return;
        case MixBlend.first:
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.y = bone.data.y + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case MixBlend.add:
        bone.y += y * alpha;
    }
  }
};
var ScaleTimeline3 = class extends CurveTimeline22 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    x *= bone.data.scaleX;
    y *= bone.data.scaleY;
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
};
var ScaleXTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          return;
        case MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time) * bone.data.scaleX;
    if (alpha == 1) {
      if (blend == MixBlend.add)
        bone.scaleX += x - bone.data.scaleX;
      else
        bone.scaleX = x;
    } else {
      let bx = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            bx = bone.data.scaleX;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = bone.scaleX;
            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      }
    }
  }
};
var ScaleYTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.scaleY = bone.data.scaleY;
          return;
        case MixBlend.first:
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time) * bone.data.scaleY;
    if (alpha == 1) {
      if (blend == MixBlend.add)
        bone.scaleY += y - bone.data.scaleY;
      else
        bone.scaleY = y;
    } else {
      let by = 0;
      if (direction == MixDirection.mixOut) {
        switch (blend) {
          case MixBlend.setup:
            by = bone.data.scaleY;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            by = bone.scaleY;
            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case MixBlend.setup:
            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.first:
          case MixBlend.replace:
            by = Math.abs(bone.scaleY) * MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
};
var ShearTimeline3 = class extends CurveTimeline22 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
};
var ShearXTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearX = bone.data.shearX;
          return;
        case MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        break;
      case MixBlend.add:
        bone.shearX += x * alpha;
    }
  }
};
var ShearYTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.shearY = bone.data.shearY;
          return;
        case MixBlend.first:
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case MixBlend.setup:
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case MixBlend.first:
      case MixBlend.replace:
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case MixBlend.add:
        bone.shearY += y * alpha;
    }
  }
};
var RGBATimeline = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 5;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b, a) {
    frame *= 5;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.setFromColor(setup);
          return;
        case MixBlend.first:
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    const i = Timeline.search(
      frames,
      time,
      5
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 5
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        const t = (time - before) / (frames[
          i + 5
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 5 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 5 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 5 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 5 + 4
          /* A*/
        ] - a) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1)
      color.set(r, g, b, a);
    else {
      if (blend == MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
var RGBTimeline = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 4;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b) {
    frame <<= 2;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
          return;
        case MixBlend.first:
          color.r += (setup.r - color.r) * alpha;
          color.g += (setup.g - color.g) * alpha;
          color.b += (setup.b - color.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 4 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 4 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 4 + 3
          /* B*/
        ] - b) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      color.r = r;
      color.g = g;
      color.b = b;
    } else {
      if (blend == MixBlend.setup) {
        const setup = slot.data.color;
        color.r = setup.r;
        color.g = setup.g;
        color.b = setup.b;
      }
      color.r += (r - color.r) * alpha;
      color.g += (g - color.g) * alpha;
      color.b += (b - color.b) * alpha;
    }
  }
};
var AlphaTimeline = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const color = slot.color;
    if (time < this.frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case MixBlend.setup:
          color.a = setup.a;
          return;
        case MixBlend.first:
          color.a += (setup.a - color.a) * alpha;
      }
      return;
    }
    const a = this.getCurveValue(time);
    if (alpha == 1)
      color.a = a;
    else {
      if (blend == MixBlend.setup)
        color.a = slot.data.color.a;
      color.a += (a - color.a) * alpha;
    }
  }
};
var RGBA2Timeline = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 8;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, a, r2, g2, b2) {
    frame <<= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
    this.frames[
      frame + 5
      /* R2*/
    ] = r2;
    this.frames[
      frame + 6
      /* G2*/
    ] = g2;
    this.frames[
      frame + 7
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case MixBlend.setup:
          light.setFromColor(setupLight);
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case MixBlend.first:
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      8
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 3];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 8
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 8 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 8 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 8 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 8 + 4
          /* A*/
        ] - a) * t;
        r2 += (frames[
          i + 8 + 5
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 8 + 6
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 8 + 7
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          7,
          curveType + 18 * 6 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.set(r, g, b, a);
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == MixBlend.setup) {
        light.setFromColor(slot.data.color);
        const setupDark = slot.data.darkColor;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
};
var RGB2Timeline = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, r2, g2, b2) {
    frame *= 7;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* R2*/
    ] = r2;
    this.frames[
      frame + 5
      /* G2*/
    ] = g2;
    this.frames[
      frame + 6
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case MixBlend.setup:
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case MixBlend.first:
          light.r += (setupLight.r - light.r) * alpha;
          light.g += (setupLight.g - light.g) * alpha;
          light.b += (setupLight.b - light.b) * alpha;
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 7 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 7 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 7 + 3
          /* B*/
        ] - b) * t;
        r2 += (frames[
          i + 7 + 4
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 7 + 5
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 7 + 6
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.r = r;
      light.g = g;
      light.b = b;
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == MixBlend.setup) {
        const setupLight = slot.data.color;
        const setupDark = slot.data.darkColor;
        light.r = setupLight.r;
        light.g = setupLight.g;
        light.b = setupLight.b;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.r += (r - light.r) * alpha;
      light.g += (g - light.g) * alpha;
      light.b += (b - light.b) * alpha;
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
};
var AttachmentTimeline3 = class extends Timeline {
  constructor(frameCount, slotIndex) {
    super(frameCount, [`${Property.attachment}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachmentNames = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frame, time, attachmentName) {
    this.frames[frame] = time;
    this.attachmentNames[frame] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == MixDirection.mixOut) {
      if (blend == MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
};
var DeformTimeline3 = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, slotIndex, attachment) {
    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachment = attachment;
    this.vertices = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frame, time, vertices) {
    this.frames[frame] = time;
    this.vertices[frame] = vertices;
  }
  /** @param value1 Ignored (0 is used for a deform timeline).
   * @param value2 Ignored (1 is used for a deform timeline). */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = cy2 * 0.03 - cy1 * 0.06;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  getCurvePercent(time, frame) {
    const curves = this.curves;
    let i = curves[frame];
    switch (i) {
      case 0:
        const x2 = this.frames[frame];
        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);
      case 1:
        return 0;
    }
    i -= 2;
    if (curves[i] > time) {
      const x2 = this.frames[frame];
      return curves[i + 1] * (time - x2) / (curves[i] - x2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!slotAttachment)
      return;
    if (!(slotAttachment instanceof VertexAttachment3) || slotAttachment.timelineAttachment != this.attachment)
      return;
    const deform = slot.deform;
    if (deform.length == 0)
      blend = MixBlend.setup;
    const vertices = this.vertices;
    const vertexCount = vertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          deform.length = 0;
          return;
        case MixBlend.first:
          if (alpha == 1) {
            deform.length = 0;
            return;
          }
          deform.length = vertexCount;
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (setupVertices[i] - deform[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform[i] *= alpha;
          }
      }
      return;
    }
    deform.length = vertexCount;
    if (time >= frames[frames.length - 1]) {
      const lastVertices = vertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i] - setupVertices[i];
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else
          Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
      } else {
        switch (blend) {
          case MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (!vertexAttachment2.bones) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case MixBlend.first:
          case MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++)
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Timeline.search1(frames, time);
    const percent = this.getCurvePercent(time, frame);
    const prevVertices = vertices[frame];
    const nextVertices = vertices[frame + 1];
    if (alpha == 1) {
      if (blend == MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (!vertexAttachment.bones) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (!vertexAttachment2.bones) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case MixBlend.first:
        case MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
};
var _EventTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _EventTimeline.propertyIds);
    this.events = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frame, event) {
    this.frames[frame] = event.time;
    this.events[frame] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (!firedEvents)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let i = 0;
    if (lastTime < frames[0])
      i = 0;
    else {
      i = Timeline.search1(frames, lastTime) + 1;
      const frameTime = frames[i];
      while (i > 0) {
        if (frames[i - 1] != frameTime)
          break;
        i--;
      }
    }
    for (; i < frameCount && time >= frames[i]; i++)
      firedEvents.push(this.events[i]);
  }
};
var EventTimeline3 = _EventTimeline;
EventTimeline3.propertyIds = [`${Property.event}`];
var _DrawOrderTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _DrawOrderTimeline.propertyIds);
    this.drawOrders = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frame, time, drawOrder) {
    this.frames[frame] = time;
    this.drawOrders[frame] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (direction == MixDirection.mixOut) {
      if (blend == MixBlend.setup)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const idx = Timeline.search1(this.frames, time);
    const drawOrderToSetupIndex = this.drawOrders[idx];
    if (!drawOrderToSetupIndex)
      Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
    else {
      const drawOrder = skeleton.drawOrder;
      const slots = skeleton.slots;
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
var DrawOrderTimeline3 = _DrawOrderTimeline;
DrawOrderTimeline3.propertyIds = [`${Property.drawOrder}`];
var IkConstraintTimeline3 = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, ikConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);
    this.ikConstraintIndex = 0;
    this.ikConstraintIndex = ikConstraintIndex;
  }
  getFrameEntries() {
    return 6;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {
    frame *= 6;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* MIX*/
    ] = mix;
    this.frames[
      frame + 2
      /* SOFTNESS*/
    ] = softness;
    this.frames[
      frame + 3
      /* BEND_DIRECTION*/
    ] = bendDirection;
    this.frames[
      frame + 4
      /* COMPRESS*/
    ] = compress ? 1 : 0;
    this.frames[
      frame + 5
      /* STRETCH*/
    ] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    let mix = 0;
    let softness = 0;
    const i = Timeline.search(
      frames,
      time,
      6
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 6
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        const t = (time - before) / (frames[
          i + 6
          /* ENTRIES*/
        ] - before);
        mix += (frames[
          i + 6 + 1
          /* MIX*/
        ] - mix) * t;
        softness += (frames[
          i + 6 + 2
          /* SOFTNESS*/
        ] - softness) * t;
        break;
      case 1:
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        break;
      default:
        mix = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        softness = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
      if (direction == MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    } else {
      constraint.mix += (mix - constraint.mix) * alpha;
      constraint.softness += (softness - constraint.softness) * alpha;
      if (direction == MixDirection.mixIn) {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    }
  }
};
var TransformConstraintTimeline3 = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, transformConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);
    this.transformConstraintIndex = 0;
    this.transformConstraintIndex = transformConstraintIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
    const frames = this.frames;
    frame *= 7;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
    frames[
      frame + 4
      /* SCALEX*/
    ] = mixScaleX;
    frames[
      frame + 5
      /* SCALEY*/
    ] = mixScaleY;
    frames[
      frame + 6
      /* SHEARY*/
    ] = mixShearY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case MixBlend.setup:
          constraint.mixRotate = data.mixRotate;
          constraint.mixX = data.mixX;
          constraint.mixY = data.mixY;
          constraint.mixScaleX = data.mixScaleX;
          constraint.mixScaleY = data.mixScaleY;
          constraint.mixShearY = data.mixShearY;
          return;
        case MixBlend.first:
          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (data.mixY - constraint.mixY) * alpha;
          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    let scaleX;
    let scaleY;
    let shearY;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 7 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 7 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 7 + 3
          /* Y*/
        ] - y) * t;
        scaleX += (frames[
          i + 7 + 4
          /* SCALEX*/
        ] - scaleX) * t;
        scaleY += (frames[
          i + 7 + 5
          /* SCALEY*/
        ] - scaleY) * t;
        shearY += (frames[
          i + 7 + 6
          /* SHEARY*/
        ] - shearY) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        scaleX = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        scaleY = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        shearY = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
    }
  }
};
var PathConstraintPositionTimeline3 = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    const position = this.getCurveValue(time);
    if (blend == MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
var PathConstraintSpacingTimeline3 = class extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    const spacing = this.getCurveValue(time);
    if (blend == MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
};
var PathConstraintMixTimeline3 = class extends CurveTimeline3 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  getFrameEntries() {
    return 4;
  }
  setFrame(frame, time, mixRotate, mixX, mixY) {
    const frames = this.frames;
    frame <<= 2;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          constraint.mixRotate = constraint.data.mixRotate;
          constraint.mixX = constraint.data.mixX;
          constraint.mixY = constraint.data.mixY;
          return;
        case MixBlend.first:
          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 4 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 4 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 4 + 3
          /* Y*/
        ] - y) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (blend == MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
    }
  }
};
var _SequenceTimeline = class extends Timeline {
  constructor(frameCount, slotIndex, attachment) {
    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);
    this.slotIndex = slotIndex;
    this.attachment = attachment;
  }
  getFrameEntries() {
    return _SequenceTimeline.ENTRIES;
  }
  getSlotIndex() {
    return this.slotIndex;
  }
  getAttachment() {
    return this.attachment;
  }
  /** Sets the time, mode, index, and frame time for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time Seconds between frames. */
  setFrame(frame, time, mode, index, delay) {
    const frames = this.frames;
    frame *= _SequenceTimeline.ENTRIES;
    frames[frame] = time;
    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;
    frames[frame + _SequenceTimeline.DELAY] = delay;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.attachment;
    const attachment = this.attachment;
    if (slotAttachment != attachment) {
      if (!(slotAttachment instanceof VertexAttachment3) || slotAttachment.timelineAttachment != attachment)
        return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        slot.sequenceIndex = -1;
      return;
    }
    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);
    const before = frames[i];
    const modeAndIndex = frames[i + _SequenceTimeline.MODE];
    const delay = frames[i + _SequenceTimeline.DELAY];
    if (!this.attachment.sequence)
      return;
    let index = modeAndIndex >> 4;
    const count = this.attachment.sequence.regions.length;
    const mode = SequenceModeValues[modeAndIndex & 15];
    if (mode != SequenceMode.hold) {
      index += (time - before) / delay + 1e-5 | 0;
      switch (mode) {
        case SequenceMode.once:
          index = Math.min(count - 1, index);
          break;
        case SequenceMode.loop:
          index %= count;
          break;
        case SequenceMode.pingpong: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : index % n;
          if (index >= count)
            index = n - index;
          break;
        }
        case SequenceMode.onceReverse:
          index = Math.max(count - 1 - index, 0);
          break;
        case SequenceMode.loopReverse:
          index = count - 1 - index % count;
          break;
        case SequenceMode.pingpongReverse: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : (index + count - 1) % n;
          if (index >= count)
            index = n - index;
        }
      }
    }
    slot.sequenceIndex = index;
  }
};
var SequenceTimeline = _SequenceTimeline;
SequenceTimeline.ENTRIES = 3;
SequenceTimeline.MODE = 1;
SequenceTimeline.DELAY = 2;

// node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs
var _AnimationState3 = class {
  constructor(data) {
    this.tracks = new Array();
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue3(this);
    this.propertyIDs = new StringSet();
    this.animationsChanged = false;
    this.trackEntryPool = new Pool(() => new TrackEntry3());
    this.data = data;
  }
  static emptyAnimation() {
    return _AnimationState3._emptyAnimation;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
        tracks[i] = null;
        this.queue.end(current);
        this.clearNext(current);
        continue;
      }
      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from)
          from.mixingTo = null;
        while (from) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (!from)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && !current.next)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      let applyTime = animationTime;
      let applyEvents = events;
      if (current.reverse) {
        applyTime = current.animation.duration - applyTime;
        applyEvents = null;
      }
      const timelines = current.animation.timelines;
      const timelineCount = timelines.length;
      if (i == 0 && mix == 1 || blend == MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof AttachmentTimeline3)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const shortestRotation = current.shortestRotation;
        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          current.timelinesRotation.length = timelineCount << 1;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;
          if (!shortestRotation && timeline instanceof RotateTimeline3) {
            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof AttachmentTimeline3) {
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          } else {
            Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == MixBlend.first)
        blend = MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != MixBlend.first)
        blend = from.mixBlend;
    }
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const timelines = from.animation.timelines;
    const timelineCount = timelines.length;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    let applyTime = animationTime;
    let events = null;
    if (from.reverse)
      applyTime = from.animation.duration - applyTime;
    else if (mix < from.eventThreshold)
      events = this.events;
    if (blend == MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const shortestRotation = from.shortestRotation;
      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
      if (firstFrame)
        from.timelinesRotation.length = timelineCount << 1;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case SUBSEQUENT:
            if (!drawOrder && timeline instanceof DrawOrderTimeline3)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaMix;
            break;
          case HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case HOLD_FIRST:
            timelineBlend = MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (!shortestRotation && timeline instanceof RotateTimeline3)
          this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof AttachmentTimeline3)
          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
        else {
          Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof DrawOrderTimeline3 && timelineBlend == MixBlend.setup)
            direction = MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    if (time < timeline.frames[0]) {
      if (blend == MixBlend.setup || blend == MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else
      this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);
      return;
    }
    const bone = skeleton.bones[timeline.boneIndex];
    if (!bone.active)
      return;
    const frames = timeline.frames;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;
      r2 = bone.data.rotation + timeline.getCurveValue(time);
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    bone.rotation = r1 + total * alpha;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, event);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (!current)
      return;
    this.queue.end(current);
    this.clearNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (!from)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    current.previous = null;
    if (from) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * See {@link #setAnimationWith()}. */
  setAnimation(trackIndex, animationName, loop = false) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop = false) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.clearNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.clearNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop = false, delay = 0) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last) {
      while (last.next)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (!last) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      entry.previous = last;
      if (delay <= 0)
        delay += last.getTrackComplete() - entry.mixDuration;
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration = 0) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState3.emptyAnimation(), false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {
    const entry = this.addAnimationWith(trackIndex, _AnimationState3.emptyAnimation(), false, delay);
    if (delay <= 0)
      entry.delay += entry.mixDuration - mixDuration;
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration = 0) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.reset();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.reverse = false;
    entry.shortestRotation = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
    entry.interruptAlpha = 1;
    entry.totalAlpha = 0;
    entry.mixBlend = MixBlend.replace;
    return entry;
  }
  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */
  clearNext(entry) {
    let next = entry.next;
    while (next) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      let entry = tracks[i];
      if (!entry)
        continue;
      while (entry.mixingFrom)
        entry = entry.mixingFrom;
      do {
        if (!entry.mixingTo || entry.mixBlend != MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = entry.timelineMode;
    timelineMode.length = timelinesCount;
    const timelineHoldMix = entry.timelineHoldMix;
    timelineHoldMix.length = 0;
    const propertyIDs = this.propertyIDs;
    if (to && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++)
        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const ids = timeline.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i] = SUBSEQUENT;
        else if (!to || timeline instanceof AttachmentTimeline3 || timeline instanceof DrawOrderTimeline3 || timeline instanceof EventTimeline3 || !to.animation.hasTimeline(ids)) {
          timelineMode[i] = FIRST;
        } else {
          for (let next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = HOLD_MIX;
              timelineHoldMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (!listener)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState3.deprecatedWarning1) {
      _AnimationState3.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState3.deprecatedWarning2) {
      _AnimationState3.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState3.deprecatedWarning3) {
      _AnimationState3.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
var AnimationState3 = _AnimationState3;
AnimationState3._emptyAnimation = new Animation3("<empty>", [], 0);
AnimationState3.deprecatedWarning1 = false;
AnimationState3.deprecatedWarning2 = false;
AnimationState3.deprecatedWarning3 = false;
var _TrackEntry3 = class {
  constructor() {
    this.animation = null;
    this.previous = null;
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.listener = null;
    this.trackIndex = 0;
    this.loop = false;
    this.holdPrevious = false;
    this.reverse = false;
    this.shortestRotation = false;
    this.eventThreshold = 0;
    this.attachmentThreshold = 0;
    this.drawOrderThreshold = 0;
    this.animationStart = 0;
    this.animationEnd = 0;
    this.animationLast = 0;
    this.nextAnimationLast = 0;
    this.delay = 0;
    this.trackTime = 0;
    this.trackLast = 0;
    this.nextTrackLast = 0;
    this.trackEnd = 0;
    this.timeScale = 0;
    this.alpha = 0;
    this.mixTime = 0;
    this.mixDuration = 0;
    this.interruptAlpha = 0;
    this.totalAlpha = 0;
    this.mixBlend = MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.previous = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  getTrackComplete() {
    const duration = this.animationEnd - this.animationStart;
    if (duration != 0) {
      if (this.loop)
        return duration * (1 + (this.trackTime / duration | 0));
      if (this.trackTime < duration)
        return duration;
    }
    return this.trackTime;
  }
  get time() {
    if (!_TrackEntry3.deprecatedWarning1) {
      _TrackEntry3.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry3.deprecatedWarning1) {
      _TrackEntry3.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry3.deprecatedWarning2) {
      _TrackEntry3.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry3.deprecatedWarning2) {
      _TrackEntry3.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
var TrackEntry3 = _TrackEntry3;
TrackEntry3.deprecatedWarning1 = false;
TrackEntry3.deprecatedWarning2 = false;
var EventQueue3 = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType3.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType3.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType3.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType3.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType3.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType3.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType3.start:
          if (entry.listener && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.start)
              listener.start(entry);
          }
          break;
        case EventType3.interrupt:
          if (entry.listener && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.interrupt)
              listener.interrupt(entry);
          }
          break;
        case EventType3.end:
          if (entry.listener && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.end)
              listener.end(entry);
          }
        case EventType3.dispose:
          if (entry.listener && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.dispose)
              listener.dispose(entry);
          }
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType3.complete:
          if (entry.listener && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.complete)
              listener.complete(entry);
          }
          break;
        case EventType3.event:
          const event = objects[i++ + 2];
          if (entry.listener && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.event)
              listener.event(entry, event);
          }
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
var EventType3 = ((EventType22) => {
  EventType22[EventType22["start"] = 0] = "start";
  EventType22[EventType22["interrupt"] = 1] = "interrupt";
  EventType22[EventType22["end"] = 2] = "end";
  EventType22[EventType22["dispose"] = 3] = "dispose";
  EventType22[EventType22["complete"] = 4] = "complete";
  EventType22[EventType22["event"] = 5] = "event";
  return EventType22;
})(EventType3 || {});
var AnimationStateAdapter3 = class {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
};
var SUBSEQUENT = 0;
var FIRST = 1;
var HOLD_SUBSEQUENT = 2;
var HOLD_FIRST = 3;
var HOLD_MIX = 4;
var SETUP = 1;
var CURRENT = 2;

// node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs
var AnimationStateData3 = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (!skeletonData)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  /** Sets a mix duration by animation name.
   *
   * See {@link #setMixWith()}. */
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (!from)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (!to)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  /** Sets the mix duration when changing from the specified animation to the other.
   *
   * See {@link TrackEntry#mixDuration}. */
  setMixWith(from, to, duration) {
    if (!from)
      throw new Error("from cannot be null.");
    if (!to)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if
   * no mix duration has been set. */
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs
var AtlasAttachmentLoader3 = class {
  constructor(atlas) {
    this.atlas = atlas;
  }
  loadSequence(name, basePath, sequence) {
    const regions = sequence.regions;
    for (let i = 0, n = regions.length; i < n; i++) {
      const path = sequence.getPath(basePath, i);
      const region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);
      regions[i] = region;
      regions[i].renderObject = regions[i];
    }
  }
  newRegionAttachment(skin, name, path, sequence) {
    const attachment = new RegionAttachment3(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newMeshAttachment(skin, name, path, sequence) {
    const attachment = new MeshAttachment3(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newBoundingBoxAttachment(skin, name) {
    return new BoundingBoxAttachment3(name);
  }
  newPathAttachment(skin, name) {
    return new PathAttachment3(name);
  }
  newPointAttachment(skin, name) {
    return new PointAttachment3(name);
  }
  newClippingAttachment(skin, name) {
    return new ClippingAttachment3(name);
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs
var Bone3 = class {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    this.matrix = new Matrix();
    this.parent = null;
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.sorted = false;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the
   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */
  isActive() {
    return this.active;
  }
  /** Computes the world transform using the parent bone and this bone's local applied transform. */
  update() {
    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform.
   *
   * See {@link #updateWorldTransformWith()}. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
   * specified local transform. Child bones are not updated.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = settings2.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (!parent) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = MathUtils.cosDeg(rotationY) * scaleY;
        const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = MathUtils.cosDeg(rotationY) * scaleY;
        m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= sx;
          pc /= sy;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = MathUtils.cosDeg(rx) * scaleX;
        const lb = MathUtils.cosDeg(ry) * scaleY;
        const lc = MathUtils.sinDeg(rx) * scaleX;
        const ld = MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case TransformMode.NoScale:
      case TransformMode.NoScaleOrReflection: {
        const cos = MathUtils.cosDeg(rotation);
        const sin = MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = MathUtils.cosDeg(shearX) * scaleX;
        const lb = MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = MathUtils.sinDeg(shearX) * scaleX;
        const ld = MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  /** Sets this bone's local transform to the setup pose. */
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;
  }
  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;
  }
  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.b * m.b);
  }
  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.c * m.c + m.d * m.d);
  }
  /** Computes the applied transform values from the world transform.
   *
   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so
   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other
   * constraints).
   *
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */
  updateAppliedTransform() {
    const parent = this.parent;
    const m = this.matrix;
    if (!parent) {
      this.ax = m.tx - this.skeleton.x;
      this.ay = m.ty - this.skeleton.y;
      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;
    }
  }
  /** Transforms a point from world coordinates to the bone's local coordinates. */
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  /** Transforms a point from the bone's local coordinates to world coordinates. */
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  /** Transforms a world rotation to a local rotation. */
  worldToLocalRotation(worldRotation) {
    const sin = MathUtils.sinDeg(worldRotation);
    const cos = MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;
  }
  /** Transforms a local rotation to a world rotation. */
  localToWorldRotation(localRotation) {
    localRotation -= this.rotation - this.shearX;
    const sin = MathUtils.sinDeg(localRotation);
    const cos = MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;
  }
  /** Rotates the world transform the specified amount.
   * <p>
   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will
   * need to be called on any child bones, recursively. */
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = MathUtils.cosDeg(degrees);
    const sin = MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs
var BoneData3 = class {
  constructor(index, name, parent) {
    this.index = 0;
    this.parent = null;
    this.length = 0;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = TransformMode.Normal;
    this.skinRequired = false;
    this.color = new Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs
var ConstraintData2 = class {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs
var Event3 = class {
  constructor(time, data) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.time = 0;
    this.volume = 0;
    this.balance = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs
var EventData3 = class {
  constructor(name) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.audioPath = null;
    this.volume = 0;
    this.balance = 0;
    this.name = name;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs
var IkConstraint3 = class {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    this.softness = 0;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find bone ${data.target.name}`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mix == 0)
      return;
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
        break;
    }
  }
  /** Applies 1 bone IK. The target is specified in the world coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    const p = bone.parent.matrix;
    if (!p)
      throw new Error("IK bone must have parent.");
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    const skelX = bone.skeleton.scaleX;
    const skelY = settings2.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;
    switch (bone.data.transformMode) {
      case TransformMode.OnlyTranslation:
        tx = targetX - bone.worldX;
        ty = targetY - bone.worldY;
        if (settings2.yDown) {
          ty = -ty;
        }
        break;
      case TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / skelX;
        const sc = pc / skelY;
        pb = -sc * s * skelX;
        pd = sa * s * skelY;
        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case TransformMode.NoScale:
        case TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Applies 2 bone IK. The target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let psy = parent.ascaleY;
    let sx = psx;
    let sy = psy;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u || stretch) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    if (!pp)
      throw new Error("IK parent must itself have a parent.");
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) * 0.5;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a2 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a2 = 0;
          if (stretch) {
            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a;
            if (uniform)
              sy *= a;
          }
        } else
          a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs
var IkConstraintData3 = class extends ConstraintData2 {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this._target = null;
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.softness = 0;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs
var PathConstraintData3 = class extends ConstraintData2 {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this._target = null;
    this.positionMode = PositionMode.Fixed;
    this.spacingMode = SpacingMode3.Fixed;
    this.rotateMode = RotateMode.Chain;
    this.offsetRotation = 0;
    this.position = 0;
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
  }
  set target(slotData) {
    this._target = slotData;
  }
  get target() {
    if (!this._target)
      throw new Error("SlotData not set.");
    else
      return this._target;
  }
};
var SpacingMode3 = ((SpacingMode22) => {
  SpacingMode22[SpacingMode22["Length"] = 0] = "Length";
  SpacingMode22[SpacingMode22["Fixed"] = 1] = "Fixed";
  SpacingMode22[SpacingMode22["Percent"] = 2] = "Percent";
  SpacingMode22[SpacingMode22["Proportional"] = 3] = "Proportional";
  return SpacingMode22;
})(SpacingMode3 || {});

// node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs
var _PathConstraint3 = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findSlot(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}`);
    this.target = target;
    this.position = data.position;
    this.spacing = data.spacing;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
  }
  isActive() {
    return this.active;
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof PathAttachment3))
      return;
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    if (mixRotate == 0 && mixX == 0 && mixY == 0)
      return;
    const data = this.data;
    const tangents = data.rotateMode == RotateMode.Tangent;
    const scale = data.rotateMode == RotateMode.ChainScale;
    const bones = this.bones;
    const boneCount = bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const spaces = Utils.setArraySize(this.spaces, spacesCount);
    const lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];
    const spacing = this.spacing;
    switch (data.spacingMode) {
      case SpacingMode3.Percent:
        if (scale) {
          for (let i = 0, n = spacesCount - 1; i < n; i++) {
            const bone = bones[i];
            const setupLength = bone.data.length;
            if (setupLength < _PathConstraint3.epsilon)
              lengths[i] = 0;
            else {
              const x = setupLength * bone.matrix.a;
              const y = setupLength * bone.matrix.b;
              lengths[i] = Math.sqrt(x * x + y * y);
            }
          }
        }
        Utils.arrayFill(spaces, 1, spacesCount, spacing);
        break;
      case SpacingMode3.Proportional:
        let sum = 0;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint3.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = length;
            sum += length;
          }
        }
        if (sum > 0) {
          sum = spacesCount / sum * spacing;
          for (let i = 1; i < spacesCount; i++)
            spaces[i] *= sum;
        }
        break;
      default:
        const lengthSpacing = data.spacingMode == SpacingMode3.Length;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint3.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
          }
        }
    }
    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = data.rotateMode == RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * mixX;
      mat.ty += (boneY - mat.ty) * mixY;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (mixRotate > 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          r = positions[p - 1];
        else if (spaces[i + 1] == 0)
          r = positions[p + 2];
        else
          r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;
          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;
        } else {
          r += offsetRotation;
        }
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.updateAppliedTransform();
    }
  }
  computeWorldPositions(path, spacesCount, tangents) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = this.world;
    const closed2 = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint3.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed2 ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (this.data.positionMode == PositionMode.Percent)
        position *= pathLength2;
      let multiplier2;
      switch (this.data.spacingMode) {
        case SpacingMode3.Percent:
          multiplier2 = pathLength2;
          break;
        case SpacingMode3.Proportional:
          multiplier2 = pathLength2 / spacesCount;
          break;
        default:
          multiplier2 = 1;
      }
      world = Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i] * multiplier2;
        position += space;
        let p = position;
        if (closed2) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint3.BEFORE) {
            prevCurve = _PathConstraint3.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint3.AFTER) {
            prevCurve = _PathConstraint3.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed2 && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed2) {
      verticesLength += 2;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (this.data.positionMode == PositionMode.Percent)
      position *= pathLength;
    let multiplier;
    switch (this.data.spacingMode) {
      case SpacingMode3.Percent:
        multiplier = pathLength;
        break;
      case SpacingMode3.Proportional:
        multiplier = pathLength / spacesCount;
        break;
      default:
        multiplier = 1;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i] * multiplier;
      position += space;
      let p = position;
      if (closed2) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p)) {
      out[o] = x1;
      out[o + 1] = y1;
      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      return;
    }
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents) {
      if (p < 1e-3)
        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      else
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    }
  }
};
var PathConstraint3 = _PathConstraint3;
PathConstraint3.NONE = -1;
PathConstraint3.BEFORE = -2;
PathConstraint3.AFTER = -3;
PathConstraint3.epsilon = 1e-5;

// node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs
var Slot3 = class {
  constructor(data, bone) {
    this.darkColor = null;
    this.attachment = null;
    this.attachmentState = 0;
    this.sequenceIndex = -1;
    this.deform = new Array();
    if (!data)
      throw new Error("data cannot be null.");
    if (!bone)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new Color();
    this.darkColor = !data.darkColor ? null : new Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** The skeleton this slot belongs to. */
  getSkeleton() {
    return this.bone.skeleton;
  }
  /** The current attachment for the slot, or null if the slot has no attachment. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.
   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the
   * specified attachment. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    if (!(attachment instanceof VertexAttachment3) || !(this.attachment instanceof VertexAttachment3) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
      this.deform.length = 0;
    }
    this.attachment = attachment;
    this.sequenceIndex = -1;
  }
  /** Sets this slot to the setup pose. */
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor)
      this.darkColor.setFromColor(this.data.darkColor);
    if (!this.data.attachmentName)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs
var TransformConstraint3 = class {
  constructor(data, skeleton) {
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    this.temp = new Vector2();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
    this.mixScaleX = data.mixScaleX;
    this.mixScaleY = data.mixScaleY;
    this.mixShearY = data.mixShearY;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}.`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
      return;
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * mixX;
        mat.ty += (temp.y - mat.ty) * mixY;
      }
      if (mixScaleX != 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        if (s != 0)
          s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        if (s != 0)
          s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r = by + (r + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyRelativeWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * mixX;
        mat.ty += temp.y * mixY;
      }
      if (mixScaleX != 0) {
        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > MathUtils.PI)
          r -= MathUtils.PI2;
        else if (r < -MathUtils.PI)
          r += MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyAbsoluteLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let rotation = bone.arotation;
      if (mixRotate != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * mixRotate;
      }
      let x = bone.ax;
      let y = bone.ay;
      x += (target.ax - x + this.data.offsetX) * mixX;
      y += (target.ay - y + this.data.offsetY) * mixY;
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (mixScaleX != 0 && scaleX != 0)
        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
      if (mixScaleY != 0 && scaleY != 0)
        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
      let shearY = bone.ashearY;
      if (mixShearY != 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        shearY += r * mixShearY;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;
      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;
      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs
var _Skeleton3 = class {
  constructor(data) {
    this._updateCache = new Array();
    this.skin = null;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (!boneData.parent)
        bone = new Bone3(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new Bone3(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new Slot3(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new IkConstraint3(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new TransformConstraint3(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new PathConstraint3(pathConstraintData, this));
    }
    this.color = new Color(1, 1, 1, 1);
    this.updateCache();
  }
  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,
   * constraints, or weighted path attachments are added or removed. */
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length == 1) {
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
    } else {
      const child = constrained[constrained.length - 1];
      this.sortBone(child);
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      child.sorted = true;
    }
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof PathAttachment3)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        this.sortBone(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof PathAttachment3))
      return;
    const pathBones = attachment.bones;
    if (!pathBones)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      for (let i = 0, n = pathBones.length; i < n; ) {
        let nn = pathBones[i++];
        nn += i;
        while (i < nn)
          this.sortBone(bones[pathBones[i++]]);
      }
    }
  }
  sortBone(bone) {
    if (!bone)
      return;
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies all constraints.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransform() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  updateWorldTransformWith(parent) {
    const rootBone = this.getRootBone();
    const pa = parent.matrix.a;
    const pb = parent.matrix.c;
    const pc = parent.matrix.b;
    const pd = parent.matrix.d;
    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;
    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;
    const rotationY = rootBone.rotation + 90 + rootBone.shearY;
    const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;
    const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;
    const sx = this.scaleX;
    const sy = settings2.yDown ? -this.scaleY : this.scaleY;
    rootBone.matrix.a = (pa * la + pb * lc) * sx;
    rootBone.matrix.c = (pa * lb + pb * ld) * sx;
    rootBone.matrix.b = (pc * la + pd * lc) * sy;
    rootBone.matrix.d = (pc * lb + pd * ld) * sy;
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++) {
      const updatable = updateCache[i];
      if (updatable != rootBone)
        updatable.update();
    }
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
      constraint.mixScaleX = data.mixScaleX;
      constraint.mixScaleY = data.mixScaleY;
      constraint.mixShearY = data.mixShearY;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
    }
  }
  /** Sets the slots and draw order to their setup pose values. */
  setSlotsToSetupPose() {
    const slots = this.slots;
    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @returns May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * repeatedly.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   *
   * See {@link #setSkin()}. */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (!skin)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the
   * skin is changed, {@link #updateCache()} is called.
   *
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   *
   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the
   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin) {
      if (this.skin)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment
   * name.
   *
   * See {@link #getAttachment()}.
   * @returns May be null. */
  getAttachmentByName(slotName, attachmentName) {
    const slot = this.data.findSlot(slotName);
    if (!slot)
      throw new Error(`Can't find slot with name ${slotName}`);
    return this.getAttachment(slot.index, attachmentName);
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and
   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.
   *
   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.
   * @returns May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (!attachmentName)
      throw new Error("attachmentName cannot be null.");
    if (this.skin) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment)
        return attachment;
    }
    if (this.data.defaultSkin)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with
   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.
   * @param attachmentName May be null to clear the slot's attachment. */
  setAttachment(slotName, attachmentName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName) {
          attachment = this.getAttachment(i, attachmentName);
          if (!attachment)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it repeatedly.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.
   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */
  getBoundsRect() {
    const offset = new Vector2();
    const size = new Vector2();
    this.getBounds(offset, size);
    return { x: offset.x, y: offset.y, width: size.x, height: size.y };
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size An output value, the width and height of the AABB.
   * @param temp Working memory to temporarily store attachments' computed world vertices. */
  getBounds(offset, size, temp = new Array(2)) {
    if (!offset)
      throw new Error("offset cannot be null.");
    if (!size)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof RegionAttachment3) {
        verticesLength = 8;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot, vertices, 0, 2);
      } else if (attachment instanceof MeshAttachment3) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton3.deprecatedWarning1) {
      _Skeleton3.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton3.deprecatedWarning1) {
      _Skeleton3.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
var Skeleton3 = _Skeleton3;
Skeleton3.deprecatedWarning1 = false;

// node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs
var SkeletonData3 = class {
  constructor() {
    this.name = null;
    this.bones = new Array();
    this.slots = new Array();
    this.skins = new Array();
    this.defaultSkin = null;
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.version = null;
    this.hash = null;
    this.fps = 0;
    this.imagesPath = null;
    this.audioPath = null;
  }
  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSkin(skinName) {
    if (!skinName)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findEvent(eventDataName) {
    if (!eventDataName)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to
   * call it multiple times.
   * @returns May be null. */
  findAnimation(animationName) {
    if (!animationName)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it multiple times.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs
var SlotData3 = class {
  constructor(index, name, boneData) {
    this.index = 0;
    this.color = new Color(1, 1, 1, 1);
    this.darkColor = null;
    this.attachmentName = null;
    this.blendMode = BLEND_MODES.NORMAL;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    if (!boneData)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs
var TransformConstraintData3 = class extends ConstraintData2 {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this._target = null;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs
var SkinEntry2 = class {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
};
var Skin3 = class {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  /** Adds an attachment to the skin for the specified slot index and name. */
  setAttachment(slotIndex, name, attachment) {
    if (!attachment)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not
   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (!attachment.attachment)
        continue;
      if (attachment.attachment instanceof MeshAttachment3) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** Returns the attachment for the specified slot index and name, or null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Removes the attachment in the skin for the specified slot index and name, if any. */
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      delete dictionary[name];
  }
  /** Returns all attachments in this skin. */
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry2(i, name, attachment));
        }
      }
    }
    return entries;
  }
  /** Returns all attachments in this skin for the specified slot index. */
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry2(slotIndex, name, attachment));
      }
    }
  }
  /** Clears all attachments, bones, and constraints. */
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBinary.mjs
var SkeletonBinary2 = class {
  constructor(attachmentLoader) {
    this.ver40 = false;
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new SkeletonData3();
    skeletonData.name = "";
    const input = new BinaryInput(binary);
    const lowHash = input.readInt32();
    const highHash = input.readInt32();
    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
    skeletonData.version = input.readString();
    const verShort = skeletonData.version.substr(0, 3);
    if (verShort !== "4.0" && verShort !== "4.1") {
      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;
      console.error(error);
    }
    this.ver40 = verShort === "4.0";
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const str = input.readString();
      if (!str)
        throw new Error("String in string table must not be null.");
      input.strings.push(str);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Bone name must not be null.");
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new BoneData3(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = input.readInt(true);
      data.skinRequired = input.readBoolean();
      if (nonessential)
        Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      if (!slotName)
        throw new Error("Slot name must not be null.");
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new SlotData3(i, slotName, boneData);
      Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        Color.rgb888ToColor(data.darkColor = new Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = input.readInt(true);
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("IK constraint data name must not be null.");
      const data = new IkConstraintData3(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Transform constraint data name must not be null.");
      const data = new TransformConstraintData3(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      data.mixScaleX = input.readFloat();
      data.mixScaleY = input.readFloat();
      data.mixShearY = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Path constraint data name must not be null.");
      const data = new PathConstraintData3(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = input.readInt(true);
      data.spacingMode = input.readInt(true);
      data.rotateMode = input.readInt(true);
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed)
        data.spacing *= scale;
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++) {
        const skin = this.readSkin(input, skeletonData, false, nonessential);
        if (!skin)
          throw new Error("readSkin() should not have returned null.");
        skeletonData.skins[i] = skin;
      }
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error("Not skin found for linked mesh.");
      if (!linkedMesh.parent)
        throw new Error("Linked mesh parent must not be null");
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const eventName = input.readStringRef();
      if (!eventName)
        throw new Error();
      const data = new EventData3(eventName);
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const animationName = input.readString();
      if (!animationName)
        throw new Error("Animatio name must not be null.");
      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
    }
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new Skin3("default");
    } else {
      const skinName = input.readStringRef();
      if (!skinName)
        throw new Error("Skin name must not be null.");
      skin = new Skin3(skinName);
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        if (!name)
          throw new Error("Attachment name must not be null");
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (!name)
      name = attachmentName;
    switch (input.readByte()) {
      case AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        const sequence = this.readSequence(input);
        if (!path)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        Color.rgba8888ToColor(region.color, color);
        region.sequence = sequence;
        if (sequence == null)
          region.updateRegion();
        return region;
      }
      case AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        const sequence = this.readSequence(input);
        let edges = [];
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritTimelines = input.readBoolean();
        const sequence = this.readSequence(input);
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        Color.rgba8888ToColor(mesh.color, color);
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh4(mesh, skinName, slotIndex, parent, inheritTimelines));
        return mesh;
      }
      case AttachmentType.Path: {
        const closed2 = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = closed2;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readSequence(input) {
    if (this.ver40 || !input.readBoolean())
      return null;
    const sequence = new Sequence(input.readInt(true));
    sequence.start = input.readInt(true);
    sequence.digits = input.readInt(true);
    sequence.setupIndex = input.readInt(true);
    return sequence;
  }
  readDeformTimelineType(input) {
    if (this.ver40)
      return ATTACHMENT_DEFORM;
    return input.readByte();
  }
  readVertices(input, vertexCount) {
    const scale = this.scale;
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices2();
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    input.readInt(true);
    const timelines = new Array();
    const scale = this.scale;
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        const frameLast = frameCount - 1;
        switch (timelineType) {
          case SLOT_ATTACHMENT: {
            const timeline = new AttachmentTimeline3(frameCount, slotIndex);
            for (let frame = 0; frame < frameCount; frame++)
              timeline.setFrame(frame, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
              a = a2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA2: {
            const bezierCount = input.readInt(true);
            const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const na = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              a = na;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB2: {
            const bezierCount = input.readInt(true);
            const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_ALPHA: {
            const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);
            let time = input.readFloat();
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);
              }
              time = time2;
              a = a2;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const type = input.readByte();
        const frameCount = input.readInt(true);
        const bezierCount = input.readInt(true);
        switch (type) {
          case BONE_ROTATE:
            timelines.push(readTimeline1(input, new RotateTimeline3(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_TRANSLATE:
            timelines.push(readTimeline2(input, new TranslateTimeline3(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEX:
            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEY:
            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_SCALE:
            timelines.push(readTimeline2(input, new ScaleTimeline3(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEX:
            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEY:
            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEAR:
            timelines.push(readTimeline2(input, new ShearTimeline3(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARX:
            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARY:
            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new IkConstraintTimeline3(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mix = input.readFloat();
      let softness = input.readFloat() * scale;
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mix2 = input.readFloat();
        const softness2 = input.readFloat() * scale;
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);
        }
        time = time2;
        mix = mix2;
        softness = softness2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new TransformConstraintTimeline3(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mixRotate = input.readFloat();
      let mixX = input.readFloat();
      let mixY = input.readFloat();
      let mixScaleX = input.readFloat();
      let mixScaleY = input.readFloat();
      let mixShearY = input.readFloat();
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mixRotate2 = input.readFloat();
        const mixX2 = input.readFloat();
        const mixY2 = input.readFloat();
        const mixScaleX2 = input.readFloat();
        const mixScaleY2 = input.readFloat();
        const mixShearY2 = input.readFloat();
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
        }
        time = time2;
        mixRotate = mixRotate2;
        mixX = mixX2;
        mixY = mixY2;
        mixScaleX = mixScaleX2;
        mixScaleY = mixScaleY2;
        mixShearY = mixShearY2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        switch (input.readByte()) {
          case PATH_POSITION:
            timelines.push(
              readTimeline1(
                input,
                new PathConstraintPositionTimeline3(input.readInt(true), input.readInt(true), index),
                data.positionMode == PositionMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_SPACING:
            timelines.push(
              readTimeline1(
                input,
                new PathConstraintSpacingTimeline3(input.readInt(true), input.readInt(true), index),
                data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed ? scale : 1
              )
            );
            break;
          case PATH_MIX:
            const timeline = new PathConstraintMixTimeline3(input.readInt(true), input.readInt(true), index);
            let time = input.readFloat();
            let mixRotate = input.readFloat();
            let mixX = input.readFloat();
            let mixY = input.readFloat();
            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const mixRotate2 = input.readFloat();
              const mixX2 = input.readFloat();
              const mixY2 = input.readFloat();
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
            }
            timelines.push(timeline);
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachmentName = input.readStringRef();
          if (!attachmentName)
            throw new Error("attachmentName must not be null.");
          const attachment = skin.getAttachment(slotIndex, attachmentName);
          const timelineType = this.readDeformTimelineType(input);
          const frameCount = input.readInt(true);
          const frameLast = frameCount - 1;
          switch (timelineType) {
            case ATTACHMENT_DEFORM: {
              const vertexAttachment = attachment;
              const weighted = vertexAttachment.bones;
              const vertices = vertexAttachment.vertices;
              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              const bezierCount = input.readInt(true);
              const timeline = new DeformTimeline3(frameCount, bezierCount, slotIndex, vertexAttachment);
              let time = input.readFloat();
              for (let frame = 0, bezier = 0; ; frame++) {
                let deform;
                let end = input.readInt(true);
                if (end == 0)
                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = Utils.newFloatArray(deformLength);
                  const start = input.readInt(true);
                  end += start;
                  if (scale == 1) {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat();
                  } else {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat() * scale;
                  }
                  if (!weighted) {
                    for (let v = 0, vn = deform.length; v < vn; v++)
                      deform[v] += vertices[v];
                  }
                }
                timeline.setFrame(frame, time, deform);
                if (frame == frameLast)
                  break;
                const time2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);
                }
                time = time2;
              }
              timelines.push(timeline);
              break;
            }
            case ATTACHMENT_SEQUENCE: {
              const timeline = new SequenceTimeline(frameCount, slotIndex, attachment);
              for (let frame = 0; frame < frameCount; frame++) {
                const time = input.readFloat();
                const modeAndIndex = input.readInt32();
                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
              }
              timelines.push(timeline);
              break;
            }
          }
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new DrawOrderTimeline3(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new EventTimeline3(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new Event3(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    return new Animation3(name, timelines, duration);
  }
};
SkeletonBinary2.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];
var LinkedMesh4 = class {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
};
var Vertices2 = class {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
};
function readTimeline1(input, timeline, scale) {
  let time = input.readFloat();
  let value = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2(input, timeline, scale) {
  let time = input.readFloat();
  let value1 = input.readFloat() * scale;
  let value2 = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const nvalue1 = input.readFloat() * scale;
    const nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
var BONE_ROTATE = 0;
var BONE_TRANSLATE = 1;
var BONE_TRANSLATEX = 2;
var BONE_TRANSLATEY = 3;
var BONE_SCALE = 4;
var BONE_SCALEX = 5;
var BONE_SCALEY = 6;
var BONE_SHEAR = 7;
var BONE_SHEARX = 8;
var BONE_SHEARY = 9;
var SLOT_ATTACHMENT = 0;
var SLOT_RGBA = 1;
var SLOT_RGB = 2;
var SLOT_RGBA2 = 3;
var SLOT_RGB2 = 4;
var SLOT_ALPHA = 5;
var ATTACHMENT_DEFORM = 0;
var ATTACHMENT_SEQUENCE = 1;
var PATH_POSITION = 0;
var PATH_SPACING = 1;
var PATH_MIX = 2;
var CURVE_STEPPED = 1;
var CURVE_BEZIER = 2;

// node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBounds.mjs
var SkeletonBounds3 = class extends SkeletonBoundsBase {
};

// node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonJson.mjs
var SkeletonJson3 = class _SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new SkeletonData3();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      const verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new BoneData3(skeletonData.bones.length, boneMap.name, parent);
        data.length = getValue(boneMap, "length", 0) * scale;
        data.x = getValue(boneMap, "x", 0) * scale;
        data.y = getValue(boneMap, "y", 0) * scale;
        data.rotation = getValue(boneMap, "rotation", 0);
        data.scaleX = getValue(boneMap, "scaleX", 1);
        data.scaleY = getValue(boneMap, "scaleY", 1);
        data.shearX = getValue(boneMap, "shearX", 0);
        data.shearY = getValue(boneMap, "shearY", 0);
        data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, "transform", "Normal"));
        data.skinRequired = getValue(boneMap, "skin", false);
        const color = getValue(boneMap, "color", null);
        if (color)
          data.color.setFromString(color);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const boneData = skeletonData.findBone(slotMap.bone);
        if (!boneData)
          throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);
        const data = new SlotData3(skeletonData.slots.length, slotMap.name, boneData);
        const color = getValue(slotMap, "color", null);
        if (color)
          data.color.setFromString(color);
        const dark = getValue(slotMap, "dark", null);
        if (dark)
          data.darkColor = Color.fromString(dark);
        data.attachmentName = getValue(slotMap, "attachment", null);
        data.blendMode = _SkeletonJson.blendModeFromString(getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new IkConstraintData3(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        data.target = skeletonData.findBone(constraintMap.target);
        data.mix = getValue(constraintMap, "mix", 1);
        data.softness = getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = getValue(constraintMap, "compress", false);
        data.stretch = getValue(constraintMap, "stretch", false);
        data.uniform = getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new TransformConstraintData3(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findBone(targetName);
        if (!target)
          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);
        data.target = target;
        data.local = getValue(constraintMap, "local", false);
        data.relative = getValue(constraintMap, "relative", false);
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.offsetX = getValue(constraintMap, "x", 0) * scale;
        data.offsetY = getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = getValue(constraintMap, "shearY", 0);
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
        data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
        data.mixShearY = getValue(constraintMap, "mixShearY", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new PathConstraintData3(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findSlot(targetName);
        if (!target)
          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);
        data.target = target;
        data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, "positionMode", "Percent"));
        data.spacingMode = Utils.enumValue(SpacingMode3, getValue(constraintMap, "spacingMode", "Length"));
        data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.position = getValue(constraintMap, "position", 0);
        if (data.positionMode == PositionMode.Fixed)
          data.position *= scale;
        data.spacing = getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == SpacingMode3.Length || data.spacingMode == SpacingMode3.Fixed)
          data.spacing *= scale;
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new Skin3(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const boneName = skinMap.bones[ii];
            const bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraintName = skinMap.ik[ii];
            const constraint = skeletonData.findIkConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraintName = skinMap.transform[ii];
            const constraint = skeletonData.findTransformConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraintName = skinMap.path[ii];
            const constraint = skeletonData.findPathConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new EventData3(eventName);
        data.intValue = getValue(eventMap, "int", 0);
        data.floatValue = getValue(eventMap, "float", 0);
        data.stringValue = getValue(eventMap, "string", "");
        data.audioPath = getValue(eventMap, "audio", null);
        if (data.audioPath) {
          data.volume = getValue(eventMap, "volume", 1);
          data.balance = getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = getValue(map, "name", name);
    switch (getValue(map, "type", "region")) {
      case "region": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = getValue(map, "x", 0) * scale;
        region.y = getValue(map, "y", 0) * scale;
        region.scaleX = getValue(map, "scaleX", 1);
        region.scaleY = getValue(map, "scaleY", 1);
        region.rotation = getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        region.sequence = sequence;
        const color = getValue(map, "color", null);
        if (color)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        const color = getValue(map, "color", null);
        if (color)
          mesh.color.setFromString(color);
        mesh.width = getValue(map, "width", 0) * scale;
        mesh.height = getValue(map, "height", 0) * scale;
        mesh.sequence = sequence;
        const parent = getValue(map, "parent", null);
        if (parent) {
          this.linkedMeshes.push(new LinkedMesh5(mesh, getValue(map, "skin", null), slotIndex, parent, getValue(map, "timelines", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = getValue(map, "edges", null);
        mesh.hullLength = getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = getValue(map, "closed", false);
        path.constantSpeed = getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = getValue(map, "color", null);
        if (color)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = getValue(map, "x", 0) * scale;
        point.y = getValue(map, "y", 0) * scale;
        point.rotation = getValue(map, "rotation", 0);
        const color = getValue(map, "color", null);
        if (color)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        const end = getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readSequence(map) {
    if (map == null)
      return null;
    const sequence = new Sequence(getValue(map, "count", 0));
    sequence.start = getValue(map, "start", 1);
    sequence.digits = getValue(map, "digits", 0);
    sequence.setupIndex = getValue(map, "setup", 0);
    return sequence;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slot = skeletonData.findSlot(slotName);
        if (!slot)
          throw new Error(`Slot not found: ${slotName}`);
        const slotIndex = slot.index;
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (!timelineMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName == "attachment") {
            const timeline = new AttachmentTimeline3(frames, slotIndex);
            for (let frame = 0; frame < frames; frame++) {
              const keyMap = timelineMap[frame];
              timeline.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
            }
            timelines.push(timeline);
          } else if (timelineName == "rgba") {
            const timeline = new RGBATimeline(frames, frames << 2, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb") {
            const timeline = new RGBTimeline(frames, frames * 3, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "alpha") {
            timelines.push(readTimeline12(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));
          } else if (timelineName == "rgba2") {
            const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = Color.fromString(keyMap.light);
            let color2 = Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = Color.fromString(nextMap.light);
              const newColor2 = Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb2") {
            const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = Color.fromString(keyMap.light);
            let color2 = Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = Color.fromString(nextMap.light);
              const newColor2 = Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const bone = skeletonData.findBone(boneName);
        if (!bone)
          throw new Error(`Bone not found: ${boneName}`);
        const boneIndex = bone.index;
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          const frames = timelineMap.length;
          if (frames == 0)
            continue;
          if (timelineName === "rotate") {
            timelines.push(readTimeline12(timelineMap, new RotateTimeline3(frames, frames, boneIndex), 0, 1));
          } else if (timelineName === "translate") {
            const timeline = new TranslateTimeline3(frames, frames << 1, boneIndex);
            timelines.push(readTimeline22(timelineMap, timeline, "x", "y", 0, scale));
          } else if (timelineName === "translatex") {
            const timeline = new TranslateXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 0, scale));
          } else if (timelineName === "translatey") {
            const timeline = new TranslateYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 0, scale));
          } else if (timelineName === "scale") {
            const timeline = new ScaleTimeline3(frames, frames << 1, boneIndex);
            timelines.push(readTimeline22(timelineMap, timeline, "x", "y", 1, 1));
          } else if (timelineName === "scalex") {
            const timeline = new ScaleXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 1, 1));
          } else if (timelineName === "scaley") {
            const timeline = new ScaleYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 1, 1));
          } else if (timelineName === "shear") {
            const timeline = new ShearTimeline3(frames, frames << 1, boneIndex);
            timelines.push(readTimeline22(timelineMap, timeline, "x", "y", 0, 1));
          } else if (timelineName === "shearx") {
            const timeline = new ShearXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 0, 1));
          } else if (timelineName === "sheary") {
            const timeline = new ShearYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 0, 1));
          }
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        let keyMap = constraintMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findIkConstraint(constraintName);
        if (!constraint)
          throw new Error(`IK Constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        const timeline = new IkConstraintTimeline3(constraintMap.length, constraintMap.length << 1, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mix = getValue(keyMap, "mix", 1);
        let softness = getValue(keyMap, "softness", 0) * scale;
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(
            frame,
            time,
            mix,
            softness,
            getValue(keyMap, "bendPositive", true) ? 1 : -1,
            getValue(keyMap, "compress", false),
            getValue(keyMap, "stretch", false)
          );
          const nextMap = constraintMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mix2 = getValue(nextMap, "mix", 1);
          const softness2 = getValue(nextMap, "softness", 0) * scale;
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const timelineMap = map.transform[constraintName];
        let keyMap = timelineMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findTransformConstraint(constraintName);
        if (!constraint)
          throw new Error(`Transform constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        const timeline = new TransformConstraintTimeline3(timelineMap.length, timelineMap.length * 6, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mixRotate = getValue(keyMap, "mixRotate", 1);
        let mixX = getValue(keyMap, "mixX", 1);
        let mixY = getValue(keyMap, "mixY", mixX);
        let mixScaleX = getValue(keyMap, "mixScaleX", 1);
        let mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
        const mixShearY = getValue(keyMap, "mixShearY", 1);
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          const nextMap = timelineMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mixRotate2 = getValue(nextMap, "mixRotate", 1);
          const mixX2 = getValue(nextMap, "mixX", 1);
          const mixY2 = getValue(nextMap, "mixY", mixX2);
          const mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
          const mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
          const mixShearY2 = getValue(nextMap, "mixShearY", 1);
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixScaleX = mixScaleX2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const constraint = skeletonData.findPathConstraint(constraintName);
        if (!constraint)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          let keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName === "position") {
            const timeline = new PathConstraintPositionTimeline3(frames, frames, constraintIndex);
            timelines.push(readTimeline12(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));
          } else if (timelineName === "spacing") {
            const timeline = new PathConstraintSpacingTimeline3(frames, frames, constraintIndex);
            timelines.push(
              readTimeline12(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode3.Length || constraint.spacingMode == SpacingMode3.Fixed ? scale : 1)
            );
          } else if (timelineName === "mix") {
            const timeline = new PathConstraintMixTimeline3(frames, frames * 3, constraintIndex);
            let time = getValue(keyMap, "time", 0);
            let mixRotate = getValue(keyMap, "mixRotate", 1);
            let mixX = getValue(keyMap, "mixX", 1);
            let mixY = getValue(keyMap, "mixY", mixX);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const mixRotate2 = getValue(nextMap, "mixRotate", 1);
              const mixX2 = getValue(nextMap, "mixX", 1);
              const mixY2 = getValue(nextMap, "mixY", mixX2);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.deform) {
      map.attachments = {};
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const outMap = map.attachments[deformName] = {};
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const outMap2 = outMap[slotName] = {};
          for (const innerMapName in slotMap) {
            outMap2[innerMapName] = {
              deform: slotMap[innerMapName]
            };
          }
        }
      }
    }
    if (map.attachments) {
      for (const attachmentsName in map.attachments) {
        const attachmentsMap = map.attachments[attachmentsName];
        const skin = skeletonData.findSkin(attachmentsName);
        if (skin == null) {
          if (settings2.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${attachmentsName}`);
          } else {
            continue;
          }
        }
        for (const slotMapName in attachmentsMap) {
          const slotMap = attachmentsMap[slotMapName];
          const slot = skeletonData.findSlot(slotMapName);
          if (!slot)
            throw new Error(`Slot not found: ${slotMapName}`);
          const slotIndex = slot.index;
          for (const attachmentMapName in slotMap) {
            const attachmentMap = slotMap[attachmentMapName];
            const attachment = skin.getAttachment(slotIndex, attachmentMapName);
            for (const timelineMapName in attachmentMap) {
              const timelineMap = attachmentMap[timelineMapName];
              let keyMap = timelineMap[0];
              if (!keyMap)
                continue;
              if (timelineMapName == "deform") {
                const weighted = attachment.bones;
                const vertices = attachment.vertices;
                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                const timeline = new DeformTimeline3(timelineMap.length, timelineMap.length, slotIndex, attachment);
                let time = getValue(keyMap, "time", 0);
                for (let frame = 0, bezier = 0; ; frame++) {
                  let deform;
                  const verticesValue = getValue(keyMap, "vertices", null);
                  if (!verticesValue)
                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = Utils.newFloatArray(deformLength);
                    const start = getValue(keyMap, "offset", 0);
                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                    if (scale != 1) {
                      for (let i = start, n = i + verticesValue.length; i < n; i++)
                        deform[i] *= scale;
                    }
                    if (!weighted) {
                      for (let i = 0; i < deformLength; i++)
                        deform[i] += vertices[i];
                    }
                  }
                  timeline.setFrame(frame, time, deform);
                  const nextMap = timelineMap[frame + 1];
                  if (!nextMap) {
                    timeline.shrink(bezier);
                    break;
                  }
                  const time2 = getValue(nextMap, "time", 0);
                  const curve = keyMap.curve;
                  if (curve)
                    bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);
                  time = time2;
                  keyMap = nextMap;
                }
                timelines.push(timeline);
              } else if (timelineMapName == "sequence") {
                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);
                let lastDelay = 0;
                for (let frame = 0; frame < timelineMap.length; frame++) {
                  const delay = getValue(keyMap, "delay", lastDelay);
                  const time = getValue(keyMap, "time", 0);
                  const mode = SequenceMode[getValue(keyMap, "mode", "hold")];
                  const index = getValue(keyMap, "index", 0);
                  timeline.setFrame(frame, time, mode, index, delay);
                  lastDelay = delay;
                  keyMap = timelineMap[frame + 1];
                }
                timelines.push(timeline);
              }
            }
          }
        }
      }
    }
    if (map.drawOrder) {
      const timeline = new DrawOrderTimeline3(map.drawOrder.length);
      const slotCount = skeletonData.slots.length;
      let frame = 0;
      for (let i = 0; i < map.drawOrder.length; i++, frame++) {
        const drawOrderMap = map.drawOrder[i];
        let drawOrder = null;
        const offsets = getValue(drawOrderMap, "offsets", null);
        if (offsets) {
          drawOrder = Utils.newArray(slotCount, -1);
          const unchanged = Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let ii = 0; ii < offsets.length; ii++) {
            const offsetMap = offsets[ii];
            const slot = skeletonData.findSlot(offsetMap.slot);
            if (!slot)
              throw new Error(`Slot not found: ${slot}`);
            const slotIndex = slot.index;
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
    }
    if (map.events) {
      const timeline = new EventTimeline3(map.events.length);
      let frame = 0;
      for (let i = 0; i < map.events.length; i++, frame++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (!eventData)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new Event3(Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
        event.intValue = getValue(eventMap, "int", eventData.intValue);
        event.floatValue = getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath) {
          event.volume = getValue(eventMap, "volume", 1);
          event.balance = getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frame, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new Animation3(name, timelines, duration));
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return BLEND_MODES.NORMAL;
    if (str == "additive")
      return BLEND_MODES.ADD;
    if (str == "multiply")
      return BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
};
var LinkedMesh5 = class {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
};
function readTimeline12(keys, timeline, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value = getValue(keyMap, "value", defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const value2 = getValue(nextMap, "value", defaultValue) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function readTimeline22(keys, timeline, name1, name2, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value1 = getValue(keyMap, name1, defaultValue) * scale;
  let value2 = getValue(keyMap, name2, defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;
    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;
    const curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame);
    return bezier;
  }
  const i = value << 2;
  const cx1 = curve[i];
  const cy1 = curve[i + 1] * scale;
  const cx2 = curve[i + 2];
  const cy2 = curve[i + 3] * scale;
  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map, property, defaultValue) {
  return map[property] !== void 0 ? map[property] : defaultValue;
}

// node_modules/@pixi-spine/runtime-4.1/lib/Spine.mjs
var Spine3 = class extends SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new Skeleton3(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new AnimationStateData3(spineData);
    this.state = new AnimationState3(this.stateData);
  }
};

// node_modules/@pixi-spine/loader-uni/lib/versions.mjs
var SPINE_VERSION = ((SPINE_VERSION2) => {
  SPINE_VERSION2[SPINE_VERSION2["UNKNOWN"] = 0] = "UNKNOWN";
  SPINE_VERSION2[SPINE_VERSION2["VER37"] = 37] = "VER37";
  SPINE_VERSION2[SPINE_VERSION2["VER38"] = 38] = "VER38";
  SPINE_VERSION2[SPINE_VERSION2["VER40"] = 40] = "VER40";
  SPINE_VERSION2[SPINE_VERSION2["VER41"] = 41] = "VER41";
  return SPINE_VERSION2;
})(SPINE_VERSION || {});
function detectSpineVersion(version) {
  const ver3 = version.substr(0, 3);
  const verNum = Math.floor(Number(ver3) * 10 + 1e-3);
  if (ver3 === "3.7") {
    return 37;
  }
  if (ver3 === "3.8") {
    return 38;
  }
  if (ver3 === "4.0") {
    return 40;
  }
  if (ver3 === "4.1") {
    return 41;
  }
  if (verNum < 37) {
    return 37;
  }
  return 0;
}

// node_modules/@pixi-spine/loader-uni/lib/SpineLoader.mjs
var UniBinaryParser = class {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    let parser = null;
    let version = this.readVersionOldFormat(dataToParse);
    let ver = detectSpineVersion(version);
    if (ver === SPINE_VERSION.VER38) {
      parser = new SkeletonBinary(new AtlasAttachmentLoader(atlas));
    }
    version = this.readVersionNewFormat(dataToParse);
    ver = detectSpineVersion(version);
    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
      parser = new SkeletonBinary2(new AtlasAttachmentLoader3(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
  readVersionOldFormat(dataToParse) {
    const input = new BinaryInput(dataToParse);
    let version;
    try {
      input.readString();
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
  readVersionNewFormat(dataToParse) {
    const input = new BinaryInput(dataToParse);
    input.readInt32();
    input.readInt32();
    let version;
    try {
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
};
var UniJsonParser = class {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    const version = dataToParse.skeleton.spine;
    const ver = detectSpineVersion(version);
    let parser = null;
    if (ver === SPINE_VERSION.VER37) {
      parser = new SkeletonJson2(new AtlasAttachmentLoader2(atlas));
    }
    if (ver === SPINE_VERSION.VER38) {
      parser = new SkeletonJson(new AtlasAttachmentLoader(atlas));
    }
    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
      parser = new SkeletonJson3(new AtlasAttachmentLoader3(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
};
var SpineLoader = class extends SpineLoaderAbstract {
  createBinaryParser() {
    return new UniBinaryParser();
  }
  createJsonParser() {
    return new UniJsonParser();
  }
  parseData(parser, atlas, dataToParse) {
    const parserCast = parser;
    return {
      spineData: parserCast.readSkeletonData(atlas, dataToParse),
      spineAtlas: atlas
    };
  }
};

// node_modules/@pixi-spine/loader-uni/lib/Spine.mjs
var Spine4 = class extends SpineBase {
  createSkeleton(spineData) {
    const ver = detectSpineVersion(spineData.version);
    let spine = null;
    if (ver === SPINE_VERSION.VER37) {
      spine = lib_exports3;
    }
    if (ver === SPINE_VERSION.VER38) {
      spine = lib_exports2;
    }
    if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {
      spine = lib_exports4;
    }
    if (!spine) {
      const error = `Cant detect version of spine model ${spineData.version}`;
      console.error(error);
    }
    this.skeleton = new spine.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new spine.AnimationStateData(spineData);
    this.state = new spine.AnimationState(this.stateData);
  }
};

// node_modules/@pixi-spine/loader-uni/lib/index.mjs
new SpineLoader().installLoader();
export {
  AttachmentType,
  BinaryInput,
  Color,
  DebugUtils,
  IntSet,
  Interpolation,
  MathUtils,
  MixBlend,
  MixDirection,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RotateMode,
  SkeletonBounds3 as SkeletonBounds,
  SkeletonBoundsBase,
  Spine4 as Spine,
  SpineBase,
  SpineDebugRenderer,
  SpineMesh,
  SpineSprite,
  StringSet,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  TimeKeeper,
  TransformMode,
  Utils,
  Vector2,
  WindowedMean,
  filterFromString,
  settings2 as settings,
  wrapFromString
};
//# sourceMappingURL=pixi-spine.js.map
