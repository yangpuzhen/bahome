{
  "version": 3,
  "sources": ["../../@pixi/display/src/Bounds.ts", "../../@pixi/display/src/DisplayObject.ts", "../../@pixi/display/src/Container.ts", "../../@pixi/display/src/settings.ts", "../../@pixi/sprite/src/Sprite.ts", "../../@pixi/mesh/src/MeshBatchUvs.ts", "../../@pixi/mesh/src/Mesh.ts", "../../@pixi/mesh/src/MeshGeometry.ts", "../../@pixi/mesh/lib/shader/mesh.frag.mjs", "../../@pixi/mesh/lib/shader/mesh.vert.mjs", "../../@pixi/mesh/src/MeshMaterial.ts", "../../@pixi/mesh-extras/src/geometry/PlaneGeometry.ts", "../../@pixi/mesh-extras/src/geometry/RopeGeometry.ts", "../../@pixi/mesh-extras/src/SimplePlane.ts", "../../@pixi/mesh-extras/src/NineSlicePlane.ts", "../../@pixi/mesh-extras/src/SimpleMesh.ts", "../../@pixi/mesh-extras/src/SimpleRope.ts", "../../@pixi/graphics/src/const.ts", "../../@pixi/graphics/src/GraphicsData.ts", "../../@pixi/graphics/src/utils/buildCircle.ts", "../../@pixi/graphics/src/utils/buildPoly.ts", "../../@pixi/graphics/src/utils/buildRectangle.ts", "../../@pixi/graphics/src/utils/buildRoundedRectangle.ts", "../../@pixi/graphics/src/utils/ArcUtils.ts", "../../@pixi/graphics/src/utils/BatchPart.ts", "../../@pixi/graphics/src/utils/BezierUtils.ts", "../../@pixi/graphics/src/utils/buildLine.ts", "../../@pixi/graphics/src/utils/QuadraticUtils.ts", "../../@pixi/graphics/src/utils/index.ts", "../../@pixi/graphics/src/GraphicsGeometry.ts", "../../@pixi/graphics/src/styles/FillStyle.ts", "../../@pixi/graphics/src/styles/LineStyle.ts", "../../@pixi/graphics/src/Graphics.ts", "../../@pixi/graphics/src/index.ts"],
  "sourcesContent": ["import { Rectangle } from '@pixi/core';\n\nimport type { IPointData, Matrix, Transform } from '@pixi/core';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n * @memberof PIXI\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX: number;\n\n    /** @default Infinity */\n    public minY: number;\n\n    /** @default -Infinity */\n    public maxX: number;\n\n    /** @default -Infinity */\n    public maxY: number;\n\n    public rect: Rectangle;\n\n    /**\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n     * Updated from outside, thus public modifier.\n     */\n    public updateID: number;\n\n    constructor()\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.rect = null;\n        this.updateID = -1;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** Clears the bounds and resets. */\n    clear(): void\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     * @param rect - Temporary object will be used if AABB is not empty\n     * @returns - A rectangle of the bounds\n     */\n    getRectangle(rect?: Rectangle): Rectangle\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     * @param point - The point to add.\n     */\n    addPoint(point: IPointData): void\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /**\n     * Adds a point, after transformed. This should be inlined when its possible.\n     * @param matrix\n     * @param point\n     */\n    addPointMatrix(matrix: Matrix, point: IPointData): void\n    {\n        const { a, b, c, d, tx, ty } = matrix;\n\n        const x = (a * point.x) + (c * point.y) + tx;\n        const y = (b * point.x) + (d * point.y) + ty;\n\n        this.minX = Math.min(this.minX, x);\n        this.maxX = Math.max(this.maxX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxY = Math.max(this.maxY, y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     * @param vertices - The verts to add.\n     */\n    addQuad(vertices: Float32Array): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     * @param transform - transform to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     * @param matrix - matrix to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     * @param transform - mesh transform\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices.\n     * @param matrix - mesh matrix\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param padX - x padding\n     * @param padY - y padding\n     */\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number,\n        endOffset: number, padX = 0, padY = padX): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other {@link PIXI.Bounds}.\n     * @param bounds - The Bounds to be added\n     */\n    addBounds(bounds: Bounds): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param bounds - The Bounds to be added.\n     * @param mask - TODO\n     */\n    addBoundsMask(bounds: Bounds, mask: Bounds): void\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     * @param bounds - other bounds\n     * @param matrix - multiplicator\n     */\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle.\n     * @param bounds - TODO\n     * @param area - TODO\n     */\n    addBoundsArea(bounds: Bounds, area: Rectangle): void\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    pad(paddingX = 0, paddingY = paddingX): void\n    {\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param padX - padding X\n     * @param padY - padding Y\n     */\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n", "import { DEG_TO_RAD, RAD_TO_DEG, Rectangle, Transform, utils } from '@pixi/core';\nimport { Bounds } from './Bounds';\n\nimport type { Filter, IPointData, MaskData, Matrix, ObservablePoint, Point, Renderer } from '@pixi/core';\nimport type { Container } from './Container';\n\nexport interface IDestroyOptions\n{\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObjectEvents extends GlobalMixins.DisplayObjectEvents\n{\n    added: [container: Container];\n    childAdded: [child: DisplayObject, container: Container, index: number];\n    childRemoved: [child: DisplayObject, container: Container, index: number];\n    destroyed: [];\n    removed: [container: Container];\n}\n\nexport interface DisplayObject\n    extends Omit<GlobalMixins.DisplayObject, keyof utils.EventEmitter<DisplayObjectEvents>>,\n    utils.EventEmitter<DisplayObjectEvents> {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link PIXI.DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link PIXI.Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds()\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * For culling purposes, it is recommended that applications use the [cullable]{@link PIXI.DisplayObject#cullable} property.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends utils.EventEmitter<DisplayObjectEvents>\n{\n    abstract sortDirty: boolean;\n\n    /** The display object container that contains this display object. */\n    public parent: Container;\n\n    /**\n     * The multiplied alpha of the displayObject.\n     * @readonly\n     */\n    public worldAlpha: number;\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     */\n    public transform: Transform;\n\n    /** The opacity of the object. */\n    public alpha: number;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     */\n    public visible: boolean;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     */\n    public renderable: boolean;\n\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     */\n    public cullable: boolean;\n\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     */\n    public cullArea: Rectangle;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     */\n    public filterArea: Rectangle;\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     */\n    public filters: Filter[] | null;\n\n    /** Used to fast check if a sprite is.. a sprite! */\n    public isSprite: boolean;\n\n    /** Does any other displayObject use this object as a mask? */\n    public isMask: boolean;\n\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     * @protected\n     */\n    public _lastSortedIndex: number;\n\n    /**\n     * The original, cached mask of the object.\n     * @protected\n     */\n    public _mask: Container | MaskData;\n\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\n    public _bounds: Bounds;\n\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\n    public _localBounds: Bounds;\n\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     * @protected\n     */\n    protected _zIndex: number;\n\n    /**\n     * Currently enabled filters.\n     * @protected\n     */\n    protected _enabledFilters: Filter[];\n\n    /** Flags the cached bounds as dirty. */\n    protected _boundsID: number;\n\n    /** Cache of this display-object's bounds-rectangle. */\n    protected _boundsRect: Rectangle;\n\n    /** Cache of this display-object's local-bounds rectangle. */\n    protected _localBoundsRect: Rectangle;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    protected _destroyed: boolean;\n\n    /** The number of times this object is used as a mask by another object. */\n    private _maskRefCount: number;\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     * @param source - The source of properties and methods to mix in.\n     */\n    static mixin(source: utils.Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        this.transform = new Transform();\n        this.alpha = 1;\n        this.visible = true;\n        this.renderable = true;\n        this.cullable = false;\n        this.cullArea = null;\n\n        this.parent = null;\n        this.worldAlpha = 1;\n\n        this._lastSortedIndex = 0;\n        this._zIndex = 0;\n\n        this.filterArea = null;\n        this.filters = null;\n        this._enabledFilters = null;\n\n        this._bounds = new Bounds();\n        this._localBounds = null;\n        this._boundsID = 0;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n        this._mask = null;\n        this._maskRefCount = 0;\n        this._destroyed = false;\n\n        this.isSprite = false;\n        this.isMask = false;\n    }\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * Fired when this DisplayObject is destroyed. This event is emitted once\n     * destroy is finished.\n     * @instance\n     * @event destroyed\n     */\n\n    /** Readonly flag for destroyed display objects. */\n    get destroyed(): boolean\n    {\n        return this._destroyed;\n    }\n\n    /** Recalculates the bounds of the display object. */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     * @param renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /** Updates the object transform for rendering. TODO - Optimization pass! */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        // inherit the worldAlpha of the parent node\n        this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     * @param container - The Container to add this DisplayObject to.\n     * @returns - The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @returns - The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     * @param _options\n     */\n    destroy(_options?: IDestroyOptions | boolean): void\n    {\n        this.removeFromParent();\n\n        this._destroyed = true;\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this.mask = null;\n\n        this.cullArea = null;\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.eventMode = 'auto';\n        this.interactiveChildren = false;\n\n        this.emit('destroyed');\n        this.removeAllListeners();\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.\n     *\n     * ```js\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     * @returns - Current parent\n     */\n    enableTempParent(): Container\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent as Container;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     * @param cacheParent - Actual parent of element\n     */\n    disableTempParent(cacheParent: Container): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: IPointData)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: IPointData)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: IPointData)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: IPointData)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see PIXI.Container#sortableChildren\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value)\n        {\n            return;\n        }\n\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, CanvasRenderer doesn't support Sprite as mask.\n     */\n    get mask(): Container | MaskData | null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container | MaskData | null)\n    {\n        if (this._mask === value)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                maskObject._maskRefCount--;\n\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = true;\n                    maskObject.isMask = false;\n                }\n            }\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = false;\n                    maskObject.isMask = true;\n                }\n\n                maskObject._maskRefCount++;\n            }\n        }\n    }\n}\n\n/**\n * @private\n */\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n", "import { MASK_TYPES, Matrix, utils } from '@pixi/core';\nimport { DisplayObject } from './DisplayObject';\n\nimport type { MaskData, Rectangle, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from './DisplayObject';\n\nconst tempMatrix = new Matrix();\n\nfunction sortChildren(a: DisplayObject, b: DisplayObject): number\n{\n    if (a.zIndex === b.zIndex)\n    {\n        return a._lastSortedIndex - b._lastSortedIndex;\n    }\n\n    return a.zIndex - b.zIndex;\n}\n\nexport interface Container extends GlobalMixins.Container, DisplayObject {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n * @example\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * @memberof PIXI\n */\nexport class Container<T extends DisplayObject = DisplayObject> extends DisplayObject\n{\n    /**\n     * Sets the default value for the container property `sortableChildren`.\n     * If set to true, the container will sort its children by zIndex value\n     * when `updateTransform()` is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}.\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @static\n     */\n    public static defaultSortableChildren = false;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public readonly children: T[];\n\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when `updateTransform()` is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @see PIXI.Container.defaultSortableChildren\n     */\n    public sortableChildren: boolean;\n\n    /**\n     * Should children be sorted by zIndex at the next updateTransform call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     */\n    public sortDirty: boolean;\n    public parent: Container;\n    public containerUpdateTransform: () => void;\n\n    protected _width: number;\n    protected _height: number;\n\n    constructor()\n    {\n        super();\n\n        this.children = [];\n        this.sortableChildren = Container.defaultSortableChildren;\n        this.sortDirty = false;\n\n        /**\n         * Fired when a DisplayObject is added to this Container.\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */\n\n        /**\n         * Fired when a DisplayObject is removed from this Container.\n         * @event PIXI.Container#childRemoved\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed the child.\n         * @param {number} index - The former children's index of the removed child.\n         */\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified.\n     * @param _length\n     */\n    protected onChildrenChange(_length?: number): void\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n     * @returns {PIXI.DisplayObject} - The first child that was added.\n     */\n    addChild<U extends T[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            this.emit('childAdded', child, this, this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {PIXI.DisplayObject} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt<U extends T>(child: U, index: number): U\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     * @param child - First display object to swap\n     * @param child2 - Second display object to swap\n     */\n    swapChildren(child: T, child2: T): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     * @param child - The DisplayObject instance to identify\n     * @returns - The index position of the child display object to identify\n     */\n    getChildIndex(child: T): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     * @param child - The child DisplayObject instance for which you want to change the index number\n     * @param index - The resulting index number for the child display object\n     */\n    setChildIndex(child: T, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        utils.removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     */\n    getChildAt(index: number): T\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n     * @returns {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild<U extends T[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            utils.removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this, index);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     */\n    removeChildAt(index: number): T\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        utils.removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex = this.children.length): T[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\n    sortChildren(): void\n    {\n        let sortRequired = false;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            child._lastSortedIndex = i;\n\n            if (!sortRequired && child.zIndex !== 0)\n            {\n                sortRequired = true;\n            }\n        }\n\n        if (sortRequired && this.children.length > 1)\n        {\n            this.children.sort(sortChildren);\n        }\n\n        this.sortDirty = false;\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    updateTransform(): void\n    {\n        if (this.sortableChildren && this.sortDirty)\n        {\n            this.sortChildren();\n        }\n\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\n     * is limited to its mask's bounds or filterArea, if any is applied.\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).isMaskData\n                    ? (child._mask as MaskData).maskObject : child._mask) as Container;\n\n                if (maskObject)\n                {\n                    maskObject.calculateBounds();\n                    this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n                }\n                else\n                {\n                    this._bounds.addBounds(child._bounds);\n                }\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n     * @returns - The rectangular bounding area.\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        const result = super.getLocalBounds(rect);\n\n        if (!skipChildrenUpdate)\n        {\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                const child = this.children[i];\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Recalculates the content bounds of this object. This should be overriden to\n     * calculate the bounds of this specific object (not including children).\n     * @protected\n     */\n    protected _calculateBounds(): void\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders this object and its children with culling.\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderWithCulling(renderer: Renderer): void\n    {\n        const sourceFrame = renderer.renderTexture.sourceFrame;\n\n        // If the source frame is empty, stop rendering.\n        if (!(sourceFrame.width > 0 && sourceFrame.height > 0))\n        {\n            return;\n        }\n\n        // Render the content of the container only if its bounds intersect with the source frame.\n        // All filters are on the stack at this point, and the filter source frame is bound:\n        // therefore, even if the bounds to non intersect the filter frame, the filter\n        // is still applied and any filter padding that is in the frame is rendered correctly.\n\n        let bounds: Rectangle;\n        let transform: Matrix;\n\n        // If cullArea is set, we use this rectangle instead of the bounds of the object. The cullArea\n        // rectangle must completely contain the container and its children including filter padding.\n        if (this.cullArea)\n        {\n            bounds = this.cullArea;\n            transform = this.worldTransform;\n        }\n        // If the container doesn't override _render, we can skip the bounds calculation and intersection test.\n        else if (this._render !== Container.prototype._render)\n        {\n            bounds = this.getBounds(true);\n        }\n\n        // Prepend the transform that is appended to the projection matrix.\n        const projectionTransform = renderer.projection.transform;\n\n        if (projectionTransform)\n        {\n            if (transform)\n            {\n                transform = tempMatrix.copyFrom(transform);\n                transform.prepend(projectionTransform);\n            }\n            else\n            {\n                transform = projectionTransform;\n            }\n        }\n\n        // Render the container if the source frame intersects the bounds.\n        if (bounds && sourceFrame.intersects(bounds, transform))\n        {\n            this._render(renderer);\n        }\n        // If the bounds are defined by cullArea and do not intersect with the source frame, stop rendering.\n        else if (this.cullArea)\n        {\n            return;\n        }\n\n        // Unless cullArea is set, we cannot skip the children if the bounds of the container do not intersect\n        // the source frame, because the children might have filters with nonzero padding, which may intersect\n        // with the source frame while the bounds do not: filter padding is not included in the bounds.\n\n        // If cullArea is not set, render the children with culling temporarily enabled so that they are not rendered\n        // if they are out of frame; otherwise, render the children normally.\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n            const childCullable = child.cullable;\n\n            child.cullable = childCullable || !this.cullArea;\n            child.render(renderer);\n            child.cullable = childCullable;\n        }\n    }\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n     * children afterward.\n     *\n     * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n     * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n     * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n     * setting alpha to zero is not recommended for purely skipping rendering.\n     *\n     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n     * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n     * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n     * Other culling methods might be better suited for a large number static objects; see\n     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n     *\n     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n     * filtering is applied on a container. This does, however, break batching and can affect performance when\n     * masking and filtering is applied extensively throughout the scene graph.\n     * @param renderer - The renderer\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || this.filters?.length)\n        {\n            this.renderAdvanced(renderer);\n        }\n        else if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     * @param renderer - The renderer\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        const filters = this.filters;\n        const mask = this._mask as MaskData;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n        }\n\n        const flush = (filters && this._enabledFilters?.length)\n            || (mask && (!mask.isMaskData\n                || (mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE))));\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (filters && this._enabledFilters?.length)\n        {\n            renderer.filter.push(this, this._enabledFilters);\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters?.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     * @param _renderer - The renderer\n     */\n    protected _render(_renderer: Renderer): void // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy();\n\n        this.sortDirty = false;\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value: number)\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value: number)\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.Container#\n * @method containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n", "import { settings, utils } from '@pixi/core';\nimport { Container } from './Container';\n\nObject.defineProperties(settings, {\n    /**\n     * Sets the default value for the container property 'sortableChildren'.\n     * @static\n     * @name SORTABLE_CHILDREN\n     * @memberof PIXI.settings\n     * @deprecated since 7.1.0\n     * @type {boolean}\n     * @see PIXI.Container.defaultSortableChildren\n     */\n    SORTABLE_CHILDREN: {\n        get()\n        {\n            return Container.defaultSortableChildren;\n        },\n        set(value: boolean)\n        {\n            if (process.env.DEBUG)\n            {\n                // eslint-disable-next-line max-len\n                utils.deprecation('7.1.0', 'settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren');\n            }\n            Container.defaultSortableChildren = value;\n        },\n    },\n});\n\nexport { settings };\n", "import { BLEND_MODES, Color, ObservablePoint, Point, Rectangle, settings, Texture, utils } from '@pixi/core';\nimport { Bounds, Container } from '@pixi/display';\n\nimport type { ColorSource, IBaseTextureOptions, IPointData, Renderer, TextureSource } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\nconst tempPoint = new Point();\nconst indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n\nexport type SpriteSource = TextureSource | Texture;\n\nexport interface Sprite extends GlobalMixins.Sprite, Container {}\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link PIXI.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof PIXI\n */\nexport class Sprite extends Container\n{\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public blendMode: BLEND_MODES;\n    public indices: Uint16Array;\n\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    /**\n     * The width of the sprite (this is initially set by the texture).\n     * @protected\n     */\n    _width: number;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     * @protected\n     */\n    _height: number;\n\n    /**\n     * The texture that the sprite is using.\n     * @private\n     */\n    _texture: Texture;\n    _textureID: number;\n\n    /**\n     * Cached tint value so we can tell when the tint is changed.\n     * Value is used for 2d CanvasRenderer.\n     * @protected\n     * @default 0xFFFFFF\n     */\n    _cachedTint: number;\n    protected _textureTrimmedID: number;\n\n    /**\n     * This is used to store the uvs data of the sprite, assigned at the same time\n     * as the vertexData in calculateVertices().\n     * @member {Float32Array}\n     */\n    protected uvs: Float32Array;\n\n    /**\n     * The anchor point defines the normalized coordinates\n     * in the texture that map to the position of this\n     * sprite.\n     *\n     * By default, this is `(0,0)` (or `texture.defaultAnchor`\n     * if you have modified that), which means the position\n     * `(x,y)` of this `Sprite` will be the top-left corner.\n     *\n     * Note: Updating `texture.defaultAnchor` after\n     * constructing a `Sprite` does _not_ update its anchor.\n     *\n     * {@link https://docs.cocos2d-x.org/cocos2d-x/en/sprites/manipulation.html}\n     * @default `this.texture.defaultAnchor`\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * This is used to store the vertex data of the sprite (basically a quad).\n     * @member {Float32Array}\n     */\n    protected vertexData: Float32Array;\n\n    /**\n     * This is used to calculate the bounds of the object IF it is a trimmed sprite.\n     * @member {Float32Array}\n     */\n    private vertexTrimmedData: Float32Array;\n\n    /**\n     * Internal roundPixels field\n     * @private\n     */\n    private _roundPixels: boolean;\n    private _transformID: number;\n    private _transformTrimmedID: number;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    private _tintColor: Color;\n\n    // Internal-only properties\n    /**\n     * The tint applied to the sprite. This is a RGB value. A value of 0xFFFFFF will remove any tint effect.\n     * @private\n     * @default 16777215\n     */\n    _tintRGB: number;\n\n    /** @param texture - The texture for this sprite. */\n    constructor(texture?: Texture)\n    {\n        super();\n\n        this._anchor = new ObservablePoint(\n            this._onAnchorUpdate,\n            this,\n            (texture ? texture.defaultAnchor.x : 0),\n            (texture ? texture.defaultAnchor.y : 0)\n        );\n\n        this._texture = null;\n\n        this._width = 0;\n        this._height = 0;\n        this._tintColor = new Color(0xFFFFFF);\n        this._tintRGB = null;\n\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n        this._cachedTint = 0xFFFFFF;\n        this.uvs = null;\n\n        // call texture setter\n        this.texture = texture || Texture.EMPTY;\n        this.vertexData = new Float32Array(8);\n        this.vertexTrimmedData = null;\n\n        this._transformID = -1;\n        this._textureID = -1;\n\n        this._transformTrimmedID = -1;\n        this._textureTrimmedID = -1;\n\n        // Batchable stuff..\n        // TODO could make this a mixin?\n        this.indices = indices;\n\n        this.pluginName = 'batch';\n\n        /**\n         * Used to fast check if a sprite is.. a sprite!\n         * @member {boolean}\n         */\n        this.isSprite = true;\n        this._roundPixels = settings.ROUND_PIXELS;\n    }\n\n    /** When the texture is updated, this event will fire to update the scale and frame. */\n    protected _onTextureUpdate(): void\n    {\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n\n        // so if _width is 0 then width was not set..\n        if (this._width)\n        {\n            this.scale.x = utils.sign(this.scale.x) * this._width / this._texture.orig.width;\n        }\n\n        if (this._height)\n        {\n            this.scale.y = utils.sign(this.scale.y) * this._height / this._texture.orig.height;\n        }\n    }\n\n    /** Called when the anchor position updates. */\n    private _onAnchorUpdate(): void\n    {\n        this._transformID = -1;\n        this._transformTrimmedID = -1;\n    }\n\n    /** Calculates worldTransform * vertices, store it in vertexData. */\n    public calculateVertices(): void\n    {\n        const texture = this._texture;\n\n        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)\n        {\n            return;\n        }\n\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n        if (this._textureID !== texture._updateID)\n        {\n            this.uvs = this._texture._uvs.uvsFloat32;\n        }\n\n        this._transformID = this.transform._worldID;\n        this._textureID = texture._updateID;\n\n        // set the vertex data\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const vertexData = this.vertexData;\n        const trim = texture.trim;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        if (trim)\n        {\n            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra\n            // space before transforming the sprite coords.\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else\n        {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n    }\n\n    /**\n     * Calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData.\n     *\n     * This is used to ensure that the true width and height of a trimmed texture is respected.\n     */\n    public calculateTrimmedVertices(): void\n    {\n        if (!this.vertexTrimmedData)\n        {\n            this.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n        {\n            return;\n        }\n\n        this._transformTrimmedID = this.transform._worldID;\n        this._textureTrimmedID = this._texture._updateID;\n\n        // lets do some special trim code!\n        const texture = this._texture;\n        const vertexData = this.vertexTrimmedData;\n        const orig = texture.orig;\n        const anchor = this._anchor;\n\n        // lets calculate the new untrimmed bounds..\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const w1 = -anchor._x * orig.width;\n        const w0 = w1 + orig.width;\n\n        const h1 = -anchor._y * orig.height;\n        const h0 = h1 + orig.height;\n\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n    }\n\n    /**\n     *\n     * Renders the object using the WebGL renderer\n     * @param renderer - The webgl renderer to use.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.calculateVertices();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /** Updates the bounds of the sprite. */\n    protected _calculateBounds(): void\n    {\n        const trim = this._texture.trim;\n        const orig = this._texture.orig;\n\n        // First lets check to see if the current texture has a trim..\n        if (!trim || (trim.width === orig.width && trim.height === orig.height))\n        {\n            // no trim! lets use the usual calculations..\n            this.calculateVertices();\n            this._bounds.addQuad(this.vertexData);\n        }\n        else\n        {\n            // lets calculate a special trimmed bounds...\n            this.calculateTrimmedVertices();\n            this._bounds.addQuad(this.vertexTrimmedData);\n        }\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     * @param rect - Optional output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            if (!this._localBounds)\n            {\n                this._localBounds = new Bounds();\n            }\n\n            this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n            this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n            this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n            this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._localBounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Tests if a point is inside this sprite\n     * @param point - the point to test\n     * @returns The result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._texture.orig.width;\n        const height = this._texture.orig.height;\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this._texture.off('update', this._onTextureUpdate, this);\n\n        this._anchor = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyBaseTexture = typeof options === 'boolean' ? options : options?.baseTexture;\n\n            this._texture.destroy(!!destroyBaseTexture);\n        }\n\n        this._texture = null;\n    }\n\n    // some helper functions..\n\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     * @param {string|PIXI.Texture|HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas} source\n     *     - Source to create texture from\n     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @returns The newly created sprite\n     */\n    static from(source: SpriteSource, options?: IBaseTextureOptions): Sprite\n    {\n        const texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n\n        return new Sprite(texture);\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     *\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     *\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n            this._transformTrimmedID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(Texture.WHITE);\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: ObservablePoint)\n    {\n        this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n    }\n\n    /**\n     * Get the tint as a RGB integer.\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return this._tintColor.toNumber();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        if (this._texture)\n        {\n            this._texture.off('update', this._onTextureUpdate, this);\n        }\n\n        this._texture = value || Texture.EMPTY;\n        this._cachedTint = 0xFFFFFF;\n\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.valid)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n}\n", "import type { Buffer, TextureMatrix } from '@pixi/core';\n\n/**\n * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.\n * @memberof PIXI\n */\nexport class MeshBatchUvs\n{\n    /** UV Buffer data. */\n    public readonly data: Float32Array;\n\n    /** Buffer with normalized UV's. */\n    public uvBuffer: Buffer;\n\n    /** Material UV matrix. */\n    public uvMatrix: TextureMatrix;\n\n    private _bufferUpdateId: number;\n    private _textureUpdateId: number;\n\n    // Internal-only properties\n    _updateID: number;\n\n    /**\n     * @param uvBuffer - Buffer with normalized uv's\n     * @param uvMatrix - Material UV matrix\n     */\n    constructor(uvBuffer: Buffer, uvMatrix: TextureMatrix)\n    {\n        this.uvBuffer = uvBuffer;\n        this.uvMatrix = uvMatrix;\n        this.data = null;\n\n        this._bufferUpdateId = -1;\n        this._textureUpdateId = -1;\n        this._updateID = 0;\n    }\n\n    /**\n     * Updates\n     * @param forceUpdate - force the update\n     */\n    public update(forceUpdate?: boolean): void\n    {\n        if (!forceUpdate\n            && this._bufferUpdateId === this.uvBuffer._updateID\n            && this._textureUpdateId === this.uvMatrix._updateID\n        )\n        {\n            return;\n        }\n\n        this._bufferUpdateId = this.uvBuffer._updateID;\n        this._textureUpdateId = this.uvMatrix._updateID;\n\n        const data = this.uvBuffer.data as Float32Array;\n\n        if (!this.data || this.data.length !== data.length)\n        {\n            (this.data as any) = new Float32Array(data.length);\n        }\n\n        this.uvMatrix.multiplyUvs(data, this.data);\n\n        this._updateID++;\n    }\n}\n", "import { DRAW_MODES, Point, Polygon, settings, State } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs';\n\nimport type { BLEND_MODES, Buffer, ColorSource, Geometry, IPointData, Renderer, Shader, Texture } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { MeshMaterial } from './MeshMaterial';\n\nconst tempPoint = new Point();\nconst tempPolygon = new Polygon();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Mesh extends GlobalMixins.Mesh {}\n\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nexport class Mesh<T extends Shader = MeshMaterial> extends Container\n{\n    /**\n     * Used by the @pixi/canvas-mesh package to draw meshes using canvas.\n     * Added here because we cannot mixin a static property to Mesh type.\n     * @ignore\n     */\n    public static defaultCanvasPadding: number;\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     * @type {PIXI.Shader|PIXI.MeshMaterial}\n     */\n    public shader: T;\n\n    /**\n     * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    public state: State;\n\n    /** The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants. */\n    public drawMode: DRAW_MODES;\n\n    /**\n     * Typically the index of the IndexBuffer where to start drawing.\n     * @default 0\n     */\n    public start: number;\n\n    /**\n     * How much of the geometry to draw, by default `0` renders everything.\n     * @default 0\n     */\n    public size: number;\n\n    private _geometry: Geometry;\n\n    /** This is the caching layer used by the batcher. */\n    private vertexData: Float32Array;\n\n    /** If geometry is changed used to decide to re-transform the vertexData. */\n    private vertexDirty: number;\n    private _transformID: number;\n\n    /** Internal roundPixels field. */\n    private _roundPixels: boolean;\n\n    /** Batched UV's are cached for atlas textures. */\n    private batchUvs: MeshBatchUvs;\n\n    // Internal-only properties\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    uvs: Float32Array;\n\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    indices: Uint16Array;\n    _tintRGB: number;\n    _texture: Texture;\n\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry: Geometry, shader: T, state?: State, drawMode: DRAW_MODES = DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        this.geometry = geometry;\n        this.shader = shader;\n        this.state = state || State.for2d();\n        this.drawMode = drawMode;\n        this.start = 0;\n        this.size = 0;\n\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = new Float32Array(1);\n        this.vertexDirty = -1;\n\n        this._transformID = -1;\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.batchUvs = null;\n    }\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry(): Geometry\n    {\n        return this._geometry;\n    }\n\n    set geometry(value: Geometry)\n    {\n        if (this._geometry === value)\n        {\n            return;\n        }\n\n        if (this._geometry)\n        {\n            this._geometry.refCount--;\n\n            if (this._geometry.refCount === 0)\n            {\n                this._geometry.dispose();\n            }\n        }\n\n        this._geometry = value;\n\n        if (this._geometry)\n        {\n            this._geometry.refCount++;\n        }\n\n        this.vertexDirty = -1;\n    }\n\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer(): Buffer\n    {\n        return this.geometry.buffers[1];\n    }\n\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer(): Buffer\n    {\n        return this.geometry.buffers[0];\n    }\n\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value: T)\n    {\n        this.shader = value;\n    }\n\n    get material(): T\n    {\n        return this.shader;\n    }\n\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint(): ColorSource\n    {\n        return 'tint' in this.shader ? (this.shader as unknown as MeshMaterial).tint : null;\n    }\n\n    set tint(value: ColorSource)\n    {\n        (this.shader as unknown as MeshMaterial).tint = value;\n    }\n\n    /**\n     * The tint color as a RGB integer\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return (this.shader as unknown as MeshMaterial).tintValue;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture(): Texture\n    {\n        return 'texture' in this.shader ? (this.shader as unknown as MeshMaterial).texture : null;\n    }\n\n    set texture(value: Texture)\n    {\n        (this.shader as unknown as MeshMaterial).texture = value;\n    }\n\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // set properties for batching..\n        // TODO could use a different way to grab verts?\n        const vertices = this.geometry.buffers[0].data;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        // TODO benchmark check for attribute size..\n        if (\n            shader.batchable\n            && this.drawMode === DRAW_MODES.TRIANGLES\n            && vertices.length < Mesh.BATCHABLE_SIZE * 2\n        )\n        {\n            this._renderToBatch(renderer);\n        }\n        else\n        {\n            this._renderDefault(renderer);\n        }\n    }\n\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as unknown as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        // bind and sync uniforms..\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        renderer.shader.bind(shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderToBatch(renderer: Renderer): void\n    {\n        const geometry = this.geometry;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (shader.uvMatrix)\n        {\n            shader.uvMatrix.update();\n            this.calculateUvs();\n        }\n\n        // set properties for batching..\n        this.calculateVertices();\n        this.indices = geometry.indexBuffer.data as Uint16Array;\n        this._tintRGB = shader._tintRGB;\n        this._texture = shader.texture;\n\n        const pluginName = (this.material as unknown as MeshMaterial).pluginName;\n\n        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n        renderer.plugins[pluginName].render(this);\n    }\n\n    /** Updates vertexData field based on transform and vertices. */\n    public calculateVertices(): void\n    {\n        const geometry = this.geometry;\n        const verticesBuffer = geometry.buffers[0];\n        const vertices = verticesBuffer.data;\n        const vertexDirtyId = verticesBuffer._updateID;\n\n        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        if (this.vertexData.length !== vertices.length)\n        {\n            this.vertexData = new Float32Array(vertices.length);\n        }\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const vertexData = this.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            vertexData[(i * 2)] = (a * x) + (c * y) + tx;\n            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;\n        }\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n            }\n        }\n\n        this.vertexDirty = vertexDirtyId;\n    }\n\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    public calculateUvs(): void\n    {\n        const geomUvs = this.geometry.buffers[1];\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (!shader.uvMatrix.isSimple)\n        {\n            if (!this.batchUvs)\n            {\n                this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n            }\n            this.batchUvs.update();\n            this.uvs = this.batchUvs.data;\n        }\n        else\n        {\n            this.uvs = geomUvs.data as Float32Array;\n        }\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n\n        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getBuffer('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices = this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        if (this._cachedTexture)\n        {\n            this._cachedTexture.destroy();\n            this._cachedTexture = null;\n        }\n\n        this.geometry = null;\n        this.shader = null;\n        this.state = null;\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = null;\n    }\n\n    /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n    public static BATCHABLE_SIZE = 100;\n}\n", "import { Buffer, Geometry, TYPES } from '@pixi/core';\n\nimport type { IArrayBuffer } from '@pixi/core';\n\n/**\n * Standard 2D geometry used in PixiJS.\n *\n * Geometry can be defined without passing in a style or data if required.\n * @example\n * import { Geometry } from 'pixi.js';\n *\n * const geometry = new Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0, 0, 1, 0, 1, 1, 0, 1], 2);\n * geometry.addIndex([0, 1, 2, 1, 3, 2]);\n * @memberof PIXI\n */\nexport class MeshGeometry extends Geometry\n{\n    // Internal-only properties\n    /**\n     * Dirty flag to limit update calls on Mesh. For example,\n     * limiting updates on a single Mesh instance with a shared Geometry\n     * within the render loop.\n     * @private\n     * @default -1\n     */\n    _updateId: number;\n\n    /**\n     * @param {Float32Array|number[]} [vertices] - Positional data on geometry.\n     * @param {Float32Array|number[]} [uvs] - Texture UVs.\n     * @param {Uint16Array|number[]} [index] - IndexBuffer\n     */\n    constructor(vertices?: IArrayBuffer, uvs?: IArrayBuffer, index?: IArrayBuffer)\n    {\n        super();\n\n        const verticesBuffer = new Buffer(vertices);\n        const uvsBuffer = new Buffer(uvs, true);\n        const indexBuffer = new Buffer(index, true, true);\n\n        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTextureCoord', uvsBuffer, 2, false, TYPES.FLOAT)\n            .addIndex(indexBuffer);\n\n        this._updateId = -1;\n    }\n\n    /**\n     * If the vertex position is updated.\n     * @readonly\n     * @private\n     */\n    get vertexDirtyId(): number\n    {\n        return this.buffers[0]._updateID;\n    }\n}\n", "var fragment = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`;\nexport {\n  fragment as default\n};\n//# sourceMappingURL=mesh.frag.mjs.map\n", "var vertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`;\nexport {\n  vertex as default\n};\n//# sourceMappingURL=mesh.vert.mjs.map\n", "import { Color, Matrix, Program, Shader, TextureMatrix } from '@pixi/core';\nimport fragment from './shader/mesh.frag';\nimport vertex from './shader/mesh.vert';\n\nimport type { ColorSource, Texture, utils } from '@pixi/core';\n\nexport interface IMeshMaterialOptions\n{\n    alpha?: number;\n    tint?: ColorSource;\n    pluginName?: string;\n    program?: Program;\n    uniforms?: utils.Dict<unknown>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MeshMaterial extends GlobalMixins.MeshMaterial {}\n\n/**\n * Slightly opinionated default shader for PixiJS 2D objects.\n * @memberof PIXI\n */\nexport class MeshMaterial extends Shader\n{\n    /**\n     * TextureMatrix instance for this Mesh, used to track Texture changes.\n     * @readonly\n     */\n    public readonly uvMatrix: TextureMatrix;\n\n    /**\n     * `true` if shader can be batch with the renderer's batch system.\n     * @default true\n     */\n    public batchable: boolean;\n\n    /**\n     * Renderer plugin for batching.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    // Internal-only properties\n    _tintRGB: number;\n\n    /**\n     * Only do update if tint or alpha changes.\n     * @private\n     * @default false\n     */\n    private _colorDirty: boolean;\n    private _alpha: number;\n    private _tintColor: Color;\n\n    /**\n     * @param uSampler - Texture that material uses to render.\n     * @param options - Additional options\n     * @param {number} [options.alpha=1] - Default alpha.\n     * @param {PIXI.ColorSource} [options.tint=0xFFFFFF] - Default tint.\n     * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.\n     * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n     * @param {object} [options.uniforms] - Custom uniforms.\n     */\n    constructor(uSampler: Texture, options?: IMeshMaterialOptions)\n    {\n        const uniforms = {\n            uSampler,\n            alpha: 1,\n            uTextureMatrix: Matrix.IDENTITY,\n            uColor: new Float32Array([1, 1, 1, 1]),\n        };\n\n        // Set defaults\n        options = Object.assign({\n            tint: 0xFFFFFF,\n            alpha: 1,\n            pluginName: 'batch',\n        }, options);\n\n        if (options.uniforms)\n        {\n            Object.assign(uniforms, options.uniforms);\n        }\n\n        super(options.program || Program.from(vertex, fragment), uniforms);\n\n        this._colorDirty = false;\n\n        this.uvMatrix = new TextureMatrix(uSampler);\n        this.batchable = options.program === undefined;\n        this.pluginName = options.pluginName;\n\n        this._tintColor = new Color(options.tint);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n        this._colorDirty = true;\n        this.alpha = options.alpha;\n    }\n\n    /** Reference to the texture being rendered. */\n    get texture(): Texture\n    {\n        return this.uniforms.uSampler;\n    }\n    set texture(value: Texture)\n    {\n        if (this.uniforms.uSampler !== value)\n        {\n            if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode)\n            {\n                this._colorDirty = true;\n            }\n\n            this.uniforms.uSampler = value;\n            this.uvMatrix.texture = value;\n        }\n    }\n\n    /**\n     * This gets automatically set by the object using this.\n     * @default 1\n     */\n    set alpha(value: number)\n    {\n        if (value === this._alpha) return;\n\n        this._alpha = value;\n        this._colorDirty = true;\n    }\n    get alpha(): number\n    {\n        return this._alpha;\n    }\n\n    /**\n     * Multiply tint for the material.\n     * @default 0xFFFFFF\n     */\n    set tint(value: ColorSource)\n    {\n        if (value === this.tint) return;\n\n        this._tintColor.setValue(value);\n        this._tintRGB = this._tintColor.toLittleEndianNumber();\n        this._colorDirty = true;\n    }\n    get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    /**\n     * Get the internal number from tint color\n     * @ignore\n     */\n    get tintValue(): number\n    {\n        return this._tintColor.toNumber();\n    }\n\n    /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link PIXI.MeshMaterial} objects. */\n    public update(): void\n    {\n        if (this._colorDirty)\n        {\n            this._colorDirty = false;\n            const baseTexture = this.texture.baseTexture;\n            const applyToChannels = (baseTexture.alphaMode as unknown as boolean);\n\n            Color.shared\n                .setValue(this._tintColor)\n                .premultiply(this._alpha, applyToChannels)\n                .toArray(this.uniforms.uColor);\n        }\n        if (this.uvMatrix.update())\n        {\n            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n        }\n    }\n}\n", "import { MeshGeometry } from '@pixi/mesh';\n\n/**\n * @memberof PIXI\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public segWidth: number;\n    public segHeight: number;\n    public width: number;\n    public height: number;\n\n    /**\n     * @param width - The width of the plane.\n     * @param height - The height of the plane.\n     * @param segWidth - Number of horizontal segments.\n     * @param segHeight - Number of vertical segments.\n     */\n    constructor(width = 100, height = 100, segWidth = 10, segHeight = 10)\n    {\n        super();\n\n        this.segWidth = segWidth;\n        this.segHeight = segHeight;\n\n        this.width = width;\n        this.height = height;\n\n        this.build();\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @private\n     */\n    build(): void\n    {\n        const total = this.segWidth * this.segHeight;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const segmentsX = this.segWidth - 1;\n        const segmentsY = this.segHeight - 1;\n\n        const sizeX = (this.width) / segmentsX;\n        const sizeY = (this.height) / segmentsY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.segWidth);\n            const y = ((i / this.segWidth) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / segmentsX, y / segmentsY);\n        }\n\n        const totalSub = segmentsX * segmentsY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % segmentsX;\n            const ypos = (i / segmentsX) | 0;\n\n            const value = (ypos * this.segWidth) + xpos;\n            const value2 = (ypos * this.segWidth) + xpos + 1;\n            const value3 = ((ypos + 1) * this.segWidth) + xpos;\n            const value4 = ((ypos + 1) * this.segWidth) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint16Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n", "import { MeshGeometry } from '@pixi/mesh';\n\nimport type { IPoint } from '@pixi/core';\n\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n * @example\n * import { Point, RopeGeometry } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new RopeGeometry(100, points);\n * @memberof PIXI\n */\nexport class RopeGeometry extends MeshGeometry\n{\n    /** An array of points that determine the rope. */\n    public points: IPoint[];\n\n    /** Rope texture scale, if zero then the rope texture is stretched. */\n    public readonly textureScale: number;\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    _width: number;\n\n    /**\n     * @param width - The width (i.e., thickness) of the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param textureScale - By default the rope texture will be stretched to match\n     *     rope length. If textureScale is positive this value will be treated as a scaling\n     *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n     *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,\n     *     then set textureScale=1 to keep the original texture pixel size.\n     *     In order to reduce alpha channel artifacts provide a larger texture and downsample -\n     *     i.e. set textureScale=0.5 to scale it down twice.\n     */\n    constructor(width = 200, points: IPoint[], textureScale = 0)\n    {\n        super(new Float32Array(points.length * 4),\n            new Float32Array(points.length * 4),\n            new Uint16Array((points.length - 1) * 6));\n\n        this.points = points;\n        this._width = width;\n        this.textureScale = textureScale;\n\n        this.build();\n    }\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    /** Refreshes Rope indices and uvs */\n    private build(): void\n    {\n        const points = this.points;\n\n        if (!points) return;\n\n        const vertexBuffer = this.getBuffer('aVertexPosition');\n        const uvBuffer = this.getBuffer('aTextureCoord');\n        const indexBuffer = this.getIndex();\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (vertexBuffer.data.length / 4 !== points.length)\n        {\n            vertexBuffer.data = new Float32Array(points.length * 4);\n            uvBuffer.data = new Float32Array(points.length * 4);\n            indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n        }\n\n        const uvs = uvBuffer.data;\n        const indices = indexBuffer.data;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        let amount = 0;\n        let prev = points[0];\n        const textureWidth = this._width * this.textureScale;\n        const total = points.length; // - 1;\n\n        for (let i = 0; i < total; i++)\n        {\n            // time to do some smart drawing!\n            const index = i * 4;\n\n            if (this.textureScale > 0)\n            {\n                // calculate pixel distance from previous point\n                const dx = prev.x - points[i].x;\n                const dy = prev.y - points[i].y;\n                const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n                prev = points[i];\n                amount += distance / textureWidth;\n            }\n            else\n            {\n                // stretch texture\n                amount = i / (total - 1);\n            }\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n        }\n\n        let indexCount = 0;\n\n        for (let i = 0; i < total - 1; i++)\n        {\n            const index = i * 2;\n\n            indices[indexCount++] = index;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 2;\n\n            indices[indexCount++] = index + 2;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 3;\n        }\n\n        // ensure that the changes are uploaded\n        uvBuffer.update();\n        indexBuffer.update();\n\n        this.updateVertices();\n    }\n\n    /** refreshes vertices of Rope mesh */\n    public updateVertices(): void\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        const vertices = this.buffers[0].data;\n        const total = points.length;\n        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n            if (perpLength < 1e-6)\n            {\n                perpX = 0;\n                perpY = 0;\n            }\n            else\n            {\n                perpX /= perpLength;\n                perpY /= perpLength;\n\n                perpX *= halfWidth;\n                perpY *= halfWidth;\n            }\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        this.buffers[0].update();\n    }\n\n    public update(): void\n    {\n        if (this.textureScale > 0)\n        {\n            this.build(); // we need to update UVs\n        }\n        else\n        {\n            this.updateVertices();\n        }\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { PlaneGeometry } from './geometry/PlaneGeometry';\n\nimport type{ Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * The SimplePlane allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, SimplePlane, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * }\n * const SimplePlane = new SimplePlane(Texture.from('snake.png'), points);\n * @memberof PIXI\n */\nexport class SimplePlane extends Mesh\n{\n    /** The geometry is automatically updated when the texture size changes. */\n    public autoResize: boolean;\n\n    protected _textureID: number;\n\n    /**\n     * @param texture - The texture to use on the SimplePlane.\n     * @param verticesX - The number of vertices in the x-axis\n     * @param verticesY - The number of vertices in the y-axis\n     */\n    constructor(texture: Texture, verticesX?: number, verticesY?: number)\n    {\n        const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n        const meshMaterial = new MeshMaterial(Texture.WHITE);\n\n        super(planeGeometry, meshMaterial);\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n        this.autoResize = true;\n    }\n\n    /**\n     * Method used for overrides, to do something in case texture frame was changed.\n     * Meshes based on plane can override it and change more details based on texture.\n     */\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n\n        const geometry: PlaneGeometry = this.geometry as any;\n        const { width, height } = this.shader.texture;\n\n        if (this.autoResize && (geometry.width !== width || geometry.height !== height))\n        {\n            geometry.width = this.shader.texture.width;\n            geometry.height = this.shader.texture.height;\n            geometry.build();\n        }\n    }\n\n    set texture(value: Texture)\n    {\n        // Track texture same way sprite does.\n        // For generated meshes like NineSlicePlane it can change the geometry.\n        // Unfortunately, this method might not work if you directly change texture in material.\n\n        if (this.shader.texture === value)\n        {\n            return;\n        }\n\n        this.shader.texture = value;\n        this._textureID = -1;\n\n        if (value.baseTexture.valid)\n        {\n            this.textureUpdated();\n        }\n        else\n        {\n            value.once('update', this.textureUpdated, this);\n        }\n    }\n\n    get texture(): Texture\n    {\n        return this.shader.texture;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._textureID !== this.shader.texture._updateID)\n        {\n            this.textureUpdated();\n        }\n\n        super._render(renderer);\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this.shader.texture.off('update', this.textureUpdated, this);\n        super.destroy(options);\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { SimplePlane } from './SimplePlane';\n\nimport type { ITypedArray } from '@pixi/core';\n\nconst DEFAULT_BORDER_SIZE = 10;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface NineSlicePlane extends GlobalMixins.NineSlicePlane {}\n\n/**\n * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * import { NineSlicePlane, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSlicePlane(Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n * @memberof PIXI\n */\nexport class NineSlicePlane extends SimplePlane\n{\n    private _origWidth: number;\n    private _origHeight: number;\n\n    /**\n     * The width of the left column (a).\n     * @private\n     */\n    _leftWidth: number;\n\n    /**\n     * The width of the right column (b)\n     * @private\n     */\n    _rightWidth: number;\n\n    /**\n     * The height of the top row (c)\n     * @private\n     */\n    _topHeight: number;\n\n    /**\n     * The height of the bottom row (d)\n     * @private\n     */\n    _bottomHeight: number;\n\n    /**\n     * @param texture - The texture to use on the NineSlicePlane.\n     * @param {number} [leftWidth=10] - size of the left vertical bar (A)\n     * @param {number} [topHeight=10] - size of the top horizontal bar (C)\n     * @param {number} [rightWidth=10] - size of the right vertical bar (B)\n     * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)\n     */\n    constructor(\n        texture: Texture,\n        leftWidth?: number,\n        topHeight?: number,\n        rightWidth?: number,\n        bottomHeight?: number\n    )\n    {\n        super(Texture.WHITE, 4, 4);\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._width = this._origWidth;\n\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._height = this._origHeight;\n\n        this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;\n        this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;\n        this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;\n        this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n    }\n\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n        this._refresh();\n    }\n\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    /** Updates the horizontal vertices. */\n    public updateHorizontalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - (this._bottomHeight * scale);\n        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n    }\n\n    /** Updates the vertical vertices. */\n    public updateVerticalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - (this._rightWidth * scale);\n        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n    }\n\n    /**\n     * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.\n     * @returns Smaller number of vertical and horizontal scale.\n     */\n    private _getMinScale(): number\n    {\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this._width > w ? 1.0 : this._width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this._height > h ? 1.0 : this._height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        return scale;\n    }\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n        this._refresh();\n    }\n\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this._refresh();\n    }\n\n    /** The width of the left column. */\n    get leftWidth(): number\n    {\n        return this._leftWidth;\n    }\n\n    set leftWidth(value: number)\n    {\n        this._leftWidth = value;\n        this._refresh();\n    }\n\n    /** The width of the right column. */\n    get rightWidth(): number\n    {\n        return this._rightWidth;\n    }\n\n    set rightWidth(value: number)\n    {\n        this._rightWidth = value;\n        this._refresh();\n    }\n\n    /** The height of the top row. */\n    get topHeight(): number\n    {\n        return this._topHeight;\n    }\n\n    set topHeight(value: number)\n    {\n        this._topHeight = value;\n        this._refresh();\n    }\n\n    /** The height of the bottom row. */\n    get bottomHeight(): number\n    {\n        return this._bottomHeight;\n    }\n\n    set bottomHeight(value: number)\n    {\n        this._bottomHeight = value;\n        this._refresh();\n    }\n\n    /** Refreshes NineSlicePlane coords. All of them. */\n    private _refresh(): void\n    {\n        const texture = this.texture;\n\n        const uvs = this.geometry.buffers[1].data;\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        const _uvw = 1.0 / this._origWidth;\n        const _uvh = 1.0 / this._origHeight;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.updateHorizontalVertices();\n        this.updateVerticalVertices();\n\n        this.geometry.buffers[0].update();\n        this.geometry.buffers[1].update();\n    }\n}\n", "import { Texture } from '@pixi/core';\nimport { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\n\nimport type { DRAW_MODES, IArrayBuffer, ITypedArray, Renderer } from '@pixi/core';\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link PIXI.Mesh}.\n * @memberof PIXI\n */\nexport class SimpleMesh extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(\n        texture: Texture = Texture.EMPTY,\n        vertices?: IArrayBuffer,\n        uvs?: IArrayBuffer,\n        indices?: IArrayBuffer,\n        drawMode?: DRAW_MODES\n    )\n    {\n        const geometry = new MeshGeometry(vertices, uvs, indices);\n\n        geometry.getBuffer('aVertexPosition').static = false;\n\n        const meshMaterial = new MeshMaterial(texture);\n\n        super(geometry, meshMaterial, null, drawMode);\n\n        this.autoUpdate = true;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        super._render(renderer);\n    }\n}\n", "import { WRAP_MODES } from '@pixi/core';\nimport { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { RopeGeometry } from './geometry/RopeGeometry';\n\nimport type { IPoint, Renderer, Texture } from '@pixi/core';\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n * @example\n * import { Point, SimpleRope, Texture } from 'pixi.js';\n *\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * };\n * const rope = new SimpleRope(Texture.from('snake.png'), points);\n * @memberof PIXI\n */\nexport class SimpleRope extends Mesh\n{\n    public autoUpdate: boolean;\n\n    /**\n     * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n     * @param texture - The texture to use on the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param {number} textureScale - Optional. Positive values scale rope texture\n     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n     * and downsampling here. If set to zero, texture will be stretched instead.\n     */\n    constructor(texture: Texture, points: IPoint[], textureScale = 0)\n    {\n        const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n        const meshMaterial = new MeshMaterial(texture);\n\n        if (textureScale > 0)\n        {\n            // attempt to set UV wrapping, will fail on non-power of two textures\n            texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n        }\n        super(ropeGeometry, meshMaterial);\n\n        /**\n         * re-calculate vertices by rope points each frame\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        const geometry: RopeGeometry = this.geometry as any;\n\n        if (this.autoUpdate || geometry._width !== this.shader.texture.height)\n        {\n            geometry._width = this.shader.texture.height;\n            geometry.update();\n        }\n\n        super._render(renderer);\n    }\n}\n", "/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n * @memberof PIXI\n * @static\n * @enum {string}\n */\nexport enum LINE_JOIN\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * 'miter': make a sharp corner where outer part of lines meet\n     * @default miter\n     */\n    MITER = 'miter',\n    /**\n     * 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n     * @default bevel\n     */\n    BEVEL = 'bevel',\n    /**\n     * 'round': add an arc at the joint\n     * @default round\n     */\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n * @see PIXI.Graphics#lineStyle\n * @memberof PIXI\n * @static\n * @enum {string}\n */\nexport enum LINE_CAP\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * 'butt': don't add any cap at line ends (leaves orthogonal edges)\n     * @default butt\n     */\n    BUTT = 'butt',\n    /**\n     * 'round': add semicircle at ends\n     * @default round\n     */\n    ROUND = 'round',\n    /**\n     * 'square': add square at end (like `BUTT` except more length at end)\n     * @default square\n     */\n    SQUARE = 'square'\n}\n\n/**\n * @memberof PIXI\n * @deprecated\n */\nexport interface IGraphicsCurvesSettings\n{\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * @private\n */\nexport const curves = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n\n/**\n * @static\n * @readonly\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @deprecated since 7.1.0\n * @see PIXI.Graphics.curves\n */\nexport const GRAPHICS_CURVES = curves;\n", "import type { IShape, Matrix, SHAPES } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     * The shape object to draw.\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n     */\n    shape: IShape;\n\n    /** The style of the line. */\n    lineStyle: LineStyle;\n\n    /** The style of the fill. */\n    fillStyle: FillStyle;\n\n    /** The transform matrix. */\n    matrix: Matrix;\n\n    /** The type of the shape, see the Const.Shapes file for all the existing types, */\n    type: SHAPES;\n\n    /** The collection of points. */\n    points: number[] = [];\n\n    /** The collection of holes. */\n\n    holes: Array<GraphicsData> = [];\n\n    /**\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - the width of the line to draw\n     * @param lineStyle - the color of the line to draw\n     * @param matrix - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        this.shape = shape;\n        this.lineStyle = lineStyle;\n        this.fillStyle = fillStyle;\n        this.matrix = matrix;\n        this.type = shape.type;\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     * @returns - Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /** Destroys the Graphics data. */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n", "// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n", "import { utils } from '@pixi/core';\n\nimport type { Polygon } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            fixOrientation(points, false);\n\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                fixOrientation(hole.points, true);\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = utils.earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n", "import type { Rectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return;\n        }\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n", "// for type only\nimport { buildCircle } from './buildCircle';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        buildCircle.build(graphicsData);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        buildCircle.triangulate(graphicsData, graphicsGeometry);\n    },\n};\n", "import { PI_2 } from '@pixi/core';\nimport { curves } from '../const';\n\ninterface IArcLikeShape\n{\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves.\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * Calculate information of the arc for {@link PIXI.Graphics.arcTo}.\n     * @private\n     * @param x1 - The x-coordinate of the first control point of the arc\n     * @param y1 - The y-coordinate of the first control point of the arc\n     * @param x2 - The x-coordinate of the second control point of the arc\n     * @param y2 - The y-coordinate of the second control point of the arc\n     * @param radius - The radius of the arc\n     * @param points - Collection of points to add to\n     * @returns - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @private\n     * @param _startX - Start x location of arc\n     * @param _startY - Start y location of arc\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param _anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = curves._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n}\n", "import type { FillStyle } from '../styles/FillStyle';\nimport type { LineStyle } from '../styles/LineStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part.\n     * @param style\n     * @param startIndex\n     * @param attribStart\n     */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part.\n     * @param endIndex\n     * @param endAttrib\n     */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n", "import { curves } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = curves._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n", "import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(\n        eix, eiy,\n        eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(\n            cx, cy,\n            sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx, cy,\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(\n            cx, cy,\n            ex, ey);\n    }\n    else\n    {\n        verts.push(\n            sx, sy,\n            cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)),\n                cx, cy);\n        }\n\n        verts.push(\n            ex, ey,\n            cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight), y0 - (perpy * innerWeight),\n        x0 + (perpx * outerWeight), y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight), y1 - (perp1y * outerWeight),\n                    x1 + (perp1x * innerWeight), y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        let join = style.join;\n\n        if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared)\n        {\n            join = LINE_JOIN.BEVEL;\n        }\n\n        if (insideMiterOk)\n        {\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    verts.push(\n                        imx, imy,\n                        omx, omy);\n                    break;\n                }\n                case LINE_JOIN.BEVEL:\n                {\n                    if (clockwise) /* rotating at inner angle */\n                    {\n                        verts.push(\n                            imx, imy, // inner miter point\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight), // first segment's outer vertex\n                            imx, imy, // inner miter point\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                    }\n                    else /* rotating at outer angle */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                            omx, omy, // outer miter point\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's outer vertex\n                            omx, omy); // outer miter point\n                    }\n\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        verts.push(\n                            imx, imy,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 4;\n\n                        verts.push(\n                            imx, imy,\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                    }\n                    else /* arc is inside */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            omx, omy);\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 4;\n\n                        verts.push(\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            omx, omy);\n                    }\n                    break;\n                }\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    if (clockwise)\n                    {\n                        verts.push(\n                            omx, omy, // inner miter point\n                            omx, omy); // inner miter point\n                    }\n                    else\n                    {\n                        verts.push(\n                            imx, imy, // outer miter point\n                            imx, imy); // outer miter point\n                    }\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 2;\n                    }\n                    else /* arc is inside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 2;\n                    }\n                    break;\n                }\n            }\n            verts.push(\n                x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's inner vertex\n                x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(\n        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n", "import { curves } from '../const';\n\n/**\n * Utilities for quadratic curves.\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     * @private\n     * @param fromX - x-coordinate of curve start point\n     * @param fromY - y-coordinate of curve start point\n     * @param cpX - x-coordinate of curve control point\n     * @param cpY - y-coordinate of curve control point\n     * @param toX - x-coordinate of curve end point\n     * @param toY - y-coordinate of curve end point\n     * @returns - Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @private\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = curves._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n", "/**\n * Generalized convenience utilities for Graphics.\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\n// for type only\nimport { SHAPES } from '@pixi/core';\nimport { buildCircle } from './buildCircle';\nimport { buildPoly } from './buildPoly';\nimport { buildRectangle } from './buildRectangle';\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\n\nimport type { BatchDrawCall } from '@pixi/core';\nimport type { BatchPart } from './BatchPart';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\nexport * from './ArcUtils';\nexport * from './BatchPart';\nexport * from './BezierUtils';\nexport * from './buildCircle';\nexport * from './buildLine';\nexport * from './buildPoly';\nexport * from './buildRectangle';\nexport * from './buildRoundedRectangle';\nexport * from './QuadraticUtils';\n\n/**\n * Map of fill commands for each shape type.\n * @memberof PIXI.graphicsUtils\n * @member {object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n", "import {\n    BaseTexture,\n    BatchDrawCall,\n    BatchGeometry,\n    BatchTextureArray,\n    Color,\n    DRAW_MODES,\n    Point,\n    WRAP_MODES\n} from '@pixi/core';\nimport { Bounds } from '@pixi/display';\nimport { GraphicsData } from './GraphicsData';\nimport {\n    BATCH_POOL, BatchPart, buildLine,\n    buildPoly,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS\n} from './utils';\n\nimport type { IPointData, IShape, Matrix, Texture } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /** The maximum number of points to consider an object \"batchable\", able to be batched by the renderer's batch system. */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * Since 6.5.0, bounds of the graphics geometry are calculated based on the vertices of generated geometry.\n     * Since shapes or strokes with full transparency (`alpha: 0`) will not generate geometry, they are not considered\n     * when calculating bounds for the graphics geometry. See PR [#8343]{@link https://github.com/pixijs/pixijs/pull/8343}\n     * and issue [#8623]{@link https://github.com/pixijs/pixijs/pull/8623}.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall = DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const maxTextures = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = maxTextures;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === maxTextures)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        const bgr = Color.shared\n            .setValue(color)\n            .toLittleEndianNumber();\n\n        const result = Color.shared\n            .setValue(bgr)\n            .toPremultiplied(alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = result;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n", "import { Texture } from '@pixi/core';\n\nimport type { Matrix } from '@pixi/core';\n\n/**\n * Fill style object for Graphics.\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /** The alpha value used when filling the Graphics object. */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform applied to the texture.\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /** If the current fill is visible. */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /** Clones the object */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /** Reset */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /** Destroy and don't use after this. */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n", "import { LINE_CAP, LINE_JOIN } from '../const';\nimport { FillStyle } from './FillStyle';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n */\nexport class LineStyle extends FillStyle\n{\n    /** The width (thickness) of any lines drawn. */\n    public width = 0;\n\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    public alignment = 0.5;\n\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    public native = false;\n\n    /**\n     * Line cap style.\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /** Miter limit. */\n    public miterLimit = 10;\n\n    /** Clones the object. */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /** Reset the line style to default. */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n        this.cap = LINE_CAP.BUTT;\n        this.join = LINE_JOIN.MITER;\n        this.miterLimit = 10;\n    }\n}\n", "import {\n    BLEND_MODES,\n    Circle,\n    Color,\n    Ellipse,\n    Matrix,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Shader,\n    SHAPES,\n    State,\n    Texture,\n    UniformGroup,\n} from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { curves, LINE_CAP, LINE_JOIN } from './const';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { ArcUtils, BezierUtils, QuadraticUtils } from './utils';\n\nimport type { BatchDrawCall, ColorSource, IPointData, IShape, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * Batch element computed from Graphics geometry.\n * @memberof PIXI\n */\nexport interface IGraphicsBatchElement\n{\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions\n{\n    color?: ColorSource;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions\n{\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n     * the resolution is calculated based on the curve's length to ensure better visual quality.\n     * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n     * @static\n     * @property {boolean} [adaptive=true] - flag indicating if the resolution should be adaptive\n     * @property {number} [maxLength=10] - maximal length of a single segment of the curve (if adaptive = false, ignored)\n     * @property {number} [minSegments=8] - minimal number of segments in the curve (if adaptive = false, ignored)\n     * @property {number} [maxSegments=2048] - maximal number of segments in the curve (if adaptive = false, ignored)\n     * @property {number} [epsilon=0.0001] - precision of the curve fitting\n     */\n    public static readonly curves = curves;\n\n    /**\n     * Temporary point to use for containsPoint.\n     * @private\n     */\n    static _TEMP_POINT = new Point();\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    public shader: Shader = null;\n\n    /** Renderer plugin for batching */\n    public pluginName = 'batch';\n\n    /**\n     * Current path\n     * @readonly\n     */\n    public currentPath: Polygon = null;\n\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    protected batches: Array<IGraphicsBatchElement> = [];\n\n    /** Update dirty for limiting calculating tints for batches. */\n    protected batchTint = -1;\n\n    /** Update dirty for limiting calculating batches.*/\n    protected batchDirty = -1;\n\n    /** Copy of the object vertex data. */\n    protected vertexData: Float32Array = null;\n\n    /** Current fill style. */\n    protected _fillStyle: FillStyle = new FillStyle();\n\n    /** Current line style. */\n    protected _lineStyle: LineStyle = new LineStyle();\n\n    /** Current shape transform matrix. */\n    protected _matrix: Matrix = null;\n\n    /** Current hole mode is enabled. */\n    protected _holeMode = false;\n    protected _transformID: number;\n    protected _tintColor: Color;\n\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    private state: State = State.for2d();\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        this._transformID = -1;\n\n        // Set default\n        this._tintColor = new Color(0xFFFFFF);\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     * @returns - A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    public get tint(): ColorSource\n    {\n        return this._tintColor.value;\n    }\n\n    public set tint(value: ColorSource)\n    {\n        this._tintColor.setValue(value);\n    }\n\n    /**\n     * The current fill style.\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param [width=0] - width of the line to draw, will update the objects stored style\n     * @param [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(width: number, color?: ColorSource, alpha?: number, alignment?: number, native?: boolean): this;\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     * @param options - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color: ColorSource = 0x0, alpha?: number, alignment = 0.5, native = false): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            options = { width: options, color, alpha, alignment, native } as ILineStyleOptions;\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     * @param [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {PIXI.ColorSource} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options?: ILineStyleOptions): this\n    {\n        // Apply defaults\n        const defaultLineStyleOptions: ILineStyleOptions = {\n            width: 0,\n            texture: Texture.WHITE,\n            color: options?.texture ? 0xFFFFFF : 0x0,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        };\n\n        options = Object.assign(defaultLineStyleOptions, options);\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally.\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     * @param x - the X coordinate to move to\n     * @param y - the Y coordinate to move to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     * @param x - the X coordinate to draw to\n     * @param y - the Y coordinate to draw to\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     * @param x\n     * @param y\n     */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The `arcTo` method creates an arc/curve between two tangents on the canvas.\n     * The first tangent is from the start point to the first control point,\n     * and the second tangent is from the first control point to the second control point.\n     * Note that the second control point is not necessarily the end point of the arc.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     * @param x1 - The x-coordinate of the first control point of the arc\n     * @param y1 - The y-coordinate of the first control point of the arc\n     * @param x2 - The x-coordinate of the second control point of the arc\n     * @param y2 - The y-coordinate of the second control point of the arc\n     * @param radius - The radius of the arc\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     * @param {PIXI.ColorSource} color - the color of the fill\n     * @param alpha - the alpha of the fill, will override the color's alpha\n     * @returns - This Graphics object. Suitable for chaining method calls\n     */\n    public beginFill(color: ColorSource = 0, alpha?: number): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Normalize the color input from options for line style or fill\n     * @param {PIXI.IFillStyleOptions} options - Fill style object.\n     */\n    private normalizeColor(options: Pick<IFillStyleOptions, 'color' | 'alpha'>): void\n    {\n        const temp = Color.shared.setValue(options.color ?? 0);\n\n        options.color = temp.toNumber();\n        options.alpha ??= temp.alpha;\n    }\n\n    /**\n     * Begin the texture fill.\n     * Note: The wrap mode of the texture is forced to REPEAT on render.\n     * @param options - Fill style object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {PIXI.ColorSource} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha] - Alpha of fill, overrides the color's alpha\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        const defaultOptions: IFillStyleOptions = {\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            matrix: null,\n        };\n\n        options = Object.assign(defaultOptions, options);\n\n        this.normalizeColor(options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param radius - Radius of the rectangle corners\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     * @param x - The X coordinate of the center of the circle\n     * @param y - The Y coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     * @param x - The X coordinate of the center of the ellipse\n     * @param y - The Y coordinate of the center of the ellipse\n     * @param width - The half width of the ellipse\n     * @param height - The half height of the ellipse\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<IPointData>): this;\n    public drawPolygon(path: Array<number> | Array<IPointData> | Polygon): this;\n\n    /**\n     * Draws a polygon using the given path.\n     * @param {number[]|PIXI.IPointData[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<IPointData>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n            if (Array.isArray(path[0]))\n            {\n                points = path[0];\n            }\n            else\n            {\n                points = path;\n            }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     * @returns - True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].matrix\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches();\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /** Populating batches for rendering. */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: Color.shared.setValue(color).toRgbArray(),\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1\n            };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     * @param renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     * @param renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        Color.shared.setValue(this._tintColor)\n            .premultiply(worldAlpha)\n            .toArray(uniforms.tint);\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     * @param renderer\n     * @param drawCall\n     */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     * @param renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const { maxTextures } = renderer.plugins[pluginName];\n                const sampleValues = new Int32Array(maxTextures);\n\n                for (let i = 0; i < maxTextures; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object.\n     * @see PIXI.GraphicsGeometry#bounds\n     */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     * @param point - the point to test\n     * @returns - the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this._tintColor.toNumber();\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                batch._tintRGB = Color.shared\n                    .setValue(this._tintColor)\n                    .multiply(batch._batchRGB)\n                    .toLittleEndianNumber();\n            }\n        }\n    }\n\n    /** If there's a transform update or a change to the shape of the geometry, recalculate the vertices. */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     * @returns - Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n            // ensure that the polygon is completed, and is available for hit detection\n            // (even if the graphics is not rendered yet)\n            this.finishPoly();\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     * @param matrix - Matrix to use for transform current shape.\n     * @returns - Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @returns - Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape.\n     * @returns - Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     * @param options - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n", "/// <reference path=\"../global.d.ts\" />\nimport {\n    ArcUtils,\n    BATCH_POOL,\n    BatchPart,\n    BezierUtils,\n    buildCircle,\n    buildLine,\n    buildPoly,\n    buildRectangle,\n    buildRoundedRectangle,\n    DRAW_CALL_POOL,\n    FILL_COMMANDS,\n    QuadraticUtils,\n} from './utils';\n\nimport type { BatchDrawCall, SHAPES } from '@pixi/core';\nimport type { IShapeBuildCommand } from './utils/IShapeBuildCommand';\n\nexport * from './const';\nexport * from './Graphics';\nexport * from './GraphicsData';\nexport * from './GraphicsGeometry';\nexport * from './styles/FillStyle';\nexport * from './styles/LineStyle';\n\nexport const graphicsUtils = {\n    buildPoly: buildPoly as IShapeBuildCommand,\n    buildCircle: buildCircle as IShapeBuildCommand,\n    buildRectangle: buildRectangle as IShapeBuildCommand,\n    buildRoundedRectangle: buildRoundedRectangle as IShapeBuildCommand,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS: FILL_COMMANDS as Record<SHAPES, IShapeBuildCommand>,\n    BATCH_POOL: BATCH_POOL as Array<BatchPart>,\n    DRAW_CALL_POOL: DRAW_CALL_POOL as Array<BatchDrawCall>\n};\n"],
  "mappings": "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",
  "names": ["_Container", "tempPoint", "_Mesh", "indices", "indices", "indices", "indices", "LINE_JOIN", "LINE_CAP", "indices", "indices", "indices", "_GraphicsGeometry", "i", "index", "_Graphics", "radius", "indices"]
}
