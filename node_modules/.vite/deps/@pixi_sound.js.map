{
  "version": 3,
  "sources": ["../../@pixi/sound/src/instance.ts", "../../@pixi/sound/src/htmlaudio/HTMLAudioInstance.ts", "../../@pixi/sound/src/htmlaudio/HTMLAudioMedia.ts", "../../@pixi/sound/src/SoundSprite.ts", "../../@pixi/sound/src/utils/supported.ts", "../../@pixi/sound/src/webaudio/WebAudioUtils.ts", "../../@pixi/sound/src/webaudio/WebAudioInstance.ts", "../../@pixi/sound/src/Filterable.ts", "../../@pixi/sound/src/webaudio/WebAudioNodes.ts", "../../@pixi/sound/src/webaudio/WebAudioMedia.ts", "../../@pixi/sound/src/Sound.ts", "../../@pixi/sound/src/htmlaudio/HTMLAudioContext.ts", "../../@pixi/sound/src/webaudio/WebAudioContext.ts", "../../@pixi/sound/src/SoundLibrary.ts", "../../@pixi/sound/lib/htmlaudio/index.mjs", "../../@pixi/sound/lib/filters/index.mjs", "../../@pixi/sound/src/filters/Filter.ts", "../../@pixi/sound/src/filters/EqualizerFilter.ts", "../../@pixi/sound/src/filters/DistortionFilter.ts", "../../@pixi/sound/src/filters/StereoFilter.ts", "../../@pixi/sound/src/filters/ReverbFilter.ts", "../../@pixi/sound/src/filters/MonoFilter.ts", "../../@pixi/sound/src/filters/StreamFilter.ts", "../../@pixi/sound/src/filters/TelephoneFilter.ts", "../../@pixi/sound/lib/webaudio/index.mjs", "../../@pixi/sound/lib/utils/index.mjs", "../../@pixi/sound/src/utils/playOnce.ts", "../../@pixi/sound/src/utils/render.ts", "../../@pixi/sound/src/utils/sineTone.ts", "../../@pixi/sound/src/soundAsset.ts", "../../@pixi/sound/src/index.ts"],
  "sourcesContent": ["import { SoundLibrary } from './SoundLibrary';\n\n/**\n * Singleton instance of the SoundLibrary\n */\nlet instance: SoundLibrary;\n\n/**\n * Internal set function for the singleton instance.\n * @ignore\n * @param sound - - Sound library instance\n */\nfunction setInstance(sound: SoundLibrary): SoundLibrary\n{\n    instance = sound;\n\n    return sound;\n}\n\n/**\n * Internal get function for the singleton instance.\n * @ignore\n */\nfunction getInstance(): SoundLibrary\n{\n    return instance;\n}\n\nexport { instance, setInstance, getInstance };\n", "import { utils, Ticker } from '@pixi/core';\nimport { IMediaInstance } from '../interfaces/IMediaInstance';\nimport { PlayOptions } from '../Sound';\nimport { HTMLAudioMedia } from './HTMLAudioMedia';\nimport { Filter } from '../filters/Filter';\n\nlet id = 0;\n\n/**\n * Instance which wraps the `<audio>` element playback.\n * @memberof htmlaudio\n * @extends PIXI.util.EventEmitter\n */\nclass HTMLAudioInstance extends utils.EventEmitter implements IMediaInstance\n{\n    /** Extra padding, in seconds, to deal with low-latecy of HTMLAudio. */\n    public static readonly PADDING: number = 0.1;\n\n    /** The current unique ID for this instance. */\n    public readonly id: number;\n\n    /** The instance of the Audio element. */\n    private _source: HTMLAudioElement;\n\n    /** The instance of the Audio media element. */\n    private _media: HTMLAudioMedia;\n\n    /** Playback rate, where 1 is 100%. */\n    private _end: number;\n\n    /** Current instance paused state. */\n    private _paused: boolean;\n\n    /** Current instance muted state. */\n    private _muted: boolean;\n\n    /** Current actual paused state. */\n    private _pausedReal: boolean;\n\n    /** Total length of the audio. */\n    private _duration: number;\n\n    /** Playback rate, where 1 is 100%. */\n    private _start: number;\n\n    /** `true` if the audio is actually playing. */\n    private _playing: boolean;\n\n    /** Volume for the instance. */\n    private _volume: number;\n\n    /** Speed for the instance. */\n    private _speed: number;\n\n    /** `true` for looping the playback */\n    private _loop: boolean;\n\n    /** @param parent - Parent element */\n    constructor(parent: HTMLAudioMedia)\n    {\n        super();\n\n        this.id = id++;\n\n        this.init(parent);\n    }\n\n    /**\n     * Set a property by name, this makes it easy to chain values\n     * @param name - Name of the property to set\n     * @param value - Value to set property to\n     */\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\n    {\n        if (this[name] === undefined)\n        {\n            throw new Error(`Property with name ${name} does not exist.`);\n        }\n        else\n        {\n            switch (name)\n            {\n                case 'speed': this.speed = value as number; break;\n                case 'volume': this.volume = value as number; break;\n                case 'paused': this.paused = value as boolean; break;\n                case 'loop': this.loop = value as boolean; break;\n                case 'muted': this.muted = value as boolean; break;\n            }\n        }\n\n        return this;\n    }\n\n    /** The current playback progress from 0 to 1. */\n    public get progress(): number\n    {\n        const { currentTime } = this._source;\n\n        return currentTime / this._duration;\n    }\n\n    /** Pauses the sound. */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /**\n     * Reference: http://stackoverflow.com/a/40370077\n     * @private\n     */\n    private _onPlay(): void\n    {\n        this._playing = true;\n    }\n\n    /**\n     * Reference: http://stackoverflow.com/a/40370077\n     * @private\n     */\n    private _onPause(): void\n    {\n        this._playing = false;\n    }\n\n    /**\n     * Initialize the instance.\n     * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor\n     */\n    public init(media: HTMLAudioMedia): void\n    {\n        this._playing = false;\n        this._duration = media.source.duration;\n        const source = this._source = media.source.cloneNode(false) as HTMLAudioElement;\n\n        source.src = media.parent.url;\n        source.onplay = this._onPlay.bind(this);\n        source.onpause = this._onPause.bind(this);\n        media.context.on('refresh', this.refresh, this);\n        media.context.on('refreshPaused', this.refreshPaused, this);\n        this._media = media;\n    }\n\n    /**\n     * Stop the sound playing\n     * @private\n     */\n    private _internalStop(): void\n    {\n        if (this._source && this._playing)\n        {\n            this._source.onended = null;\n            this._source.pause();\n        }\n    }\n\n    /** Stop the sound playing */\n    public stop(): void\n    {\n        this._internalStop();\n\n        if (this._source)\n        {\n            this.emit('stop');\n        }\n    }\n\n    /** Set the instance speed from 0 to 1 */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n    }\n\n    /** Get the set the volume for this instance from 0 to 1 */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /** If the sound instance should loop playback */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /** `true` if the sound is muted */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /**\n     * HTML Audio does not support filters, this is non-functional API.\n     */\n    public get filters(): Filter[]\n    {\n        console.warn('HTML Audio does not support filters');\n\n        return null;\n    }\n    public set filters(_filters: Filter[])\n    {\n        console.warn('HTML Audio does not support filters');\n    }\n\n    /** Call whenever the loop, speed or volume changes */\n    public refresh(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Update the looping\n        this._source.loop = this._loop || sound.loop;\n\n        // Update the volume\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\n\n        this._source.volume = instanceVolume * globalVolume * soundVolume;\n\n        // Update the speed\n        this._source.playbackRate = this._speed * global.speed * sound.speed;\n    }\n\n    /** Handle changes in paused state, either globally or sound or instance */\n    public refreshPaused(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Handle the paused state\n        const pausedReal = this._paused || sound.paused || global.paused;\n\n        if (pausedReal !== this._pausedReal)\n        {\n            this._pausedReal = pausedReal;\n\n            if (pausedReal)\n            {\n                this._internalStop();\n\n                /**\n                 * The sound is paused.\n                 * @event paused\n                 */\n                this.emit('paused');\n            }\n            else\n            {\n                /**\n                 * The sound is unpaused.\n                 * @event resumed\n                 */\n                this.emit('resumed');\n\n                // resume the playing with offset\n                this.play({\n                    start: this._source.currentTime,\n                    end: this._end,\n                    volume: this._volume,\n                    speed: this._speed,\n                    loop: this._loop,\n                });\n            }\n\n            /**\n             * The sound is paused or unpaused.\n             * @event pause\n             * @property {boolean} paused - If the instance was paused or not.\n             */\n            this.emit('pause', pausedReal);\n        }\n    }\n\n    /** Start playing the sound/ */\n    public play(options: PlayOptions): void\n    {\n        const { start, end, speed, loop, volume, muted } = options;\n\n        if (end)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(end > start, 'End time is before start time');\n        }\n\n        this._speed = speed;\n        this._volume = volume;\n        this._loop = !!loop;\n        this._muted = muted;\n        this.refresh();\n\n        // WebAudio doesn't support looping when a duration is set\n        // we'll set this just for the heck of it\n        if (this.loop && end !== null)\n        {\n            console.warn('Looping not support when specifying an \"end\" time');\n            this.loop = false;\n        }\n\n        this._start = start;\n        this._end = end || this._duration;\n\n        // Lets expand the start and end a little\n        // to deal with the low-latecy of playing audio this way\n        // this is a little fudge-factor\n        this._start = Math.max(0, this._start - HTMLAudioInstance.PADDING);\n        this._end = Math.min(this._end + HTMLAudioInstance.PADDING, this._duration);\n\n        this._source.onloadedmetadata = () =>\n        {\n            if (this._source)\n            {\n                this._source.currentTime = start;\n                this._source.onloadedmetadata = null;\n                this.emit('progress', start, this._duration);\n                Ticker.shared.add(this._onUpdate, this);\n            }\n        };\n        this._source.onended = this._onComplete.bind(this);\n        this._source.play();\n\n        /**\n         * The sound is started.\n         * @event start\n         */\n        this.emit('start');\n    }\n\n    /**\n     * Handle time update on sound.\n     * @private\n     */\n    private _onUpdate(): void\n    {\n        this.emit('progress', this.progress, this._duration);\n        if (this._source.currentTime >= this._end && !this._source.loop)\n        {\n            this._onComplete();\n        }\n    }\n\n    /**\n     * Callback when completed.\n     * @private\n     */\n    private _onComplete(): void\n    {\n        Ticker.shared.remove(this._onUpdate, this);\n        this._internalStop();\n        this.emit('progress', 1, this._duration);\n        /**\n         * The sound ends, don't use after this\n         * @event end\n         */\n        this.emit('end', this);\n    }\n\n    /** Don't use after this. */\n    public destroy(): void\n    {\n        Ticker.shared.remove(this._onUpdate, this);\n        this.removeAllListeners();\n\n        const source = this._source;\n\n        if (source)\n        {\n            // Remove the listeners\n            source.onended = null;\n            source.onplay = null;\n            source.onpause = null;\n\n            this._internalStop();\n        }\n\n        this._source = null;\n        this._speed = 1;\n        this._volume = 1;\n        this._loop = false;\n        this._end = null;\n        this._start = 0;\n        this._duration = 0;\n        this._playing = false;\n        this._pausedReal = false;\n        this._paused = false;\n        this._muted = false;\n\n        if (this._media)\n        {\n            this._media.context.off('refresh', this.refresh, this);\n            this._media.context.off('refreshPaused', this.refreshPaused, this);\n            this._media = null;\n        }\n    }\n\n    /**\n     * To string method for instance.\n     * @return The string representation of instance.\n     */\n    public toString(): string\n    {\n        return `[HTMLAudioInstance id=${this.id}]`;\n    }\n}\n\nexport { HTMLAudioInstance };\n", "import { utils } from '@pixi/core';\nimport { Filter } from '../filters/Filter';\nimport { IMedia } from '../interfaces/IMedia';\nimport { LoadedCallback, Sound } from '../Sound';\nimport { HTMLAudioContext } from './HTMLAudioContext';\nimport { HTMLAudioInstance } from './HTMLAudioInstance';\n\n/**\n * The fallback version of Sound which uses `<audio>` instead of WebAudio API.\n * @memberof htmlaudio\n * @extends PIXI.util.EventEmitter\n */\nclass HTMLAudioMedia extends utils.EventEmitter implements IMedia\n{\n    public parent: Sound;\n    private _source: HTMLAudioElement;\n\n    public init(parent: Sound): void\n    {\n        this.parent = parent;\n        this._source = parent.options.source as HTMLAudioElement || new Audio();\n        if (parent.url)\n        {\n            this._source.src = parent.url;\n        }\n    }\n\n    // Implement create\n    public create(): HTMLAudioInstance\n    {\n        return new HTMLAudioInstance(this);\n    }\n\n    /**\n     * If the audio media is playable (ready).\n     * @readonly\n     */\n    public get isPlayable(): boolean\n    {\n        return !!this._source && this._source.readyState === 4;\n    }\n\n    /**\n     * THe duration of the media in seconds.\n     * @readonly\n     */\n    public get duration(): number\n    {\n        return this._source.duration;\n    }\n\n    /**\n     * Reference to the context.\n     * @readonly\n     */\n    public get context(): HTMLAudioContext\n    {\n        return this.parent.context as HTMLAudioContext;\n    }\n\n    /** The collection of filters, does not apply to HTML Audio. */\n    public get filters(): Filter[]\n    {\n        return null;\n    }\n    public set filters(_filters: Filter[])\n    {\n        console.warn('HTML Audio does not support filters');\n    }\n\n    // Override the destroy\n    public destroy(): void\n    {\n        this.removeAllListeners();\n\n        this.parent = null;\n\n        if (this._source)\n        {\n            this._source.src = '';\n            this._source.load();\n            this._source = null;\n        }\n    }\n\n    /**\n     * Get the audio source element.\n     * @type {HTMLAudioElement}\n     * @readonly\n     */\n    public get source(): HTMLAudioElement\n    {\n        return this._source;\n    }\n\n    // Implement the method to being preloading\n    public load(callback?: LoadedCallback): void\n    {\n        const source = this._source;\n        const sound = this.parent;\n\n        // See if the source is already loaded\n        if (source.readyState === 4)\n        {\n            sound.isLoaded = true;\n            const instance = sound.autoPlayStart();\n\n            if (callback)\n            {\n                setTimeout(() =>\n                {\n                    callback(null, sound, instance);\n                }, 0);\n            }\n\n            return;\n        }\n\n        // If there's no source, we cannot load\n        if (!sound.url)\n        {\n            callback(new Error('sound.url or sound.source must be set'));\n\n            return;\n        }\n\n        // Set the source\n        source.src = sound.url;\n\n        const onLoad = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            sound.isLoaded = true;\n            const instance = sound.autoPlayStart();\n\n            if (callback)\n            {\n                callback(null, sound, instance);\n            }\n        };\n\n        const onAbort = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            if (callback)\n            {\n                callback(new Error('Sound loading has been aborted'));\n            }\n        };\n\n        const onError = () =>\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            removeListeners();\n            const message = `Failed to load audio element (code: ${source.error.code})`;\n\n            if (callback)\n            {\n                callback(new Error(message));\n            }\n            else\n            {\n                console.error(message);\n            }\n        };\n\n        // Remove all event listeners\n        const removeListeners = () =>\n        {\n            // Listen for callback\n            source.removeEventListener('canplaythrough', onLoad);\n            source.removeEventListener('load', onLoad);\n            source.removeEventListener('abort', onAbort);\n            source.removeEventListener('error', onError);\n        };\n\n        // Listen for callback\n        source.addEventListener('canplaythrough', onLoad, false);\n        source.addEventListener('load', onLoad, false);\n        source.addEventListener('abort', onAbort, false);\n        source.addEventListener('error', onError, false);\n\n        // Begin the loading\n        source.load();\n    }\n}\n\nexport { HTMLAudioMedia };\n", "import { IMediaInstance } from './interfaces';\nimport { CompleteCallback, Sound } from './Sound';\n\n/** Data for adding new sound sprites. */\ninterface SoundSpriteData\n{\n    /** The start time in seconds. */\n    start: number;\n    /** The end time in seconds. */\n    end: number;\n    /** The optional speed, if not speed, uses the default speed of the parent. */\n    speed?: number;\n}\n\n// Collection of sound sprites\ntype SoundSprites = Record<string, SoundSprite>;\n\n/**\n * Object that represents a single Sound's sprite. To add sound sprites\n * use the {@link Sound#addSprites} method.\n * @example\n * import { sound } from '@pixi/sound';\n * sound.add('alias', {\n *   url: 'path/to/file.ogg',\n *   sprites: {\n *     blast: { start: 0, end: 0.2 },\n *     boom: { start: 0.3, end: 0.5 },\n *   },\n *   loaded() {\n *     sound.play('alias', 'blast');\n *   }\n * );\n *\n */\nclass SoundSprite\n{\n    /**\n     * The reference sound\n     * @readonly\n     */\n    public parent: Sound;\n\n    /**\n     * The starting location in seconds.\n     * @readonly\n     */\n    public start: number;\n\n    /**\n     * The ending location in seconds\n     * @readonly\n     */\n    public end: number;\n\n    /**\n     * The speed override where 1 is 100% speed playback.\n     * @readonly\n     */\n    public speed: number;\n\n    /**\n     * The duration of the sound in seconds.\n     * @readonly\n     */\n    public duration: number;\n\n    /**\n     * Whether to loop the sound sprite.\n     * @readonly\n     */\n    public loop: boolean;\n\n    /**\n     * @param parent - The parent sound\n     * @param options - Data associated with object.\n     */\n    constructor(parent: Sound, options: SoundSpriteData)\n    {\n        this.parent = parent;\n        Object.assign(this, options);\n        this.duration = this.end - this.start;\n\n        // eslint-disable-next-line no-console\n        console.assert(this.duration > 0, 'End time must be after start time');\n    }\n\n    /**\n     * Play the sound sprite.\n     * @param {Function} [complete] - Function call when complete\n     * @return Sound instance being played.\n     */\n    public play(complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\n    {\n        return this.parent.play({\n            complete,\n            speed: this.speed || this.parent.speed,\n            end: this.end,\n            start: this.start,\n            loop: this.loop });\n    }\n\n    /** Destroy and don't use after this */\n    public destroy(): void\n    {\n        this.parent = null;\n    }\n}\n\nexport type { SoundSprites, SoundSpriteData };\nexport { SoundSprite };\n", "type ExtensionMap = Record<string, boolean>;\n\n/**\n * The list of extensions that can be played. This is the preferred order of playback.\n * If you want to priority the order of playback, you can use this array to do so.\n * @readonly\n * @memberof utils\n */\nconst extensions: string[] = [\n    'ogg',\n    'oga',\n    'opus',\n    'm4a',\n    'mp3',\n    'mpeg',\n    'wav',\n    'aiff',\n    'wma',\n    'mid',\n    'caf',\n];\n\nconst mimes: string[] = [\n    'audio/mpeg',\n    'audio/ogg',\n];\n\n/**\n * The list of browser supported audio formats.\n * @readonly\n * @memberof utils\n * @property {boolean} mp3 - `true` if file-type is supported\n * @property {boolean} ogg - `true` if file-type is supported\n * @property {boolean} oga - `true` if file-type is supported\n * @property {boolean} opus - `true` if file-type is supported\n * @property {boolean} mpeg - `true` if file-type is supported\n * @property {boolean} wav - `true` if file-type is supported\n * @property {boolean} aiff - `true` if file-type is supported\n * @property {boolean} wma - `true` if file-type is supported\n * @property {boolean} mid - `true` if file-type is supported\n * @property {boolean} caf - `true` if file-type is supported. Note that for this we check if the\n *                             'opus' codec is supported inside the caf container.\n */\nconst supported: ExtensionMap = {};\n\n/**\n * Function to validate file type formats. This is called when the library initializes, but can\n * be called again if you need to recognize a format not listed in `utils.extensions` at\n * initialization.\n * @memberof utils\n * @param typeOverrides - - Dictionary of type overrides (inputs for\n *                                 AudioElement.canPlayType()), keyed by extension from the\n *                                 utils.extensions array.\n */\nfunction validateFormats(typeOverrides?: Record<string, string>): void\n{\n    const overrides: Record<string, string> = {\n        m4a: 'audio/mp4',\n        oga: 'audio/ogg',\n        opus: 'audio/ogg; codecs=\"opus\"',\n        caf: 'audio/x-caf; codecs=\"opus\"', ...(typeOverrides || {}) };\n    const audio = document.createElement('audio');\n    const formats: ExtensionMap = {};\n    const no = /^no$/;\n\n    extensions.forEach((ext) =>\n    {\n        const canByExt = audio.canPlayType(`audio/${ext}`).replace(no, '');\n        const canByType = overrides[ext] ? audio.canPlayType(overrides[ext]).replace(no, '') : '';\n\n        formats[ext] = !!canByExt || !!canByType;\n    });\n    Object.assign(supported, formats);\n}\n\n// initialize supported\nvalidateFormats();\n\nexport {\n    validateFormats,\n    supported,\n    extensions,\n    mimes,\n};\n", "import { getInstance } from '../instance';\nimport { WebAudioContext } from './WebAudioContext';\n\n/**\n * Internal class for Web Audio abstractions and convenience methods.\n * @memberof webaudio\n */\nclass WebAudioUtils\n{\n    /**\n     * Dezippering is removed in the future Web Audio API, instead\n     * we use the `setValueAtTime` method, however, this is not available\n     * in all environments (e.g., Android webview), so we fallback to the `value` setter.\n     * @param param - AudioNode parameter object\n     * @param value - Value to set\n     * @return The value set\n     */\n    public static setParamValue(param: AudioParam, value: number): number\n    {\n        if (param.setValueAtTime)\n        {\n            const context = getInstance().context as WebAudioContext;\n\n            param.setValueAtTime(value, context.audioContext.currentTime);\n        }\n        else\n        {\n            param.value = value;\n        }\n\n        return value;\n    }\n}\n\nexport { WebAudioUtils };\n", "import { utils, Ticker } from '@pixi/core';\nimport { IMediaInstance } from '../interfaces';\nimport { PlayOptions } from '../Sound';\nimport { WebAudioMedia } from './WebAudioMedia';\nimport { WebAudioUtils } from './WebAudioUtils';\nimport { Filter } from '../filters/Filter';\n\nlet id = 0;\n\n/**\n * A single play instance that handles the AudioBufferSourceNode.\n * @memberof webaudio\n * @extends PIXI.utils.EventEmitter\n */\nclass WebAudioInstance extends utils.EventEmitter implements IMediaInstance\n{\n    /**\n     * The current unique ID for this instance.\n     * @readonly\n     */\n    public readonly id: number;\n\n    /** The source Sound. */\n    private _media: WebAudioMedia;\n\n    /** true if paused. */\n    private _paused: boolean;\n\n    /** true if muted. */\n    private _muted: boolean;\n\n    /** true if paused. */\n    private _pausedReal: boolean;\n\n    /** The instance volume */\n    private _volume: number;\n\n    /** Last update frame number. */\n    private _lastUpdate: number;\n\n    /** The total number of seconds elapsed in playback. */\n    private _elapsed: number;\n\n    /** Playback rate, where 1 is 100%. */\n    private _speed: number;\n\n    /** Playback rate, where 1 is 100%. */\n    private _end: number;\n\n    /** `true` if should be looping. */\n    private _loop: boolean;\n\n    /** Gain node for controlling volume of instance */\n    private _gain: GainNode;\n\n    /** Length of the sound in seconds. */\n    private _duration: number;\n\n    /** The progress of the sound from 0 to 1. */\n    private _progress: number;\n\n    /** Audio buffer source clone from Sound object. */\n    private _source: AudioBufferSourceNode;\n\n    /** The filters */\n    private _filters: Filter[];\n\n    constructor(media: WebAudioMedia)\n    {\n        super();\n\n        this.id = id++;\n        this._media = null;\n        this._paused = false;\n        this._muted = false;\n        this._elapsed = 0;\n\n        // Initialize\n        this.init(media);\n    }\n\n    /**\n     * Set a property by name, this makes it easy to chain values\n     * @param name - Name of the property to set.\n     * @param value - Value to set property to.\n     */\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\n    {\n        if (this[name] === undefined)\n        {\n            throw new Error(`Property with name ${name} does not exist.`);\n        }\n        else\n        {\n            switch (name)\n            {\n                case 'speed': this.speed = value as number; break;\n                case 'volume': this.volume = value as number; break;\n                case 'muted': this.muted = value as boolean; break;\n                case 'loop': this.loop = value as boolean; break;\n                case 'paused': this.paused = value as boolean; break;\n            }\n        }\n\n        return this;\n    }\n\n    /** Stops the instance, don't use after this. */\n    public stop(): void\n    {\n        if (this._source)\n        {\n            this._internalStop();\n            this.emit('stop');\n        }\n    }\n\n    /** Set the instance speed from 0 to 1 */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n        this._update(true); // update progress\n    }\n\n    /** Get the set the volume for this instance from 0 to 1 */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /** `true` if the sound is muted */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /** If the sound instance should loop playback */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /** The collection of filters. */\n    public get filters(): Filter[]\n    {\n        return this._filters;\n    }\n    public set filters(filters: Filter[])\n    {\n        if (this._filters)\n        {\n            this._filters?.filter((filter) => filter).forEach((filter) => filter.disconnect());\n            this._filters = null;\n            // Reconnect direct path\n            this._source.connect(this._gain);\n        }\n        this._filters = filters?.length ? filters.slice(0) : null;\n        this.refresh();\n    }\n\n    /** Refresh loop, volume and speed based on changes to parent */\n    public refresh(): void\n    {\n        // Sound could be paused\n        if (!this._source)\n        {\n            return;\n        }\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Updating looping\n        this._source.loop = this._loop || sound.loop;\n\n        // Update the volume\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\n\n        WebAudioUtils.setParamValue(this._gain.gain, instanceVolume * soundVolume * globalVolume);\n\n        // Update the speed\n        WebAudioUtils.setParamValue(this._source.playbackRate, this._speed * sound.speed * global.speed);\n\n        this.applyFilters();\n    }\n\n    /** Connect filters nodes to audio context */\n    private applyFilters(): void\n    {\n        if (this._filters?.length)\n        {\n            // Disconnect direct path before inserting filters\n            this._source.disconnect();\n\n            // Connect each filter\n            let source: { connect: (node: AudioNode) => void } = this._source;\n\n            this._filters.forEach((filter: Filter) =>\n            {\n                source.connect(filter.destination);\n                source = filter;\n            });\n            source.connect(this._gain);\n        }\n    }\n\n    /** Handle changes in paused state, either globally or sound or instance */\n    public refreshPaused(): void\n    {\n        const global = this._media.context;\n        const sound = this._media.parent;\n\n        // Consider global and sound paused\n        const pausedReal = this._paused || sound.paused || global.paused;\n\n        if (pausedReal !== this._pausedReal)\n        {\n            this._pausedReal = pausedReal;\n\n            if (pausedReal)\n            {\n                // pause the sounds\n                this._internalStop();\n\n                /**\n                 * The sound is paused.\n                 * @event paused\n                 */\n                this.emit('paused');\n            }\n            else\n            {\n                /**\n                 * The sound is unpaused.\n                 * @event resumed\n                 */\n                this.emit('resumed');\n\n                // resume the playing with offset\n                this.play({\n                    start: this._elapsed % this._duration,\n                    end: this._end,\n                    speed: this._speed,\n                    loop: this._loop,\n                    volume: this._volume,\n                });\n            }\n\n            /**\n             * The sound is paused or unpaused.\n             * @event pause\n             * @property {boolean} paused - If the instance was paused or not.\n             */\n            this.emit('pause', pausedReal);\n        }\n    }\n\n    /**\n     * Plays the sound.\n     * @param options - Play options.\n     */\n    public play(options: PlayOptions): void\n    {\n        const { start, end, speed, loop, volume, muted, filters } = options;\n\n        if (end)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(end > start, 'End time is before start time');\n        }\n        this._paused = false;\n        const { source, gain } = this._media.nodes.cloneBufferSource();\n\n        this._source = source;\n        this._gain = gain;\n        this._speed = speed;\n        this._volume = volume;\n        this._loop = !!loop;\n        this._muted = muted;\n        this._filters = filters;\n        this.refresh();\n\n        const duration: number = this._source.buffer.duration;\n\n        this._duration = duration;\n        this._end = end;\n        this._lastUpdate = this._now();\n        this._elapsed = start;\n        this._source.onended = this._onComplete.bind(this);\n\n        if (this._loop)\n        {\n            this._source.loopEnd = end;\n            this._source.loopStart = start;\n            this._source.start(0, start);\n        }\n        else if (end)\n        {\n            this._source.start(0, start, end - start);\n        }\n        else\n        {\n            this._source.start(0, start);\n        }\n\n        /**\n         * The sound is started.\n         * @event start\n         */\n        this.emit('start');\n\n        // Do an update for the initial progress\n        this._update(true);\n\n        // Start handling internal ticks\n        this.enableTicker(true);\n    }\n\n    /** Start the update progress. */\n    private enableTicker(enabled: boolean): void\n    {\n        Ticker.shared.remove(this._updateListener, this);\n        if (enabled)\n        {\n            Ticker.shared.add(this._updateListener, this);\n        }\n    }\n\n    /** The current playback progress from 0 to 1. */\n    public get progress(): number\n    {\n        return this._progress;\n    }\n\n    /** Pauses the sound. */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /** Don't use after this. */\n    public destroy(): void\n    {\n        this.removeAllListeners();\n        this._internalStop();\n        if (this._gain)\n        {\n            this._gain.disconnect();\n            this._gain = null;\n        }\n        if (this._media)\n        {\n            this._media.context.events.off('refresh', this.refresh, this);\n            this._media.context.events.off('refreshPaused', this.refreshPaused, this);\n            this._media = null;\n        }\n        this._filters?.forEach((filter) => filter.disconnect());\n        this._filters = null;\n        this._end = null;\n        this._speed = 1;\n        this._volume = 1;\n        this._loop = false;\n        this._elapsed = 0;\n        this._duration = 0;\n        this._paused = false;\n        this._muted = false;\n        this._pausedReal = false;\n    }\n\n    /**\n     * To string method for instance.\n     * @return The string representation of instance.\n     */\n    public toString(): string\n    {\n        return `[WebAudioInstance id=${this.id}]`;\n    }\n\n    /**\n     * Get the current time in seconds.\n     * @return Seconds since start of context\n     */\n    private _now(): number\n    {\n        return this._media.context.audioContext.currentTime;\n    }\n\n    /** Callback for update listener */\n    private _updateListener()\n    {\n        this._update();\n    }\n\n    /** Internal update the progress. */\n    private _update(force = false): void\n    {\n        if (this._source)\n        {\n            const now: number = this._now();\n            const delta: number = now - this._lastUpdate;\n\n            if (delta > 0 || force)\n            {\n                const speed: number = this._source.playbackRate.value;\n\n                this._elapsed += delta * speed;\n                this._lastUpdate = now;\n                const duration: number = this._duration;\n                let progress: number;\n\n                if (this._source.loopStart)\n                {\n                    const soundLength = this._source.loopEnd - this._source.loopStart;\n\n                    progress = (this._source.loopStart + (this._elapsed % soundLength)) / duration;\n                }\n                else\n                {\n                    progress = (this._elapsed % duration) / duration;\n                }\n\n                // Update the progress\n                this._progress = progress;\n\n                /**\n                 * The sound progress is updated.\n                 * @event progress\n                 * @property {number} progress - Amount progressed from 0 to 1\n                 * @property {number} duration - The total playback in seconds\n                 */\n                this.emit('progress', this._progress, duration);\n            }\n        }\n    }\n\n    /** Initializes the instance. */\n    public init(media: WebAudioMedia): void\n    {\n        this._media = media;\n        media.context.events.on('refresh', this.refresh, this);\n        media.context.events.on('refreshPaused', this.refreshPaused, this);\n    }\n\n    /** Stops the instance. */\n    private _internalStop(): void\n    {\n        if (this._source)\n        {\n            this.enableTicker(false);\n            this._source.onended = null;\n            this._source.stop(0); // param needed for iOS 8 bug\n            this._source.disconnect();\n            try\n            {\n                this._source.buffer = null;\n            }\n            catch (err)\n            {\n                // try/catch workaround for bug in older Chrome versions\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n            }\n            this._source = null;\n        }\n    }\n\n    /** Callback when completed. */\n    private _onComplete(): void\n    {\n        if (this._source)\n        {\n            this.enableTicker(false);\n            this._source.onended = null;\n            this._source.disconnect();\n            try\n            {\n                this._source.buffer = null;\n            }\n            catch (err)\n            {\n                // try/catch workaround for bug in older Chrome versions\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n            }\n        }\n        this._source = null;\n        this._progress = 1;\n        this.emit('progress', 1, this._duration);\n        /**\n         * The sound ends, don't use after this\n         * @event end\n         */\n        this.emit('end', this);\n    }\n}\n\nexport { WebAudioInstance };\n", "import { Filter } from './filters/Filter';\n\n/**\n * Abstract class which SoundNodes and SoundContext\n * both extend. This provides the functionality for adding\n * dynamic filters.\n */\nclass Filterable\n{\n    /** Get the gain node */\n    private _input: AudioNode;\n\n    /** The destination output audio node */\n    private _output: AudioNode;\n\n    /** Collection of filters. */\n    private _filters: Filter[];\n\n    /**\n     * @param input - The source audio node\n     * @param output - The output audio node\n     */\n    constructor(input: AudioNode, output: AudioNode)\n    {\n        this._output = output;\n        this._input = input;\n    }\n\n    /** The destination output audio node */\n    get destination(): AudioNode\n    {\n        return this._input;\n    }\n\n    /** The collection of filters. */\n    get filters(): Filter[]\n    {\n        return this._filters;\n    }\n    set filters(filters: Filter[])\n    {\n        if (this._filters)\n        {\n            this._filters.forEach((filter: Filter) =>\n            {\n                if (filter)\n                {\n                    filter.disconnect();\n                }\n            });\n            this._filters = null;\n            // Reconnect direct path\n            this._input.connect(this._output);\n        }\n\n        if (filters && filters.length)\n        {\n            this._filters = filters.slice(0);\n\n            // Disconnect direct path before inserting filters\n            this._input.disconnect();\n\n            // Connect each filter\n            let prevFilter: Filter = null;\n\n            filters.forEach((filter: Filter) =>\n            {\n                if (prevFilter === null)\n                {\n                    // first filter is the destination\n                    // for the analyser\n                    this._input.connect(filter.destination);\n                }\n                else\n                {\n                    prevFilter.connect(filter.destination);\n                }\n                prevFilter = filter;\n            });\n            prevFilter.connect(this._output);\n        }\n    }\n\n    /** Cleans up. */\n    public destroy(): void\n    {\n        this.filters = null;\n        this._input = null;\n        this._output = null;\n    }\n}\n\nexport { Filterable };\n", "import { Filterable } from '../Filterable';\nimport { WebAudioContext } from './WebAudioContext';\nimport { WebAudioUtils } from './WebAudioUtils';\n\n/** Output for cloning source node. */\ninterface SourceClone\n{\n    /** Cloned audio buffer source */\n    source: AudioBufferSourceNode;\n    /** Independent volume control */\n    gain: GainNode;\n}\n\n/**\n * @memberof webaudio\n */\nclass WebAudioNodes extends Filterable\n{\n    /**\n     * The buffer size for script processor, default is `0` which auto-detects. If you plan to use\n     * script node on iOS, you'll need to provide a non-zero amount.\n     * @default 0\n     */\n    public static BUFFER_SIZE = 0;\n\n    /**\n     * Get the buffer source node\n     * @readonly\n     */\n    public bufferSource: AudioBufferSourceNode;\n\n    /**\n     * Get the gain node\n     * @readonly\n     */\n    public gain: GainNode;\n\n    /**\n     * Get the analyser node\n     * @readonly\n     */\n    public analyser: AnalyserNode;\n\n    /**\n     * Reference to the SoundContext\n     * @readonly\n     */\n    public context: WebAudioContext;\n\n    /** Private reference to the script processor node. */\n    private _script: ScriptProcessorNode;\n\n    /**\n     * @param context - The audio context.\n     */\n    constructor(context: WebAudioContext)\n    {\n        const audioContext: AudioContext = context.audioContext;\n\n        const bufferSource: AudioBufferSourceNode = audioContext.createBufferSource();\n        const gain: GainNode = audioContext.createGain();\n        const analyser: AnalyserNode = audioContext.createAnalyser();\n\n        bufferSource.connect(analyser);\n        analyser.connect(gain);\n        gain.connect(context.destination);\n\n        super(analyser, gain);\n\n        this.context = context;\n        this.bufferSource = bufferSource;\n        this.gain = gain;\n        this.analyser = analyser;\n    }\n\n    /**\n     * Get the script processor node.\n     * @readonly\n     */\n    public get script(): ScriptProcessorNode\n    {\n        if (!this._script)\n        {\n            this._script = this.context.audioContext.createScriptProcessor(WebAudioNodes.BUFFER_SIZE);\n            this._script.connect(this.context.destination);\n        }\n\n        return this._script;\n    }\n\n    /** Cleans up. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        this.bufferSource.disconnect();\n        if (this._script)\n        {\n            this._script.disconnect();\n        }\n        this.gain.disconnect();\n        this.analyser.disconnect();\n\n        this.bufferSource = null;\n        this._script = null;\n        this.gain = null;\n        this.analyser = null;\n\n        this.context = null;\n    }\n\n    /**\n     * Clones the bufferSource. Used just before playing a sound.\n     * @returns {SourceClone} The clone AudioBufferSourceNode.\n     */\n    public cloneBufferSource(): SourceClone\n    {\n        const orig: AudioBufferSourceNode = this.bufferSource;\n        const source: AudioBufferSourceNode = this.context.audioContext.createBufferSource();\n\n        source.buffer = orig.buffer;\n        WebAudioUtils.setParamValue(source.playbackRate, orig.playbackRate.value);\n        source.loop = orig.loop;\n\n        const gain: GainNode = this.context.audioContext.createGain();\n\n        source.connect(gain);\n        gain.connect(this.destination);\n\n        return { source, gain };\n    }\n\n    /**\n     * Get buffer size of `ScriptProcessorNode`.\n     * @readonly\n     */\n    get bufferSize(): number\n    {\n        return this.script.bufferSize;\n    }\n}\n\nexport type { SourceClone };\nexport { WebAudioNodes };\n", "import { settings } from '@pixi/core';\nimport { Filter } from '../filters/Filter';\nimport { IMedia } from '../interfaces/IMedia';\nimport { LoadedCallback, Sound } from '../Sound';\nimport { WebAudioContext } from './WebAudioContext';\nimport { WebAudioInstance } from './WebAudioInstance';\nimport { WebAudioNodes } from './WebAudioNodes';\n\n/**\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\n * @memberof webaudio\n */\nclass WebAudioMedia implements IMedia\n{\n    /**\n     * Reference to the parent Sound container.\n     * @readonly\n     */\n    public parent: Sound;\n\n    /**\n     * The file buffer to load.\n     * @readonly\n     */\n    public source: ArrayBuffer | AudioBuffer;\n\n    /** Instance of the chain builder. */\n    private _nodes: WebAudioNodes;\n\n    /** Instance of the source node. */\n    private _source: AudioBufferSourceNode;\n\n    /**\n     * Re-initialize without constructing.\n     * @param parent - - Instance of parent Sound container\n     */\n    public init(parent: Sound): void\n    {\n        this.parent = parent;\n        this._nodes = new WebAudioNodes(this.context);\n        this._source = this._nodes.bufferSource;\n        this.source = parent.options.source as ArrayBuffer | AudioBuffer;\n    }\n\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\n    public destroy(): void\n    {\n        this.parent = null;\n        this._nodes.destroy();\n        this._nodes = null;\n        try\n        {\n            this._source.buffer = null;\n        }\n        catch (err)\n        {\n            // try/catch workaround for bug in older Chrome versions\n            console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\n        }\n        this._source = null;\n        this.source = null;\n    }\n\n    // Implement create\n    public create(): WebAudioInstance\n    {\n        return new WebAudioInstance(this);\n    }\n\n    // Implement context\n    public get context(): WebAudioContext\n    {\n        return this.parent.context as WebAudioContext;\n    }\n\n    // Implement isPlayable\n    public get isPlayable(): boolean\n    {\n        return !!this._source && !!this._source.buffer;\n    }\n\n    // Implement filters\n    public get filters(): Filter[]\n    {\n        return this._nodes.filters;\n    }\n    public set filters(filters: Filter[])\n    {\n        this._nodes.filters = filters;\n    }\n\n    // Implements duration\n    public get duration(): number\n    {\n        // eslint-disable-next-line no-console\n        console.assert(this.isPlayable, 'Sound not yet playable, no duration');\n\n        return this._source.buffer.duration;\n    }\n\n    /** Gets and sets the buffer. */\n    public get buffer(): AudioBuffer\n    {\n        return this._source.buffer;\n    }\n    public set buffer(buffer: AudioBuffer)\n    {\n        this._source.buffer = buffer;\n    }\n\n    /** Get the current chained nodes object */\n    public get nodes(): WebAudioNodes\n    {\n        return this._nodes;\n    }\n\n    // Implements load\n    public load(callback?: LoadedCallback): void\n    {\n        // Load from the arraybuffer, incase it was loaded outside\n        if (this.source)\n        {\n            this._decode(this.source, callback);\n        }\n        // Load from the file path\n        else if (this.parent.url)\n        {\n            this._loadUrl(callback);\n        }\n        else if (callback)\n        {\n            callback(new Error('sound.url or sound.source must be set'));\n        }\n        else\n        {\n            console.error('sound.url or sound.source must be set');\n        }\n    }\n\n    /** Loads a sound using XHMLHttpRequest object. */\n    private async _loadUrl(callback?: LoadedCallback): Promise<void>\n    {\n        const url: string = this.parent.url;\n        const response = await settings.ADAPTER.fetch(url);\n\n        this._decode(await response.arrayBuffer(), callback);\n    }\n\n    /**\n     * Decodes the array buffer.\n     * @param arrayBuffer - From load.\n     * @param {Function} callback - Callback optional\n     */\n    private _decode(arrayBuffer: ArrayBuffer | AudioBuffer, callback?: LoadedCallback): void\n    {\n        const audioBufferReadyFn = (err: Error, buffer: AudioBuffer) =>\n        {\n            if (err)\n            {\n                if (callback)\n                {\n                    callback(err);\n                }\n            }\n            else\n            {\n                this.parent.isLoaded = true;\n                this.buffer = buffer;\n                const instance = this.parent.autoPlayStart();\n\n                if (callback)\n                {\n                    callback(null, this.parent, instance);\n                }\n            }\n        };\n\n        if (arrayBuffer instanceof AudioBuffer)\n        {\n            audioBufferReadyFn(null, arrayBuffer);\n        }\n        else\n        {\n            const context = this.parent.context as WebAudioContext;\n\n            context.decode(arrayBuffer, audioBufferReadyFn);\n        }\n    }\n}\n\nexport { WebAudioMedia };\n", "import { utils } from '@pixi/core';\nimport { Filter } from './filters/Filter';\nimport { HTMLAudioMedia } from './htmlaudio/HTMLAudioMedia';\nimport { getInstance } from './instance';\nimport { IMedia, IMediaContext, IMediaInstance } from './interfaces';\nimport { SoundSprite, SoundSpriteData, SoundSprites } from './SoundSprite';\nimport { extensions, supported } from './utils/supported';\nimport { WebAudioMedia } from './webaudio/WebAudioMedia';\n\n/**\n * Options to use for creating sounds.\n */\ninterface Options\n{\n    /**\n     * `true` to immediately start preloading.\n     * @default false\n     */\n    autoPlay?: boolean;\n    /**\n     * `true` to disallow playing multiple layered instances at once.\n     * @default false\n     */\n    singleInstance?: boolean;\n    /**\n     * The amount of volume 1 = 100%.\n     * @default 1\n     */\n    volume?: number;\n    /**\n     * The playback rate where 1 is 100% speed.\n     * @default 1\n     */\n    speed?: number;\n    /**\n     * Global complete callback when play is finished.\n     * @type {Function}\n     */\n    complete?: CompleteCallback;\n    /**\n     * Call when finished loading.\n     * @type {Function}\n     */\n    loaded?: LoadedCallback;\n    /**\n     * `true` to immediately start preloading if loading from `url`.\n     */\n    preload?: boolean;\n    /**\n     * Initial loop value, `true` is loop infinitely\n     * @default false\n     */\n    loop?: boolean;\n    /**\n     * The source of the file being loaded\n     */\n    url?: string | string[];\n    /**\n     * If sound is already preloaded, available.\n     */\n    source?: ArrayBuffer | AudioBuffer | HTMLAudioElement;\n    /**\n     * The map of sprite data. Where a sprite is an object\n     * with a `start` and `end`, which are the times in seconds. Optionally, can include\n     * a `speed` amount where 1 is 100% speed.\n     */\n    sprites?: Record<string, SoundSpriteData>;\n}\n\n/**\n * Options used for sound playback.\n */\ninterface PlayOptions\n{\n    /**\n     * Start time offset in seconds.\n     * @default 0\n     */\n    start?: number;\n    /**\n     * End time in seconds.\n     */\n    end?: number;\n    /**\n     * Override default speed, default to the Sound's speed setting.\n     */\n    speed?: number;\n    /**\n    * Override default loop, default to the Sound's loop setting.\n    */\n    loop?: boolean;\n    /**\n     * Override default volume, default to the Sound's volume setting.\n     */\n    volume?: number;\n    /**\n     * The sprite to play.\n     */\n    sprite?: string;\n    /**\n     * If sound instance is muted by default.\n     * @default false\n     */\n    muted?: boolean;\n    /**\n     * Filters that apply to play.\n     * Only supported with WebAudio.\n     */\n    filters?: Filter[];\n    /**\n     * When completed.\n     * @type {Function}\n     */\n    complete?: CompleteCallback;\n    /**\n     * If not already preloaded, callback when finishes load.\n     * @type {Function}\n     */\n    loaded?: LoadedCallback;\n    /**\n     * Setting `true` will stop any playing instances. This is the same as\n     * the singleInstance property on Sound, but is play-specific.\n     */\n    singleInstance?: boolean;\n}\n\n/**\n * Callback when sound is loaded.\n * @ignore\n * @param {Error} err - The callback error.\n * @param {Sound} sound - The instance of new sound.\n * @param {IMediaInstance} instance - The instance of auto-played sound.\n */\ntype LoadedCallback = (err: Error, sound?: Sound, instance?: IMediaInstance) => void;\n\n/**\n * Callback when sound is completed.\n * @ignore\n * @param {Sound} sound - The instance of sound.\n */\ntype CompleteCallback = (sound: Sound) => void;\n\ntype SoundSpriteDataMap = Record<string, SoundSpriteData>;\n\n/**\n * Sound represents a single piece of loaded media. When playing a sound {@link IMediaInstance} objects\n * are created. Properties such a `volume`, `pause`, `mute`, `speed`, etc will have an effect on all instances.\n */\nclass Sound\n{\n    /** Pool of instances */\n    private static _pool: IMediaInstance[] = [];\n\n    /**\n     * `true` if the buffer is loaded.\n     * @default false\n     */\n    public isLoaded: boolean;\n\n    /**\n     * `true` if the sound is currently being played.\n     * @default false\n     * @readonly\n     */\n    public isPlaying: boolean;\n\n    /**\n     * true to start playing immediate after load.\n     * @default false\n     * @readonly\n     */\n    public autoPlay: boolean;\n\n    /**\n     * `true` to disallow playing multiple layered instances at once.\n     * @default false\n     */\n    public singleInstance: boolean;\n\n    /**\n     * `true` to immediately start preloading.\n     * @default false\n     * @readonly\n     */\n    public preload: boolean;\n\n    /**\n     * The file source to load.\n     * @readonly\n     */\n    public url: string;\n\n    /**\n     * The constructor options.\n     * @readonly\n     */\n    public options: Options;\n\n    /** The audio source */\n    public media: IMedia;\n\n    /** The list of play calls while waiting to preload the sound. */\n    private _preloadQueue: (() => void)[] | null;\n\n    /** The collection of instances being played. */\n    private _instances: IMediaInstance[];\n\n    /** The user defined sound sprites. */\n    private _sprites: SoundSprites;\n\n    /** The options when auto-playing. */\n    private _autoPlayOptions: PlayOptions;\n\n    /** The internal volume. */\n    private _volume: number;\n\n    /** The internal paused state. */\n    private _paused: boolean;\n\n    /** The internal muted state. */\n    private _muted: boolean;\n\n    /** The internal volume. */\n    private _loop: boolean;\n\n    /** The internal playbackRate */\n    private _speed: number;\n\n    /**\n     * Create a new sound instance from source.\n     * @param source - Either the path or url to the source file.\n     *        or the object of options to use.\n     * @return Created sound instance.\n     */\n    public static from(source: string | string[] | Options | ArrayBuffer | HTMLAudioElement | AudioBuffer): Sound\n    {\n        let options: Options = {};\n\n        if (typeof source === 'string')\n        {\n            options.url = source as string;\n        }\n        else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement)\n        {\n            options.source = source;\n        }\n        else if (Array.isArray(source))\n        {\n            options.url = source;\n        }\n        else\n        {\n            options = source;\n        }\n\n        // Default settings\n        options = {\n            autoPlay: false,\n            singleInstance: false,\n            url: null,\n            source: null,\n            preload: false,\n            volume: 1,\n            speed: 1,\n            complete: null,\n            loaded: null,\n            loop: false, ...options };\n\n        Object.freeze(options);\n\n        const media: IMedia = getInstance().useLegacy\n            ? new HTMLAudioMedia()\n            : new WebAudioMedia();\n\n        return new Sound(media, options);\n    }\n\n    /**\n     * Use `Sound.from`\n     * @ignore\n     */\n    constructor(media: IMedia, options: Options)\n    {\n        this.media = media;\n        this.options = options;\n        this._instances = [];\n        this._sprites = {};\n\n        this.media.init(this);\n\n        const complete = options.complete;\n\n        this._autoPlayOptions = complete ? { complete } : null;\n        this.isLoaded = false;\n        this._preloadQueue = null;\n        this.isPlaying = false;\n        this.autoPlay = options.autoPlay;\n        this.singleInstance = options.singleInstance;\n        this.preload = options.preload || this.autoPlay;\n\n        this.url = Array.isArray(options.url)\n            ? this.preferUrl(options.url)\n            : options.url;\n        this.speed = options.speed;\n        this.volume = options.volume;\n        this.loop = options.loop;\n\n        if (options.sprites)\n        {\n            this.addSprites(options.sprites);\n        }\n\n        if (this.preload)\n        {\n            this._preload(options.loaded);\n        }\n    }\n\n    /**\n     * Internal help for resolving which file to use if there are multiple provide\n     * this is especially helpful for working with bundlers (non Assets loading).\n     */\n    private preferUrl(urls: string[]): string\n    {\n        const [file] = urls\n            .map((url) => ({ url, ext: utils.path.extname(url).slice(1) }))\n            .filter(({ ext }) => supported[ext])\n            .sort((a, b) => extensions.indexOf(a.ext) - extensions.indexOf(b.ext));\n\n        if (!file)\n        {\n            throw new Error('No supported file type found');\n        }\n\n        return file.url;\n    }\n\n    /** Instance of the media context. */\n    public get context(): IMediaContext\n    {\n        return getInstance().context;\n    }\n\n    /** Stops all the instances of this sound from playing. */\n    public pause(): this\n    {\n        this.isPlaying = false;\n        this.paused = true;\n\n        return this;\n    }\n\n    /** Resuming all the instances of this sound from playing */\n    public resume(): this\n    {\n        this.isPlaying = this._instances.length > 0;\n        this.paused = false;\n\n        return this;\n    }\n\n    /** Stops all the instances of this sound from playing. */\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n    public set paused(paused: boolean)\n    {\n        this._paused = paused;\n        this.refreshPaused();\n    }\n\n    /** The playback rate. */\n    public get speed(): number\n    {\n        return this._speed;\n    }\n    public set speed(speed: number)\n    {\n        this._speed = speed;\n        this.refresh();\n    }\n\n    /** Set the filters. Only supported with WebAudio. */\n    public get filters(): Filter[]\n    {\n        return this.media.filters;\n    }\n    public set filters(filters: Filter[])\n    {\n        this.media.filters = filters;\n    }\n\n    /**\n     * Add a sound sprite, which is a saved instance of a longer sound.\n     * Similar to an image spritesheet.\n     * @param alias - The unique name of the sound sprite.\n     * @param data - Either completed function or play options.\n     */\n    public addSprites(alias: string, data: SoundSpriteData): SoundSprite;\n\n    /**\n     * Convenience method to add more than one sprite add a time.\n     * @param data - Map of sounds to add where the key is the alias,\n     *        and the data are configuration options.\n     * @return The map of sound sprites added.\n     */\n    public addSprites(data: SoundSpriteDataMap): SoundSprites;\n\n    /**\n     * @ignore\n     */\n    public addSprites(source: string | SoundSpriteDataMap, data?: SoundSpriteData): any\n    {\n        if (typeof source === 'object')\n        {\n            const results: SoundSprites = {};\n\n            for (const alias in source)\n            {\n                results[alias] = this.addSprites(alias, source[alias]);\n            }\n\n            return results;\n        }\n\n        // eslint-disable-next-line no-console\n        console.assert(!this._sprites[source], `Alias ${source} is already taken`);\n        const sprite = new SoundSprite(this, data);\n\n        this._sprites[source] = sprite;\n\n        return sprite;\n    }\n\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\n    public destroy(): void\n    {\n        this._removeInstances();\n        this.removeSprites();\n        this.media.destroy();\n        this.media = null;\n        this._sprites = null;\n        this._instances = null;\n    }\n\n    /**\n     * Remove a sound sprite.\n     * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.\n     */\n    public removeSprites(alias?: string): Sound\n    {\n        if (!alias)\n        {\n            for (const name in this._sprites)\n            {\n                this.removeSprites(name);\n            }\n        }\n        else\n        {\n            const sprite: SoundSprite = this._sprites[alias];\n\n            if (sprite !== undefined)\n            {\n                sprite.destroy();\n                delete this._sprites[alias];\n            }\n        }\n\n        return this;\n    }\n\n    /** If the current sound is playable (loaded). */\n    public get isPlayable(): boolean\n    {\n        return this.isLoaded && this.media && this.media.isPlayable;\n    }\n\n    /** Stops all the instances of this sound from playing. */\n    public stop(): this\n    {\n        if (!this.isPlayable)\n        {\n            this.autoPlay = false;\n            this._autoPlayOptions = null;\n\n            return this;\n        }\n        this.isPlaying = false;\n\n        // Go in reverse order so we don't skip items\n        for (let i = this._instances.length - 1; i >= 0; i--)\n        {\n            this._instances[i].stop();\n        }\n\n        return this;\n    }\n\n    /**\n     * Play a sound sprite, which is a saved instance of a longer sound.\n     * Similar to an image spritesheet.\n     * @method play\n     * @instance\n     * @param alias - The unique name of the sound sprite.\n     * @param {Function} callback - Callback when completed.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(alias: string, callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\n\n    /**\n     * Plays the sound.\n     * @method play\n     * @instance\n     * @param {Function|PlayOptions} source - Either completed function or play options.\n     * @param {Function} callback - Callback when completed.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(source?: string | PlayOptions | CompleteCallback,\n        callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\n\n    // Overloaded function\n    public play(source?: string | PlayOptions | CompleteCallback,\n        complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\n    {\n        let options: PlayOptions;\n\n        if (typeof source === 'string')\n        {\n            const sprite: string = source as string;\n\n            options = { sprite, loop: this.loop, complete };\n        }\n        else if (typeof source === 'function')\n        {\n            options = {};\n            options.complete = source as CompleteCallback;\n        }\n        else\n        {\n            options = source as PlayOptions;\n        }\n\n        options = {\n            complete: null,\n            loaded: null,\n            sprite: null,\n            end: null,\n            start: 0,\n            volume: 1,\n            speed: 1,\n            muted: false,\n            loop: false, ...(options || {}) };\n\n        // A sprite is specified, add the options\n        if (options.sprite)\n        {\n            const alias: string = options.sprite;\n\n            // eslint-disable-next-line no-console\n            console.assert(!!this._sprites[alias], `Alias ${alias} is not available`);\n            const sprite: SoundSprite = this._sprites[alias];\n\n            options.start = sprite.start + (options.start || 0);\n            options.end = sprite.end;\n            options.speed = sprite.speed || 1;\n            options.loop = sprite.loop || options.loop;\n            delete options.sprite;\n        }\n\n        // @deprecated offset option\n        if ((options as any).offset)\n        {\n            options.start = (options as any).offset as number;\n        }\n\n        // if not yet playable, ignore\n        // - usefull when the sound download isnt yet completed\n        if (!this.isLoaded)\n        {\n            // Handle the case when trying to play a sound that is not yet loaded\n            // We'll add it to a queue to play after initial load finishes\n            if (this._preloadQueue)\n            {\n                return new Promise<IMediaInstance>((resolve) =>\n                {\n                    this._preloadQueue.push(() =>\n                    {\n                        resolve(this.play(options));\n                    });\n                });\n            }\n\n            this._preloadQueue = [];\n            this.autoPlay = true;\n            this._autoPlayOptions = options;\n\n            return new Promise<IMediaInstance>((resolve, reject) =>\n            {\n                this._preload((err: Error, sound: Sound, media: IMediaInstance) =>\n                {\n                    this._preloadQueue.forEach((resolve) => resolve());\n                    this._preloadQueue = null;\n\n                    if (err)\n                    {\n                        reject(err);\n                    }\n                    else\n                    {\n                        if (options.loaded)\n                        {\n                            options.loaded(err, sound, media);\n                        }\n                        resolve(media);\n                    }\n                });\n            });\n        }\n\n        // Stop all sounds\n        if (this.singleInstance || options.singleInstance)\n        {\n            this._removeInstances();\n        }\n\n        // clone the bufferSource\n        const instance = this._createInstance();\n\n        this._instances.push(instance);\n        this.isPlaying = true;\n        instance.once('end', () =>\n        {\n            if (options.complete)\n            {\n                options.complete(this);\n            }\n            this._onComplete(instance);\n        });\n        instance.once('stop', () =>\n        {\n            this._onComplete(instance);\n        });\n\n        instance.play(options);\n\n        return instance;\n    }\n\n    /** Internal only, speed, loop, volume change occured. */\n    public refresh(): void\n    {\n        const len = this._instances.length;\n\n        for (let i = 0; i < len; i++)\n        {\n            this._instances[i].refresh();\n        }\n    }\n\n    /** Handle changes in paused state. Internal only. */\n    public refreshPaused(): void\n    {\n        const len = this._instances.length;\n\n        for (let i = 0; i < len; i++)\n        {\n            this._instances[i].refreshPaused();\n        }\n    }\n\n    /** Gets and sets the volume. */\n    public get volume(): number\n    {\n        return this._volume;\n    }\n    public set volume(volume: number)\n    {\n        this._volume = volume;\n        this.refresh();\n    }\n\n    /** Gets and sets the muted flag. */\n    public get muted(): boolean\n    {\n        return this._muted;\n    }\n    public set muted(muted: boolean)\n    {\n        this._muted = muted;\n        this.refresh();\n    }\n\n    /** Gets and sets the looping. */\n    public get loop(): boolean\n    {\n        return this._loop;\n    }\n    public set loop(loop: boolean)\n    {\n        this._loop = loop;\n        this.refresh();\n    }\n\n    /** Starts the preloading of sound. */\n    private _preload(callback?: LoadedCallback): void\n    {\n        this.media.load(callback);\n    }\n\n    /** Gets the list of instances that are currently being played of this sound. */\n    public get instances(): IMediaInstance[]\n    {\n        return this._instances;\n    }\n\n    /** Get the map of sprites. */\n    public get sprites(): SoundSprites\n    {\n        return this._sprites;\n    }\n\n    /** Get the duration of the audio in seconds. */\n    public get duration(): number\n    {\n        return this.media.duration;\n    }\n\n    /** Auto play the first instance. */\n    public autoPlayStart(): IMediaInstance\n    {\n        let instance: IMediaInstance;\n\n        if (this.autoPlay)\n        {\n            instance = this.play(this._autoPlayOptions) as IMediaInstance;\n        }\n\n        return instance;\n    }\n\n    /** Removes all instances. */\n    private _removeInstances(): void\n    {\n        // destroying also stops\n        for (let i = this._instances.length - 1; i >= 0; i--)\n        {\n            this._poolInstance(this._instances[i]);\n        }\n        this._instances.length = 0;\n    }\n\n    /**\n     * Sound instance completed.\n     * @param instance\n     */\n    private _onComplete(instance: IMediaInstance): void\n    {\n        if (this._instances)\n        {\n            const index = this._instances.indexOf(instance);\n\n            if (index > -1)\n            {\n                this._instances.splice(index, 1);\n            }\n            this.isPlaying = this._instances.length > 0;\n        }\n        this._poolInstance(instance);\n    }\n\n    /** Create a new instance. */\n    private _createInstance(): IMediaInstance\n    {\n        if (Sound._pool.length > 0)\n        {\n            const instance: IMediaInstance = Sound._pool.pop();\n\n            instance.init(this.media);\n\n            return instance;\n        }\n\n        return this.media.create();\n    }\n\n    /**\n     * Destroy/recycling the instance object.\n     * @param instance - Instance to recycle\n     */\n    private _poolInstance(instance: IMediaInstance): void\n    {\n        instance.destroy();\n        // Add it if it isn't already added\n        if (Sound._pool.indexOf(instance) < 0)\n        {\n            Sound._pool.push(instance);\n        }\n    }\n}\n\nexport { Sound };\nexport type {\n    Options,\n    PlayOptions,\n    LoadedCallback,\n    CompleteCallback,\n    SoundSpriteDataMap\n};\n", "import { utils } from '@pixi/core';\nimport { Filter } from '../filters/Filter';\nimport { IMediaContext } from '../interfaces/IMediaContext';\n\n/**\n * The fallback version of WebAudioContext which uses `<audio>` instead of WebAudio API.\n * @memberof htmlaudio\n * @extends PIXI.util.EventEmitter\n */\nclass HTMLAudioContext extends utils.EventEmitter implements IMediaContext\n{\n    /** Current global speed from 0 to 1 */\n    public speed = 1;\n\n    /** Current muted status of the context */\n    public muted = false;\n\n    /** Current volume from 0 to 1  */\n    public volume = 1;\n\n    /** Current paused status */\n    public paused = false;\n\n    /** Internal trigger when volume, mute or speed changes */\n    public refresh(): void\n    {\n        this.emit('refresh');\n    }\n\n    /** Internal trigger paused changes */\n    public refreshPaused(): void\n    {\n        this.emit('refreshPaused');\n    }\n\n    /**\n     * HTML Audio does not support filters, this is non-functional API.\n     */\n    public get filters(): Filter[]\n    {\n        console.warn('HTML Audio does not support filters');\n\n        return null;\n    }\n    public set filters(_filters: Filter[])\n    {\n        console.warn('HTML Audio does not support filters');\n    }\n\n    /**\n     * HTML Audio does not support `audioContext`\n     * @readonly\n     * @type {AudioContext}\n     */\n    public get audioContext(): AudioContext\n    {\n        console.warn('HTML Audio does not support audioContext');\n\n        return null;\n    }\n\n    /**\n     * Toggles the muted state.\n     * @return The current muted state.\n     */\n    public toggleMute(): boolean\n    {\n        this.muted = !this.muted;\n        this.refresh();\n\n        return this.muted;\n    }\n\n    /**\n     * Toggles the paused state.\n     * @return The current paused state.\n     */\n    public togglePause(): boolean\n    {\n        this.paused = !this.paused;\n        this.refreshPaused();\n\n        return this.paused;\n    }\n\n    /** Destroy and don't use after this */\n    public destroy(): void\n    {\n        this.removeAllListeners();\n    }\n}\n\nexport { HTMLAudioContext };\n", "import { utils } from '@pixi/core';\nimport { Filterable } from '../Filterable';\nimport { IMediaContext } from '../interfaces';\n\n/**\n * Main class to handle WebAudio API. There's a simple chain\n * of AudioNode elements: analyser > compressor > context.destination.\n * any filters that are added are inserted between the analyser and compressor nodes\n * @memberof webaudio\n */\nclass WebAudioContext extends Filterable implements IMediaContext\n{\n    /**\n     * Context Compressor node\n     * @readonly\n     */\n    public compressor: DynamicsCompressorNode;\n\n    /**\n     * Context Analyser node\n     * @readonly\n     */\n    public analyser: AnalyserNode;\n\n    /**\n     * Global speed of all sounds\n     * @readonly\n     */\n    public speed: number;\n\n    /**\n     * Sets the muted state.\n     * @default false\n     */\n    public muted: boolean;\n\n    /**\n     * Sets the volume from 0 to 1.\n     * @default 1\n     */\n    public volume: number;\n\n    /**\n     * Handle global events\n     * @type {PIXI.utils.EventEmitter}\n     */\n    public events: utils.EventEmitter;\n\n    /** The instance of the AudioContext for WebAudio API. */\n    private _ctx: AudioContext;\n\n    /** The instance of the OfflineAudioContext for fast decoding audio. */\n    private _offlineCtx: OfflineAudioContext;\n\n    /** Current paused status */\n    private _paused: boolean;\n\n    /**\n     * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\n     * empty sound.\n     */\n    private _locked: boolean;\n\n    /** The paused state when blurring the current window */\n    private _pausedOnBlur: boolean;\n\n    /** Set to false ignore suspending when window is blurred */\n    public autoPause = true;\n\n    constructor()\n    {\n        const win: any = window as any;\n        const ctx = new WebAudioContext.AudioContext();\n        const compressor: DynamicsCompressorNode = ctx.createDynamicsCompressor();\n        const analyser: AnalyserNode = ctx.createAnalyser();\n\n        // setup the end of the node chain\n        analyser.connect(compressor);\n        compressor.connect(ctx.destination);\n\n        super(analyser, compressor);\n\n        this._ctx = ctx;\n        // ios11 safari's webkitOfflineAudioContext allows only 44100 Hz sample rate\n        //\n        // For the sample rate value passed to OfflineAudioContext constructor,\n        // all browsers are required to support a range of 8000 to 96000.\n        // Reference:\n        // https://www.w3.org/TR/webaudio/#dom-offlineaudiocontext-offlineaudiocontext-numberofchannels-length-samplerate\n        this._offlineCtx = new WebAudioContext.OfflineAudioContext(1, 2,\n            (win.OfflineAudioContext) ? Math.max(8000, Math.min(96000, ctx.sampleRate)) : 44100);\n\n        this.compressor = compressor;\n        this.analyser = analyser;\n        this.events = new utils.EventEmitter();\n\n        // Set the defaults\n        this.volume = 1;\n        this.speed = 1;\n        this.muted = false;\n        this.paused = false;\n\n        this._locked = ctx.state === 'suspended' && ('ontouchstart' in globalThis || 'onclick' in globalThis);\n\n        // Listen for document level clicks to unlock WebAudio. See the _unlock method.\n        if (this._locked)\n        {\n            this._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\n            this._unlock = this._unlock.bind(this);\n            document.addEventListener('mousedown', this._unlock, true);\n            document.addEventListener('touchstart', this._unlock, true);\n            document.addEventListener('touchend', this._unlock, true);\n        }\n\n        this.onFocus = this.onFocus.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        globalThis.addEventListener('focus', this.onFocus);\n        globalThis.addEventListener('blur', this.onBlur);\n    }\n\n    /** Handle mobile WebAudio context resume */\n    private onFocus(): void\n    {\n        if (!this.autoPause)\n        {\n            return;\n        }\n        // Safari uses the non-standard \"interrupted\" state in some cases\n        // such as when the app loses focus because the screen is locked\n        // or when the user switches to another app.\n        const state = this._ctx.state as 'suspended' | 'interrupted';\n\n        if (state === 'suspended' || state === 'interrupted' || !this._locked)\n        {\n            this.paused = this._pausedOnBlur;\n            this.refreshPaused();\n        }\n    }\n\n    /** Handle mobile WebAudio context suspend */\n    private onBlur(): void\n    {\n        if (!this.autoPause)\n        {\n            return;\n        }\n        if (!this._locked)\n        {\n            this._pausedOnBlur = this._paused;\n            this.paused = true;\n            this.refreshPaused();\n        }\n    }\n\n    /**\n     * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\n     * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\n     * will fail if the user presses for too long, indicating a scroll event instead of a click event.\n     *\n     * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\n     * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\n     * stick with `mousedown` and `touchend`.\n     */\n    private _unlock(): void\n    {\n        if (!this._locked)\n        {\n            return;\n        }\n        this.playEmptySound();\n        if (this._ctx.state === 'running')\n        {\n            document.removeEventListener('mousedown', this._unlock, true);\n            document.removeEventListener('touchend', this._unlock, true);\n            document.removeEventListener('touchstart', this._unlock, true);\n            this._locked = false;\n        }\n    }\n\n    /**\n     * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\n     * require the first sound to be played inside of a user initiated event (touch/click).\n     */\n    public playEmptySound(): void\n    {\n        const source = this._ctx.createBufferSource();\n\n        source.buffer = this._ctx.createBuffer(1, 1, 22050);\n        source.connect(this._ctx.destination);\n        source.start(0, 0, 0);\n        if (source.context.state === 'suspended')\n        {\n            (source.context as AudioContext).resume();\n        }\n    }\n\n    /**\n     * Get AudioContext class, if not supported returns `null`\n     * @type {AudioContext}\n     * @readonly\n     */\n    public static get AudioContext(): typeof AudioContext\n    {\n        const win: any = window as any;\n\n        return (\n            win.AudioContext\n            || win.webkitAudioContext\n            || null\n        );\n    }\n\n    /**\n     * Get OfflineAudioContext class, if not supported returns `null`\n     * @type {OfflineAudioContext}\n     * @readonly\n     */\n    public static get OfflineAudioContext(): typeof OfflineAudioContext\n    {\n        const win: any = window as any;\n\n        return (\n            win.OfflineAudioContext\n            || win.webkitOfflineAudioContext\n            || null\n        );\n    }\n\n    /** Destroy this context. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        const ctx: any = this._ctx as any;\n        // check if browser supports AudioContext.close()\n\n        if (typeof ctx.close !== 'undefined')\n        {\n            ctx.close();\n        }\n        globalThis.removeEventListener('focus', this.onFocus);\n        globalThis.removeEventListener('blur', this.onBlur);\n        this.events.removeAllListeners();\n        this.analyser.disconnect();\n        this.compressor.disconnect();\n        this.analyser = null;\n        this.compressor = null;\n        this.events = null;\n        this._offlineCtx = null;\n        this._ctx = null;\n    }\n\n    /**\n     * The WebAudio API AudioContext object.\n     * @readonly\n     * @type {AudioContext}\n     */\n    public get audioContext(): AudioContext\n    {\n        return this._ctx;\n    }\n\n    /**\n     * The WebAudio API OfflineAudioContext object.\n     * @readonly\n     * @type {OfflineAudioContext}\n     */\n    public get offlineContext(): OfflineAudioContext\n    {\n        return this._offlineCtx;\n    }\n\n    /**\n     * Pauses all sounds, even though we handle this at the instance\n     * level, we'll also pause the audioContext so that the\n     * time used to compute progress isn't messed up.\n     * @default false\n     */\n    public set paused(paused: boolean)\n    {\n        if (paused && this._ctx.state === 'running')\n        {\n            this._ctx.suspend();\n        }\n        else if (!paused && this._ctx.state === 'suspended')\n        {\n            this._ctx.resume();\n        }\n        this._paused = paused;\n    }\n    public get paused(): boolean\n    {\n        return this._paused;\n    }\n\n    /** Emit event when muted, volume or speed changes */\n    public refresh(): void\n    {\n        this.events.emit('refresh');\n    }\n\n    /** Emit event when muted, volume or speed changes */\n    public refreshPaused(): void\n    {\n        this.events.emit('refreshPaused');\n    }\n\n    /**\n     * Toggles the muted state.\n     * @return The current muted state.\n     */\n    public toggleMute(): boolean\n    {\n        this.muted = !this.muted;\n        this.refresh();\n\n        return this.muted;\n    }\n\n    /**\n     * Toggles the paused state.\n     * @return The current muted state.\n     */\n    public togglePause(): boolean\n    {\n        this.paused = !this.paused;\n        this.refreshPaused();\n\n        return this._paused;\n    }\n\n    /**\n     * Decode the audio data\n     * @param arrayBuffer - Buffer from loader\n     * @param callback - When completed, error and audioBuffer are parameters.\n     */\n    public decode(arrayBuffer: ArrayBuffer, callback: (err?: Error, buffer?: AudioBuffer) => void): void\n    {\n        const handleError = (err: Error) =>\n        {\n            callback(new Error(err?.message || 'Unable to decode file'));\n        };\n        const result = this._offlineCtx.decodeAudioData(\n            arrayBuffer, (buffer: AudioBuffer) =>\n            {\n                callback(null, buffer);\n            },\n            handleError,\n        );\n        // Reference: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData\n        // decodeAudioData return value: Void, or a Promise object that fulfills with the decodedData.\n\n        if (result)\n        {\n            result.catch(handleError);\n        }\n    }\n}\n\nexport { WebAudioContext };\n", "import { Filter } from './filters/Filter';\nimport { IMediaContext } from './interfaces/IMediaContext';\nimport { IMediaInstance } from './interfaces/IMediaInstance';\nimport { CompleteCallback, Options, PlayOptions, Sound } from './Sound';\nimport { HTMLAudioContext } from './htmlaudio/HTMLAudioContext';\nimport { WebAudioContext } from './webaudio/WebAudioContext';\n\ntype SoundSourceMap = Record<string, Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement>;\ntype SoundMap = Record<string, Sound>;\n\n/**\n * Manages the playback of sounds. This is the main class for PixiJS Sound. If you're\n * using the browser-based bundled this is `PIXI.sound`. Otherwise, you can do this:\n * @example\n * import { sound } from '@pixi/sound';\n *\n * // sound is an instance of SoundLibrary\n * sound.add('my-sound', 'path/to/file.mp3');\n * sound.play('my-sound');\n */\nclass SoundLibrary\n{\n    /**\n     * For legacy approach for Audio. Instead of using WebAudio API\n     * for playback of sounds, it will use HTML5 `<audio>` element.\n     */\n    private _useLegacy: boolean;\n\n    /** The global context to use. */\n    private _context: IMediaContext;\n\n    /** The WebAudio specific context */\n    private _webAudioContext: WebAudioContext;\n\n    /** The HTML Audio (legacy) context. */\n    private _htmlAudioContext: HTMLAudioContext;\n\n    /** The map of all sounds by alias. */\n    private _sounds: SoundMap;\n\n    constructor()\n    {\n        this.init();\n    }\n\n    /**\n     * Re-initialize the sound library, this will\n     * recreate the AudioContext. If there's a hardware-failure\n     * call `close` and then `init`.\n     * @return Sound instance\n     */\n    public init(): this\n    {\n        if (this.supported)\n        {\n            this._webAudioContext = new WebAudioContext();\n        }\n        this._htmlAudioContext = new HTMLAudioContext();\n        this._sounds = {};\n        this.useLegacy = !this.supported;\n\n        return this;\n    }\n\n    /**\n     * The global context to use.\n     * @readonly\n     */\n    public get context(): IMediaContext\n    {\n        return this._context;\n    }\n\n    /**\n     * Apply filters to all sounds. Can be useful\n     * for setting global planning or global effects.\n     * **Only supported with WebAudio.**\n     * @example\n     * import { sound, filters } from '@pixi/sound';\n     * // Adds a filter to pan all output left\n     * sound.filtersAll = [\n     *     new filters.StereoFilter(-1)\n     * ];\n     */\n    public get filtersAll(): Filter[]\n    {\n        if (!this.useLegacy)\n        {\n            return this._context.filters;\n        }\n\n        return [];\n    }\n    public set filtersAll(filtersAll: Filter[])\n    {\n        if (!this.useLegacy)\n        {\n            this._context.filters = filtersAll;\n        }\n    }\n\n    /**\n     * `true` if WebAudio is supported on the current browser.\n     */\n    public get supported(): boolean\n    {\n        return WebAudioContext.AudioContext !== null;\n    }\n\n    /**\n     * Register an existing sound with the library cache.\n     * @method add\n     * @instance\n     * @param {string} alias - The sound alias reference.\n     * @param {Sound} sound - Sound reference to use.\n     * @return {Sound} Instance of the Sound object.\n     */\n\n    /**\n     * Adds a new sound by alias.\n     * @param alias - The sound alias reference.\n     * @param {ArrayBuffer|AudioBuffer|String|Options|HTMLAudioElement} options - Either the path or url to the source file.\n     *        or the object of options to use.\n     * @return Instance of the Sound object.\n     */\n    public add(alias: string, options: Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Sound): Sound;\n\n    /**\n     * Adds multiple sounds at once.\n     * @param map - Map of sounds to add, the key is the alias, the value is the\n     *        `string`, `ArrayBuffer`, `AudioBuffer`, `HTMLAudioElement` or the list of options\n     *        (see {@link Options} for full options).\n     * @param globalOptions - The default options for all sounds.\n     *        if a property is defined, it will use the local property instead.\n     * @return Instance to the Sound object.\n     */\n    public add(map: SoundSourceMap, globalOptions?: Options): SoundMap;\n\n    /**\n     * @ignore\n     */\n    public add(source: string | SoundSourceMap,\n        sourceOptions?: Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Sound): any\n    {\n        if (typeof source === 'object')\n        {\n            const results: SoundMap = {};\n\n            for (const alias in source)\n            {\n                const options: Options = this._getOptions(\n                    source[alias],\n                    sourceOptions as Options,\n                );\n\n                results[alias] = this.add(alias, options);\n            }\n\n            return results;\n        }\n\n        // eslint-disable-next-line no-console\n        console.assert(!this._sounds[source], `Sound with alias ${source} already exists.`);\n\n        if (sourceOptions instanceof Sound)\n        {\n            this._sounds[source] = sourceOptions;\n\n            return sourceOptions;\n        }\n\n        const options: Options = this._getOptions(sourceOptions);\n        const sound: Sound = Sound.from(options);\n\n        this._sounds[source] = sound;\n\n        return sound;\n    }\n\n    /**\n     * Internal methods for getting the options object\n     * @private\n     * @param source - The source options\n     * @param overrides - Override default options\n     * @return The construction options\n     */\n    private _getOptions(source: string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Options,\n        overrides?: Options): Options\n    {\n        let options: Options;\n\n        if (typeof source === 'string')\n        {\n            options = { url: source };\n        }\n        else if (Array.isArray(source))\n        {\n            options = { url: source };\n        }\n        else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement)\n        {\n            options = { source };\n        }\n        else\n        {\n            options = source as Options;\n        }\n        options = { ...options, ...(overrides || {}) };\n\n        return options;\n    }\n\n    /**\n     * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.\n     */\n    public get useLegacy(): boolean\n    {\n        return this._useLegacy;\n    }\n    public set useLegacy(legacy: boolean)\n    {\n        this._useLegacy = legacy;\n\n        // Set the context to use\n        this._context = (!legacy && this.supported)\n            ? this._webAudioContext\n            : this._htmlAudioContext;\n    }\n\n    /**\n     * This disables auto-pause all playback when the window blurs (WebAudio only).\n     * This is helpful to keep from playing sounds when the user switches tabs.\n     * However, if you're running content within an iframe, this may be undesirable\n     * and you should disable (set to `true`) this behavior.\n     * @default false\n     */\n    public get disableAutoPause(): boolean\n    {\n        return !this._webAudioContext.autoPause;\n    }\n    public set disableAutoPause(autoPause: boolean)\n    {\n        this._webAudioContext.autoPause = !autoPause;\n    }\n\n    /**\n     * Removes a sound by alias.\n     * @param alias - The sound alias reference.\n     * @return Instance for chaining.\n     */\n    public remove(alias: string): this\n    {\n        this.exists(alias, true);\n        this._sounds[alias].destroy();\n        delete this._sounds[alias];\n\n        return this;\n    }\n\n    /**\n     * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.\n     */\n    public get volumeAll(): number\n    {\n        return this._context.volume;\n    }\n    public set volumeAll(volume: number)\n    {\n        this._context.volume = volume;\n        this._context.refresh();\n    }\n\n    /**\n     * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.\n     */\n    public get speedAll(): number\n    {\n        return this._context.speed;\n    }\n    public set speedAll(speed: number)\n    {\n        this._context.speed = speed;\n        this._context.refresh();\n    }\n\n    /**\n     * Toggle paused property for all sounds.\n     * @return `true` if all sounds are paused.\n     */\n    public togglePauseAll(): boolean\n    {\n        return this._context.togglePause();\n    }\n\n    /**\n     * Pauses any playing sounds.\n     * @return Instance for chaining.\n     */\n    public pauseAll(): this\n    {\n        this._context.paused = true;\n        this._context.refreshPaused();\n\n        return this;\n    }\n\n    /**\n     * Resumes any sounds.\n     * @return Instance for chaining.\n     */\n    public resumeAll(): this\n    {\n        this._context.paused = false;\n        this._context.refreshPaused();\n\n        return this;\n    }\n\n    /**\n     * Toggle muted property for all sounds.\n     * @return `true` if all sounds are muted.\n     */\n    public toggleMuteAll(): boolean\n    {\n        return this._context.toggleMute();\n    }\n\n    /**\n     * Mutes all playing sounds.\n     * @return Instance for chaining.\n     */\n    public muteAll(): this\n    {\n        this._context.muted = true;\n        this._context.refresh();\n\n        return this;\n    }\n\n    /**\n     * Unmutes all playing sounds.\n     * @return Instance for chaining.\n     */\n    public unmuteAll(): this\n    {\n        this._context.muted = false;\n        this._context.refresh();\n\n        return this;\n    }\n\n    /**\n     * Stops and removes all sounds. They cannot be used after this.\n     * @return Instance for chaining.\n     */\n    public removeAll(): this\n    {\n        for (const alias in this._sounds)\n        {\n            this._sounds[alias].destroy();\n            delete this._sounds[alias];\n        }\n\n        return this;\n    }\n\n    /**\n     * Stops all sounds.\n     * @return Instance for chaining.\n     */\n    public stopAll(): this\n    {\n        for (const alias in this._sounds)\n        {\n            this._sounds[alias].stop();\n        }\n\n        return this;\n    }\n\n    /**\n     * Checks if a sound by alias exists.\n     * @param alias - Check for alias.\n     * @param assert - Whether enable console.assert.\n     * @return true if the sound exists.\n     */\n    public exists(alias: string, assert = false): boolean\n    {\n        const exists = !!this._sounds[alias];\n\n        if (assert)\n        {\n            // eslint-disable-next-line no-console\n            console.assert(exists, `No sound matching alias '${alias}'.`);\n        }\n\n        return exists;\n    }\n\n    /**\n     * Convenience function to check to see if any sound is playing.\n     * @returns `true` if any sound is currently playing.\n     */\n    public isPlaying(): boolean\n    {\n        for (const alias in this._sounds)\n        {\n            if (this._sounds[alias].isPlaying)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find a sound by alias.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public find(alias: string): Sound\n    {\n        this.exists(alias, true);\n\n        return this._sounds[alias];\n    }\n\n    /**\n     * Plays a sound.\n     * @method play\n     * @instance\n     * @param {string} alias - The sound alias reference.\n     * @param {string} sprite - The alias of the sprite to play.\n     * @return {IMediaInstance|null} The sound instance, this cannot be reused\n     *         after it is done playing. Returns `null` if the sound has not yet loaded.\n     */\n\n    /**\n     * Plays a sound.\n     * @param alias - The sound alias reference.\n     * @param {PlayOptions|Function} options - The options or callback when done.\n     * @return The sound instance,\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\n     *        has not yet loaded.\n     */\n    public play(\n        alias: string,\n        options?: PlayOptions | CompleteCallback | string): IMediaInstance | Promise<IMediaInstance>\n    {\n        return this.find(alias).play(options);\n    }\n\n    /**\n     * Stops a sound.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public stop(alias: string): Sound\n    {\n        return this.find(alias).stop();\n    }\n\n    /**\n     * Pauses a sound.\n     * @param alias - The sound alias reference.\n     * @return Sound object.\n     */\n    public pause(alias: string): Sound\n    {\n        return this.find(alias).pause();\n    }\n\n    /**\n     * Resumes a sound.\n     * @param alias - The sound alias reference.\n     * @return Instance for chaining.\n     */\n    public resume(alias: string): Sound\n    {\n        return this.find(alias).resume();\n    }\n\n    /**\n     * Get or set the volume for a sound.\n     * @param alias - The sound alias reference.\n     * @param volume - Optional current volume to set.\n     * @return The current volume.\n     */\n    public volume(alias: string, volume?: number): number\n    {\n        const sound = this.find(alias);\n\n        if (volume !== undefined)\n        {\n            sound.volume = volume;\n        }\n\n        return sound.volume;\n    }\n\n    /**\n     * Get or set the speed for a sound.\n     * @param alias - The sound alias reference.\n     * @param speed - Optional current speed to set.\n     * @return The current speed.\n     */\n    public speed(alias: string, speed?: number): number\n    {\n        const sound = this.find(alias);\n\n        if (speed !== undefined)\n        {\n            sound.speed = speed;\n        }\n\n        return sound.speed;\n    }\n\n    /**\n     * Get the length of a sound in seconds.\n     * @param alias - The sound alias reference.\n     * @return The current duration in seconds.\n     */\n    public duration(alias: string): number\n    {\n        return this.find(alias).duration;\n    }\n\n    /**\n     * Closes the sound library. This will release/destroy\n     * the AudioContext(s). Can be used safely if you want to\n     * initialize the sound library later. Use `init` method.\n     */\n    public close(): this\n    {\n        this.removeAll();\n        this._sounds = null;\n        if (this._webAudioContext)\n        {\n            this._webAudioContext.destroy();\n            this._webAudioContext = null;\n        }\n        if (this._htmlAudioContext)\n        {\n            this._htmlAudioContext.destroy();\n            this._htmlAudioContext = null;\n        }\n        this._context = null;\n\n        return this;\n    }\n}\n\nexport { SoundLibrary };\nexport type { SoundSourceMap, SoundMap };\n", "export { HTMLAudioMedia } from './HTMLAudioMedia.mjs';\nexport { HTMLAudioInstance } from './HTMLAudioInstance.mjs';\nexport { HTMLAudioContext } from './HTMLAudioContext.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { Filter } from './Filter.mjs';\nexport { EqualizerFilter } from './EqualizerFilter.mjs';\nexport { DistortionFilter } from './DistortionFilter.mjs';\nexport { StereoFilter } from './StereoFilter.mjs';\nexport { ReverbFilter } from './ReverbFilter.mjs';\nexport { MonoFilter } from './MonoFilter.mjs';\nexport { StreamFilter } from './StreamFilter.mjs';\nexport { TelephoneFilter } from './TelephoneFilter.mjs';\n//# sourceMappingURL=index.mjs.map\n", "/**\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\n *\n * @memberof filters\n */\nclass Filter\n{\n    /** The node to connect for the filter to the previous filter. */\n    public destination: AudioNode;\n\n    /** The node to connect for the filter to the previous filter. */\n    public source: AudioNode;\n\n    /**\n     * @param {AudioNode} destination - The audio node to use as the destination for the input AudioNode\n     * @param {AudioNode} [source] - Optional output node, defaults to destination node. This is useful\n     *        when creating filters which contains multiple AudioNode elements chained together.\n     */\n    constructor(destination: AudioNode, source?: AudioNode)\n    {\n        this.init(destination, source);\n    }\n\n    /** Reinitialize */\n    protected init(destination: AudioNode, source?: AudioNode): void\n    {\n        this.destination = destination;\n        this.source = source || destination;\n    }\n\n    /**\n     * Connect to the destination.\n     * @param {AudioNode} destination - The destination node to connect the output to\n     */\n    public connect(destination: AudioNode): void\n    {\n        this.source?.connect(destination);\n    }\n\n    /** Completely disconnect filter from destination and source nodes. */\n    public disconnect(): void\n    {\n        this.source?.disconnect();\n    }\n\n    /** Destroy the filter and don't use after this. */\n    public destroy(): void\n    {\n        this.disconnect();\n        this.destination = null;\n        this.source = null;\n    }\n}\n\nexport { Filter };\n", "import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\ninterface Band\n{\n    f: number;\n    type: string;\n    gain: number;\n}\n\n/**\n * Filter for adding equalizer bands.\n *\n * @memberof filters\n */\nclass EqualizerFilter extends Filter\n{\n    /**\n     * Band at 32 Hz\n     * @readonly\n     */\n    public static readonly F32: number = 32;\n\n    /**\n     * Band at 64 Hz\n     * @readonly\n     */\n    public static readonly F64: number = 64;\n\n    /**\n     * Band at 125 Hz\n     * @readonly\n     */\n    public static readonly F125: number = 125;\n\n    /**\n     * Band at 250 Hz\n     * @readonly\n     */\n    public static readonly F250: number = 250;\n\n    /**\n     * Band at 500 Hz\n     * @readonly\n     */\n    public static readonly F500: number = 500;\n\n    /**\n     * Band at 1000 Hz\n     * @readonly\n     */\n    public static readonly F1K: number = 1000;\n\n    /**\n     * Band at 2000 Hz\n     * @readonly\n     */\n    public static readonly F2K: number = 2000;\n\n    /**\n     * Band at 4000 Hz\n     * @readonly\n     */\n    public static readonly F4K: number = 4000;\n\n    /**\n     * Band at 8000 Hz\n     * @readonly\n     */\n    public static readonly F8K: number = 8000;\n\n    /**\n     * Band at 16000 Hz\n     * @readonly\n     */\n    public static readonly F16K: number = 16000;\n\n    /**\n     * The list of bands\n     * @readonly\n     */\n    public readonly bands: BiquadFilterNode[];\n\n    /**\n     * The map of bands to frequency\n     * @readonly\n     */\n    public readonly bandsMap: Record<number, BiquadFilterNode>;\n\n    /**\n     * @param f32 - Default gain for 32 Hz\n     * @param f64 - Default gain for 64 Hz\n     * @param f125 - Default gain for 125 Hz\n     * @param f250 - Default gain for 250 Hz\n     * @param f500 - Default gain for 500 Hz\n     * @param f1k - Default gain for 1000 Hz\n     * @param f2k - Default gain for 2000 Hz\n     * @param f4k - Default gain for 4000 Hz\n     * @param f8k - Default gain for 8000 Hz\n     * @param f16k - Default gain for 16000 Hz\n     */\n    constructor(f32 = 0, f64 = 0, f125 = 0, f250 = 0, f500 = 0,\n        f1k = 0, f2k = 0, f4k = 0, f8k = 0, f16k = 0)\n    {\n        let bands: BiquadFilterNode[] = [];\n\n        const equalizerBands: Band[] = [\n            {\n                f: EqualizerFilter.F32,\n                type: 'lowshelf',\n                gain: f32,\n            },\n            {\n                f: EqualizerFilter.F64,\n                type: 'peaking',\n                gain: f64,\n            },\n            {\n                f: EqualizerFilter.F125,\n                type: 'peaking',\n                gain: f125,\n            },\n            {\n                f: EqualizerFilter.F250,\n                type: 'peaking',\n                gain: f250,\n            },\n            {\n                f: EqualizerFilter.F500,\n                type: 'peaking',\n                gain: f500,\n            },\n            {\n                f: EqualizerFilter.F1K,\n                type: 'peaking',\n                gain: f1k,\n            },\n            {\n                f: EqualizerFilter.F2K,\n                type: 'peaking',\n                gain: f2k,\n            },\n            {\n                f: EqualizerFilter.F4K,\n                type: 'peaking',\n                gain: f4k,\n            },\n            {\n                f: EqualizerFilter.F8K,\n                type: 'peaking',\n                gain: f8k,\n            },\n            {\n                f: EqualizerFilter.F16K,\n                type: 'highshelf',\n                gain: f16k,\n            },\n        ];\n\n        if (!getInstance().useLegacy)\n        {\n            bands = equalizerBands.map((band: Band) =>\n            {\n                const node: BiquadFilterNode = getInstance().context.audioContext.createBiquadFilter();\n\n                node.type = band.type as BiquadFilterType;\n                WebAudioUtils.setParamValue(node.Q, 1);\n                node.frequency.value = band.f; // WebAudioUtils.setParamValue(filter.frequency, band.f);\n                WebAudioUtils.setParamValue(node.gain, band.gain);\n\n                return node;\n            });\n        }\n\n        // Setup the constructor AudioNode, where first is the input, and last is the output\n        super(bands[0], bands[bands.length - 1]);\n\n        // Manipulate the bands\n        this.bands = bands;\n\n        // Create a map\n        this.bandsMap = {};\n\n        for (let i = 0; i < this.bands.length; i++)\n        {\n            const node: BiquadFilterNode = this.bands[i];\n\n            // Connect the previous band to the current one\n            if (i > 0)\n            {\n                this.bands[i - 1].connect(node);\n            }\n            this.bandsMap[node.frequency.value] = node;\n        }\n    }\n\n    /**\n     * Set gain on a specific frequency.\n     * @param frequency - The frequency, see EqualizerFilter.F* for bands\n     * @param gain - Recommended -40 to 40.\n     */\n    public setGain(frequency: number, gain = 0): void\n    {\n        if (!this.bandsMap[frequency])\n        {\n            throw new Error(`No band found for frequency ${frequency}`);\n        }\n        WebAudioUtils.setParamValue(this.bandsMap[frequency].gain, gain);\n    }\n\n    /**\n     * Get gain amount on a specific frequency.\n     * @return The amount of gain set.\n     */\n    public getGain(frequency: number): number\n    {\n        if (!this.bandsMap[frequency])\n        {\n            throw new Error(`No band found for frequency ${frequency}`);\n        }\n\n        return this.bandsMap[frequency].gain.value;\n    }\n\n    /**\n     * Gain at 32 Hz frequencey.\n     * @default 0\n     */\n    public set f32(value: number)\n    {\n        this.setGain(EqualizerFilter.F32, value);\n    }\n    public get f32(): number\n    {\n        return this.getGain(EqualizerFilter.F32);\n    }\n\n    /**\n     * Gain at 64 Hz frequencey.\n     * @default 0\n     */\n    public set f64(value: number)\n    {\n        this.setGain(EqualizerFilter.F64, value);\n    }\n    public get f64(): number\n    {\n        return this.getGain(EqualizerFilter.F64);\n    }\n\n    /**\n     * Gain at 125 Hz frequencey.\n     * @default 0\n     */\n    public set f125(value: number)\n    {\n        this.setGain(EqualizerFilter.F125, value);\n    }\n    public get f125(): number\n    {\n        return this.getGain(EqualizerFilter.F125);\n    }\n\n    /**\n     * Gain at 250 Hz frequencey.\n     * @default 0\n     */\n    public set f250(value: number)\n    {\n        this.setGain(EqualizerFilter.F250, value);\n    }\n    public get f250(): number\n    {\n        return this.getGain(EqualizerFilter.F250);\n    }\n\n    /**\n     * Gain at 500 Hz frequencey.\n     * @default 0\n     */\n    public set f500(value: number)\n    {\n        this.setGain(EqualizerFilter.F500, value);\n    }\n    public get f500(): number\n    {\n        return this.getGain(EqualizerFilter.F500);\n    }\n\n    /**\n     * Gain at 1 KHz frequencey.\n     * @default 0\n     */\n    public set f1k(value: number)\n    {\n        this.setGain(EqualizerFilter.F1K, value);\n    }\n    public get f1k(): number\n    {\n        return this.getGain(EqualizerFilter.F1K);\n    }\n\n    /**\n     * Gain at 2 KHz frequencey.\n     * @default 0\n     */\n    public set f2k(value: number)\n    {\n        this.setGain(EqualizerFilter.F2K, value);\n    }\n    public get f2k(): number\n    {\n        return this.getGain(EqualizerFilter.F2K);\n    }\n\n    /**\n     * Gain at 4 KHz frequencey.\n     * @default 0\n     */\n    public set f4k(value: number)\n    {\n        this.setGain(EqualizerFilter.F4K, value);\n    }\n    public get f4k(): number\n    {\n        return this.getGain(EqualizerFilter.F4K);\n    }\n\n    /**\n     * Gain at 8 KHz frequencey.\n     * @default 0\n     */\n    public set f8k(value: number)\n    {\n        this.setGain(EqualizerFilter.F8K, value);\n    }\n    public get f8k(): number\n    {\n        return this.getGain(EqualizerFilter.F8K);\n    }\n\n    /**\n     * Gain at 16 KHz frequencey.\n     * @default 0\n     */\n    public set f16k(value: number)\n    {\n        this.setGain(EqualizerFilter.F16K, value);\n    }\n    public get f16k(): number\n    {\n        return this.getGain(EqualizerFilter.F16K);\n    }\n\n    /** Reset all frequency bands to have gain of 0 */\n    public reset(): void\n    {\n        this.bands.forEach((band: BiquadFilterNode) =>\n        {\n            WebAudioUtils.setParamValue(band.gain, 0);\n        });\n    }\n\n    public destroy(): void\n    {\n        this.bands.forEach((band: BiquadFilterNode) =>\n        {\n            band.disconnect();\n        });\n        (this as any).bands = null;\n        (this as any).bandsMap = null;\n    }\n}\n\nexport { EqualizerFilter };\n", "import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding adding delaynode.\n *\n * @memberof filters\n */\nclass DistortionFilter extends Filter\n{\n    /** The Wave shape node use to distort */\n    private _distortion: WaveShaperNode;\n\n    /** The amount of distoration */\n    private _amount: number;\n\n    /** @param amount - The amount of distoration from 0 to 1. */\n    constructor(amount = 0)\n    {\n        let distortion: WaveShaperNode;\n\n        if (!getInstance().useLegacy)\n        {\n            const { audioContext } = getInstance().context;\n\n            distortion = audioContext.createWaveShaper();\n        }\n\n        super(distortion);\n\n        this._distortion = distortion;\n\n        this.amount = amount;\n    }\n\n    /** The amount of distortion to set. */\n    set amount(value: number)\n    {\n        this._amount = value;\n        if (getInstance().useLegacy)\n        {\n            return;\n        }\n        const scaledValue = value * 1000;\n        const samples = 44100;\n        const curve: Float32Array = new Float32Array(samples);\n        const deg: number = Math.PI / 180;\n\n        let i = 0;\n        let x: number;\n\n        for (; i < samples; ++i)\n        {\n            x = (i * 2 / samples) - 1;\n            curve[i] = (3 + scaledValue) * x * 20 * deg / (Math.PI + (scaledValue * Math.abs(x)));\n        }\n        this._distortion.curve = curve;\n        this._distortion.oversample = '4x';\n    }\n    get amount(): number\n    {\n        return this._amount;\n    }\n\n    public destroy(): void\n    {\n        this._distortion = null;\n        super.destroy();\n    }\n}\n\nexport { DistortionFilter };\n", "import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding Stereo panning.\n *\n * @memberof filters\n */\nclass StereoFilter extends Filter\n{\n    /** The stereo panning node */\n    private _stereo: StereoPannerNode;\n\n    /** The stereo panning node */\n    private _panner: PannerNode;\n\n    /** The amount of panning, -1 is left, 1 is right, 0 is centered */\n    private _pan: number;\n\n    /** @param pan - The amount of panning, -1 is left, 1 is right, 0 is centered. */\n    constructor(pan = 0)\n    {\n        let stereo: StereoPannerNode;\n        let panner: PannerNode;\n        let destination: AudioNode;\n\n        if (!getInstance().useLegacy)\n        {\n            const { audioContext } = getInstance().context;\n\n            if (audioContext.createStereoPanner)\n            {\n                stereo = audioContext.createStereoPanner();\n                destination = stereo;\n            }\n            else\n            {\n                panner = audioContext.createPanner();\n                panner.panningModel = 'equalpower';\n                destination = panner;\n            }\n        }\n\n        super(destination);\n\n        this._stereo = stereo;\n        this._panner = panner;\n\n        this.pan = pan;\n    }\n\n    /** Set the amount of panning, where -1 is left, 1 is right, and 0 is centered */\n    set pan(value: number)\n    {\n        this._pan = value;\n        if (this._stereo)\n        {\n            WebAudioUtils.setParamValue(this._stereo.pan, value);\n        }\n        else if (this._panner)\n        {\n            this._panner.setPosition(value, 0, 1 - Math.abs(value));\n        }\n    }\n    get pan(): number\n    {\n        return this._pan;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n        this._stereo = null;\n        this._panner = null;\n    }\n}\n\nexport { StereoFilter };\n", "import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Filter for adding reverb. Refactored from\n * https://github.com/web-audio-components/simple-reverb/\n *\n * @memberof filters\n */\nclass ReverbFilter extends Filter\n{\n    private _seconds: number;\n    private _decay: number;\n    private _reverse: boolean;\n\n    /**\n     * @param seconds - Seconds for reverb\n     * @param decay - The decay length\n     * @param reverse - Reverse reverb\n     */\n    constructor(seconds = 3, decay = 2, reverse = false)\n    {\n        super(null);\n        this._seconds = this._clamp(seconds, 1, 50);\n        this._decay = this._clamp(decay, 0, 100);\n        this._reverse = reverse;\n        this._rebuild();\n    }\n\n    /**\n     * Clamp a value\n     * @param value\n     * @param min - Minimum value\n     * @param max - Maximum value\n     * @return Clamped number\n     */\n    private _clamp(value: number, min: number, max: number): number\n    {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n     * Length of reverb in seconds from 1 to 50\n     * @default 3\n     */\n    get seconds(): number\n    {\n        return this._seconds;\n    }\n    set seconds(seconds: number)\n    {\n        this._seconds = this._clamp(seconds, 1, 50);\n        this._rebuild();\n    }\n\n    /**\n     * Decay value from 0 to 100\n     * @default 2\n     */\n    get decay(): number\n    {\n        return this._decay;\n    }\n    set decay(decay: number)\n    {\n        this._decay = this._clamp(decay, 0, 100);\n        this._rebuild();\n    }\n\n    /**\n     * Reverse value from 0 to 1\n     * @default false\n     */\n    get reverse(): boolean\n    {\n        return this._reverse;\n    }\n    set reverse(reverse: boolean)\n    {\n        this._reverse = reverse;\n        this._rebuild();\n    }\n\n    /**\n     * Utility function for building an impulse response\n     * from the module parameters.\n     */\n    private _rebuild(): void\n    {\n        if (getInstance().useLegacy)\n        {\n            return;\n        }\n        const { audioContext } = getInstance().context;\n        const rate: number = audioContext.sampleRate;\n        const length: number = rate * this._seconds;\n        const impulse: AudioBuffer = audioContext.createBuffer(2, length, rate);\n        const impulseL: Float32Array = impulse.getChannelData(0);\n        const impulseR: Float32Array = impulse.getChannelData(1);\n        let n: number;\n\n        for (let i = 0; i < length; i++)\n        {\n            n = this._reverse ? length - i : i;\n            impulseL[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\n            impulseR[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\n        }\n        const convolver = audioContext.createConvolver();\n\n        convolver.buffer = impulse;\n        this.init(convolver);\n    }\n}\n\nexport { ReverbFilter };\n", "import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Combine all channels into mono channel.\n *\n * @memberof filters\n */\nclass MonoFilter extends Filter\n{\n    /** Merger node */\n    private _merger: ChannelMergerNode;\n\n    constructor()\n    {\n        let merger: ChannelMergerNode;\n        let splitter: ChannelSplitterNode;\n\n        if (!getInstance().useLegacy)\n        {\n            const { audioContext } = getInstance().context;\n\n            splitter = audioContext.createChannelSplitter();\n            merger = audioContext.createChannelMerger();\n            merger.connect(splitter);\n        }\n        super(merger, splitter);\n        this._merger = merger;\n    }\n\n    public destroy(): void\n    {\n        this._merger?.disconnect();\n        this._merger = null;\n        super.destroy();\n    }\n}\n\nexport { MonoFilter };\n", "import { getInstance } from '../instance';\nimport { Filter } from './Filter';\n\n/**\n * Export a MediaStream to be recorded\n *\n * @memberof filters\n */\nclass StreamFilter extends Filter\n{\n    private _stream: MediaStream;\n\n    constructor()\n    {\n        let destination: MediaStreamAudioDestinationNode;\n        let source: MediaStreamAudioSourceNode;\n\n        if (!getInstance().useLegacy)\n        {\n            const { audioContext } = getInstance().context;\n\n            destination = audioContext.createMediaStreamDestination();\n            source = audioContext.createMediaStreamSource(destination.stream);\n        }\n\n        super(destination, source);\n        this._stream = destination?.stream;\n    }\n\n    public get stream(): MediaStream\n    {\n        return this._stream;\n    }\n\n    public destroy(): void\n    {\n        this._stream = null;\n        super.destroy();\n    }\n}\n\nexport { StreamFilter };\n", "import { getInstance } from '../instance';\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\nimport { Filter } from './Filter';\n\n/**\n * Creates a telephone-sound filter.\n *\n * @memberof filters\n */\nclass TelephoneFilter extends Filter\n{\n    constructor()\n    {\n        let destination: AudioNode;\n        let source: AudioNode;\n\n        if (!getInstance().useLegacy)\n        {\n            const { audioContext } = getInstance().context;\n            const lpf1 = audioContext.createBiquadFilter();\n            const lpf2 = audioContext.createBiquadFilter();\n            const hpf1 = audioContext.createBiquadFilter();\n            const hpf2 = audioContext.createBiquadFilter();\n\n            lpf1.type = 'lowpass';\n            WebAudioUtils.setParamValue(lpf1.frequency, 2000.0);\n\n            lpf2.type = 'lowpass';\n            WebAudioUtils.setParamValue(lpf2.frequency, 2000.0);\n\n            hpf1.type = 'highpass';\n            WebAudioUtils.setParamValue(hpf1.frequency, 500.0);\n\n            hpf2.type = 'highpass';\n            WebAudioUtils.setParamValue(hpf2.frequency, 500.0);\n\n            lpf1.connect(lpf2);\n            lpf2.connect(hpf1);\n            hpf1.connect(hpf2);\n\n            destination = lpf1;\n            source = hpf2;\n        }\n\n        super(destination, source);\n    }\n}\n\nexport { TelephoneFilter };\n", "export { WebAudioMedia } from './WebAudioMedia.mjs';\nexport { WebAudioInstance } from './WebAudioInstance.mjs';\nexport { WebAudioNodes } from './WebAudioNodes.mjs';\nexport { WebAudioContext } from './WebAudioContext.mjs';\nexport { WebAudioUtils } from './WebAudioUtils.mjs';\n//# sourceMappingURL=index.mjs.map\n", "export { PLAY_ID, playOnce } from './playOnce.mjs';\nexport { render } from './render.mjs';\nexport { sineTone } from './sineTone.mjs';\nexport { extensions, mimes, supported, validateFormats } from './supported.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { getInstance } from '../instance';\n\n/**\n * Increment the alias for play once\n * @static\n * @default 0\n */\nlet PLAY_ID = 0;\n\n/**\n * Create a new \"Audio\" stream based on given audio path and project uri; returns the audio object.\n * @memberof utils\n * @param url - Full path of the file to play.\n * @param {Function} callback - Callback when complete.\n * @return New audio element alias.\n */\nfunction playOnce(url: string, callback?: (err?: Error) => void): string\n{\n    const alias = `alias${PLAY_ID++}`;\n\n    getInstance().add(alias, {\n        url,\n        preload: true,\n        autoPlay: true,\n        loaded: (err: Error) =>\n        {\n            if (err)\n            {\n                console.error(err);\n                getInstance().remove(alias);\n                if (callback)\n                {\n                    callback(err);\n                }\n            }\n        },\n        complete: () =>\n        {\n            getInstance().remove(alias);\n            if (callback)\n            {\n                callback(null);\n            }\n        },\n    });\n\n    return alias;\n}\n\nexport { playOnce, PLAY_ID };\n", "import { BaseTexture } from '@pixi/core';\nimport { Sound } from '../Sound';\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\n\ninterface RenderOptions\n{\n    /**\n     * Width of the render.\n     * @default 512\n     */\n    width?: number;\n    /**\n     * Height of the render.\n     * @default 128\n     */\n    height?: number;\n    /**\n     * Fill style for waveform.\n     * @default 'black'\n     */\n    fill?: string | CanvasPattern | CanvasGradient;\n}\n\n/**\n * Render image as Texture. **Only supported with WebAudio**\n * @memberof utils\n * @param sound - Instance of sound to render\n * @param options - Custom rendering options\n * @return Result texture\n */\nfunction render(sound: Sound, options?: RenderOptions): BaseTexture\n{\n    const canvas: HTMLCanvasElement = document.createElement('canvas');\n\n    options = {\n        width: 512,\n        height: 128,\n        fill: 'black', ...(options || {}) };\n\n    canvas.width = options.width;\n    canvas.height = options.height;\n\n    const baseTexture = BaseTexture.from(canvas);\n\n    if (!(sound.media instanceof WebAudioMedia))\n    {\n        return baseTexture;\n    }\n\n    const media: WebAudioMedia = sound.media as WebAudioMedia;\n\n    // eslint-disable-next-line no-console\n    console.assert(!!media.buffer, 'No buffer found, load first');\n\n    const context: CanvasRenderingContext2D = canvas.getContext('2d');\n\n    context.fillStyle = options.fill;\n    const data: Float32Array = media.buffer.getChannelData(0);\n    const step: number = Math.ceil(data.length / options.width);\n    const amp: number = options.height / 2;\n\n    for (let i = 0; i < options.width; i++)\n    {\n        let min = 1.0;\n        let max = -1.0;\n\n        for (let j = 0; j < step; j++)\n        {\n            const datum: number = data[(i * step) + j];\n\n            if (datum < min)\n            {\n                min = datum;\n            }\n            if (datum > max)\n            {\n                max = datum;\n            }\n        }\n        context.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));\n    }\n\n    return baseTexture;\n}\n\nexport type { RenderOptions };\nexport { render };\n", "import { Sound } from '../Sound';\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\nimport { WebAudioContext } from '../webaudio/WebAudioContext';\n\n/**\n * Create a new sound for a sine wave-based tone.  **Only supported with WebAudio**\n * @memberof utils\n * @param hertz - Frequency of sound.\n * @param seconds - Duration of sound in seconds.\n * @return New sound.\n */\nfunction sineTone(hertz = 200, seconds = 1): Sound\n{\n    const sound = Sound.from({\n        singleInstance: true,\n    });\n\n    if (!(sound.media instanceof WebAudioMedia))\n    {\n        return sound;\n    }\n\n    const media = sound.media as WebAudioMedia;\n    const context = sound.context as WebAudioContext;\n\n    // set default value\n    const nChannels = 1;\n    const sampleRate = 48000;\n    const amplitude = 2;\n\n    // create the buffer\n    const buffer = context.audioContext.createBuffer(\n        nChannels,\n        seconds * sampleRate,\n        sampleRate,\n    );\n    const fArray = buffer.getChannelData(0);\n\n    // fill the buffer\n    for (let i = 0; i < fArray.length; i++)\n    {\n        const time  = i / buffer.sampleRate;\n        const angle = hertz * time * Math.PI;\n\n        fArray[i] = Math.sin(angle) * amplitude;\n    }\n\n    // set the buffer\n    media.buffer = buffer;\n    sound.isLoaded = true;\n\n    return sound;\n}\n\nexport { sineTone };\n", "import { utils, extensions, ExtensionType } from '@pixi/core';\nimport { AssetExtension, LoadAsset, LoaderParser, LoaderParserPriority } from '@pixi/assets';\nimport { supported, extensions as exts, mimes } from './utils/supported';\nimport { Options, Sound } from './Sound';\nimport { getInstance } from './instance';\n\n/** Get the alias for the sound */\nconst getAlias = (asset: LoadAsset) =>\n{\n    const url = asset.src;\n\n    return (asset as any)?.alias?.[0] ?? utils.path.basename(url, utils.path.extname(url));\n};\n\n/**\n * Simple loader plugin for loading text data.\n */\nconst soundAsset = {\n    extension: ExtensionType.Asset,\n    detection: {\n        test: async () => true,\n        add: async (formats) => [...formats, ...exts.filter((ext) => supported[ext])],\n        remove: async (formats) => formats.filter((ext) => formats.includes(ext)),\n    },\n    loader: {\n        extension: {\n            type: [ExtensionType.LoadParser],\n            priority: LoaderParserPriority.High,\n        },\n\n        /** Should we attempt to load this file? */\n        test(url: string): boolean\n        {\n            const ext = utils.path.extname(url).slice(1);\n\n            return !!supported[ext] || mimes.some((mime) => url.startsWith(`data:${mime}`));\n        },\n\n        /** Load the sound file, this is mostly handled by Sound.from() */\n        async load(url: string, asset: LoadAsset<Omit<Options, 'url' | 'preload'>>): Promise<Sound>\n        {\n            // We'll use the internal Sound.from to load the asset\n            const sound = await new Promise<Sound>((resolve, reject) => Sound.from({\n                ...asset.data,\n                url,\n                preload: true,\n                loaded(err, sound)\n                {\n                    if (err)\n                    {\n                        reject(err);\n                    }\n                    else\n                    {\n                        resolve(sound);\n                    }\n                    asset.data?.loaded?.(err, sound);\n                },\n            }));\n\n            getInstance().add(getAlias(asset), sound);\n\n            return sound;\n        },\n\n        /** Remove the sound from the library */\n        async unload(_sound: Sound, asset: LoadAsset): Promise<void>\n        {\n            getInstance().remove(getAlias(asset));\n        },\n    } as LoaderParser<Sound>,\n} as AssetExtension;\n\nextensions.add(soundAsset);\n\nexport { soundAsset };\n", "import { setInstance } from './instance';\nimport { SoundLibrary } from './SoundLibrary';\nimport * as htmlaudio from './htmlaudio';\nimport * as filters from './filters';\nimport * as webaudio from './webaudio';\nimport * as utils from './utils';\n\nconst sound = setInstance(new SoundLibrary());\n\nexport * from './Sound';\nexport * from './soundAsset';\nexport * from './SoundLibrary';\nexport * from './Filterable';\nexport * from './interfaces';\nexport * from './filters/Filter';\nexport * from './SoundSprite';\nexport {\n    sound,\n    htmlaudio,\n    filters,\n    webaudio,\n    utils,\n};\n"],
  "mappings": "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",
  "names": ["sound", "sound", "sound", "instance", "extensions", "id", "sound", "instance", "extensions", "sound", "resolve", "instance", "options", "sound", "extensions", "sound", "sound", "exts", "sound", "extensions"]
}
