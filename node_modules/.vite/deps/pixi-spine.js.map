{
  "version": 3,
  "sources": ["../../@pixi-spine/base/src/core/AttachmentType.ts", "../../@pixi-spine/base/src/core/BinaryInput.ts", "../../@pixi-spine/base/src/core/IAnimation.ts", "../../@pixi-spine/base/src/core/IConstraint.ts", "../../@pixi-spine/base/src/core/ISkeleton.ts", "../../@pixi-spine/base/src/core/TextureRegion.ts", "../../@pixi-spine/base/src/core/TextureAtlas.ts", "../../@pixi-spine/base/src/core/Utils.ts", "../../@pixi-spine/base/src/core/SkeletonBoundsBase.ts", "../../@pixi-spine/base/src/settings.ts", "../../@pixi-spine/base/src/SpineBase.ts", "../../@pixi-spine/base/src/SpineDebugRenderer.ts", "../../@pixi-spine/loader-base/src/atlasLoader.ts", "../../@pixi-spine/loader-base/src/SpineLoaderAbstract.ts", "../../@pixi-spine/runtime-3.8/lib/index.mjs", "../../@pixi-spine/runtime-3.8/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/Slot.ts", "../../@pixi-spine/runtime-3.8/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-3.8/src/core/vertexeffects/JitterEffect.ts", "../../@pixi-spine/runtime-3.8/src/core/vertexeffects/SwirlEffect.ts", "../../@pixi-spine/runtime-3.8/src/core/Animation.ts", "../../@pixi-spine/runtime-3.8/src/core/AnimationState.ts", "../../@pixi-spine/runtime-3.8/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-3.8/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-3.8/src/core/Bone.ts", "../../@pixi-spine/runtime-3.8/src/core/BoneData.ts", "../../@pixi-spine/runtime-3.8/src/core/Constraint.ts", "../../@pixi-spine/runtime-3.8/src/core/Event.ts", "../../@pixi-spine/runtime-3.8/src/core/EventData.ts", "../../@pixi-spine/runtime-3.8/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-3.8/src/core/Skeleton.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-3.8/src/core/SlotData.ts", "../../@pixi-spine/runtime-3.8/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-3.8/src/core/Skin.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonBinary.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-3.8/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-3.8/src/Spine.ts", "../../@pixi-spine/runtime-3.7/lib/index.mjs", "../../@pixi-spine/runtime-3.7/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/Slot.ts", "../../@pixi-spine/runtime-3.7/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-3.7/src/core/vertexeffects/JitterEffect.ts", "../../@pixi-spine/runtime-3.7/src/core/vertexeffects/SwirlEffect.ts", "../../@pixi-spine/runtime-3.7/src/core/Animation.ts", "../../@pixi-spine/runtime-3.7/src/core/AnimationState.ts", "../../@pixi-spine/runtime-3.7/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-3.7/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-3.7/src/core/Bone.ts", "../../@pixi-spine/runtime-3.7/src/core/BoneData.ts", "../../@pixi-spine/runtime-3.7/src/core/Event.ts", "../../@pixi-spine/runtime-3.7/src/core/EventData.ts", "../../@pixi-spine/runtime-3.7/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-3.7/src/core/Skeleton.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-3.7/src/core/SlotData.ts", "../../@pixi-spine/runtime-3.7/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-3.7/src/core/Skin.ts", "../../@pixi-spine/runtime-3.7/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-3.7/src/Spine.ts", "../../@pixi-spine/runtime-4.1/lib/index.mjs", "../../@pixi-spine/runtime-4.1/src/core/attachments/Attachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/BoundingBoxAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/ClippingAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/MeshAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/PathAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/PointAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/RegionAttachment.ts", "../../@pixi-spine/runtime-4.1/src/core/attachments/Sequence.ts", "../../@pixi-spine/runtime-4.1/src/core/Animation.ts", "../../@pixi-spine/runtime-4.1/src/core/AnimationState.ts", "../../@pixi-spine/runtime-4.1/src/core/AnimationStateData.ts", "../../@pixi-spine/runtime-4.1/src/core/AtlasAttachmentLoader.ts", "../../@pixi-spine/runtime-4.1/src/core/Bone.ts", "../../@pixi-spine/runtime-4.1/src/core/BoneData.ts", "../../@pixi-spine/runtime-4.1/src/core/ConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/Event.ts", "../../@pixi-spine/runtime-4.1/src/core/EventData.ts", "../../@pixi-spine/runtime-4.1/src/core/IkConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/IkConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/PathConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/PathConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/Slot.ts", "../../@pixi-spine/runtime-4.1/src/core/TransformConstraint.ts", "../../@pixi-spine/runtime-4.1/src/core/Skeleton.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonData.ts", "../../@pixi-spine/runtime-4.1/src/core/SlotData.ts", "../../@pixi-spine/runtime-4.1/src/core/TransformConstraintData.ts", "../../@pixi-spine/runtime-4.1/src/core/Skin.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonBinary.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonBounds.ts", "../../@pixi-spine/runtime-4.1/src/core/SkeletonJson.ts", "../../@pixi-spine/runtime-4.1/src/Spine.ts", "../../@pixi-spine/loader-uni/src/versions.ts", "../../@pixi-spine/loader-uni/src/SpineLoader.ts", "../../@pixi-spine/loader-uni/src/Spine.ts", "../../@pixi-spine/loader-uni/src/index.ts"],
  "sourcesContent": ["/**\n * @public\n */\nexport enum AttachmentType {\n    Region,\n    BoundingBox,\n    Mesh,\n    LinkedMesh,\n    Path,\n    Point,\n    Clipping,\n}\n", "/**\n * @public\n */\nexport class BinaryInput {\n    constructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) {}\n\n    readByte(): number {\n        return this.buffer.getInt8(this.index++);\n    }\n\n    readUnsignedByte(): number {\n        return this.buffer.getUint8(this.index++);\n    }\n\n    readShort(): number {\n        const value = this.buffer.getInt16(this.index);\n\n        this.index += 2;\n\n        return value;\n    }\n\n    readInt32(): number {\n        const value = this.buffer.getInt32(this.index);\n\n        this.index += 4;\n\n        return value;\n    }\n\n    readInt(optimizePositive: boolean) {\n        let b = this.readByte();\n        let result = b & 0x7f;\n\n        if ((b & 0x80) != 0) {\n            b = this.readByte();\n            result |= (b & 0x7f) << 7;\n            if ((b & 0x80) != 0) {\n                b = this.readByte();\n                result |= (b & 0x7f) << 14;\n                if ((b & 0x80) != 0) {\n                    b = this.readByte();\n                    result |= (b & 0x7f) << 21;\n                    if ((b & 0x80) != 0) {\n                        b = this.readByte();\n                        result |= (b & 0x7f) << 28;\n                    }\n                }\n            }\n        }\n\n        return optimizePositive ? result : (result >>> 1) ^ -(result & 1);\n    }\n\n    readStringRef(): string | null {\n        const index = this.readInt(true);\n\n        return index == 0 ? null : this.strings[index - 1];\n    }\n\n    readString(): string | null {\n        let byteCount = this.readInt(true);\n\n        switch (byteCount) {\n            case 0:\n                return null;\n            case 1:\n                return '';\n        }\n        byteCount--;\n        let chars = '';\n\n        for (let i = 0; i < byteCount; ) {\n            const b = this.readUnsignedByte();\n\n            switch (b >> 4) {\n                case 12:\n                case 13:\n                    chars += String.fromCharCode(((b & 0x1f) << 6) | (this.readByte() & 0x3f));\n                    i += 2;\n                    break;\n                case 14:\n                    chars += String.fromCharCode(((b & 0x0f) << 12) | ((this.readByte() & 0x3f) << 6) | (this.readByte() & 0x3f));\n                    i += 3;\n                    break;\n                default:\n                    chars += String.fromCharCode(b);\n                    i++;\n            }\n        }\n\n        return chars;\n    }\n\n    readFloat(): number {\n        const value = this.buffer.getFloat32(this.index);\n\n        this.index += 4;\n\n        return value;\n    }\n\n    readBoolean(): boolean {\n        return this.readByte() != 0;\n    }\n}\n", "import type { ISkeleton, ISkeletonData } from './ISkeleton';\nimport type { Map } from './Utils';\n\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixBlend {\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n     * value is set. */\n    setup,\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\n     * AttachmentTimeline, use the setup value before the first key.\n     *\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\n    first,\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n     * kept until the first key).\n     *\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n    replace,\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n     * (the current value is kept until the first key).\n     *\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n     * the property values will increase continually. */\n    add,\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixDirection {\n    mixIn,\n    mixOut,\n}\n\n/**\n * @public\n */\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\n    name: string;\n    timelines: Timeline[];\n    duration: number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\n    data: AnimationStateData;\n    tracks: ITrackEntry[];\n    listeners: IAnimationStateListener[];\n    timeScale: number;\n\n    update(dt: number): void;\n    apply(skeleton: ISkeleton): boolean;\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\n    setEmptyAnimation(trackIndex: number, mixDuration: number): ITrackEntry;\n    setEmptyAnimations(mixDuration: number): void;\n    hasAnimation(animationName: string): boolean;\n    addListener(listener: IAnimationStateListener): void;\n    removeListener(listener: IAnimationStateListener): void;\n    clearListeners(): void;\n    clearTracks(): void;\n    clearTrack(index: number): void;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number>;\n    defaultMix: number;\n    setMix(fromName: string, toName: string, duration: number): void;\n    setMixWith(from: Animation, to: Animation, duration: number): void;\n    getMix(from: Animation, to: Animation): number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateListener {\n    start?(entry: ITrackEntry): void;\n    interrupt?(entry: ITrackEntry): void;\n    end?(entry: ITrackEntry): void;\n    dispose?(entry: ITrackEntry): void;\n    complete?(entry: ITrackEntry): void;\n    event?(entry: ITrackEntry, event: IEvent): void;\n}\n\n/**\n * @public\n */\nexport interface ITimeline {}\n\n/**\n * @public\n */\nexport interface ITrackEntry {\n    trackIndex: number;\n    loop: boolean;\n    animationEnd: number;\n    listener: IAnimationStateListener;\n\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n}\n\n/**\n * @public\n */\nexport interface IEventData {\n    name: string;\n}\n\n/**\n * @public\n */\nexport interface IEvent {\n    time: number;\n    data: IEventData;\n}\n", "// These enums were moved from PathConstraintData.ts of spine 3.7, 3.8 and 4.0\n\n/** Controls how the first bone is positioned along the path.\n *\n * See [Position mode](http://esotericsoftware.com/spine-path-constraints#Position-mode) in the Spine User Guide.\n * @public\n * */\nexport enum PositionMode {\n    Fixed,\n    Percent,\n}\n\n/** Controls how bones are rotated, translated, and scaled to match the path.\n *\n * [Rotate mode](http://esotericsoftware.com/spine-path-constraints#Rotate-mod) in the Spine User Guide.\n * @public\n * */\nexport enum RotateMode {\n    Tangent,\n    Chain,\n    ChainScale,\n}\n\n/**\n * @public\n */\nexport interface IConstraintData {\n    name: string;\n    order: number;\n}\n\n/**\n * @public\n */\nexport interface IIkConstraint {\n    data: IIkConstraintData;\n    /** -1 | 0 | 1 */\n    bendDirection: number;\n    compress: boolean;\n    stretch: boolean;\n\n    /** A percentage (0-1) */\n    mix: number;\n}\n\n/**\n * @public\n */\nexport interface IIkConstraintData extends IConstraintData {\n    /** -1 | 0 | 1 */\n    bendDirection: number;\n    compress: boolean;\n    stretch: boolean;\n    uniform: boolean;\n\n    /** A percentage (0-1) */\n    mix: number;\n}\n\n/**\n * @public\n */\nexport interface IPathConstraint {\n    data: IPathConstraintData;\n    position: number;\n    spacing: number;\n\n    spaces: number[];\n    positions: number[];\n    world: number[];\n    curves: number[];\n    lengths: number[];\n    segments: number[];\n}\n\n/**\n * @public\n */\nexport interface IPathConstraintData extends IConstraintData {\n    positionMode: PositionMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n}\n\n/**\n * @public\n */\nexport interface ITransformConstraint {\n    data: ITransformConstraintData;\n}\n\n/**\n * @public\n */\nexport interface ITransformConstraintData extends IConstraintData {\n    offsetRotation: number;\n    offsetX: number;\n    offsetY: number;\n    offsetScaleX: number;\n    offsetScaleY: number;\n    offsetShearY: number;\n    relative: boolean;\n    local: boolean;\n}\n", "import type { AttachmentType } from './AttachmentType';\nimport type { IAnimation, IEventData } from './IAnimation';\nimport type { IIkConstraintData, IPathConstraintData, ITransformConstraintData } from './IConstraint';\nimport type { Color, Vector2, Map } from './Utils';\nimport type { TextureRegion } from './TextureRegion';\nimport type { BLEND_MODES, Matrix } from '@pixi/core';\n\n// This enum was moved from BoneData.ts of spine 3.7, 3.8 and 4.0\n\n/** Determines how a bone inherits world transforms from parent bones.\n * @public\n * */\nexport enum TransformMode {\n    Normal,\n    OnlyTranslation,\n    NoRotationOrReflection,\n    NoScale,\n    NoScaleOrReflection,\n}\n\n/**\n * @public\n */\nexport interface IBone {\n    data: IBoneData;\n    matrix: Matrix;\n    active: boolean;\n}\n\n/**\n * @public\n */\nexport interface ISkin {\n    name: string;\n    attachments: Array<Map<IAttachment>>;\n\n    getAttachment(slotIndex: number, name: string): IAttachment | null;\n}\n\n/**\n * @public\n */\nexport interface IAttachment {\n    name: string;\n    type: AttachmentType;\n    readonly sequence?: ISequence;\n}\n\n/**\n * @public\n */\nexport interface IHasTextureRegion {\n    /** The name used to find the {@link #region()}. */\n    path: string;\n\n    /** The region used to draw the attachment. After setting the region or if the region's properties are changed,\n     * {@link #updateRegion()} must be called. */\n    region: TextureRegion | null;\n\n    /** Updates any values the attachment calculates using the {@link #getRegion()}. Must be called after setting the\n     * {@link #getRegion()} or if the region's properties are changed. */\n    // updateRegion (): void;\n\n    /** The color to tint the attachment. */\n    color: Color;\n\n    readonly sequence: ISequence | null;\n}\n\n/**\n * @public\n */\nexport interface ISequence {\n    id: number;\n    regions: TextureRegion[];\n    apply(slot: ISlot, attachment: IHasTextureRegion): void;\n}\n\n/**\n * @public\n */\nexport interface IVertexAttachment<Slot extends ISlot = ISlot> extends IAttachment {\n    id: number;\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>): void;\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number): void;\n    worldVerticesLength: number;\n}\n\n/**\n * @public\n */\nexport interface IClippingAttachment extends IVertexAttachment {\n    endSlot?: ISlotData;\n}\n\n/**\n * @public\n */\nexport interface IRegionAttachment extends IAttachment {\n    region: TextureRegion;\n    color: Color;\n    x;\n    y;\n    scaleX;\n    scaleY;\n    rotation;\n    width;\n    height: number;\n}\n\n/**\n * @public\n */\nexport interface IMeshAttachment extends IVertexAttachment {\n    region: TextureRegion;\n    color: Color;\n    regionUVs: Float32Array;\n    triangles: number[];\n    hullLength: number;\n}\n\n/**\n * @public\n */\nexport interface ISlotData {\n    index: number;\n    name: string;\n    boneData: IBoneData;\n    color: Color;\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * @public\n */\nexport interface IBoneData {\n    index: number;\n    name: string;\n    parent: IBoneData;\n    length: number;\n    x: number;\n    y: number;\n    rotation: number;\n    scaleX: number;\n    scaleY: number;\n    shearX: number;\n    shearY: number;\n    transformMode: TransformMode;\n}\n\n/**\n * @public\n */\nexport interface ISlot {\n    getAttachment(): IAttachment;\n    data: ISlotData;\n    color: Color;\n    darkColor: Color;\n    blendMode: number;\n    bone: IBone;\n\n    sprites?: any;\n    currentSprite?: any;\n    currentSpriteName?: string;\n\n    meshes?: any;\n    currentMesh?: any;\n    currentMeshName?: string;\n    currentMeshId?: number;\n\n    currentGraphics?: any;\n    clippingContainer?: any;\n\n    hackRegion?: TextureRegion;\n    hackAttachment?: IAttachment;\n}\n\n/**\n * @public\n */\nexport interface ISkeleton<SkeletonData extends ISkeletonData = ISkeletonData, Bone extends IBone = IBone, Slot extends ISlot = ISlot, Skin extends ISkin = ISkin> {\n    bones: Bone[];\n    slots: Slot[];\n    drawOrder: Slot[];\n    skin: Skin;\n    data: SkeletonData;\n    x: number; // added for debug purposes\n    y: number; // added for debug purposes\n    updateWorldTransform(): void;\n    setToSetupPose(): void;\n    findSlotIndex(slotName: string): number;\n    getAttachmentByName(slotName: string, attachmentName: string): IAttachment;\n\n    setBonesToSetupPose(): void;\n    setSlotsToSetupPose(): void;\n    findBone(boneName: string): Bone;\n    findSlot(slotName: string): Slot;\n    findBoneIndex(boneName: string): number;\n    findSlotIndex(slotName: string): number;\n    setSkinByName(skinName: string): void;\n    setAttachment(slotName: string, attachmentName: string): void;\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number>): void;\n}\n\n/**\n * @public\n */\nexport interface ISkeletonParser {\n    scale: number;\n}\n\n/**\n * @public\n */\nexport interface ISkeletonData<\n    BoneData extends IBoneData = IBoneData,\n    SlotData extends ISlotData = ISlotData,\n    Skin extends ISkin = ISkin,\n    Animation extends IAnimation = IAnimation,\n    EventData extends IEventData = IEventData,\n    IkConstraintData extends IIkConstraintData = IIkConstraintData,\n    TransformConstraintData extends ITransformConstraintData = ITransformConstraintData,\n    PathConstraintData extends IPathConstraintData = IPathConstraintData\n> {\n    name: string;\n    bones: BoneData[];\n    slots: SlotData[];\n    skins: Skin[];\n    defaultSkin: Skin;\n    events: EventData[];\n    animations: Animation[];\n    version: string;\n    hash: string;\n    width: number;\n    height: number;\n    ikConstraints: IkConstraintData[];\n    transformConstraints: TransformConstraintData[];\n    pathConstraints: PathConstraintData[];\n\n    findBone(boneName: string): BoneData | null;\n    findBoneIndex(boneName: string): number;\n    findSlot(slotName: string): SlotData | null;\n    findSlotIndex(slotName: string): number;\n    findSkin(skinName: string): Skin | null;\n\n    findEvent(eventDataName: string): EventData | null;\n    findAnimation(animationName: string): Animation | null;\n    findIkConstraint(constraintName: string): IkConstraintData | null;\n    findTransformConstraint(constraintName: string): TransformConstraintData | null;\n    findPathConstraint(constraintName: string): PathConstraintData | null;\n}\n", "import type { Texture, Rectangle } from '@pixi/core';\n\n/**\n * @public\n */\nexport function filterFromString(text: string): TextureFilter {\n    switch (text.toLowerCase()) {\n        case 'nearest':\n            return TextureFilter.Nearest;\n        case 'linear':\n            return TextureFilter.Linear;\n        case 'mipmap':\n            return TextureFilter.MipMap;\n        case 'mipmapnearestnearest':\n            return TextureFilter.MipMapNearestNearest;\n        case 'mipmaplinearnearest':\n            return TextureFilter.MipMapLinearNearest;\n        case 'mipmapnearestlinear':\n            return TextureFilter.MipMapNearestLinear;\n        case 'mipmaplinearlinear':\n            return TextureFilter.MipMapLinearLinear;\n        default:\n            throw new Error(`Unknown texture filter ${text}`);\n    }\n}\n\n/**\n * @public\n */\nexport function wrapFromString(text: string): TextureWrap {\n    switch (text.toLowerCase()) {\n        case 'mirroredtepeat':\n            return TextureWrap.MirroredRepeat;\n        case 'clamptoedge':\n            return TextureWrap.ClampToEdge;\n        case 'repeat':\n            return TextureWrap.Repeat;\n        default:\n            throw new Error(`Unknown texture wrap ${text}`);\n    }\n}\n\n/**\n * @public\n */\nexport enum TextureFilter {\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\n    Linear = 9729, // WebGLRenderingContext.LINEAR\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n    MipMapLinearLinear = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n}\n\n/**\n * @public\n */\nexport enum TextureWrap {\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n    Repeat = 10497, // WebGLRenderingContext.REPEAT\n}\n\n/**\n * @public\n */\nexport class TextureRegion {\n    texture: Texture;\n\n    // thats for overrides\n    size: Rectangle = null;\n\n    names: string[] = null;\n    values: number[][] = null;\n\n    renderObject: any = null;\n\n    get width(): number {\n        const tex = this.texture;\n\n        if (tex.trim) {\n            return tex.trim.width;\n        }\n\n        return tex.orig.width;\n    }\n\n    get height(): number {\n        const tex = this.texture;\n\n        if (tex.trim) {\n            return tex.trim.height;\n        }\n\n        return tex.orig.height;\n    }\n\n    get u(): number {\n        return (this.texture as any)._uvs.x0;\n    }\n\n    get v(): number {\n        return (this.texture as any)._uvs.y0;\n    }\n\n    get u2(): number {\n        return (this.texture as any)._uvs.x2;\n    }\n\n    get v2(): number {\n        return (this.texture as any)._uvs.y2;\n    }\n\n    get offsetX(): number {\n        const tex = this.texture;\n\n        return tex.trim ? tex.trim.x : 0;\n    }\n\n    get offsetY(): number {\n        // console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n        return this.spineOffsetY;\n    }\n\n    get pixiOffsetY(): number {\n        const tex = this.texture;\n\n        return tex.trim ? tex.trim.y : 0;\n    }\n\n    get spineOffsetY(): number {\n        const tex = this.texture;\n\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n    }\n\n    get originalWidth(): number {\n        return this.texture.orig.width;\n    }\n\n    get originalHeight(): number {\n        return this.texture.orig.height;\n    }\n\n    get x(): number {\n        return this.texture.frame.x;\n    }\n\n    get y(): number {\n        return this.texture.frame.y;\n    }\n\n    get rotate(): boolean {\n        return this.texture.rotate !== 0;\n    }\n\n    get degrees() {\n        return (360 - this.texture.rotate * 45) % 360;\n    }\n}\n", "import { Texture, SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle } from '@pixi/core';\nimport { TextureRegion, TextureWrap, TextureFilter, filterFromString } from './TextureRegion';\nimport type { Map, Disposable } from './Utils';\nimport type { BaseTexture } from '@pixi/core';\n\nclass RegionFields {\n    x = 0;\n    y = 0;\n    width = 0;\n    height = 0;\n    offsetX = 0;\n    offsetY = 0;\n    originalWidth = 0;\n    originalHeight = 0;\n    rotate = 0;\n    index = 0;\n}\n/**\n * @public\n */\nexport class TextureAtlas implements Disposable {\n    pages = new Array<TextureAtlasPage>();\n    regions = new Array<TextureAtlasRegion>();\n\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\n        if (atlasText) {\n            this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n    }\n\n    addTexture(name: string, texture: Texture) {\n        const pages = this.pages;\n        let page: TextureAtlasPage = null;\n\n        for (let i = 0; i < pages.length; i++) {\n            if (pages[i].baseTexture === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new TextureAtlasPage();\n            page.name = 'texturePage';\n            const baseTexture = texture.baseTexture;\n\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.baseTexture = baseTexture;\n            // those fields are not relevant in Pixi\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\n            page.uWrap = TextureWrap.ClampToEdge;\n            page.vWrap = TextureWrap.ClampToEdge;\n            pages.push(page);\n        }\n        const region = new TextureAtlasRegion();\n\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n\n        return region;\n    }\n\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\n        for (const key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    }\n\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        return this.load(atlasText, textureLoader, callback);\n    }\n\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (textureLoader == null) {\n            throw new Error('textureLoader cannot be null.');\n        }\n\n        const reader = new TextureAtlasReader(atlasText);\n        const entry = new Array<string>(4);\n        let page: TextureAtlasPage = null;\n        const pageFields: Map<Function> = {};\n        let region: RegionFields = null;\n\n        pageFields.size = () => {\n            page.width = parseInt(entry[1]);\n            page.height = parseInt(entry[2]);\n        };\n        pageFields.format = () => {\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\n        };\n        pageFields.filter = () => {\n            page.minFilter = filterFromString(entry[1]);\n            page.magFilter = filterFromString(entry[2]);\n        };\n        pageFields.repeat = () => {\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\n        };\n        pageFields.pma = () => {\n            page.pma = entry[1] == 'true';\n        };\n\n        const regionFields: Map<Function> = {};\n\n        regionFields.xy = () => {\n            // Deprecated, use bounds.\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n        };\n        regionFields.size = () => {\n            // Deprecated, use bounds.\n            region.width = parseInt(entry[1]);\n            region.height = parseInt(entry[2]);\n        };\n        regionFields.bounds = () => {\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n            region.width = parseInt(entry[3]);\n            region.height = parseInt(entry[4]);\n        };\n        regionFields.offset = () => {\n            // Deprecated, use offsets.\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n        };\n        regionFields.orig = () => {\n            // Deprecated, use offsets.\n            region.originalWidth = parseInt(entry[1]);\n            region.originalHeight = parseInt(entry[2]);\n        };\n        regionFields.offsets = () => {\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n            region.originalWidth = parseInt(entry[3]);\n            region.originalHeight = parseInt(entry[4]);\n        };\n        regionFields.rotate = () => {\n            const rotateValue = entry[1];\n            let rotate = 0;\n\n            if (rotateValue.toLocaleLowerCase() == 'true') {\n                rotate = 6;\n            } else if (rotateValue.toLocaleLowerCase() == 'false') {\n                rotate = 0;\n            } else {\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\n            }\n            region.rotate = rotate;\n        };\n        regionFields.index = () => {\n            region.index = parseInt(entry[1]);\n        };\n\n        let line = reader.readLine();\n        // Ignore empty lines before first entry.\n\n        while (line != null && line.trim().length == 0) {\n            line = reader.readLine();\n        }\n        // Header entries.\n        while (true) {\n            if (line == null || line.trim().length == 0) break;\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n            line = reader.readLine();\n        }\n\n        const iterateParser = () => {\n            while (true) {\n                if (line == null) {\n                    return callback && callback(this);\n                }\n                if (line.trim().length == 0) {\n                    page = null;\n                    line = reader.readLine();\n                } else if (page === null) {\n                    page = new TextureAtlasPage();\n                    page.name = line.trim();\n\n                    while (true) {\n                        if (reader.readEntry(entry, (line = reader.readLine())) == 0) break;\n                        const field: Function = pageFields[entry[0]];\n\n                        if (field) field();\n                    }\n                    this.pages.push(page);\n\n                    textureLoader(page.name, (texture: BaseTexture) => {\n                        if (texture === null) {\n                            this.pages.splice(this.pages.indexOf(page), 1);\n\n                            return callback && callback(null);\n                        }\n                        page.baseTexture = texture;\n                        // TODO: set scaleMode and mipmapMode from spine\n                        if (page.pma) {\n                            texture.alphaMode = ALPHA_MODES.PMA;\n                        }\n                        if (!texture.valid) {\n                            texture.setSize(page.width, page.height);\n                        }\n                        page.setFilters();\n\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\n                                    `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`\n                                );\n                            }\n                        }\n                        iterateParser();\n                    });\n                    break;\n                } else {\n                    region = new RegionFields();\n                    const atlasRegion = new TextureAtlasRegion();\n\n                    atlasRegion.name = line;\n                    atlasRegion.page = page;\n                    let names: string[] = null;\n                    let values: number[][] = null;\n\n                    while (true) {\n                        const count = reader.readEntry(entry, (line = reader.readLine()));\n\n                        if (count == 0) break;\n                        const field: Function = regionFields[entry[0]];\n\n                        if (field) {\n                            field();\n                        } else {\n                            if (names == null) {\n                                names = [];\n                                values = [];\n                            }\n                            names.push(entry[0]);\n                            const entryValues: number[] = [];\n\n                            for (let i = 0; i < count; i++) {\n                                entryValues.push(parseInt(entry[i + 1]));\n                            }\n                            values.push(entryValues);\n                        }\n                    }\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\n                        region.originalWidth = region.width;\n                        region.originalHeight = region.height;\n                    }\n\n                    const resolution = page.baseTexture.resolution;\n\n                    region.x /= resolution;\n                    region.y /= resolution;\n                    region.width /= resolution;\n                    region.height /= resolution;\n                    region.originalWidth /= resolution;\n                    region.originalHeight /= resolution;\n                    region.offsetX /= resolution;\n                    region.offsetY /= resolution;\n\n                    const swapWH = region.rotate % 4 !== 0;\n                    const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n\n                    const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n                    const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n                    atlasRegion.index = region.index;\n                    atlasRegion.texture.updateUvs();\n\n                    this.regions.push(atlasRegion);\n                }\n            }\n        };\n\n        iterateParser();\n    }\n\n    findRegion(name: string): TextureAtlasRegion {\n        for (let i = 0; i < this.regions.length; i++) {\n            if (this.regions[i].name == name) {\n                return this.regions[i];\n            }\n        }\n\n        return null;\n    }\n\n    dispose() {\n        for (let i = 0; i < this.pages.length; i++) {\n            this.pages[i].baseTexture.dispose();\n        }\n    }\n}\n\n/**\n * @public\n */\nclass TextureAtlasReader {\n    lines: Array<string>;\n    index = 0;\n\n    constructor(text: string) {\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n    }\n\n    readLine(): string {\n        if (this.index >= this.lines.length) {\n            return null;\n        }\n\n        return this.lines[this.index++];\n    }\n\n    readEntry(entry: string[], line: string): number {\n        if (line == null) return 0;\n        line = line.trim();\n        if (line.length == 0) return 0;\n\n        const colon = line.indexOf(':');\n\n        if (colon == -1) return 0;\n        entry[0] = line.substr(0, colon).trim();\n        for (let i = 1, lastMatch = colon + 1; ; i++) {\n            const comma = line.indexOf(',', lastMatch);\n\n            if (comma == -1) {\n                entry[i] = line.substr(lastMatch).trim();\n\n                return i;\n            }\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n            lastMatch = comma + 1;\n            if (i == 4) return 4;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasPage {\n    name: string;\n    minFilter: TextureFilter = TextureFilter.Nearest;\n    magFilter: TextureFilter = TextureFilter.Nearest;\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\n    baseTexture: BaseTexture;\n    width: number;\n    height: number;\n    pma: boolean;\n\n    public setFilters() {\n        const tex = this.baseTexture;\n        const filter = this.minFilter;\n\n        if (filter == TextureFilter.Linear) {\n            tex.scaleMode = SCALE_MODES.LINEAR;\n        } else if (this.minFilter == TextureFilter.Nearest) {\n            tex.scaleMode = SCALE_MODES.NEAREST;\n        } else {\n            tex.mipmap = MIPMAP_MODES.POW2;\n            if (filter == TextureFilter.MipMapNearestNearest) {\n                tex.scaleMode = SCALE_MODES.NEAREST;\n            } else {\n                tex.scaleMode = SCALE_MODES.LINEAR;\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasRegion extends TextureRegion {\n    page: TextureAtlasPage;\n    name: string;\n    index: number;\n}\n", "import type { ISkeleton } from './ISkeleton';\n\n/**\n * @public\n */\n\nexport interface Map<T> {\n    [key: string]: T;\n}\n\n/**\n * @public\n */\nexport interface StringMap<T> {\n    [key: string]: T;\n}\n\n/**\n * @public\n */\nexport class IntSet {\n    array = new Array<number>();\n\n    add(value: number): boolean {\n        const contains = this.contains(value);\n\n        this.array[value | 0] = value | 0;\n\n        return !contains;\n    }\n\n    contains(value: number) {\n        return this.array[value | 0] != undefined;\n    }\n\n    remove(value: number) {\n        this.array[value | 0] = undefined;\n    }\n\n    clear() {\n        this.array.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport class StringSet {\n    entries: StringMap<boolean> = {};\n    size = 0;\n\n    add(value: string): boolean {\n        const contains = this.entries[value];\n\n        this.entries[value] = true;\n        if (!contains) {\n            this.size++;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    addAll(values: string[]): boolean {\n        const oldSize = this.size;\n\n        for (let i = 0, n = values.length; i < n; i++) {\n            this.add(values[i]);\n        }\n\n        return oldSize != this.size;\n    }\n\n    contains(value: string) {\n        return this.entries[value];\n    }\n\n    clear() {\n        this.entries = {};\n        this.size = 0;\n    }\n}\n\n/**\n * @public\n */\nexport interface NumberArrayLike {\n    readonly length: number;\n    [n: number]: number;\n}\n\n/**\n * @public\n */\nexport interface Disposable {\n    dispose(): void;\n}\n\n/**\n * @public\n */\nexport interface Restorable {\n    restore(): void;\n}\n\n/**\n * @public\n */\nexport class Color {\n    public static WHITE = new Color(1, 1, 1, 1);\n    public static RED = new Color(1, 0, 0, 1);\n    public static GREEN = new Color(0, 1, 0, 1);\n    public static BLUE = new Color(0, 0, 1, 1);\n    public static MAGENTA = new Color(1, 0, 1, 1);\n\n    constructor(public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {}\n\n    set(r: number, g: number, b: number, a: number) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n\n        return this.clamp();\n    }\n\n    setFromColor(c: Color) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n\n        return this;\n    }\n\n    setFromString(hex: string) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255;\n        this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;\n\n        return this;\n    }\n\n    add(r: number, g: number, b: number, a: number) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n\n        return this.clamp();\n    }\n\n    clamp() {\n        if (this.r < 0) this.r = 0;\n        else if (this.r > 1) this.r = 1;\n\n        if (this.g < 0) this.g = 0;\n        else if (this.g > 1) this.g = 1;\n\n        if (this.b < 0) this.b = 0;\n        else if (this.b > 1) this.b = 1;\n\n        if (this.a < 0) this.a = 0;\n        else if (this.a > 1) this.a = 1;\n\n        return this;\n    }\n\n    static rgba8888ToColor(color: Color, value: number) {\n        color.r = ((value & 0xff000000) >>> 24) / 255;\n        color.g = ((value & 0x00ff0000) >>> 16) / 255;\n        color.b = ((value & 0x0000ff00) >>> 8) / 255;\n        color.a = (value & 0x000000ff) / 255;\n    }\n\n    static rgb888ToColor(color: Color, value: number) {\n        color.r = ((value & 0x00ff0000) >>> 16) / 255;\n        color.g = ((value & 0x0000ff00) >>> 8) / 255;\n        color.b = (value & 0x000000ff) / 255;\n    }\n\n    static fromString(hex: string): Color {\n        return new Color().setFromString(hex);\n    }\n}\n\n/**\n * @public\n */\nexport class MathUtils {\n    static PI = 3.1415927;\n    static PI2 = MathUtils.PI * 2;\n    static radiansToDegrees = 180 / MathUtils.PI;\n    static radDeg = MathUtils.radiansToDegrees;\n    static degreesToRadians = MathUtils.PI / 180;\n    static degRad = MathUtils.degreesToRadians;\n\n    static clamp(value: number, min: number, max: number) {\n        if (value < min) return min;\n        if (value > max) return max;\n\n        return value;\n    }\n\n    static cosDeg(degrees: number) {\n        return Math.cos(degrees * MathUtils.degRad);\n    }\n\n    static sinDeg(degrees: number) {\n        return Math.sin(degrees * MathUtils.degRad);\n    }\n\n    static signum(value: number): number {\n        return Math.sign(value);\n    }\n\n    static toInt(x: number) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n    }\n\n    static cbrt(x: number) {\n        const y = Math.pow(Math.abs(x), 1 / 3);\n\n        return x < 0 ? -y : y;\n    }\n\n    static randomTriangular(min: number, max: number): number {\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n    }\n\n    static randomTriangularWith(min: number, max: number, mode: number): number {\n        const u = Math.random();\n        const d = max - min;\n\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n\n        return max - Math.sqrt((1 - u) * d * (max - mode));\n    }\n\n    static isPowerOfTwo(value: number) {\n        return value && (value & (value - 1)) === 0;\n    }\n}\n\n/**\n * @public\n */\nexport abstract class Interpolation {\n    protected abstract applyInternal(a: number): number;\n    apply(start: number, end: number, a: number): number {\n        return start + (end - start) * this.applyInternal(a);\n    }\n}\n\n/**\n * @public\n */\nexport class Pow extends Interpolation {\n    protected power = 2;\n\n    constructor(power: number) {\n        super();\n        this.power = power;\n    }\n\n    applyInternal(a: number): number {\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n    }\n}\n\n/**\n * @public\n */\nexport class PowOut extends Pow {\n    applyInternal(a: number): number {\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n    }\n}\n\n/**\n * @public\n */\nexport class Utils {\n    static SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== 'undefined';\n\n    static arrayCopy<T>(source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n            dest[j] = source[i];\n        }\n    }\n\n    static arrayFill<T>(array: ArrayLike<T>, fromIndex: number, toIndex: number, value: T) {\n        for (let i = fromIndex; i < toIndex; i++) {\n            array[i] = value;\n        }\n    }\n\n    static setArraySize<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n        const oldSize = array.length;\n\n        if (oldSize == size) return array;\n        array.length = size;\n        if (oldSize < size) {\n            for (let i = oldSize; i < size; i++) array[i] = value;\n        }\n\n        return array;\n    }\n\n    static ensureArrayCapacity<T>(array: Array<T>, size: number, value: any = 0): Array<T> {\n        if (array.length >= size) return array;\n\n        return Utils.setArraySize(array, size, value);\n    }\n\n    static newArray<T>(size: number, defaultValue: T): Array<T> {\n        const array = new Array<T>(size);\n\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\n\n        return array;\n    }\n\n    static newFloatArray(size: number): NumberArrayLike {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Float32Array(size);\n        }\n\n        const array = new Array<number>(size);\n\n        for (let i = 0; i < array.length; i++) array[i] = 0;\n\n        return array;\n    }\n\n    static newShortArray(size: number): NumberArrayLike {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n            return new Int16Array(size);\n        }\n\n        const array = new Array<number>(size);\n\n        for (let i = 0; i < array.length; i++) array[i] = 0;\n\n        return array;\n    }\n\n    static toFloatArray(array: Array<number>) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n    }\n\n    static toSinglePrecision(value: number) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n    }\n\n    // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n    static webkit602BugfixHelper(alpha: number, blend: any) {}\n\n    static contains<T>(array: Array<T>, element: T, identity = true) {\n        for (let i = 0; i < array.length; i++) {\n            if (array[i] == element) return true;\n        }\n\n        return false;\n    }\n\n    static enumValue(type: any, name: string) {\n        return type[name[0].toUpperCase() + name.slice(1)];\n    }\n}\n\n/**\n * @public\n */\nexport class DebugUtils {\n    static logBones(skeleton: ISkeleton) {\n        for (let i = 0; i < skeleton.bones.length; i++) {\n            const bone = skeleton.bones[i];\n            const mat = bone.matrix;\n\n            console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class Pool<T> {\n    private items = new Array<T>();\n    private instantiator: () => T;\n\n    constructor(instantiator: () => T) {\n        this.instantiator = instantiator;\n    }\n\n    obtain() {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n    }\n\n    free(item: T) {\n        if ((item as any).reset) (item as any).reset();\n        this.items.push(item);\n    }\n\n    freeAll(items: ArrayLike<T>) {\n        for (let i = 0; i < items.length; i++) {\n            this.free(items[i]);\n        }\n    }\n\n    clear() {\n        this.items.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport class Vector2 {\n    constructor(public x = 0, public y = 0) {}\n\n    set(x: number, y: number): Vector2 {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    length() {\n        const x = this.x;\n        const y = this.y;\n\n        return Math.sqrt(x * x + y * y);\n    }\n\n    normalize() {\n        const len = this.length();\n\n        if (len != 0) {\n            this.x /= len;\n            this.y /= len;\n        }\n\n        return this;\n    }\n}\n\n/**\n * @public\n */\nexport class TimeKeeper {\n    maxDelta = 0.064;\n    framesPerSecond = 0;\n    delta = 0;\n    totalTime = 0;\n\n    private lastTime = Date.now() / 1000;\n    private frameCount = 0;\n    private frameTime = 0;\n\n    update() {\n        const now = Date.now() / 1000;\n\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n\n        this.frameCount++;\n        if (this.frameTime > 1) {\n            this.framesPerSecond = this.frameCount / this.frameTime;\n            this.frameTime = 0;\n            this.frameCount = 0;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport interface ArrayLike<T> {\n    length: number;\n    [n: number]: T;\n}\n\n/**\n * @public\n */\nexport class WindowedMean {\n    values: Array<number>;\n    addedValues = 0;\n    lastValue = 0;\n    mean = 0;\n    dirty = true;\n\n    constructor(windowSize = 32) {\n        this.values = new Array<number>(windowSize);\n    }\n\n    hasEnoughData() {\n        return this.addedValues >= this.values.length;\n    }\n\n    addValue(value: number) {\n        if (this.addedValues < this.values.length) this.addedValues++;\n        this.values[this.lastValue++] = value;\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n        this.dirty = true;\n    }\n\n    getMean() {\n        if (this.hasEnoughData()) {\n            if (this.dirty) {\n                let mean = 0;\n\n                for (let i = 0; i < this.values.length; i++) {\n                    mean += this.values[i];\n                }\n                this.mean = mean / this.values.length;\n                this.dirty = false;\n            }\n\n            return this.mean;\n        }\n\n        return 0;\n    }\n}\n", "import { AttachmentType } from './AttachmentType';\nimport type { ISkeleton, IVertexAttachment } from './ISkeleton';\nimport { NumberArrayLike, Pool, Utils } from './Utils';\n\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBoundsBase<BoundingBoxAttachment extends IVertexAttachment> {\n    /** The left edge of the axis aligned bounding box. */\n    minX = 0;\n\n    /** The bottom edge of the axis aligned bounding box. */\n    minY = 0;\n\n    /** The right edge of the axis aligned bounding box. */\n    maxX = 0;\n\n    /** The top edge of the axis aligned bounding box. */\n    maxY = 0;\n\n    /** The visible bounding boxes. */\n    boundingBoxes = new Array<BoundingBoxAttachment>();\n\n    /** The world vertices for the bounding box polygons. */\n    polygons = new Array<NumberArrayLike>();\n\n    private polygonPool = new Pool<NumberArrayLike>(() => Utils.newFloatArray(16));\n\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n     * box's polygon.\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n     *           SkeletonBounds AABB methods will always return true. */\n    update(skeleton: ISkeleton, updateAabb: boolean) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        const boundingBoxes = this.boundingBoxes;\n        const polygons = this.polygons;\n        const polygonPool = this.polygonPool;\n        const slots = skeleton.slots;\n        const slotCount = slots.length;\n\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (let i = 0; i < slotCount; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) continue;\n            const attachment = slot.getAttachment();\n\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\n                const boundingBox = attachment as BoundingBoxAttachment;\n\n                boundingBoxes.push(boundingBox);\n\n                let polygon = polygonPool.obtain() as NumberArrayLike;\n\n                if (polygon.length != boundingBox.worldVerticesLength) {\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                }\n                polygons.push(polygon);\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n            }\n        }\n\n        if (updateAabb) {\n            this.aabbCompute();\n        } else {\n            this.minX = Number.POSITIVE_INFINITY;\n            this.minY = Number.POSITIVE_INFINITY;\n            this.maxX = Number.NEGATIVE_INFINITY;\n            this.maxY = Number.NEGATIVE_INFINITY;\n        }\n    }\n\n    aabbCompute() {\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            const polygon = polygons[i];\n            const vertices = polygon;\n\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                const x = vertices[ii];\n                const y = vertices[ii + 1];\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint(x: number, y: number) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {\n            return false;\n        }\n        const m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        let x = (minY - y1) / m + x1;\n\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n\n        return false;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton(bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    }\n\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\n    containsPoint(x: number, y: number): BoundingBoxAttachment | null {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains the point. */\n    containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        let prevIndex = nn - 2;\n        let inside = false;\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const vertexY = vertices[ii + 1];\n            const prevY = vertices[prevIndex + 1];\n\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                const vertexX = vertices[ii];\n\n                if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n\n        return inside;\n    }\n\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n     * true. */\n    intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains any part of the line segment. */\n    intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        const width12 = x1 - x2;\n        const height12 = y1 - y2;\n        const det1 = x1 * y2 - y1 * x2;\n        let x3 = vertices[nn - 2];\n        let y3 = vertices[nn - 1];\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const x4 = vertices[ii];\n            const y4 = vertices[ii + 1];\n            const det2 = x3 * y4 - y3 * x4;\n            const width34 = x3 - x4;\n            const height34 = y3 - y4;\n            const det3 = width12 * height34 - height12 * width34;\n            const x = (det1 * width34 - width12 * det2) / det3;\n\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                const y = (det1 * height34 - height12 * det2) / det3;\n\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n\n        return false;\n    }\n\n    /** Returns the polygon for the specified bounding box, or null. */\n    getPolygon(boundingBox: BoundingBoxAttachment) {\n        if (!boundingBox) throw new Error('boundingBox cannot be null.');\n        const index = this.boundingBoxes.indexOf(boundingBox);\n\n        return index == -1 ? null : this.polygons[index];\n    }\n\n    /** The width of the axis aligned bounding box. */\n    getWidth() {\n        return this.maxX - this.minX;\n    }\n\n    /** The height of the axis aligned bounding box. */\n    getHeight() {\n        return this.maxY - this.minY;\n    }\n}\n", "/**\n * @public\n */\nexport const settings = {\n    yDown: true,\n    /**\n     * pixi-spine gives option to not fail at certain parsing errors\n     * spine-ts fails here\n     */\n    FAIL_ON_NON_EXISTING_SKIN: false,\n\n    /**\n     * past Spine.globalAutoUpdate\n     */\n    GLOBAL_AUTO_UPDATE: true,\n\n    /**\n     * past Spine.globalDelayLimit\n     */\n    GLOBAL_DELAY_LIMIT: 0,\n};\n", "import { AttachmentType } from './core/AttachmentType';\nimport { TextureRegion } from './core/TextureRegion';\nimport { MathUtils } from './core/Utils';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IAttachment, IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, ISlot, IVertexAttachment } from './core/ISkeleton';\nimport { DRAW_MODES, Rectangle, Polygon, Transform, Texture, utils } from '@pixi/core';\nimport { Container, DisplayObject } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { settings } from './settings';\nimport type { ISpineDebugRenderer } from './SpineDebugRenderer';\n\nconst tempRgb = [0, 0, 0];\n\n/**\n * @public\n */\nexport interface ISpineDisplayObject extends DisplayObject {\n    region?: TextureRegion;\n    attachment?: IAttachment;\n}\n\n/**\n * @public\n */\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n}\n\n/**\n * @public\n */\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * let spineAnimation = new spine(spineData);\n * ```\n *\n * @public\n * @class\n * @extends Container\n * @memberof spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport abstract class SpineBase<\n        Skeleton extends ISkeleton,\n        SkeletonData extends ISkeletonData,\n        AnimationState extends IAnimationState,\n        AnimationStateData extends IAnimationStateData\n    >\n    extends Container\n    implements GlobalMixins.Spine\n{\n    tintRgb: ArrayLike<number>;\n    spineData: SkeletonData;\n    skeleton: Skeleton;\n    stateData: AnimationStateData;\n    state: AnimationState;\n    slotContainers: Array<Container>;\n    tempClipContainers: Array<Container>;\n    localDelayLimit: number;\n    private _autoUpdate: boolean;\n    protected _visible: boolean;\n    private _debug: ISpineDebugRenderer;\n    public get debug(): ISpineDebugRenderer {\n        return this._debug;\n    }\n    public set debug(value: ISpineDebugRenderer) {\n        if (value == this._debug) {\n            // soft equality allows null == undefined\n            return;\n        }\n        this._debug?.unregisterSpine(this);\n        value?.registerSpine(this);\n        this._debug = value;\n    }\n\n    abstract createSkeleton(spineData: ISkeletonData);\n\n    constructor(spineData: SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if (typeof spineData === 'string') {\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.createSkeleton(spineData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        this.tempClipContainers = [];\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n            const attachment: any = slot.getAttachment();\n            const slotContainer = this.newContainer();\n\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n            this.tempClipContainers.push(null);\n\n            if (!attachment) {\n                continue;\n            }\n            if (attachment.type === AttachmentType.Region) {\n                const spriteName = attachment.name;\n                const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            } else if (attachment.type === AttachmentType.Mesh) {\n                const mesh = this.createMesh(slot, attachment);\n\n                slot.currentMesh = mesh;\n                slot.currentMeshId = attachment.id;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            } else if (attachment.type === AttachmentType.Clipping) {\n                this.createGraphics(slot, attachment);\n                slotContainer.addChild(slot.clippingContainer);\n                slotContainer.addChild(slot.currentGraphics);\n            }\n        }\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        this.autoUpdate = true;\n        this.visible = true;\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be automatically updated every\n     * time the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoUpdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n        }\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return utils.rgb2hex(this.tintRgb as any);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = utils.hex2rgb(value, this.tintRgb as any);\n    }\n\n    /**\n     * Limit value for the update dt with Spine.globalDelayLimit\n     * that can be overridden with localDelayLimit\n     * @return {number} - Maximum processed dt value for the update\n     */\n    get delayLimit(): number {\n        const limit = typeof this.localDelayLimit !== 'undefined' ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\n\n        // If limit is 0, this means there is no limit for the delay\n        return limit || Number.MAX_VALUE;\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        // Limit delta value to avoid animation jumps\n        const delayLimit = this.delayLimit;\n\n        if (dt > delayLimit) dt = delayLimit;\n\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n\n        // check we haven't been destroyed via a spine event callback in state update\n        if (!this.skeleton) {\n            return;\n        }\n\n        this.skeleton.updateWorldTransform();\n\n        const slots = this.skeleton.slots;\n\n        // in case pixi has double tint\n        const globalClr = (this as any).color;\n        let light: ArrayLike<number> = null;\n        let dark: ArrayLike<number> = null;\n\n        if (globalClr) {\n            light = globalClr.light;\n            dark = globalClr.dark;\n        } else {\n            light = this.tintRgb;\n        }\n\n        // let thack = false;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n            const slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            let spriteColor: any = null;\n\n            if (attachment.sequence) {\n                attachment.sequence.apply(slot, attachment as any);\n            }\n            let region = (attachment as IRegionAttachment).region;\n\n            const attColor = (attachment as any).color;\n\n            switch (attachment != null && attachment.type) {\n                case AttachmentType.Region:\n                    const transform = slotContainer.transform;\n\n                    transform.setFromMatrix(slot.bone.matrix);\n\n                    region = (attachment as IRegionAttachment).region;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                        slot.currentMesh = null;\n                        slot.currentMeshId = undefined;\n                        slot.currentMeshName = undefined;\n                    }\n                    if (!region) {\n                        if (slot.currentSprite) {\n                            slot.currentSprite.renderable = false;\n                        }\n                        break;\n                    }\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\n                        const spriteName = attachment.name;\n\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        } else {\n                            const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n\n                        // force sprite update when attachment name is same.\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\n                    }\n                    slot.currentSprite.renderable = true;\n                    if (!slot.hackRegion) {\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\n                    }\n                    if (slot.currentSprite.color) {\n                        // YAY! double - tint!\n                        spriteColor = slot.currentSprite.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentSprite.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentSprite.blendMode = slot.blendMode;\n                    break;\n\n                case AttachmentType.Mesh:\n                    if (slot.currentSprite) {\n                        // TODO: refactor this thing, switch it on and off for container\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n\n                        // TODO: refactor this shit\n                        const transform = new Transform();\n\n                        (transform as any)._parentID = -1;\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\n                        slotContainer.transform = transform;\n                    }\n                    if (!region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.renderable = false;\n                        }\n                        break;\n                    }\n\n                    const id = (attachment as IVertexAttachment).id;\n\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\n                        const meshId = id;\n\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n\n                        slot.meshes = slot.meshes || {};\n\n                        if (slot.meshes[meshId] !== undefined) {\n                            slot.meshes[meshId].visible = true;\n                        } else {\n                            const mesh = this.createMesh(slot, attachment as IMeshAttachment);\n\n                            slotContainer.addChild(mesh);\n                        }\n\n                        slot.currentMesh = slot.meshes[meshId];\n                        slot.currentMeshName = attachment.name;\n                        slot.currentMeshId = meshId;\n                    }\n                    slot.currentMesh.renderable = true;\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (slot.currentMesh.color) {\n                        // pixi-heaven\n                        spriteColor = slot.currentMesh.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentMesh.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                    if (!slot.hackRegion) {\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\n                    }\n                    break;\n                case AttachmentType.Clipping:\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment as IClippingAttachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\n                    slotContainer.alpha = 1.0;\n                    slotContainer.visible = true;\n                    continue;\n                default:\n                    slotContainer.visible = false;\n                    continue;\n            }\n            slotContainer.visible = true;\n\n            // pixi has double tint\n            if (spriteColor) {\n                let r0 = slot.color.r * attColor.r;\n                let g0 = slot.color.g * attColor.g;\n                let b0 = slot.color.b * attColor.b;\n\n                // YAY! double-tint!\n                spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\n                if (slot.darkColor) {\n                    r0 = slot.darkColor.r;\n                    g0 = slot.darkColor.g;\n                    b0 = slot.darkColor.b;\n                } else {\n                    r0 = 0.0;\n                    g0 = 0.0;\n                    b0 = 0.0;\n                }\n                spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n            }\n\n            slotContainer.alpha = slot.color.a;\n        }\n\n        // == this is clipping implementation ===\n        // TODO: remove parent hacks when pixi masks allow it\n        const drawOrder = this.skeleton.drawOrder;\n        let clippingAttachment: IClippingAttachment = null;\n        let clippingContainer: Container = null;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = slots[drawOrder[i].data.index];\n            const slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n            if (!clippingContainer) {\n                // Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\n                    slotContainer.parent.removeChild(slotContainer);\n                    // silend add hack\n                    (slotContainer as any).parent = this;\n                }\n            }\n            if (slot.currentGraphics && slot.getAttachment()) {\n                clippingContainer = slot.clippingContainer;\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\n                clippingContainer.children.length = 0;\n                this.children[i] = slotContainer;\n\n                if (clippingAttachment.endSlot === slot.data) {\n                    clippingAttachment.endSlot = null;\n                }\n            } else if (clippingContainer) {\n                let c = this.tempClipContainers[i];\n\n                if (!c) {\n                    c = this.tempClipContainers[i] = this.newContainer();\n                    c.visible = false;\n                }\n                this.children[i] = c;\n\n                // silent remove hack\n                (slotContainer as any).parent = null;\n                clippingContainer.addChild(slotContainer);\n                if (clippingAttachment.endSlot == slot.data) {\n                    clippingContainer.renderable = true;\n                    clippingContainer = null;\n                    clippingAttachment = null;\n                }\n            } else {\n                this.children[i] = slotContainer;\n            }\n        }\n\n        // if you can debug, then debug!\n        this._debug?.renderDebug(this);\n    }\n\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\n        // prevent setters calling when attachment and region is same\n        if (sprite.attachment === attachment && sprite.region === region) {\n            return;\n        }\n\n        sprite.region = region;\n        sprite.attachment = attachment;\n\n        sprite.texture = region.texture;\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        if (!region.size) {\n            sprite.scale.x = (attachment.scaleX * attachment.width) / region.originalWidth;\n            sprite.scale.y = (-attachment.scaleY * attachment.height) / region.originalHeight;\n        } else {\n            // hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\n        if (mesh.attachment === attachment && mesh.region === region) {\n            return;\n        }\n\n        mesh.region = region;\n        mesh.attachment = attachment;\n        mesh.texture = region.texture;\n        region.texture.updateUvs();\n        mesh.uvBuffer.update(attachment.regionUVs);\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (settings.GLOBAL_AUTO_UPDATE) {\n            this.lastTime = this.lastTime || Date.now();\n            const timeDelta = (Date.now() - this.lastTime) * 0.001;\n\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        Container.prototype.updateTransform.call(this);\n    }\n\n    /**\n     * Create a new sprite to be used with core.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n        }\n        const texture = region ? region.texture : null;\n        const sprite = this.newSprite(texture);\n\n        sprite.anchor.set(0.5);\n        if (region) {\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n        }\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[defName] = sprite;\n\n        return sprite;\n    }\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n            slot.hackAttachment = null;\n            slot.hackRegion = null;\n        }\n        const strip = this.newMesh(\n            region ? region.texture : null,\n            new Float32Array(attachment.regionUVs.length),\n            attachment.regionUVs,\n            new Uint16Array(attachment.triangles),\n            DRAW_MODES.TRIANGLES\n        );\n\n        if (typeof (strip as any)._canvasPadding !== 'undefined') {\n            (strip as any)._canvasPadding = 1.5;\n        }\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        if (region) {\n            this.setMeshRegion(attachment, strip, region);\n        }\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.id] = strip;\n\n        return strip;\n    }\n\n    static clippingPolygon: Array<number> = [];\n\n    // @ts-ignore\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const graphics = this.newGraphics();\n        const poly = new Polygon([]);\n\n        graphics.clear();\n        graphics.beginFill(0xffffff, 1);\n        graphics.drawPolygon(poly as any);\n        graphics.renderable = false;\n        slot.currentGraphics = graphics;\n        slot.clippingContainer = this.newContainer();\n        slot.clippingContainer.mask = slot.currentGraphics;\n\n        return graphics;\n    }\n\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const geom = slot.currentGraphics.geometry;\n        const vertices = (geom.graphicsData[0].shape as Polygon).points;\n        const n = clip.worldVerticesLength;\n\n        vertices.length = n;\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n        geom.invalidate();\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n        const attachment: any = slot.getAttachment();\n        let region: TextureRegion = attachment.region;\n\n        if (texture) {\n            region = new TextureRegion();\n            region.texture = texture;\n            region.size = size;\n            slot.hackRegion = region;\n            slot.hackAttachment = attachment;\n        } else {\n            slot.hackRegion = null;\n            slot.hackAttachment = null;\n        }\n        if (slot.currentSprite) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n        } else if (slot.currentMesh) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        }\n\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\n        const index = this.skeleton.findSlotIndex(slotName);\n\n        if (index == -1) {\n            return false;\n        }\n\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n\n    /**\n     * Changes texture of an attachment\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param attachmentName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\n        // changes the texture of an attachment at the skeleton level\n        const slotIndex = this.skeleton.findSlotIndex(slotName);\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName);\n\n        attachment.region.texture = texture;\n\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n\n        // gets the currently active attachment in this slot\n        const currentAttachment: any = slot.getAttachment();\n\n        if (attachmentName === currentAttachment.name) {\n            // if the attachment we are changing is currently active, change the the live texture\n            let region: TextureRegion = attachment.region;\n\n            if (texture) {\n                region = new TextureRegion();\n                region.texture = texture;\n                region.size = size;\n                slot.hackRegion = region;\n                slot.hackAttachment = currentAttachment;\n            } else {\n                slot.hackRegion = null;\n                slot.hackAttachment = null;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // those methods can be overriden to spawn different classes\n    newContainer() {\n        return new Container();\n    }\n\n    newSprite(tex: Texture) {\n        return new SpineSprite(tex);\n    }\n\n    newGraphics() {\n        return new Graphics();\n    }\n\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n    }\n\n    transformHack() {\n        return 1;\n    }\n\n    /**\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\n     * @param nameSuffix\n     * @param group\n     * @param outGroup\n     */\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\n        if (!nameSuffix) {\n            return undefined;\n        }\n        const list_d = [];\n        const list_n = [];\n\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n            const slot = this.skeleton.slots[i];\n            const name = slot.currentSpriteName || slot.currentMeshName || '';\n            const target = slot.currentSprite || slot.currentMesh;\n\n            if (name.endsWith(nameSuffix)) {\n                target.parentGroup = group;\n                list_n.push(target);\n            } else if (outGroup && target) {\n                target.parentGroup = outGroup;\n                list_d.push(target);\n            }\n        }\n\n        return [list_d, list_n];\n    }\n\n    destroy(options?: any): void {\n        this.debug = null; // setter will do the cleanup\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n\n            for (const name in slot.meshes) {\n                slot.meshes[name].destroy(options);\n            }\n            slot.meshes = null;\n\n            for (const name in slot.sprites) {\n                slot.sprites[name].destroy(options);\n            }\n            slot.sprites = null;\n        }\n\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n            this.slotContainers[i].destroy(options);\n        }\n        this.spineData = null;\n        this.skeleton = null;\n        this.slotContainers = null;\n        this.stateData = null;\n        this.state = null;\n        this.tempClipContainers = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * The visibility of the spine object. If false the object will not be drawn,\n * the updateTransform function will not be called, and the spine will not be automatically updated.\n *\n * @member {boolean}\n * @memberof spine.Spine#\n * @default true\n */\nObject.defineProperty(SpineBase.prototype, 'visible', {\n    get() {\n        return this._visible;\n    },\n    set(value: boolean) {\n        if (value !== this._visible) {\n            this._visible = value;\n            if (value) {\n                this.lastTime = 0;\n            }\n        }\n    },\n});\n", "import { Container } from '@pixi/display';\nimport { Graphics } from '@pixi/graphics';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, IVertexAttachment } from './core/ISkeleton';\nimport type { SpineBase } from './SpineBase';\nimport { AttachmentType } from './core/AttachmentType';\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase';\n\n/**\n * Make a class that extends from this interface to create your own debug renderer.\n * @public\n */\nexport interface ISpineDebugRenderer {\n    /**\n     * This will be called every frame, after the spine has been updated.\n     */\n    renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\n     */\n    unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\n     */\n    registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n}\n\ntype DebugDisplayObjects = {\n    bones: Container;\n    skeletonXY: Graphics;\n    regionAttachmentsShape: Graphics;\n    meshTrianglesLine: Graphics;\n    meshHullLine: Graphics;\n    clippingPolygon: Graphics;\n    boundingBoxesRect: Graphics;\n    boundingBoxesCircle: Graphics;\n    boundingBoxesPolygon: Graphics;\n    pathsCurve: Graphics;\n    pathsLine: Graphics;\n    parentDebugContainer: Container;\n};\n\n/**\n * This is a debug renderer that uses PixiJS Graphics under the hood.\n * @public\n */\nexport class SpineDebugRenderer implements ISpineDebugRenderer {\n    private registeredSpines: Map<SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, DebugDisplayObjects> = new Map();\n\n    public drawDebug = true;\n    public drawMeshHull = true;\n    public drawMeshTriangles = true;\n    public drawBones = true;\n    public drawPaths = true;\n    public drawBoundingBoxes = true;\n    public drawClipping = true;\n    public drawRegionAttachments = true;\n\n    public lineWidth = 1;\n    public regionAttachmentsColor = 0x0078ff;\n    public meshHullColor = 0x0078ff;\n    public meshTrianglesColor = 0xffcc00;\n    public clippingPolygonColor = 0xff00ff;\n    public boundingBoxesRectColor = 0x00ff00;\n    public boundingBoxesPolygonColor = 0x00ff00;\n    public boundingBoxesCircleColor = 0x00ff00;\n    public pathsCurveColor = 0xff0000;\n    public pathsLineColor = 0xff00ff;\n    public skeletonXYColor = 0xff0000;\n    public bonesColor = 0x00eecc;\n\n    /**\n     * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\n     */\n    public registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>) {\n        if (this.registeredSpines.has(spine)) {\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\n        }\n        const debugDisplayObjects = {\n            parentDebugContainer: new Container(),\n            bones: new Container(),\n            skeletonXY: new Graphics(),\n            regionAttachmentsShape: new Graphics(),\n            meshTrianglesLine: new Graphics(),\n            meshHullLine: new Graphics(),\n            clippingPolygon: new Graphics(),\n            boundingBoxesRect: new Graphics(),\n            boundingBoxesCircle: new Graphics(),\n            boundingBoxesPolygon: new Graphics(),\n            pathsCurve: new Graphics(),\n            pathsLine: new Graphics(),\n        };\n\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        this.registeredSpines.set(spine, debugDisplayObjects);\n    }\n    public renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            // This should never happen. Spines are registered when you assign spine.debug\n            this.registerSpine(spine);\n        }\n\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.skeletonXY.clear();\n        debugDisplayObjects.regionAttachmentsShape.clear();\n        debugDisplayObjects.meshTrianglesLine.clear();\n        debugDisplayObjects.meshHullLine.clear();\n        debugDisplayObjects.clippingPolygon.clear();\n        debugDisplayObjects.boundingBoxesRect.clear();\n        debugDisplayObjects.boundingBoxesCircle.clear();\n        debugDisplayObjects.boundingBoxesPolygon.clear();\n        debugDisplayObjects.pathsCurve.clear();\n        debugDisplayObjects.pathsLine.clear();\n\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\n        }\n\n        const scale = spine.scale.x || spine.scale.y || 1;\n        const lineWidth = this.lineWidth / scale;\n\n        if (this.drawBones) {\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n        }\n\n        if (this.drawPaths) {\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawBoundingBoxes) {\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawClipping) {\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawMeshHull || this.drawMeshTriangles) {\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawRegionAttachments) {\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n    }\n\n    private drawBonesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number,\n        scale: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const skeletonX = skeleton.x;\n        const skeletonY = skeleton.y;\n        const bones = skeleton.bones;\n\n        debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\n\n        for (let i = 0, len = bones.length; i < len; i++) {\n            const bone = bones[i];\n            const boneLen = bone.data.length;\n            const starX = skeletonX + bone.matrix.tx;\n            const starY = skeletonY + bone.matrix.ty;\n            const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\n            const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\n\n            if (bone.data.name === 'root' || bone.data.parent === null) {\n                continue;\n            }\n\n            // Triangle calculation formula\n            // area: A=sqrt((a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c))/4\n            // alpha: alpha=acos((pow(b, 2)+pow(c, 2)-pow(a, 2))/(2*b*c))\n            // beta: beta=acos((pow(a, 2)+pow(c, 2)-pow(b, 2))/(2*a*c))\n            // gamma: gamma=acos((pow(a, 2)+pow(b, 2)-pow(c, 2))/(2*a*b))\n\n            const w = Math.abs(starX - endX);\n            const h = Math.abs(starY - endY);\n            // a = w, // side length a\n            const a2 = Math.pow(w, 2); // square root of side length a\n            const b = h; // side length b\n            const b2 = Math.pow(h, 2); // square root of side length b\n            const c = Math.sqrt(a2 + b2); // side length c\n            const c2 = Math.pow(c, 2); // square root of side length c\n            const rad = Math.PI / 180;\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\n\n            if (c === 0) {\n                continue;\n            }\n\n            const gp = new Graphics();\n\n            debugDisplayObjects.bones.addChild(gp);\n\n            // draw bone\n            const refRation = c / 50 / scale;\n\n            gp.beginFill(this.bonesColor, 1);\n            gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\n            gp.endFill();\n            gp.x = starX;\n            gp.y = starY;\n            gp.pivot.y = c;\n\n            // Calculate bone rotation angle\n            let rotation = 0;\n\n            if (starX < endX && starY < endY) {\n                // bottom right\n                rotation = -B + 180 * rad;\n            } else if (starX > endX && starY < endY) {\n                // bottom left\n                rotation = 180 * rad + B;\n            } else if (starX > endX && starY > endY) {\n                // top left\n                rotation = -B;\n            } else if (starX < endX && starY > endY) {\n                // bottom left\n                rotation = B;\n            } else if (starY === endY && starX < endX) {\n                // To the right\n                rotation = 90 * rad;\n            } else if (starY === endY && starX > endX) {\n                // go left\n                rotation = -90 * rad;\n            } else if (starX === endX && starY < endY) {\n                // down\n                rotation = 180 * rad;\n            } else if (starX === endX && starY > endY) {\n                // up\n                rotation = 0;\n            }\n            gp.rotation = rotation;\n\n            // Draw the starting rotation point of the bone\n            gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\n            gp.beginFill(0x000000, 0.6);\n            gp.drawCircle(0, c, refRation * 1.2);\n            gp.endFill();\n        }\n\n        // Draw the skeleton starting point \"X\" form\n        const startDotSize = lineWidth * 3;\n\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\n    }\n\n    private drawRegionAttachmentsFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Region) {\n                continue;\n            }\n\n            const regionAttachment = attachment as IRegionAttachment & {\n                computeWorldVertices: (slot: unknown, worldVertices: unknown, offset: unknown, stride: unknown) => void;\n                updateOffset?: () => void;\n            };\n\n            const vertices = new Float32Array(8);\n\n            if (regionAttachment.updateOffset) regionAttachment.updateOffset(); // We don't need this on all versions\n\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n            debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\n        }\n    }\n\n    private drawMeshHullAndMeshTriangles(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\n        debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Mesh) {\n                continue;\n            }\n\n            const meshAttachment: IMeshAttachment = attachment as IMeshAttachment;\n\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n            const triangles = meshAttachment.triangles;\n            let hullLength = meshAttachment.hullLength;\n\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n            // draw the skinned mesh (triangle)\n            if (this.drawMeshTriangles) {\n                for (let i = 0, len = triangles.length; i < len; i += 3) {\n                    const v1 = triangles[i] * 2;\n                    const v2 = triangles[i + 1] * 2;\n                    const v3 = triangles[i + 2] * 2;\n\n                    debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\n                }\n            }\n\n            // draw skin border\n            if (this.drawMeshHull && hullLength > 0) {\n                hullLength = (hullLength >> 1) * 2;\n                let lastX = vertices[hullLength - 2];\n                let lastY = vertices[hullLength - 1];\n\n                for (let i = 0, len = hullLength; i < len; i += 2) {\n                    const x = vertices[i];\n                    const y = vertices[i + 1];\n\n                    debugDisplayObjects.meshHullLine.moveTo(x, y);\n                    debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n        }\n    }\n\n    private drawClippingFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Clipping) {\n                continue;\n            }\n\n            const clippingAttachment: IClippingAttachment = attachment as IClippingAttachment;\n\n            const nn = clippingAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\n        }\n    }\n\n    private drawBoundingBoxesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        // draw the total outline of the bounding box\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n\n        const bounds = new SkeletonBoundsBase();\n\n        bounds.update(spine.skeleton, true);\n        debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n\n        const polygons = bounds.polygons;\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void => {\n            debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\n            debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\n\n            if (count < 3) {\n                throw new Error('Polygon must contain at least 3 vertices');\n            }\n            const paths = [];\n            const dotSize = lineWidth * 2;\n\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n                const x1 = polygonVertices[i];\n                const y1 = polygonVertices[i + 1];\n\n                // draw the bounding box node\n                debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n                debugDisplayObjects.boundingBoxesCircle.endFill();\n\n                paths.push(x1, y1);\n            }\n\n            // draw the bounding box area\n            debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\n            debugDisplayObjects.boundingBoxesPolygon.endFill();\n        };\n\n        for (let i = 0, len = polygons.length; i < len; i++) {\n            const polygon = polygons[i];\n\n            drawPolygon(polygon, 0, polygon.length);\n        }\n    }\n\n    private drawPathsFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\n        debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Path) {\n                continue;\n            }\n\n            const pathAttachment = attachment as IVertexAttachment & { closed: boolean };\n            let nn = pathAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            let x1 = world[2];\n            let y1 = world[3];\n            let x2 = 0;\n            let y2 = 0;\n\n            if (pathAttachment.closed) {\n                const cx1 = world[0];\n                const cy1 = world[1];\n                const cx2 = world[nn - 2];\n                const cy2 = world[nn - 1];\n\n                x2 = world[nn - 4];\n                y2 = world[nn - 3];\n\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n            }\n            nn -= 4;\n            for (let ii = 4; ii < nn; ii += 6) {\n                const cx1 = world[ii];\n                const cy1 = world[ii + 1];\n                const cx2 = world[ii + 2];\n                const cy2 = world[ii + 3];\n\n                x2 = world[ii + 4];\n                y2 = world[ii + 5];\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n                x1 = x2;\n                y1 = y2;\n            }\n        }\n    }\n\n    public unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n        }\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });\n        this.registeredSpines.delete(spine);\n    }\n}\n", "import { TextureAtlas } from '@pixi-spine/base';\nimport { type AssetExtension, LoaderParserPriority, LoadAsset, Loader, checkExtension } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport type { ISpineMetadata } from './SpineLoaderAbstract';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata> = {\n    extension: ExtensionType.Asset,\n\n    // cache: {\n    //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,\n    //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),\n    // },\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n        },\n\n        test(url: string): boolean {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas> {\n            const response = await settings.ADAPTER.fetch(url);\n\n            const txt = await response.text();\n\n            return txt as RawAtlas;\n        },\n\n        testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n            const isExtensionRight = checkExtension(options.src, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        async parse(asset: RawAtlas, options: LoadAsset, loader: Loader): Promise<TextureAtlas> {\n            const metadata: ISpineMetadata = options.data;\n            let basePath = utils.path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                basePath += '/';\n            }\n\n            let resolve = null;\n            let reject = null;\n            const retPromise = new Promise<TextureAtlas>((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            let retval;\n            const resolveCallback = (newAtlas: TextureAtlas): void => {\n                if (!newAtlas) {\n                    reject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                }\n                resolve(retval);\n            };\n\n            // if we have an already loaded pixi image in the image field, use that.\n            if (metadata.image || metadata.images) {\n                // merge the objects\n                const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);\n\n                retval = new TextureAtlas(\n                    asset as RawAtlas,\n                    (line: any, callback: any) => {\n                        const page = pages[line] || (pages.default as any);\n\n                        if (page && page.baseTexture) callback(page.baseTexture);\n                        else callback(page);\n                    },\n                    resolveCallback\n                );\n            } else {\n                // We don't have ready to use pixi textures, we need to load them now!\n                retval = new TextureAtlas(asset as RawAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);\n            }\n\n            return (await retPromise) as TextureAtlas;\n        },\n\n        unload(atlas: TextureAtlas) {\n            atlas.dispose();\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineMetadata>;\n\n/**\n * Ugly function to promisify the spine texture atlas loader function.\n * @public\n */\nexport const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader: Loader, atlasBasePath: string, imageMetadata: any) => {\n    return async (pageName: string, textureLoadedCallback: (tex: BaseTexture) => any): Promise<void> => {\n        // const url = utils.path.join(...atlasBasePath.split(utils.path.sep), pageName); // Broken in upstream\n\n        const url = utils.path.normalize([...atlasBasePath.split(utils.path.sep), pageName].join(utils.path.sep));\n\n        const texture = await loader.load<Texture>({ src: url, data: imageMetadata });\n\n        textureLoadedCallback(texture.baseTexture);\n    };\n};\n\nextensions.add(spineTextureAtlasLoader);\n", "import { ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\nimport { AssetExtension, checkExtension, LoadAsset, Loader, LoaderParserPriority } from '@pixi/assets';\nimport { BaseTexture, extensions, ExtensionType, settings, Texture, utils } from '@pixi/core';\nimport { makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject } from './atlasLoader';\n\ntype SPINEJSON = any;\ntype SPINEBINARY = ArrayBuffer;\n\nfunction isJson(resource: unknown): resource is SPINEJSON {\n    return resource.hasOwnProperty('bones');\n}\n\nfunction isBuffer(resource: unknown): resource is SPINEBINARY {\n    return resource instanceof ArrayBuffer;\n}\n\n/**\n * This abstract class is used to create a spine loader specifically for a needed version\n * @public\n */\nexport abstract class SpineLoaderAbstract<SKD extends ISkeletonData> {\n    constructor() {}\n\n    abstract createJsonParser(): ISkeletonParser;\n\n    abstract createBinaryParser(): ISkeletonParser;\n\n    abstract parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<SKD>;\n\n    public installLoader(): any {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const spineAdapter = this;\n        const spineLoaderExtension: AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata> = {\n            extension: ExtensionType.Asset,\n\n            loader: {\n                extension: {\n                    type: ExtensionType.LoadParser,\n                    priority: LoaderParserPriority.Normal,\n                },\n\n                // #region Downloading skel buffer data\n                test(url) {\n                    return checkExtension(url, '.skel');\n                },\n\n                async load<SPINEBINARY>(url: string): Promise<SPINEBINARY> {\n                    const response = await settings.ADAPTER.fetch(url);\n\n                    const buffer = await response.arrayBuffer();\n\n                    return buffer as SPINEBINARY;\n                },\n                // #endregion\n\n                // #region Parsing spine data\n                testParse(asset: unknown, options: LoadAsset): Promise<boolean> {\n                    const isJsonSpineModel = checkExtension(options.src, '.json') && isJson(asset);\n                    const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\n\n                    // From 6.x loader. If the atlas is strictly false we bail\n                    const isMetadataAngry = options.data?.spineAtlas === false;\n\n                    return Promise.resolve((isJsonSpineModel && !isMetadataAngry) || isBinarySpineModel);\n                },\n\n                async parse(asset: SPINEJSON | SPINEBINARY, loadAsset, loader): Promise<ISpineResource<SKD>> {\n                    const fileExt = utils.path.extname(loadAsset.src).toLowerCase();\n                    const fileName = utils.path.basename(loadAsset.src, fileExt);\n                    let basePath = utils.path.dirname(loadAsset.src);\n\n                    if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1) {\n                        basePath += '/';\n                    }\n\n                    const isJsonSpineModel = checkExtension(loadAsset.src, '.json') && isJson(asset);\n                    // const isBinarySpineModel = fileExt === 'slel' && isBuffer(asset);\n\n                    let parser: ISkeletonParser = null;\n                    let dataToParse = asset;\n\n                    if (isJsonSpineModel) {\n                        parser = spineAdapter.createJsonParser();\n                    } else {\n                        parser = spineAdapter.createBinaryParser();\n                        dataToParse = new Uint8Array(asset);\n                    }\n\n                    const metadata = (loadAsset.data || {}) as ISpineMetadata;\n                    const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;\n\n                    if (metadataSkeletonScale) {\n                        parser.scale = metadataSkeletonScale;\n                    }\n\n                    // if metadataAtlas is a TextureAtlas, use it directly\n                    const metadataAtlas: TextureAtlas = metadata.spineAtlas as TextureAtlas;\n\n                    if (metadataAtlas && metadataAtlas.pages) {\n                        return spineAdapter.parseData(parser, metadataAtlas, dataToParse);\n                    }\n\n                    // if for some odd reason, you dumped the text information of the atlas into the metadata...\n                    const textAtlas = metadata.atlasRawData;\n\n                    if (textAtlas) {\n                        let auxResolve = null;\n                        let auxReject = null;\n                        const atlasPromise = new Promise<TextureAtlas>((resolve, reject) => {\n                            auxResolve = resolve;\n                            auxReject = reject;\n                        });\n                        const atlas = new TextureAtlas(textAtlas, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), (newAtlas) => {\n                            if (!newAtlas) {\n                                auxReject('Something went terribly wrong loading a spine .atlas file\\nMost likely your texture failed to load.');\n                            }\n                            auxResolve(atlas);\n                        });\n                        const textureAtlas = await atlasPromise;\n\n                        return spineAdapter.parseData(parser, textureAtlas, dataToParse);\n                    }\n\n                    // Maybe you told us where to find the file? (I sure hope you remembered to add the .atlas extension)\n                    let atlasPath = metadata.spineAtlasFile;\n\n                    // Finally, if no information at all about the atlas, we guess the atlas file name\n                    if (!atlasPath) {\n                        atlasPath = `${basePath + fileName}.atlas`;\n                    }\n\n                    const textureAtlas = await loader.load<TextureAtlas>({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });\n\n                    return spineAdapter.parseData(parser, textureAtlas, dataToParse);\n                },\n\n                // #endregion\n\n                // unload(asset: ISpineResource<SKD>, loadAsset, loader) {\n                // \t???\n                // },\n            },\n        } as AssetExtension<SPINEJSON | SPINEBINARY | ISpineResource<SKD>, ISpineMetadata>;\n\n        extensions.add(spineLoaderExtension);\n\n        return spineLoaderExtension;\n    }\n}\n\n/**\n * The final spineData+spineAtlas object that can be used to create a Spine.\n * @public\n */\nexport interface ISpineResource<SKD extends ISkeletonData> {\n    spineData: SKD;\n    spineAtlas: TextureAtlas;\n}\n\n/**\n * Metadata for loading spine assets\n * @public\n */\nexport interface ISpineMetadata {\n    // Passed directly to Spine's SkeletonJson/BinaryParser\n    spineSkeletonScale?: number;\n    // If you already have a TextureAtlas, you can pass it directly\n    spineAtlas?: Partial<TextureAtlas>;\n    // If you are going to download an .atlas file, you can specify an alias here for cache/future lookup\n    spineAtlasAlias?: string[];\n    // If you want to use a custom .atlas file, you can specify the path here. **It must be a .atlas file or you need your own parser!**\n    spineAtlasFile?: string;\n    // If for some reason, you have the raw text content of an .atlas file, and want to use it dump it here\n    atlasRawData?: string;\n    // If you are hardcore and can write your own loader function to load the textures for the atlas, you can pass it here\n    imageLoader?: (loader: Loader, path: string) => (path: string, callback: (tex: BaseTexture) => any) => any;\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\n    imageMetadata?: any;\n    // If you already have atlas pages loaded as pixi textures and want to use that to create the atlas, you can pass them here\n    images?: Record<string, Texture | BaseTexture>;\n    // If your spine only uses one atlas page and you have it as a pixi texture, you can pass it here\n    image?: Texture | BaseTexture;\n}\n", "export { Attachment, VertexAttachment } from './core/attachments/Attachment.mjs';\nexport { BoundingBoxAttachment } from './core/attachments/BoundingBoxAttachment.mjs';\nexport { ClippingAttachment } from './core/attachments/ClippingAttachment.mjs';\nexport { MeshAttachment } from './core/attachments/MeshAttachment.mjs';\nexport { PathAttachment } from './core/attachments/PathAttachment.mjs';\nexport { PointAttachment } from './core/attachments/PointAttachment.mjs';\nexport { RegionAttachment } from './core/attachments/RegionAttachment.mjs';\nexport { JitterEffect } from './core/vertexeffects/JitterEffect.mjs';\nexport { SwirlEffect } from './core/vertexeffects/SwirlEffect.mjs';\nexport { Animation, AttachmentTimeline, ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TimelineType, TransformConstraintTimeline, TranslateTimeline, TwoColorTimeline } from './core/Animation.mjs';\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry } from './core/AnimationState.mjs';\nexport { AnimationStateData } from './core/AnimationStateData.mjs';\nexport { AtlasAttachmentLoader } from './core/AtlasAttachmentLoader.mjs';\nexport { Bone } from './core/Bone.mjs';\nexport { BoneData } from './core/BoneData.mjs';\nexport { ConstraintData } from './core/Constraint.mjs';\nexport { Event } from './core/Event.mjs';\nexport { EventData } from './core/EventData.mjs';\nexport { IkConstraint } from './core/IkConstraint.mjs';\nexport { IkConstraintData } from './core/IkConstraintData.mjs';\nexport { PathConstraint } from './core/PathConstraint.mjs';\nexport { PathConstraintData, SpacingMode } from './core/PathConstraintData.mjs';\nexport { Skeleton } from './core/Skeleton.mjs';\nexport { SkeletonBinary } from './core/SkeletonBinary.mjs';\nexport { SkeletonBounds } from './core/SkeletonBounds.mjs';\nexport { SkeletonData } from './core/SkeletonData.mjs';\nexport { SkeletonJson } from './core/SkeletonJson.mjs';\nexport { Skin, SkinEntry } from './core/Skin.mjs';\nexport { Slot } from './core/Slot.mjs';\nexport { SlotData } from './core/SlotData.mjs';\nexport { TransformConstraint } from './core/TransformConstraint.mjs';\nexport { TransformConstraintData } from './core/TransformConstraintData.mjs';\nexport { Spine } from './Spine.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { AttachmentType, Utils } from '@pixi-spine/base';\nimport type { IAttachment, ArrayLike } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    abstract copy(): Attachment;\n}\n\n/**\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    id = (VertexAttachment.nextID++ & 65535) << 11;\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n    deformAttachment: VertexAttachment = this;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.deform;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    copyTo(attachment: VertexAttachment) {\n        if (this.bones != null) {\n            attachment.bones = new Array<number>(this.bones.length);\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n        } else attachment.bones = null;\n\n        if (this.vertices != null) {\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n        } else attachment.vertices = null;\n\n        attachment.worldVerticesLength = this.worldVerticesLength;\n        attachment.deformAttachment = this.deformAttachment;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new BoundingBoxAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    endSlot: SlotData;\n\n    // Nonessential.\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new ClippingAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.endSlot = this.endSlot;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion;\n    path: string;\n    regionUVs: Float32Array;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    width: number;\n    height: number;\n    hullLength: number;\n    edges: Array<number>;\n    private parentMesh: MeshAttachment;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh != null) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        // Nonessential.\n        if (this.edges != null) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name);\n\n        copy.region = this.region;\n        copy.path = this.path;\n        copy.color.setFromColor(this.color);\n        copy.deformAttachment = this.deformAttachment;\n        copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\n        // copy.updateUVs();\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n    lengths: Array<number>;\n    closed = false;\n    constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new PathAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.lengths = new Array<number>(this.lengths.length);\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n        copy.closed = closed;\n        copy.constantSpeed = this.constantSpeed;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n    x: number;\n    y: number;\n    rotation: number;\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n\n    copy(): Attachment {\n        const copy = new PointAttachment(this.name);\n\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.rotation = this.rotation;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Color, ISlot } from '@pixi-spine/base';\n\nimport type { Attachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\n\n/**\n * @public\n */\nexport class Slot implements ISlot {\n    // this is canon\n    blendMode: number;\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    darkColor: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentState: number;\n    deform = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (bone == null) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = data.darkColor == null ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** @return May be null. */\n    getAttachment(): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment(attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.deform.length = 0;\n    }\n\n    setAttachmentTime(time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime(): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n", "import { Attachment } from './Attachment';\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\n\nimport type { Bone } from '../Bone';\nimport { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\n    type = AttachmentType.Region;\n\n    static OX1 = 0;\n    static OY1 = 1;\n    static OX2 = 2;\n    static OY2 = 3;\n    static OX3 = 4;\n    static OY3 = 5;\n    static OX4 = 6;\n    static OY4 = 7;\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n\n    x = 0;\n    y = 0;\n    scaleX = 1;\n    scaleY = 1;\n    rotation = 0;\n    width = 0;\n    height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    rendererObject: any;\n    region: TextureRegion;\n\n    offset = Utils.newFloatArray(8);\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateOffset(): void {\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const localXCos = localX * cos + this.x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + this.y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + this.x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + this.y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n    }\n\n    setRegion(region: TextureRegion): void {\n        this.region = region;\n        const uvs = this.uvs;\n\n        if (region.rotate) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        const vertexOffset = this.offset;\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n\n    copy(): Attachment {\n        const copy = new RegionAttachment(this.name);\n\n        copy.region = this.region;\n        copy.rendererObject = this.rendererObject;\n        copy.path = this.path;\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.scaleX = this.scaleX;\n        copy.scaleY = this.scaleY;\n        copy.rotation = this.rotation;\n        copy.width = this.width;\n        copy.height = this.height;\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class JitterEffect implements VertexEffect {\n    jitterX = 0;\n    jitterY = 0;\n\n    constructor(jitterX: number, jitterY: number) {\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n    }\n\n    begin(skeleton: Skeleton): void {}\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    }\n\n    end(): void {}\n}\n", "import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SwirlEffect implements VertexEffect {\n    static interpolation = new PowOut(2);\n    centerX = 0;\n    centerY = 0;\n    radius = 0;\n    angle = 0;\n    private worldX = 0;\n    private worldY = 0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    begin(skeleton: Skeleton): void {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n    }\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        const radAngle = this.angle * MathUtils.degreesToRadians;\n        const x = position.x - this.worldX;\n        const y = position.y - this.worldY;\n        const dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n            const cos = Math.cos(theta);\n            const sin = Math.sin(theta);\n\n            position.x = cos * x - sin * y + this.worldX;\n            position.y = sin * x + cos * y + this.worldY;\n        }\n    }\n\n    end(): void {}\n}\n", "import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\n/** A simple container for a list of timelines and a name. */\n/**\n * @public\n */\nexport class Animation {\n    /** The animation's name, which is unique across all animations in the skeleton. */\n    name: string;\n    timelines: Array<Timeline>;\n    timelineIds: Array<boolean>;\n\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error('name cannot be null.');\n        if (timelines == null) throw new Error('timelines cannot be null.');\n        this.name = name;\n        this.timelines = timelines;\n        this.timelineIds = [];\n        for (let i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;\n        this.duration = duration;\n    }\n\n    hasTimeline(id: number) {\n        return this.timelineIds[id] == true;\n    }\n\n    /** Applies all the animation's timelines to the specified skeleton.\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\n     * @param events May be null to ignore fired events. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n\n    /** @param target After the first and before the last value.\n     * @returns index of first value greater than the target. */\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n\n        if (high == 0) return step;\n        let current = high >>> 1;\n\n        while (true) {\n            if (values[(current + 1) * step] <= target) low = current + 1;\n            else high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\n\n        return -1;\n    }\n}\n\n/** The interface for all timelines. */\n/**\n * @public\n */\nexport interface Timeline {\n    /** Applies this timeline to the skeleton.\n     * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\n     *           skeleton components the timeline may change.\n     * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\n     *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\n     *           (exclusive) and `time` (inclusive).\n     * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\n     *           interpolate between the keys.\n     * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\n     *           does not fire events.\n     * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\n     *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\n     *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\n     *           apply animations on top of each other (layering).\n     * @param blend Controls how mixing is applied when `alpha` < 1.\n     * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\n     *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n    /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\n    getPropertyId(): number;\n}\n\n/**\n * @public\n */\nexport enum TimelineType {\n    rotate,\n    translate,\n    scale,\n    shear,\n    attachment,\n    color,\n    deform,\n    event,\n    drawOrder,\n    ikConstraint,\n    transformConstraint,\n    pathConstraintPosition,\n    pathConstraintSpacing,\n    pathConstraintMix,\n    twoColor,\n}\n\n/** The base class for timelines that use interpolation between key frame values. */\n/**\n * @public\n */\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0;\n    static STEPPED = 1;\n    static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    abstract getPropertyId(): number;\n\n    constructor(frameCount: number) {\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    /** The number of key frames for this timeline. */\n    getFrameCount() {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    /** Sets the specified key frame to linear interpolation. */\n    setLinear(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    /** Sets the specified key frame to stepped interpolation. */\n    setStepped(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    /** Returns the interpolation type for the specified key frame.\n     * @returns Linear is 0, stepped is 1, Bezier is 2. */\n    getCurveType(frameIndex: number): number {\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\n\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        const type = this.curves[index];\n\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\n     * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\n     * difference between the key frame's values. */\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx;\n        let ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const curves = this.curves;\n\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx;\n        let y = dfy;\n\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    /** Returns the interpolated percentage for the specified key frame and linear percentage. */\n    getCurvePercent(frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        const curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const type = curves[i];\n\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number;\n                let prevY: number;\n\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\n            }\n        }\n        const y = curves[i - 1];\n\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n}\n\n/** Changes a bone's local {@link Bone#rotation}. */\n/**\n * @public\n */\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n    boneIndex: number;\n\n    /** The time in seconds and rotation in degrees for each key frame. */\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    getPropertyId() {\n        return (TimelineType.rotate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    const r = bone.data.rotation - bone.rotation;\n\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\n\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation + r * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    r += bone.data.rotation - bone.rotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                case MixBlend.add:\n                    bone.rotation += r * alpha;\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\n/**\n * @public\n */\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_X = -2;\n    static PREV_Y = -1;\n    static X = 1;\n    static Y = 2;\n\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n    boneIndex: number;\n\n    /** The time in seconds, x, and y values for each key frame. */\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.translate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time in seconds, x, and y values for the specified key frame. */\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + TranslateTimeline.PREV_X];\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n\n            x = frames[frame + TranslateTimeline.PREV_X];\n            y = frames[frame + TranslateTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\n/**\n * @public\n */\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.scale << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n\n            x = frames[frame + ScaleTimeline.PREV_X];\n            y = frames[frame + ScaleTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n        }\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = MathUtils.signum(x);\n                        by = MathUtils.signum(y);\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\n/**\n * @public\n */\nexport class ShearTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.shear << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ShearTimeline.PREV_X];\n            y = frames[frames.length + ShearTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n\n            x = frames[frame + ShearTimeline.PREV_X];\n            y = frames[frame + ShearTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}. */\n/**\n * @public\n */\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_R = -4;\n    static PREV_G = -3;\n    static PREV_B = -2;\n    static PREV_A = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n    slotIndex: number;\n\n    /** The time in seconds, red, green, blue, and alpha values for each key frame. */\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.color << 24) + this.slotIndex;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n\n                    return;\n                case MixBlend.first:\n                    const color = slot.color;\n                    const setup = slot.data.color;\n\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        if (alpha == 1) slot.color.set(r, g, b, a);\n        else {\n            const color = slot.color;\n\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\n/**\n * @public\n */\nexport class TwoColorTimeline extends CurveTimeline {\n    static ENTRIES = 8;\n    static PREV_TIME = -8;\n    static PREV_R = -7;\n    static PREV_G = -6;\n    static PREV_B = -5;\n    static PREV_A = -4;\n    static PREV_R2 = -3;\n    static PREV_G2 = -2;\n    static PREV_B2 = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n    static R2 = 5;\n    static G2 = 6;\n    static B2 = 7;\n\n    /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\n     * null. */\n    slotIndex: number;\n\n    /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.twoColor << 24) + this.slotIndex;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frameIndex *= TwoColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n                    slot.darkColor.setFromColor(slot.data.darkColor);\n\n                    return;\n                case MixBlend.first:\n                    const light = slot.color;\n                    const dark = slot.darkColor;\n                    const setupLight = slot.data.color;\n                    const setupDark = slot.data.darkColor;\n\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + TwoColorTimeline.PREV_R];\n            g = frames[i + TwoColorTimeline.PREV_G];\n            b = frames[i + TwoColorTimeline.PREV_B];\n            a = frames[i + TwoColorTimeline.PREV_A];\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n\n            r = frames[frame + TwoColorTimeline.PREV_R];\n            g = frames[frame + TwoColorTimeline.PREV_G];\n            b = frames[frame + TwoColorTimeline.PREV_B];\n            a = frames[frame + TwoColorTimeline.PREV_A];\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n        }\n        if (alpha == 1) {\n            slot.color.set(r, g, b, a);\n            slot.darkColor.set(r2, g2, b2, 1);\n        } else {\n            const light = slot.color;\n            const dark = slot.darkColor;\n\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                dark.setFromColor(slot.data.darkColor);\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#attachment}. */\n/**\n * @public\n */\nexport class AttachmentTimeline implements Timeline {\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n    slotIndex: number;\n\n    /** The time in seconds for each key frame. */\n    frames: ArrayLike<number>; // time, ...\n\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\n    attachmentNames: Array<string>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.attachment << 24) + this.slotIndex;\n    }\n\n    /** The number of key frames for this timeline. */\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        let frameIndex = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        const attachmentName = this.attachmentNames[frameIndex];\n\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nlet zeros: ArrayLike<number> = null;\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\n/**\n * @public\n */\nexport class DeformTimeline extends CurveTimeline {\n    /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\n    slotIndex: number;\n\n    /** The attachment that will be deformed. */\n    attachment: VertexAttachment;\n\n    /** The time in seconds for each key frame. */\n    frames: ArrayLike<number>; // time, ...\n\n    /** The vertices for each key frame. */\n    frameVertices: Array<ArrayLike<number>>;\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n        if (zeros == null) zeros = Utils.newFloatArray(64);\n    }\n\n    getPropertyId() {\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\n    }\n\n    /** Sets the time in seconds and the vertices for the specified key frame.\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment: Attachment = slot.getAttachment();\n\n        if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\n\n        const deformArray: Array<number> = slot.deform;\n\n        if (deformArray.length == 0) blend = MixBlend.setup;\n\n        const frameVertices = this.frameVertices;\n        const vertexCount = frameVertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const vertexAttachment = <VertexAttachment>slotAttachment;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    deformArray.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        deformArray.length = 0;\n                        break;\n                    }\n                    const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        const deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = frameVertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            deform[i] += lastVertices[i] - setupVertices[i];\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n                    }\n                } else {\n                    Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n                        break;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time);\n        const prevVertices = frameVertices[frame - 1];\n        const nextVertices = frameVertices[frame];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (vertexAttachment.bones == null) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/** Fires an {@link Event} when specific animation times are reached. */\n/**\n * @public\n */\nexport class EventTimeline implements Timeline {\n    /** The time in seconds for each key frame. */\n    frames: ArrayLike<number>; // time, ...\n\n    /** The event for each key frame. */\n    events: Array<Event>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.event << 24;\n    }\n\n    /** The number of key frames for this timeline. */\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the event for the specified key frame. */\n    setFrame(frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > `lastTime` and <= `time`. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (firedEvents == null) return;\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n\n        if (lastTime < frames[0]) frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            const frameTime = frames[frame];\n\n            while (frame > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\n    }\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}. */\n/**\n * @public\n */\nexport class DrawOrderTimeline implements Timeline {\n    /** The time in seconds for each key frame. */\n    frames: ArrayLike<number>; // time, ...\n\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n    drawOrders: Array<Array<number>>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.drawOrder << 24;\n    }\n\n    /** The number of key frames for this timeline. */\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the draw order for the specified key frame.\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n     *           draw order. */\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\n        const slots: Array<Slot> = skeleton.slots;\n\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        let frame = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frame = frames.length - 1;\n        else frame = Animation.binarySearch(frames, time) - 1;\n\n        const drawOrderToSetupIndex = this.drawOrders[frame];\n\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\n/**\n * @public\n */\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 6;\n    static PREV_TIME = -6;\n    static PREV_MIX = -5;\n    static PREV_SOFTNESS = -4;\n    static PREV_BEND_DIRECTION = -3;\n    static PREV_COMPRESS = -2;\n    static PREV_STRETCH = -1;\n    static MIX = 1;\n    static SOFTNESS = 2;\n    static BEND_DIRECTION = 3;\n    static COMPRESS = 4;\n    static STRETCH = 5;\n\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    ikConstraintIndex: number;\n\n    /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\n    frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n    }\n\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n    setFrame(frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (!constraint.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.softness = constraint.data.softness;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            if (blend == MixBlend.setup) {\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\n                if (direction == MixDirection.mixOut) {\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n                } else {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            } else {\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\n                if (direction == MixDirection.mixIn) {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        const softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n            constraint.softness = constraint.data.softness + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        } else {\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n            constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        }\n    }\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\n/**\n * @public\n */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_ROTATE = -4;\n    static PREV_TRANSLATE = -3;\n    static PREV_SCALE = -2;\n    static PREV_SHEAR = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n    static SCALE = 3;\n    static SHEAR = 4;\n\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    transformConstraintIndex: number;\n\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n    }\n\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (!constraint.active) return;\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                    constraint.scaleMix = data.scaleMix;\n                    constraint.shearMix = data.shearMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n        let scale = 0;\n        let shear = 0;\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / TransformConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n        }\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\n        }\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}. */\n/**\n * @public\n */\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    pathConstraintIndex: number;\n\n    /** The time in seconds and path constraint position for each key frame. */\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n    }\n\n    /** Sets the time in seconds and path constraint position for the specified key frame. */\n    setFrame(frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        let position = 0;\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\n            // Time is after last frame.\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n            );\n\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n        }\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}. */\n/**\n * @public\n */\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        let spacing = 0;\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n            // Time is after last frame.\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n            );\n\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n        }\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/** Changes a transform constraint's {@link PathConstraint#rotateMix} and\n * {@link TransformConstraint#translateMix}. */\n/**\n * @public\n */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_ROTATE = -2;\n    static PREV_TRANSLATE = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex: number;\n\n    /** The time in seconds, rotate mix, and translate mix for each key frame. */\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n    }\n\n    /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = constraint.data.rotateMix;\n                    constraint.translateMix = constraint.data.translateMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n            // Time is after last frame.\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n        }\n    }\n}\n", "import { IAnimationState, IAnimationStateListener, ITrackEntry, MixBlend, MixDirection, MathUtils, Pool, IntSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport type { Slot } from './Slot';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\n/**\n * @public\n */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static emptyAnimation = new Animation('<empty>', [], 0);\n\n    /** 1. A previously applied timeline has set this property.\n     *\n     * Result: Mix from the current pose to the timeline pose. */\n    static SUBSEQUENT = 0;\n    /** 1. This is the first timeline to set this property.\n     * 2. The next track entry applied after this one does not have a timeline to set this property.\n     *\n     * Result: Mix from the setup pose to the timeline pose. */\n    static FIRST = 1;\n    /** 1) A previously applied timeline has set this property.<br>\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\n     * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n     * animations that key the same property. A subsequent timeline will set this property using a mix. */\n    static HOLD_SUBSEQUENT = 2;\n    /** 1) This is the first timeline to set this property.<br>\n     * 2) The next track entry to be applied does have a timeline to set this property.<br>\n     * 3) The next track entry after that one does not have a timeline to set this property.<br>\n     * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n     * that key the same property. A subsequent timeline will set this property using a mix. */\n    static HOLD_FIRST = 3;\n    /** 1. This is the first timeline to set this property.\n     * 2. The next track entry to be applied does have a timeline to set this property.\n     * 3. The next track entry after that one does have a timeline to set this property.\n     * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n     *\n     * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n     * 2 track entries in a row have a timeline that sets the same property.\n     *\n     * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n     * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n     * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n     * place. */\n    static HOLD_MIX = 4;\n\n    static SETUP = 1;\n    static CURRENT = 2;\n\n    /** The AnimationStateData to look up mix durations. */\n    data: AnimationStateData;\n\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    tracks = new Array<TrackEntry>();\n\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    timeScale = 1;\n    unkeyedState = 0;\n\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new IntSet();\n    animationsChanged = false;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next != null) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom != null) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.disposeNext(current);\n                continue;\n            }\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from != null) from.mixingTo = null;\n                while (from != null) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    /** Returns true when all mixing from entries are complete. */\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (from == null) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n     * animation state can be applied to multiple skeletons to pose them identically.\n     * @returns True if any animations were applied. */\n    apply(skeleton: Skeleton): boolean {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            const timelineCount = current.animation.timelines.length;\n            const timelines = current.animation.timelines;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    const timeline = timelines[ii];\n\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                    else timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const firstFrame = current.timelinesRotation.length == 0;\n\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                const timelinesRotation = current.timelinesRotation;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                    } else if (timeline instanceof AttachmentTimeline) {\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n        // the time is before the first key).\n        const setupState = this.unkeyedState + AnimationState.SETUP;\n        const slots = skeleton.slots;\n\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.attachmentState == setupState) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n            }\n        }\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const events = mix < from.eventThreshold ? this.events : null;\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        const timelineCount = from.animation.timelines.length;\n        const timelines = from.animation.timelines;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const firstFrame = from.timelinesRotation.length == 0;\n\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            const timelinesRotation = from.timelinesRotation;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.HOLD_SUBSEQUENT:\n                        timelineBlend = blend;\n                        alpha = alphaHold;\n                        break;\n                    case AnimationState.HOLD_FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n        const slot = skeleton.slots[timeline.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = timeline.frames;\n\n        if (time < frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n        } else {\n            let frameIndex;\n\n            if (time >= frames[frames.length - 1])\n                // Time is after last frame.\n                frameIndex = frames.length - 1;\n            else frameIndex = Animation.binarySearch(frames, time) - 1;\n            this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n        }\n\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\n        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n        if (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\n    }\n\n    applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const rotateTimeline = timeline as RotateTimeline;\n        const frames = rotateTimeline.frames;\n        const bone = skeleton.bones[rotateTimeline.boneIndex];\n\n        if (!bone.active) return;\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n                // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                const frameTime = frames[frame];\n                const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        r1 += total * alpha;\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, events[i]);\n        }\n    }\n\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    /** Removes all animations from the track, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (current == null) return;\n\n        this.queue.end(current);\n\n        this.disposeNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (from == null) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n\n        if (from != null) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    /** Sets an animation by name.\n     *\n     * {@link #setAnimationWith(}. */\n    setAnimation(trackIndex: number, animationName: string, loop: boolean) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n     * applied to a skeleton, it is replaced (not mixed from).\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    setAnimationWith(trackIndex: number, animation: Animation, loop: boolean) {\n        if (animation == null) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current != null) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.disposeNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.disposeNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    /** Queues an animation by name.\n     *\n     * See {@link #addAnimationWith()}. */\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n     * equivalent to calling {@link #setAnimationWith()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n     *           previous entry is looping, its next loop completion is used instead of its duration.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        if (animation == null) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last != null) {\n            while (last.next != null) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (last == null) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            if (delay <= 0) {\n                const duration = last.animationEnd - last.animationStart;\n\n                if (duration != 0) {\n                    if (last.loop) delay += duration * (1 + ((last.trackTime / duration) | 0));\n                    else delay += Math.max(duration, last.trackTime);\n                    delay -= this.data.getMix(last.animation, animation);\n                } else delay = last.trackTime;\n            }\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n     *\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n     * 0 still mixes out over one frame.\n     *\n     * Mixing in is done by first setting an empty animation, then adding an animation using\n     * {@link #addAnimation()} and on the returned track entry, set the\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n    setEmptyAnimation(trackIndex: number, mixDuration: number) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n     * {@link #setEmptyAnimation()}.\n     *\n     * See {@link #setEmptyAnimation()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n     *           loop completion is used instead of its duration.\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number) {\n        if (delay <= 0) delay -= mixDuration;\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n     * duration. */\n    setEmptyAnimations(mixDuration: number) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    /** @param last May be null. */\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n        entry.mixBlend = MixBlend.replace;\n\n        return entry;\n    }\n\n    disposeNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next != null) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            let entry = this.tracks[i];\n\n            if (entry == null) continue;\n            while (entry.mixingFrom != null) entry = entry.mixingFrom;\n\n            do {\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                entry = entry.mixingTo;\n            } while (entry != null);\n        }\n    }\n\n    computeHold(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n\n        entry.timelineHoldMix.length = 0;\n        const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n        const propertyIDs = this.propertyIDs;\n\n        if (to != null && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) {\n                timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\n            }\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const timeline = timelines[i];\n            const id = timeline.getPropertyId();\n\n            if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;\n            else if (\n                to == null ||\n                timeline instanceof AttachmentTimeline ||\n                timeline instanceof DrawOrderTimeline ||\n                timeline instanceof EventTimeline ||\n                !to.animation.hasTimeline(id)\n            ) {\n                timelineMode[i] = AnimationState.FIRST;\n            } else {\n                for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n                    if (next.animation.hasTimeline(id)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = AnimationState.HOLD_MIX;\n                        timelineDipMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = AnimationState.HOLD_FIRST;\n            }\n        }\n    }\n\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all track entries. */\n    addListener(listener: AnimationStateListener) {\n        if (listener == null) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener()}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    /** Removes all listeners added with {@link #addListener()}. */\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n     * are not wanted because new animations are being set. */\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\n/**\n * @public\n */\nexport class TrackEntry implements ITrackEntry {\n    /** The animation to apply for this track entry. */\n    animation: Animation;\n\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    next: TrackEntry;\n\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    mixingFrom: TrackEntry;\n\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    mixingTo: TrackEntry;\n\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    listener: AnimationStateListener;\n\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    trackIndex: number;\n\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    loop: boolean;\n\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    holdPrevious: boolean;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    eventThreshold: number;\n\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    attachmentThreshold: number;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    drawOrderThreshold: number;\n\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    animationStart: number;\n\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    animationEnd: number;\n\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    animationLast: number;\n\n    nextAnimationLast: number;\n\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    delay: number;\n\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    trackTime: number;\n\n    trackLast: number;\n    nextTrackLast: number;\n\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    trackEnd: number;\n\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    timeScale: number;\n\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    alpha: number;\n\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    mixTime: number;\n\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n     * `animationStart` time. */\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    /** Returns true if at least one loop has been completed.\n     *\n     * See {@link AnimationStateListener#complete()}. */\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n     * long way around when using {@link #alpha} and starting animations on other tracks.\n     *\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: Boolean = false;\n    private static deprecatedWarning2: Boolean = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    private static deprecatedWarning1: Boolean = false;\n\n    deprecateStuff() {\n        if (!EventQueue.deprecatedWarning1) {\n            EventQueue.deprecatedWarning1 = true;\n            console.warn(\n                \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n            );\n        }\n\n        return true;\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n                    // deprecation\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                    break;\n                case EventType.end:\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n                    // deprecation\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n                    // deprecation\n\n                    const count = MathUtils.toInt(entry.loopsCount());\n\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n                    // deprecation\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/**\n * @public\n */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?(entry: TrackEntry): void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?(entry: TrackEntry): void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?(entry: TrackEntry): void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?(entry: TrackEntry): void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?(entry: TrackEntry): void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?(entry: TrackEntry, event: Event): void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n", "import type { SkeletonData } from './SkeletonData';\nimport type { IAnimation, IAnimationStateData, Map } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/**\n * @public\n */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = {};\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.');\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith(from: IAnimation, to: IAnimation, duration: number) {\n        if (from == null) throw new Error('from cannot be null.');\n        if (to == null) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix(from: IAnimation, to: IAnimation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n", "import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n        const attachment = new RegionAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n        const attachment = new MeshAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n", "import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 0;\n    scaleY = 0;\n    shearX = 0;\n    shearY = 0;\n    ax = 0;\n    ay = 0;\n    arotation = 0;\n    ascaleX = 0;\n    ascaleY = 0;\n    ashearX = 0;\n    ashearY = 0;\n    appliedValid = false;\n\n    sorted = false;\n    active = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (parent == null) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pa /= this.skeleton.scaleX;\n                    pc /= this.skeleton.scaleY;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (\n                    this.data.transformMode == TransformMode.NoScale &&\n                    pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\n                )\n                    s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n    }\n\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n    }\n\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n    updateAppliedTransform() {\n        this.appliedValid = true;\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (parent == null) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    localToWorldRotation(localRotation: number) {\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        this.appliedValid = false;\n    }\n}\n", "import { Color, TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 1;\n    scaleY = 1;\n    shearX = 0;\n    shearY = 0;\n    transformMode = TransformMode.Normal;\n    skinRequired = false;\n\n    color = new Color();\n\n    constructor(index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n", "/**\n * @public\n */\nexport abstract class ConstraintData {\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\n}\n", "import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n    volume: number;\n    balance: number;\n\n    constructor(time: number, data: EventData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n", "import type { IEventData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class EventData implements IEventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    audioPath: string;\n    volume: number;\n    balance: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n", "import type { Updatable } from './Updatable';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { IIkConstraint, MathUtils, TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraint implements IIkConstraint, Updatable {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    bendDirection = 0;\n    compress = false;\n    stretch = false;\n    mix = 1;\n    softness = 0;\n    active = false;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.softness = data.softness;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n                break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        const p = bone.parent.matrix;\n\n        const pa = p.a;\n        let pb = p.c;\n        const pc = p.b;\n        let pd = p.d;\n        let rotationIK = -bone.ashearX - bone.arotation;\n        let tx = 0;\n        let ty = 0;\n\n        switch (bone.data.transformMode) {\n            case TransformMode.OnlyTranslation:\n                tx = targetX - bone.worldX;\n                ty = targetY - bone.worldY;\n                break;\n            case TransformMode.NoRotationOrReflection:\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                const sa = pa / bone.skeleton.scaleX;\n                const sc = pc / bone.skeleton.scaleY;\n\n                pb = -sc * s * bone.skeleton.scaleX;\n                pd = sa * s * bone.skeleton.scaleY;\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n            // Fall through\n            default:\n                const x = targetX - p.tx;\n                const y = targetY - p.ty;\n                const d = pa * pd - pb * pc;\n\n                tx = (x * pd - y * pb) / d - bone.ax;\n                ty = (y * pa - x * pc) / d - bone.ay;\n        }\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            switch (bone.data.transformMode) {\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n            }\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n\n            return;\n        }\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let sx = psx;\n        let psy = parent.ascaleY;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = cwx - pp.tx;\n        let y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1;\n        let a2;\n\n        if (l1 < 0.0001) {\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\n            return;\n        }\n        x = targetX - pp.tx;\n        y = targetY - pp.ty;\n        let tx = (x * d - y * b) * id - px;\n        let ty = (y * a - x * c) * id - py;\n        let dd = tx * tx + ty * ty;\n\n        if (softness != 0) {\n            softness *= (psx * (csx + 1)) / 2;\n            const td = Math.sqrt(dd);\n            const sd = td - l1 - l2 * psx + softness;\n\n            if (sd > 0) {\n                let p = Math.min(1, sd / (softness * 2)) - 1;\n\n                p = (sd - softness * (1 - p * p)) / td;\n                tx -= p * tx;\n                ty -= p * ty;\n                dd = tx * tx + ty * ty;\n            }\n        }\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) cos = -1;\n            else if (cos > 1) {\n                cos = 1;\n                if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n            }\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n", "import { ConstraintData } from './Constraint';\nimport type { BoneData } from './BoneData';\nimport type { IIkConstraintData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraintData extends ConstraintData implements IIkConstraintData {\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    compress = false;\n    stretch = false;\n    uniform = false;\n    mix = 1;\n    softness = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n", "import { ConstraintData } from './Constraint';\nimport type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport type { RotateMode, PositionMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraintData extends ConstraintData {\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n    rotateMix: number;\n    translateMix: number;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n/**\n * @public\n */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n}\n", "import { PathAttachment } from './attachments';\nimport type { Updatable } from './Updatable';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n/**\n * @public\n */\nexport class PathConstraint implements Updatable {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0;\n    spacing = 0;\n    rotateMix = 0;\n    translateMix = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    active = false;\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const translate = translateMix > 0;\n        const rotate = rotateMix > 0;\n\n        if (!translate && !rotate) return;\n\n        const data = this.data;\n        const spacingMode = data.spacingMode;\n        const lengthSpacing = spacingMode == SpacingMode.Length;\n        const rotateMode = data.rotateMode;\n        const tangents = rotateMode == RotateMode.Tangent;\n        const scale = rotateMode == RotateMode.ChainScale;\n        const boneCount = this.bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const bones = this.bones;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        let lengths: Array<number> = null;\n        const spacing = this.spacing;\n\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n; ) {\n                const bone = bones[i];\n                const setupLength = bone.data.length;\n\n                if (setupLength < PathConstraint.epsilon) {\n                    if (scale) lengths[i] = 0;\n                    spaces[++i] = 0;\n                } else {\n                    const x = setupLength * bone.matrix.a;\n                    const y = setupLength * bone.matrix.b;\n                    const length = Math.sqrt(x * x + y * y);\n\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                }\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++) spaces[i] = spacing;\n        }\n\n        const positions = this.computeWorldPositions(\n            <PathAttachment>attachment,\n            spacesCount,\n            tangents,\n            data.positionMode == PositionMode.Percent,\n            spacingMode == SpacingMode.Percent\n        );\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * translateMix;\n            mat.ty += (boneY - mat.ty) * translateMix;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents)\n                    if (tangents) r = positions[p - 1];\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\n                    else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.appliedValid = false;\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = null;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i];\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i];\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n}\n", "import type { Updatable } from './Updatable';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class TransformConstraint implements Updatable {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    temp = new Vector2();\n    active = false;\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * translateMix;\n                mat.ty += (temp.y - mat.ty) * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                mat.a *= s;\n                mat.b *= s;\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyRelativeWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * translateMix;\n                mat.ty += temp.y * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * rotateMix;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax - x + this.data.offsetX) * translateMix;\n                y += (target.ay - y + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n            }\n\n            const shearY = bone.ashearY;\n\n            if (shearMix > 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.shearY += r * shearMix;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax + this.data.offsetX) * translateMix;\n                y += (target.ay + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n            }\n\n            let shearY = bone.ashearY;\n\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n}\n", "import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    updateCacheReset = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    scaleX = 1;\n    scaleY = 1;\n    x = 0;\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (boneData.parent == null) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n        this.updateCacheReset.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin != null) {\n            const skinBones = this.skin.bones;\n\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone = this.bones[skinBones[i].index];\n\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone != null);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n            const child = constrained[constrained.length - 1];\n\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        constraint.active =\n            constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (pathBones == null) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n            let i = 0;\n\n            while (i < pathBones.length) {\n                const boneCount = pathBones[i++];\n\n                for (let n = i + boneCount; i < n; i++) {\n                    const boneIndex = pathBones[i];\n\n                    this.sortBone(bones[boneIndex]);\n                }\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform() {\n        const updateCacheReset = this.updateCacheReset;\n\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n            const bone = updateCacheReset[i] as Bone;\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n            bone.appliedValid = true;\n        }\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (skin == null) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin != null) {\n            if (this.skin != null) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name != null) {\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n    /** @return May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error('attachmentName cannot be null.');\n        if (this.skin != null) {\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment(slotName: string, attachmentName?: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB.\n     * @param temp Working memory */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (offset == null) throw new Error('offset cannot be null.');\n        if (size == null) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: ArrayLike<number> = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update(delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n", "import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/**\n * @public\n */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    version: string;\n    hash: string;\n\n    // Nonessential\n    fps = 0;\n    imagesPath: string;\n    audioPath: string;\n\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    findSkin(skinName: string) {\n        if (skinName == null) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    findEvent(eventDataName: string) {\n        if (eventDataName == null) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    findAnimation(animationName: string) {\n        if (animationName == null) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n", "import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport type { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class SlotData implements ISlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        if (boneData == null) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n", "import type { BoneData } from './BoneData';\nimport { ConstraintData } from './Constraint';\n\n/**\n * @public\n */\nexport class TransformConstraintData extends ConstraintData {\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    offsetRotation = 0;\n    offsetX = 0;\n    offsetY = 0;\n    offsetScaleX = 0;\n    offsetScaleY = 0;\n    offsetShearY = 0;\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n", "import { Attachment, MeshAttachment } from './attachments';\nimport type { BoneData } from './BoneData';\nimport type { ConstraintData } from './Constraint';\nimport type { Skeleton } from './Skeleton';\n\nimport type { Map, ISkin } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SkinEntry {\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\n}\n\n/**\n * @public\n */\nexport class Skin implements ISkin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n    bones = Array<BoneData>();\n    constraints = new Array<ConstraintData>();\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    addSkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let j = 0; j < this.bones.length; j++) {\n                if (this.bones[j] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let j = 0; j < this.constraints.length; j++) {\n                if (this.constraints[j] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n        }\n    }\n\n    copySkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let j = 0; j < this.bones.length; j++) {\n                if (this.bones[j] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let j = 0; j < this.constraints.length; j++) {\n                if (this.constraints[j] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            if (attachment.attachment == null) continue;\n            if (attachment.attachment instanceof MeshAttachment) {\n                attachment.attachment = attachment.attachment.newLinkedMesh();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            } else {\n                attachment.attachment = attachment.attachment.copy();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            }\n        }\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, name: string): Attachment {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    removeAttachment(slotIndex: number, name: string) {\n        const dictionary = this.attachments[slotIndex];\n\n        if (dictionary) dictionary[name] = null;\n    }\n\n    getAttachments(): Array<SkinEntry> {\n        const entries = new Array<SkinEntry>();\n\n        for (let i = 0; i < this.attachments.length; i++) {\n            const slotAttachments = this.attachments[i];\n\n            if (slotAttachments) {\n                for (const name in slotAttachments) {\n                    const attachment = slotAttachments[name];\n\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\n                }\n            }\n        }\n\n        return entries;\n    }\n\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n        const slotAttachments = this.attachments[slotIndex];\n\n        if (slotAttachments) {\n            for (const name in slotAttachments) {\n                const attachment = slotAttachments[name];\n\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n            }\n        }\n    }\n\n    clear() {\n        this.attachments.length = 0;\n        this.bones.length = 0;\n        this.constraints.length = 0;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n", "import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport {\n    Animation,\n    AttachmentTimeline,\n    ColorTimeline,\n    CurveTimeline,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ShearTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TwoColorTimeline,\n} from './Animation';\nimport { AttachmentType, BinaryInput, Color, PositionMode, RotateMode, TransformMode, Utils } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/**\n * @public\n */\nexport class SkeletonBinary {\n    static AttachmentTypeValues = [\n        0 /* AttachmentType.Region*/, 1 /* AttachmentType.BoundingBox*/, 2 /* AttachmentType.Mesh*/, 3 /* AttachmentType.LinkedMesh*/, 4 /* AttachmentType.Path*/,\n        5 /* AttachmentType.Point*/, 6 /* AttachmentType.Clipping*/,\n    ];\n    static TransformModeValues = [\n        TransformMode.Normal,\n        TransformMode.OnlyTranslation,\n        TransformMode.NoRotationOrReflection,\n        TransformMode.NoScale,\n        TransformMode.NoScaleOrReflection,\n    ];\n    static PositionModeValues = [PositionMode.Fixed, PositionMode.Percent];\n    static SpacingModeValues = [SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\n    static RotateModeValues = [RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale];\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\n\n    static BONE_ROTATE = 0;\n    static BONE_TRANSLATE = 1;\n    static BONE_SCALE = 2;\n    static BONE_SHEAR = 3;\n\n    static SLOT_ATTACHMENT = 0;\n    static SLOT_COLOR = 1;\n    static SLOT_TWO_COLOR = 2;\n\n    static PATH_POSITION = 0;\n    static PATH_SPACING = 1;\n    static PATH_MIX = 2;\n\n    static CURVE_LINEAR = 0;\n    static CURVE_STEPPED = 1;\n    static CURVE_BEZIER = 2;\n\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(binary: Uint8Array): SkeletonData {\n        const scale = this.scale;\n\n        const skeletonData = new SkeletonData();\n\n        skeletonData.name = ''; // BOZO\n\n        const input = new BinaryInput(binary);\n\n        skeletonData.hash = input.readString();\n        skeletonData.version = input.readString();\n        if (skeletonData.version === '3.8.75') {\n            const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n\n            console.error(error);\n        }\n        skeletonData.x = input.readFloat();\n        skeletonData.y = input.readFloat();\n        skeletonData.width = input.readFloat();\n        skeletonData.height = input.readFloat();\n\n        const nonessential = input.readBoolean();\n\n        if (nonessential) {\n            skeletonData.fps = input.readFloat();\n\n            skeletonData.imagesPath = input.readString();\n            skeletonData.audioPath = input.readString();\n        }\n\n        let n = 0;\n        // Strings.\n\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) input.strings.push(input.readString());\n\n        // Bones.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const name = input.readString();\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n            const data = new BoneData(i, name, parent);\n\n            data.rotation = input.readFloat();\n            data.x = input.readFloat() * scale;\n            data.y = input.readFloat() * scale;\n            data.scaleX = input.readFloat();\n            data.scaleY = input.readFloat();\n            data.shearX = input.readFloat();\n            data.shearY = input.readFloat();\n            data.length = input.readFloat() * scale;\n            data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\n            data.skinRequired = input.readBoolean();\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n            skeletonData.bones.push(data);\n        }\n\n        // Slots.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const slotName = input.readString();\n            const boneData = skeletonData.bones[input.readInt(true)];\n            const data = new SlotData(i, slotName, boneData);\n\n            Color.rgba8888ToColor(data.color, input.readInt32());\n\n            const darkColor = input.readInt32();\n\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\n\n            data.attachmentName = input.readStringRef();\n            data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\n            skeletonData.slots.push(data);\n        }\n\n        // IK constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new IkConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.mix = input.readFloat();\n            data.softness = input.readFloat() * scale;\n            data.bendDirection = input.readByte();\n            data.compress = input.readBoolean();\n            data.stretch = input.readBoolean();\n            data.uniform = input.readBoolean();\n            skeletonData.ikConstraints.push(data);\n        }\n\n        // Transform constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new TransformConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.local = input.readBoolean();\n            data.relative = input.readBoolean();\n            data.offsetRotation = input.readFloat();\n            data.offsetX = input.readFloat() * scale;\n            data.offsetY = input.readFloat() * scale;\n            data.offsetScaleX = input.readFloat();\n            data.offsetScaleY = input.readFloat();\n            data.offsetShearY = input.readFloat();\n            data.rotateMix = input.readFloat();\n            data.translateMix = input.readFloat();\n            data.scaleMix = input.readFloat();\n            data.shearMix = input.readFloat();\n            skeletonData.transformConstraints.push(data);\n        }\n\n        // Path constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const data = new PathConstraintData(input.readString());\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.slots[input.readInt(true)];\n            data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\n            data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\n            data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\n            data.offsetRotation = input.readFloat();\n            data.position = input.readFloat();\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n            data.spacing = input.readFloat();\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n            data.rotateMix = input.readFloat();\n            data.translateMix = input.readFloat();\n            skeletonData.pathConstraints.push(data);\n        }\n\n        // Default skin.\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\n        if (defaultSkin != null) {\n            skeletonData.defaultSkin = defaultSkin;\n            skeletonData.skins.push(defaultSkin);\n        }\n\n        // Skins.\n        {\n            let i = skeletonData.skins.length;\n\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\n            for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\n        }\n\n        // Linked meshes.\n        n = this.linkedMeshes.length;\n        for (let i = 0; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? (parent as VertexAttachment) : linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const data = new EventData(input.readStringRef());\n\n            data.intValue = input.readInt(false);\n            data.floatValue = input.readFloat();\n            data.stringValue = input.readString();\n            data.audioPath = input.readString();\n            if (data.audioPath != null) {\n                data.volume = input.readFloat();\n                data.balance = input.readFloat();\n            }\n            skeletonData.events.push(data);\n        }\n\n        // Animations.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\n\n        return skeletonData;\n    }\n\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\n        let skin = null;\n        let slotCount = 0;\n\n        if (defaultSkin) {\n            slotCount = input.readInt(true);\n            if (slotCount == 0) return null;\n            skin = new Skin('default');\n        } else {\n            skin = new Skin(input.readStringRef());\n            skin.bones.length = input.readInt(true);\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n            slotCount = input.readInt(true);\n        }\n\n        for (let i = 0; i < slotCount; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const name = input.readStringRef();\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\n                if (attachment != null) skin.setAttachment(slotIndex, name, attachment);\n            }\n        }\n\n        return skin;\n    }\n\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\n        const scale = this.scale;\n\n        let name = input.readStringRef();\n\n        if (name == null) name = attachmentName;\n\n        const typeIndex = input.readByte();\n        const type = SkeletonBinary.AttachmentTypeValues[typeIndex];\n\n        switch (type) {\n            case AttachmentType.Region: {\n                let path = input.readStringRef();\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const scaleX = input.readFloat();\n                const scaleY = input.readFloat();\n                const width = input.readFloat();\n                const height = input.readFloat();\n                const color = input.readInt32();\n\n                if (path == null) path = name;\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (region == null) return null;\n                region.path = path;\n                region.x = x * scale;\n                region.y = y * scale;\n                region.scaleX = scaleX;\n                region.scaleY = scaleY;\n                region.rotation = rotation;\n                region.width = width * scale;\n                region.height = height * scale;\n                Color.rgba8888ToColor(region.color, color);\n                // region.updateOffset();\n\n                return region;\n            }\n            case AttachmentType.BoundingBox: {\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (box == null) return null;\n                box.worldVerticesLength = vertexCount << 1;\n                box.vertices = vertices.vertices;\n                box.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\n\n                return box;\n            }\n            case AttachmentType.Mesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const vertexCount = input.readInt(true);\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n                const triangles = this.readShortArray(input);\n                const vertices = this.readVertices(input, vertexCount);\n                const hullLength = input.readInt(true);\n                let edges = null;\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    edges = this.readShortArray(input);\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (path == null) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.bones = vertices.bones;\n                mesh.vertices = vertices.vertices;\n                mesh.worldVerticesLength = vertexCount << 1;\n                mesh.triangles = triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n                mesh.hullLength = hullLength << 1;\n                if (nonessential) {\n                    mesh.edges = edges;\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n\n                return mesh;\n            }\n            case AttachmentType.LinkedMesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const skinName = input.readStringRef();\n                const parent = input.readStringRef();\n                const inheritDeform = input.readBoolean();\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (path == null) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                if (nonessential) {\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\n\n                return mesh;\n            }\n            case AttachmentType.Path: {\n                const closed = input.readBoolean();\n                const constantSpeed = input.readBoolean();\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const lengths = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n                const color = nonessential ? input.readInt32() : 0;\n\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (path == null) return null;\n                path.closed = closed;\n                path.constantSpeed = constantSpeed;\n                path.worldVerticesLength = vertexCount << 1;\n                path.vertices = vertices.vertices;\n                path.bones = vertices.bones;\n                path.lengths = lengths;\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\n\n                return path;\n            }\n            case AttachmentType.Point: {\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const color = nonessential ? input.readInt32() : 0;\n\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (point == null) return null;\n                point.x = x * scale;\n                point.y = y * scale;\n                point.rotation = rotation;\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\n\n                return point;\n            }\n            case AttachmentType.Clipping: {\n                const endSlotIndex = input.readInt(true);\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (clip == null) return null;\n                clip.endSlot = skeletonData.slots[endSlotIndex];\n                clip.worldVerticesLength = vertexCount << 1;\n                clip.vertices = vertices.vertices;\n                clip.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\n        const verticesLength = vertexCount << 1;\n        const vertices = new Vertices();\n        const scale = this.scale;\n\n        if (!input.readBoolean()) {\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\n            return vertices;\n        }\n        const weights = new Array<number>();\n        const bonesArray = new Array<number>();\n\n        for (let i = 0; i < vertexCount; i++) {\n            const boneCount = input.readInt(true);\n\n            bonesArray.push(boneCount);\n            for (let ii = 0; ii < boneCount; ii++) {\n                bonesArray.push(input.readInt(true));\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat());\n            }\n        }\n        vertices.vertices = Utils.toFloatArray(weights);\n        vertices.bones = bonesArray;\n\n        return vertices;\n    }\n\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\n        const array = new Array<number>(n);\n\n        if (scale == 1) {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\n        } else {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n        }\n\n        return array;\n    }\n\n    private readShortArray(input: BinaryInput): number[] {\n        const n = input.readInt(true);\n        const array = new Array<number>(n);\n\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\n\n        return array;\n    }\n\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n        const timelines = new Array<Timeline>();\n        const scale = this.scale;\n        let duration = 0;\n        const tempColor1 = new Color();\n        const tempColor2 = new Color();\n\n        // Slot timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n\n                switch (timelineType) {\n                    case SkeletonBinary.SLOT_ATTACHMENT: {\n                        const timeline = new AttachmentTimeline(frameCount);\n\n                        timeline.slotIndex = slotIndex;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[frameCount - 1]);\n                        break;\n                    }\n                    case SkeletonBinary.SLOT_COLOR: {\n                        const timeline = new ColorTimeline(frameCount);\n\n                        timeline.slotIndex = slotIndex;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            const time = input.readFloat();\n\n                            Color.rgba8888ToColor(tempColor1, input.readInt32());\n                            timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\n                        break;\n                    }\n                    case SkeletonBinary.SLOT_TWO_COLOR: {\n                        const timeline = new TwoColorTimeline(frameCount);\n\n                        timeline.slotIndex = slotIndex;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            const time = input.readFloat();\n\n                            Color.rgba8888ToColor(tempColor1, input.readInt32());\n                            Color.rgb888ToColor(tempColor2, input.readInt32());\n                            timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const boneIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n\n                switch (timelineType) {\n                    case SkeletonBinary.BONE_ROTATE: {\n                        const timeline = new RotateTimeline(frameCount);\n\n                        timeline.boneIndex = boneIndex;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\n                        break;\n                    }\n                    case SkeletonBinary.BONE_TRANSLATE:\n                    case SkeletonBinary.BONE_SCALE:\n                    case SkeletonBinary.BONE_SHEAR: {\n                        let timeline;\n                        let timelineScale = 1;\n\n                        if (timelineType == SkeletonBinary.BONE_SCALE) timeline = new ScaleTimeline(frameCount);\n                        else if (timelineType == SkeletonBinary.BONE_SHEAR) timeline = new ShearTimeline(frameCount);\n                        else {\n                            timeline = new TranslateTimeline(frameCount);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const timeline = new IkConstraintTimeline(frameCount);\n\n            timeline.ikConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\n        }\n\n        // Transform constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const timeline = new TransformConstraintTimeline(frameCount);\n\n            timeline.transformConstraintIndex = index;\n            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n                if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\n        }\n\n        // Path constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const data = skeletonData.pathConstraints[index];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n\n                switch (timelineType) {\n                    case SkeletonBinary.PATH_POSITION:\n                    case SkeletonBinary.PATH_SPACING: {\n                        let timeline;\n                        let timelineScale = 1;\n\n                        if (timelineType == SkeletonBinary.PATH_SPACING) {\n                            timeline = new PathConstraintSpacingTimeline(frameCount);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(frameCount);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                        break;\n                    }\n                    case SkeletonBinary.PATH_MIX: {\n                        const timeline = new PathConstraintMixTimeline(frameCount);\n\n                        timeline.pathConstraintIndex = index;\n                        for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                            timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\n                            if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const skin = skeletonData.skins[input.readInt(true)];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const slotIndex = input.readInt(true);\n\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n                    const attachment = skin.getAttachment(slotIndex, input.readStringRef()) as VertexAttachment;\n                    const weighted = attachment.bones != null;\n                    const vertices = attachment.vertices;\n                    const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                    const frameCount = input.readInt(true);\n                    const timeline = new DeformTimeline(frameCount);\n\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n                        const time = input.readFloat();\n                        let deform;\n                        let end = input.readInt(true);\n\n                        if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                        else {\n                            deform = Utils.newFloatArray(deformLength);\n                            const start = input.readInt(true);\n\n                            end += start;\n                            if (scale == 1) {\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                            } else {\n                                for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                            }\n                            if (!weighted) {\n                                for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, time, deform);\n                        if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[frameCount - 1]);\n                }\n            }\n        }\n\n        // Draw order timeline.\n        const drawOrderCount = input.readInt(true);\n\n        if (drawOrderCount > 0) {\n            const timeline = new DrawOrderTimeline(drawOrderCount);\n            const slotCount = skeletonData.slots.length;\n\n            for (let i = 0; i < drawOrderCount; i++) {\n                const time = input.readFloat();\n                const offsetCount = input.readInt(true);\n                const drawOrder = Utils.newArray(slotCount, 0);\n\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n                let originalIndex = 0;\n                let unchangedIndex = 0;\n\n                for (let ii = 0; ii < offsetCount; ii++) {\n                    const slotIndex = input.readInt(true);\n                    // Collect unchanged items.\n\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                    // Set changed items.\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n                }\n                // Collect remaining unchanged items.\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                // Fill in unchanged items.\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                timeline.setFrame(i, time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\n        }\n\n        // Event timeline.\n        const eventCount = input.readInt(true);\n\n        if (eventCount > 0) {\n            const timeline = new EventTimeline(eventCount);\n\n            for (let i = 0; i < eventCount; i++) {\n                const time = input.readFloat();\n                const eventData = skeletonData.events[input.readInt(true)];\n                const event = new Event(time, eventData);\n\n                event.intValue = input.readInt(false);\n                event.floatValue = input.readFloat();\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n                if (event.data.audioPath != null) {\n                    event.volume = input.readFloat();\n                    event.balance = input.readFloat();\n                }\n                timeline.setFrame(i, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[eventCount - 1]);\n        }\n\n        return new Animation(name, timelines, duration);\n    }\n\n    private readCurve(input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\n        switch (input.readByte()) {\n            case SkeletonBinary.CURVE_STEPPED:\n                timeline.setStepped(frameIndex);\n                break;\n            case SkeletonBinary.CURVE_BEZIER:\n                this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\n                break;\n        }\n    }\n\n    setCurve(timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n\nclass Vertices {\n    constructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) {}\n}\n", "import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n", "import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport {\n    Animation,\n    AttachmentTimeline,\n    ColorTimeline,\n    CurveTimeline,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ShearTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TwoColorTimeline,\n} from './Animation';\nimport { ArrayLike, Color, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/**\n * @public\n */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            if (skeletonData.version.substr(0, 3) !== '3.8') {\n                const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            if (skeletonData.version === '3.8.75') {\n                const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = this.getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\n                data.skinRequired = this.getValue(boneMap, 'skin', false);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const slotName: string = slotMap.name;\n                const boneName: string = slotMap.bone;\n                const boneData = skeletonData.findBone(boneName);\n\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                const color: string = this.getValue(slotMap, 'color', null);\n\n                if (color != null) data.color.setFromString(color);\n\n                const dark: string = this.getValue(slotMap, 'dark', null);\n\n                if (dark != null) {\n                    data.darkColor = new Color(1, 1, 1, 1);\n                    data.darkColor.setFromString(dark);\n                }\n\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\n\n                data.mix = this.getValue(constraintMap, 'mix', 1);\n                data.softness = this.getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = this.getValue(constraintMap, 'compress', false);\n                data.stretch = this.getValue(constraintMap, 'stretch', false);\n                data.uniform = this.getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = this.getValue(constraintMap, 'local', false);\n                data.relative = this.getValue(constraintMap, 'relative', false);\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\n\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n                data.skinRequired = this.getValue(constraintMap, 'skin', false);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.position = this.getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const bone = skeletonData.findBone(skinMap.bones[ii]);\n\n                        if (bone == null) throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\n\n                        if (constraint == null) throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\n\n                        if (constraint == null) throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\n\n                        if (constraint == null) throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (slot == null) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = this.getValue(eventMap, 'int', 0);\n                data.floatValue = this.getValue(eventMap, 'float', 0);\n                data.stringValue = this.getValue(eventMap, 'string', '');\n                data.audioPath = this.getValue(eventMap, 'audio', null);\n                if (data.audioPath != null) {\n                    data.volume = this.getValue(eventMap, 'volume', 1);\n                    data.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = this.getValue(map, 'name', name);\n\n        const type = this.getValue(map, 'type', 'region');\n\n        switch (type) {\n            case 'region': {\n                const path = this.getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, 'x', 0) * scale;\n                region.y = this.getValue(map, 'y', 0) * scale;\n                region.scaleX = this.getValue(map, 'scaleX', 1);\n                region.scaleY = this.getValue(map, 'scaleY', 1);\n                region.rotation = this.getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = this.getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) mesh.color.setFromString(color);\n\n                mesh.width = this.getValue(map, 'width', 0) * scale;\n                mesh.height = this.getValue(map, 'height', 0) * scale;\n\n                const parent: string = this.getValue(map, 'parent', null);\n\n                if (parent != null) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent, this.getValue(map, 'deform', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.edges = this.getValue(map, 'edges', null);\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (path == null) return null;\n                path.closed = this.getValue(map, 'closed', false);\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (point == null) return null;\n                point.x = this.getValue(map, 'x', 0) * scale;\n                point.y = this.getValue(map, 'y', 0) * scale;\n                point.rotation = this.getValue(map, 'rotation', 0);\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (clip == null) return null;\n\n                const end = this.getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex++, this.getValue(valueMap, 'time', 0), valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else if (timelineName == 'color') {\n                        const timeline = new ColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const color = new Color();\n\n                            color.setFromString(valueMap.color || 'ffffffff');\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n                    } else if (timelineName == 'twoColor') {\n                        const timeline = new TwoColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const light = new Color();\n                            const dark = new Color();\n\n                            light.setFromString(valueMap.light);\n                            dark.setFromString(valueMap.dark);\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBoneIndex(boneName);\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n\n                    if (timelineName === 'rotate') {\n                        const timeline = new RotateTimeline(timelineMap.length);\n\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'angle', 0));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n                        let defaultValue = 0;\n\n                        if (timelineName === 'scale') {\n                            timeline = new ScaleTimeline(timelineMap.length);\n                            defaultValue = 1;\n                        } else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const x = this.getValue(valueMap, 'x', defaultValue);\n                            const y = this.getValue(valueMap, 'y', defaultValue);\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const timeline = new IkConstraintTimeline(constraintMap.length);\n\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        this.getValue(valueMap, 'time', 0),\n                        this.getValue(valueMap, 'mix', 1),\n                        this.getValue(valueMap, 'softness', 0) * scale,\n                        this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\n                        this.getValue(valueMap, 'compress', false),\n                        this.getValue(valueMap, 'stretch', false)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const constraintMap = map.transform[constraintName];\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\n\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        this.getValue(valueMap, 'time', 0),\n                        this.getValue(valueMap, 'rotateMix', 1),\n                        this.getValue(valueMap, 'translateMix', 1),\n                        this.getValue(valueMap, 'scaleMix', 1),\n                        this.getValue(valueMap, 'shearMix', 1)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const index = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const data = skeletonData.pathConstraints[index];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n\n                    if (timelineName === 'position' || timelineName === 'spacing') {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'spacing') {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\n\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n                        const weighted = attachment.bones != null;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            const valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            const verticesValue: Array<Number> = this.getValue(valueMap, 'vertices', null);\n\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, this.getValue(valueMap, 'time', 0), deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\n            const slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                const drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let i = 0; i < offsets.length; i++) {\n                        const offsetMap = offsets[i];\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n\n            for (let i = 0; i < map.events.length; i++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath != null) {\n                    event.volume = this.getValue(eventMap, 'volume', 1);\n                    event.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.hasOwnProperty('curve')) return;\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\n        else {\n            const curve: number = map.curve;\n\n            timeline.setCurve(frameIndex, curve, this.getValue(map, 'c2', 0), this.getValue(map, 'c3', 1), this.getValue(map, 'c4', 1));\n        }\n    }\n\n    getValue(map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'fixed') return PositionMode.Fixed;\n        if (str == 'percent') return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'length') return SpacingMode.Length;\n        if (str == 'fixed') return SpacingMode.Fixed;\n        if (str == 'percent') return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'tangent') return RotateMode.Tangent;\n        if (str == 'chain') return RotateMode.Chain;\n        if (str == 'chainscale') return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n\n    static transformModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return TransformMode.Normal;\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\n        if (str == 'noscale') return TransformMode.NoScale;\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\n        throw new Error(`Unknown transform mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritDeform: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritDeform = inheritDeform;\n    }\n}\n", "import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n", "export { Attachment, VertexAttachment } from './core/attachments/Attachment.mjs';\nexport { BoundingBoxAttachment } from './core/attachments/BoundingBoxAttachment.mjs';\nexport { ClippingAttachment } from './core/attachments/ClippingAttachment.mjs';\nexport { MeshAttachment } from './core/attachments/MeshAttachment.mjs';\nexport { PathAttachment } from './core/attachments/PathAttachment.mjs';\nexport { PointAttachment } from './core/attachments/PointAttachment.mjs';\nexport { RegionAttachment } from './core/attachments/RegionAttachment.mjs';\nexport { JitterEffect } from './core/vertexeffects/JitterEffect.mjs';\nexport { SwirlEffect } from './core/vertexeffects/SwirlEffect.mjs';\nexport { Animation, AttachmentTimeline, ColorTimeline, CurveTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RotateTimeline, ScaleTimeline, ShearTimeline, TimelineType, TransformConstraintTimeline, TranslateTimeline, TwoColorTimeline } from './core/Animation.mjs';\nexport { AnimationState, AnimationStateAdapter2, EventQueue, EventType, TrackEntry } from './core/AnimationState.mjs';\nexport { AnimationStateData } from './core/AnimationStateData.mjs';\nexport { AtlasAttachmentLoader } from './core/AtlasAttachmentLoader.mjs';\nexport { Bone } from './core/Bone.mjs';\nexport { BoneData } from './core/BoneData.mjs';\nexport { Event } from './core/Event.mjs';\nexport { EventData } from './core/EventData.mjs';\nexport { IkConstraint } from './core/IkConstraint.mjs';\nexport { IkConstraintData } from './core/IkConstraintData.mjs';\nexport { PathConstraint } from './core/PathConstraint.mjs';\nexport { PathConstraintData, SpacingMode } from './core/PathConstraintData.mjs';\nexport { Skeleton } from './core/Skeleton.mjs';\nexport { SkeletonBounds } from './core/SkeletonBounds.mjs';\nexport { SkeletonData } from './core/SkeletonData.mjs';\nexport { SkeletonJson } from './core/SkeletonJson.mjs';\nexport { Skin } from './core/Skin.mjs';\nexport { Slot } from './core/Slot.mjs';\nexport { SlotData } from './core/SlotData.mjs';\nexport { TransformConstraint } from './core/TransformConstraint.mjs';\nexport { TransformConstraintData } from './core/TransformConstraintData.mjs';\nexport { Spine } from './Spine.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import type { IAttachment, ArrayLike, AttachmentType } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n}\n\n/**\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    id = (VertexAttachment.nextID++ & 65535) << 11;\n    bones: Array<number>;\n    vertices: ArrayLike<number>;\n    worldVerticesLength = 0;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n\n    /** Transforms local vertices to world coordinates.\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\n     * @param offset The worldVertices index to begin writing values. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.attachmentVertices;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (bones == null) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n    applyDeform(sourceAttachment: VertexAttachment) {\n        return this == sourceAttachment;\n    }\n}\n", "import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n", "import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    endSlot: SlotData;\n\n    // Nonessential.\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n", "import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, TextureRegion } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion;\n    path: string;\n    regionUVs: Float32Array;\n    uvs: ArrayLike<number>;\n    triangles: Array<number>;\n    color = new Color(1, 1, 1, 1);\n    hullLength: number;\n    private parentMesh: MeshAttachment;\n    inheritDeform = false;\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n    }\n\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n}\n", "import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n    lengths: Array<number>;\n    closed = false;\n    constantSpeed = false;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n}\n", "import { VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n    x: number;\n    y: number;\n    rotation: number;\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n}\n", "import { Color, ISlot } from '@pixi-spine/base';\n\nimport type { Attachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\n\n/**\n * @public\n */\nexport class Slot implements ISlot {\n    blendMode: number;\n\n    // this is canon\n    data: SlotData;\n    bone: Bone;\n    color: Color;\n    darkColor: Color;\n    attachment: Attachment;\n    private attachmentTime: number;\n    attachmentVertices = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (bone == null) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = data.darkColor == null ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** @return May be null. */\n    getAttachment(): Attachment {\n        return this.attachment;\n    }\n\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n     * @param attachment May be null. */\n    setAttachment(attachment: Attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    }\n\n    setAttachmentTime(time: number) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n    }\n\n    /** Returns the time since the attachment was set. */\n    getAttachmentTime(): number {\n        return this.bone.skeleton.time - this.attachmentTime;\n    }\n\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n", "import { Attachment } from './Attachment';\nimport { AttachmentType, ArrayLike, Color, TextureRegion, Utils, IRegionAttachment } from '@pixi-spine/base';\n\nimport type { Bone } from '../Bone';\nimport { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment {\n    type = AttachmentType.Region;\n\n    static OX1 = 0;\n    static OY1 = 1;\n    static OX2 = 2;\n    static OY2 = 3;\n    static OX3 = 4;\n    static OY3 = 5;\n    static OX4 = 6;\n    static OY4 = 7;\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n\n    x = 0;\n    y = 0;\n    scaleX = 1;\n    scaleY = 1;\n    rotation = 0;\n    width = 0;\n    height = 0;\n    color = new Color(1, 1, 1, 1);\n\n    path: string;\n    rendererObject: any;\n    region: TextureRegion;\n\n    offset = Utils.newFloatArray(8);\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    updateOffset(): void {\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const localXCos = localX * cos + this.x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + this.y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + this.x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + this.y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n    }\n\n    setRegion(region: TextureRegion): void {\n        this.region = region;\n        const uvs = this.uvs;\n\n        if (region.rotate) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    computeWorldVertices(bone: Bone | Slot, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n        const vertexOffset = this.offset;\n        const mat = bone instanceof Slot ? bone.bone.matrix : bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n}\n", "import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class JitterEffect implements VertexEffect {\n    jitterX = 0;\n    jitterY = 0;\n\n    constructor(jitterX: number, jitterY: number) {\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n    }\n\n    begin(skeleton: Skeleton): void {}\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        position.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n    }\n\n    end(): void {}\n}\n", "import type { VertexEffect } from '../VertexEffect';\nimport type { Skeleton } from '../Skeleton';\nimport { Color, MathUtils, PowOut, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class SwirlEffect implements VertexEffect {\n    static interpolation = new PowOut(2);\n    centerX = 0;\n    centerY = 0;\n    radius = 0;\n    angle = 0;\n    private worldX = 0;\n    private worldY = 0;\n\n    constructor(radius: number) {\n        this.radius = radius;\n    }\n\n    begin(skeleton: Skeleton): void {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n    }\n\n    transform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n        const radAngle = this.angle * MathUtils.degreesToRadians;\n        const x = position.x - this.worldX;\n        const y = position.y - this.worldY;\n        const dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n            const theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n            const cos = Math.cos(theta);\n            const sin = Math.sin(theta);\n\n            position.x = cos * x - sin * y + this.worldX;\n            position.y = sin * x + cos * y + this.worldY;\n        }\n    }\n\n    end(): void {}\n}\n", "import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { ArrayLike, MathUtils, Utils, MixBlend, MixDirection, IAnimation, ITimeline } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\n\n/**\n * @public\n */\nexport class Animation implements IAnimation<Timeline> {\n    name: string;\n    timelines: Array<Timeline>;\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (name == null) throw new Error('name cannot be null.');\n        if (timelines == null) throw new Error('timelines cannot be null.');\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n\n    static binarySearch(values: ArrayLike<number>, target: number, step = 1) {\n        let low = 0;\n        let high = values.length / step - 2;\n\n        if (high == 0) return step;\n        let current = high >>> 1;\n\n        while (true) {\n            if (values[(current + 1) * step] <= target) low = current + 1;\n            else high = current;\n            if (low == high) return (low + 1) * step;\n            current = (low + high) >>> 1;\n        }\n    }\n\n    static linearSearch(values: ArrayLike<number>, target: number, step: number) {\n        for (let i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\n\n        return -1;\n    }\n}\n\n/**\n * @public\n */\nexport interface Timeline extends ITimeline {\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n    getPropertyId(): number;\n}\n\n/**\n * @public\n */\nexport enum TimelineType {\n    rotate,\n    translate,\n    scale,\n    shear,\n    attachment,\n    color,\n    deform,\n    event,\n    drawOrder,\n    ikConstraint,\n    transformConstraint,\n    pathConstraintPosition,\n    pathConstraintSpacing,\n    pathConstraintMix,\n    twoColor,\n}\n\n/**\n * @public\n */\nexport abstract class CurveTimeline implements Timeline {\n    static LINEAR = 0;\n    static STEPPED = 1;\n    static BEZIER = 2;\n    static BEZIER_SIZE = 10 * 2 - 1;\n\n    private curves: ArrayLike<number>; // type, x, y, ...\n\n    abstract getPropertyId(): number;\n\n    constructor(frameCount: number) {\n        if (frameCount <= 0) throw new Error(`frameCount must be > 0: ${frameCount}`);\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n    }\n\n    getFrameCount() {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n    }\n\n    setLinear(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n    }\n\n    setStepped(frameIndex: number) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n    }\n\n    getCurveType(frameIndex: number): number {\n        const index = frameIndex * CurveTimeline.BEZIER_SIZE;\n\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        const type = this.curves[index];\n\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n\n        return CurveTimeline.BEZIER;\n    }\n\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve(frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n        const tmpx = (-cx1 * 2 + cx2) * 0.03;\n        const tmpy = (-cy1 * 2 + cy2) * 0.03;\n        const dddfx = ((cx1 - cx2) * 3 + 1) * 0.006;\n        const dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        let ddfx = tmpx * 2 + dddfx;\n        let ddfy = tmpy * 2 + dddfy;\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;\n        let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const curves = this.curves;\n\n        curves[i++] = CurveTimeline.BEZIER;\n\n        let x = dfx;\n        let y = dfy;\n\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    }\n\n    getCurvePercent(frameIndex: number, percent: number) {\n        percent = MathUtils.clamp(percent, 0, 1);\n        const curves = this.curves;\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        const type = curves[i];\n\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        let x = 0;\n\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                let prevX: number;\n                let prevY: number;\n\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n\n                return prevY + ((curves[i + 1] - prevY) * (percent - prevX)) / (x - prevX);\n            }\n        }\n        const y = curves[i - 1];\n\n        return y + ((1 - y) * (percent - x)) / (1 - x); // Last point is 1,1.\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n}\n\n/**\n * @public\n */\nexport class RotateTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_ROTATION = -1;\n    static ROTATION = 1;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, degrees, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount << 1);\n    }\n\n    getPropertyId() {\n        return (TimelineType.rotate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time and angle of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, degrees: number) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    const r = bone.data.rotation - bone.rotation;\n\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\n\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation + r * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    r += bone.data.rotation - bone.rotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                case MixBlend.add:\n                    bone.rotation += r * alpha;\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n        let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n\n        r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TranslateTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_X = -2;\n    static PREV_Y = -1;\n    static X = 1;\n    static Y = 2;\n\n    boneIndex: number;\n    frames: ArrayLike<number>; // time, x, y, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.translate << 24) + this.boneIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, x: number, y: number) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + TranslateTimeline.PREV_X];\n            y = frames[frames.length + TranslateTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n\n            x = frames[frame + TranslateTimeline.PREV_X];\n            y = frames[frame + TranslateTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n            x += (frames[frame + TranslateTimeline.X] - x) * percent;\n            y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ScaleTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.scale << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n\n            x = frames[frame + ScaleTimeline.PREV_X];\n            y = frames[frame + ScaleTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n        }\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bx = MathUtils.signum(x);\n                        by = MathUtils.signum(y);\n                        bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                        bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ShearTimeline extends TranslateTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.shear << 24) + this.boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n            // Time is after last frame.\n            x = frames[frames.length + ShearTimeline.PREV_X];\n            y = frames[frames.length + ShearTimeline.PREV_Y];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n\n            x = frames[frame + ShearTimeline.PREV_X];\n            y = frames[frame + ShearTimeline.PREV_Y];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n            x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n            y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n        }\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class ColorTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_R = -4;\n    static PREV_G = -3;\n    static PREV_B = -2;\n    static PREV_A = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.color << 24) + this.slotIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n\n                    return;\n                case MixBlend.first:\n                    const color = slot.color;\n                    const setup = slot.data.color;\n\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + ColorTimeline.PREV_R];\n            g = frames[i + ColorTimeline.PREV_G];\n            b = frames[i + ColorTimeline.PREV_B];\n            a = frames[i + ColorTimeline.PREV_A];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n\n            r = frames[frame + ColorTimeline.PREV_R];\n            g = frames[frame + ColorTimeline.PREV_G];\n            b = frames[frame + ColorTimeline.PREV_B];\n            a = frames[frame + ColorTimeline.PREV_A];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n        if (alpha == 1) slot.color.set(r, g, b, a);\n        else {\n            const color = slot.color;\n\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TwoColorTimeline extends CurveTimeline {\n    static ENTRIES = 8;\n    static PREV_TIME = -8;\n    static PREV_R = -7;\n    static PREV_G = -6;\n    static PREV_B = -5;\n    static PREV_A = -4;\n    static PREV_R2 = -3;\n    static PREV_G2 = -2;\n    static PREV_B2 = -1;\n    static R = 1;\n    static G = 2;\n    static B = 3;\n    static A = 4;\n    static R2 = 5;\n    static G2 = 6;\n    static B2 = 7;\n\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.twoColor << 24) + this.slotIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frameIndex *= TwoColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    slot.color.setFromColor(slot.data.color);\n                    slot.darkColor.setFromColor(slot.data.darkColor);\n\n                    return;\n                case MixBlend.first:\n                    const light = slot.color;\n                    const dark = slot.darkColor;\n                    const setupLight = slot.data.color;\n                    const setupDark = slot.data.darkColor;\n\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            r = frames[i + TwoColorTimeline.PREV_R];\n            g = frames[i + TwoColorTimeline.PREV_G];\n            b = frames[i + TwoColorTimeline.PREV_B];\n            a = frames[i + TwoColorTimeline.PREV_A];\n            r2 = frames[i + TwoColorTimeline.PREV_R2];\n            g2 = frames[i + TwoColorTimeline.PREV_G2];\n            b2 = frames[i + TwoColorTimeline.PREV_B2];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n\n            r = frames[frame + TwoColorTimeline.PREV_R];\n            g = frames[frame + TwoColorTimeline.PREV_G];\n            b = frames[frame + TwoColorTimeline.PREV_B];\n            a = frames[frame + TwoColorTimeline.PREV_A];\n            r2 = frames[frame + TwoColorTimeline.PREV_R2];\n            g2 = frames[frame + TwoColorTimeline.PREV_G2];\n            b2 = frames[frame + TwoColorTimeline.PREV_B2];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n            r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n            g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n            b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n            a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n            r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n            g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n            b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n        }\n        if (alpha == 1) {\n            slot.color.set(r, g, b, a);\n            slot.darkColor.set(r2, g2, b2, 1);\n        } else {\n            const light = slot.color;\n            const dark = slot.darkColor;\n\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                dark.setFromColor(slot.data.darkColor);\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class AttachmentTimeline implements Timeline {\n    slotIndex: number;\n    frames: ArrayLike<number>; // time, ...\n    attachmentNames: Array<string>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.attachment << 24) + this.slotIndex;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, attachmentName: string) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n            const attachmentName = slot.data.attachmentName;\n\n            slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n            }\n\n            return;\n        }\n\n        let frameIndex = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n        const attachmentName = this.attachmentNames[frameIndex];\n\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\nlet zeros: ArrayLike<number> = null;\n\n/**\n * @public\n */\nexport class DeformTimeline extends CurveTimeline {\n    slotIndex: number;\n    attachment: VertexAttachment;\n    frames: ArrayLike<number>; // time, ...\n    frameVertices: Array<ArrayLike<number>>;\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount);\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n        if (zeros == null) zeros = Utils.newFloatArray(64);\n    }\n\n    getPropertyId() {\n        return (TimelineType.deform << 27) + Number(this.attachment.id) + this.slotIndex;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, vertices: ArrayLike<number>) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n        const slotAttachment: Attachment = slot.getAttachment();\n\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n        const verticesArray: Array<number> = slot.attachmentVertices;\n\n        if (verticesArray.length == 0) blend = MixBlend.setup;\n\n        const frameVertices = this.frameVertices;\n        const vertexCount = frameVertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const vertexAttachment = <VertexAttachment>slotAttachment;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    verticesArray.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        verticesArray.length = 0;\n                        break;\n                    }\n                    const vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += (setupVertices[i] - vertices[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) vertices[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        const vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = frameVertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            vertices[i] += lastVertices[i] - setupVertices[i];\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i];\n                    }\n                } else {\n                    Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) vertices[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time);\n        const prevVertices = frameVertices[frame - 1];\n        const nextVertices = frameVertices[frame];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (vertexAttachment.bones == null) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    vertices[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class EventTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    events: Array<Event>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.event << 24;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe. */\n    setFrame(frameIndex: number, event: Event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n    }\n\n    /** Fires events for frames > lastTime and <= time. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (firedEvents == null) return;\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let frame = 0;\n\n        if (lastTime < frames[0]) frame = 0;\n        else {\n            frame = Animation.binarySearch(frames, lastTime);\n            const frameTime = frames[frame];\n\n            while (frame > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[frame - 1] != frameTime) break;\n                frame--;\n            }\n        }\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\n    }\n}\n\n/**\n * @public\n */\nexport class DrawOrderTimeline implements Timeline {\n    frames: ArrayLike<number>; // time, ...\n    drawOrders: Array<Array<number>>;\n\n    constructor(frameCount: number) {\n        this.frames = Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array<Array<number>>(frameCount);\n    }\n\n    getPropertyId() {\n        return TimelineType.drawOrder << 24;\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time of the specified keyframe.\n     * @param drawOrder May be null to use bind pose draw order. */\n    setFrame(frameIndex: number, time: number, drawOrder: Array<number>) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const drawOrder: Array<Slot> = skeleton.drawOrder;\n        const slots: Array<Slot> = skeleton.slots;\n\n        if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n            Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        let frame = 0;\n\n        if (time >= frames[frames.length - 1])\n            // Time is after last frame.\n            frame = frames.length - 1;\n        else frame = Animation.binarySearch(frames, time) - 1;\n\n        const drawOrderToSetupIndex = this.drawOrders[frame];\n\n        if (drawOrderToSetupIndex == null) Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n        else {\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class IkConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_MIX = -4;\n    static PREV_BEND_DIRECTION = -3;\n    static PREV_COMPRESS = -2;\n    static PREV_STRETCH = -1;\n    static MIX = 1;\n    static BEND_DIRECTION = 2;\n    static COMPRESS = 3;\n    static STRETCH = 4;\n\n    ikConstraintIndex: number;\n    frames: ArrayLike<number>; // time, mix, bendDirection, compress, stretch, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n    }\n\n    /** Sets the time, mix and bend direction of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, mix: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            if (blend == MixBlend.setup) {\n                constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                if (direction == MixDirection.mixOut) {\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n                } else {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            } else {\n                constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                if (direction == MixDirection.mixIn) {\n                    constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        const mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        const frameTime = frames[frame];\n        const percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        } else {\n            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    static ENTRIES = 5;\n    static PREV_TIME = -5;\n    static PREV_ROTATE = -4;\n    static PREV_TRANSLATE = -3;\n    static PREV_SCALE = -2;\n    static PREV_SHEAR = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n    static SCALE = 3;\n    static SHEAR = 4;\n\n    transformConstraintIndex: number;\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                    constraint.scaleMix = data.scaleMix;\n                    constraint.shearMix = data.shearMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                    constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                    constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n        let scale = 0;\n        let shear = 0;\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n            // Time is after last frame.\n            const i = frames.length;\n\n            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n\n            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / TransformConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n        }\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n            constraint.shearMix += (shear - constraint.shearMix) * alpha;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintPositionTimeline extends CurveTimeline {\n    static ENTRIES = 2;\n    static PREV_TIME = -2;\n    static PREV_VALUE = -1;\n    static VALUE = 1;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, position, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n    }\n\n    /** Sets the time and value of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, value: number) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        let position = 0;\n\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\n            // Time is after last frame.\n            position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n\n            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime)\n            );\n\n            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n        }\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n    constructor(frameCount: number) {\n        super(frameCount);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        let spacing = 0;\n\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n            // Time is after last frame.\n            spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n        else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n\n            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)\n            );\n\n            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n        }\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/**\n * @public\n */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    static ENTRIES = 3;\n    static PREV_TIME = -3;\n    static PREV_ROTATE = -2;\n    static PREV_TRANSLATE = -1;\n    static ROTATE = 1;\n    static TRANSLATE = 2;\n\n    pathConstraintIndex: number;\n\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n    constructor(frameCount: number) {\n        super(frameCount);\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n    }\n\n    getPropertyId() {\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n    }\n\n    /** Sets the time and mixes of the specified keyframe. */\n    setFrame(frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const frames = this.frames;\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.rotateMix = constraint.data.rotateMix;\n                    constraint.translateMix = constraint.data.translateMix;\n\n                    return;\n                case MixBlend.first:\n                    constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate = 0;\n        let translate = 0;\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n            // Time is after last frame.\n            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            const frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n\n            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n            const frameTime = frames[frame];\n            const percent = this.getCurvePercent(\n                frame / PathConstraintMixTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime)\n            );\n\n            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n        } else {\n            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n            constraint.translateMix += (translate - constraint.translateMix) * alpha;\n        }\n    }\n}\n", "import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, IntSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static emptyAnimation = new Animation('<empty>', [], 0);\n    static SUBSEQUENT = 0;\n    static FIRST = 1;\n    static HOLD = 2;\n    static HOLD_MIX = 3;\n\n    data: AnimationStateData;\n    tracks = new Array<TrackEntry>();\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new IntSet();\n    animationsChanged = false;\n    timeScale = 1;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next != null) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom != null) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.disposeNext(current);\n                continue;\n            }\n            if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from != null) from.mixingTo = null;\n                while (from != null) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (from == null) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    apply(skeleton: Skeleton): boolean {\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (current == null || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            const timelineCount = current.animation.timelines.length;\n            const timelines = current.animation.timelines;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const firstFrame = current.timelinesRotation.length == 0;\n\n                if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                const timelinesRotation = current.timelinesRotation;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const events = mix < from.eventThreshold ? this.events : null;\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        const timelineCount = from.animation.timelines.length;\n        const timelines = from.animation.timelines;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const firstFrame = from.timelinesRotation.length == 0;\n\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            const timelinesRotation = from.timelinesRotation;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!attachments && timeline instanceof AttachmentTimeline) continue;\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.HOLD:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n                if (timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (timelineBlend == MixBlend.setup) {\n                        if (timeline instanceof AttachmentTimeline) {\n                            if (attachments) direction = MixDirection.mixOut;\n                        } else if (timeline instanceof DrawOrderTimeline) {\n                            if (drawOrder) direction = MixDirection.mixOut;\n                        }\n                    }\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyRotateTimeline(timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend, timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const rotateTimeline = timeline as RotateTimeline;\n        const frames = rotateTimeline.frames;\n        const bone = skeleton.bones[rotateTimeline.boneIndex];\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES])\n                // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                const frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                const prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                const frameTime = frames[frame];\n                const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        r1 += total * alpha;\n        bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, events[i]);\n        }\n    }\n\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (current == null) return;\n\n        this.queue.end(current);\n\n        this.disposeNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (from == null) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n\n        if (from != null) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    setAnimationWith(trackIndex: number, animation: Animation, loop: boolean) {\n        if (animation == null) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current != null) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.disposeNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.disposeNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (animation == null) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    addAnimationWith(trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n        if (animation == null) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last != null) {\n            while (last.next != null) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (last == null) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            if (delay <= 0) {\n                const duration = last.animationEnd - last.animationStart;\n\n                if (duration != 0) {\n                    if (last.loop) delay += duration * (1 + ((last.trackTime / duration) | 0));\n                    else delay += Math.max(duration, last.trackTime);\n                    delay -= this.data.getMix(last.animation, animation);\n                } else delay = last.trackTime;\n            }\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    setEmptyAnimation(trackIndex: number, mixDuration: number) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number) {\n        if (delay <= 0) delay -= mixDuration;\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    setEmptyAnimations(mixDuration: number) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n\n        return entry;\n    }\n\n    disposeNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next != null) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            let entry = this.tracks[i];\n\n            if (entry == null) continue;\n            while (entry.mixingFrom != null) entry = entry.mixingFrom;\n\n            do {\n                if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.setTimelineModes(entry);\n                entry = entry.mixingTo;\n            } while (entry != null);\n        }\n    }\n\n    setTimelineModes(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n\n        entry.timelineHoldMix.length = 0;\n        const timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n        const propertyIDs = this.propertyIDs;\n\n        if (to != null && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) {\n                propertyIDs.add(timelines[i].getPropertyId());\n                timelineMode[i] = AnimationState.HOLD;\n            }\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const id = timelines[i].getPropertyId();\n\n            if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;\n            else if (to == null || !this.hasTimeline(to, id)) timelineMode[i] = AnimationState.FIRST;\n            else {\n                for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n                    if (this.hasTimeline(next, id)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = AnimationState.HOLD_MIX;\n                        timelineDipMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = AnimationState.HOLD;\n            }\n        }\n    }\n\n    hasTimeline(entry: TrackEntry, id: number): boolean {\n        const timelines = entry.animation.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) if (timelines[i].getPropertyId() == id) return true;\n\n        return false;\n    }\n\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    addListener(listener: AnimationStateListener) {\n        if (listener == null) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/**\n * @public\n */\nexport class TrackEntry implements ITrackEntry {\n    animation: Animation;\n    next: TrackEntry;\n    mixingFrom: TrackEntry;\n    mixingTo: TrackEntry;\n    listener: AnimationStateListener;\n    trackIndex: number;\n    loop: boolean;\n    holdPrevious: boolean;\n    eventThreshold: number;\n    attachmentThreshold: number;\n    drawOrderThreshold: number;\n    animationStart: number;\n    animationEnd: number;\n    animationLast: number;\n    nextAnimationLast: number;\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n    private static deprecatedWarning2 = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    deprecateStuff() {\n        if (!EventQueue.deprecatedWarning1) {\n            EventQueue.deprecatedWarning1 = true;\n            console.warn(\n                \"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\"\n            );\n        }\n\n        return true;\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n                    // deprecation\n                    entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                    this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                    break;\n                case EventType.end:\n                    if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n                    // deprecation\n                    entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                    this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n                    // deprecation\n\n                    const count = MathUtils.toInt(entry.loopsCount());\n\n                    entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                    this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event);\n                    // deprecation\n                    entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                    this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/**\n * @public\n */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?(entry: TrackEntry): void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?(entry: TrackEntry): void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?(entry: TrackEntry): void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?(entry: TrackEntry): void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?(entry: TrackEntry): void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?(entry: TrackEntry, event: Event): void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter2 implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n", "import type { SkeletonData } from './SkeletonData';\nimport type { IAnimationStateData, Map } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/**\n * @public\n */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = {};\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (from == null) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (to == null) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1 = false;\n\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn('Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.');\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith(from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error('from cannot be null.');\n        if (to == null) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix(from: Animation, to: Animation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n", "import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n        const attachment = new RegionAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n        const region = this.atlas.findRegion(path);\n\n        if (region == null) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n        const attachment = new MeshAttachment(name);\n\n        attachment.region = region;\n\n        return attachment;\n    }\n\n    /** @return May be null to not load an attachment. */\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    /** @return May be null to not load an attachment */\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n", "import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    data: BoneData;\n    skeleton: Skeleton;\n    parent: Bone;\n    children = new Array<Bone>();\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 0;\n    scaleY = 0;\n    shearX = 0;\n    shearY = 0;\n    ax = 0;\n    ay = 0;\n    arotation = 0;\n    ascaleX = 0;\n    ascaleY = 0;\n    ashearX = 0;\n    ashearY = 0;\n    appliedValid = false;\n\n    sorted = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** NOT USED IN 3.7. Needed for the debug graph code */\n    active = true;\n\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n    update() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (parent == null) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (\n                    this.data.transformMode == TransformMode.NoScale &&\n                    pa * pd - pb * pc < 0 != (settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)\n                )\n                    s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n    }\n\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n    }\n\n    /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n     * the applied transform after the world transform has been modified directly (eg, by a constraint).\n     * <p>\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n    updateAppliedTransform() {\n        this.appliedValid = true;\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (parent == null) {\n            this.ax = m.tx;\n            this.ay = m.ty;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    localToWorldRotation(localRotation: number) {\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        this.appliedValid = false;\n    }\n}\n", "import { TransformMode } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoneData {\n    index: number;\n    name: string;\n    parent: BoneData;\n    length: number;\n    x = 0;\n    y = 0;\n    rotation = 0;\n    scaleX = 1;\n    scaleY = 1;\n    shearX = 0;\n    shearY = 0;\n    transformMode = TransformMode.Normal;\n\n    constructor(index: number, name: string, parent: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n", "import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    time: number;\n    volume: number;\n    balance: number;\n\n    constructor(time: number, data: EventData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n", "import type { IEventData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class EventData implements IEventData {\n    name: string;\n    intValue: number;\n    floatValue: number;\n    stringValue: string;\n    audioPath: string;\n    volume: number;\n    balance: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n", "import type { Constraint } from './Constraint';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class IkConstraint implements Constraint {\n    data: IkConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    bendDirection = 0;\n    compress = false;\n    stretch = false;\n    mix = 1;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\n                break;\n        }\n    }\n\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n     * coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        const p = bone.parent.matrix;\n        const id = 1 / (p.a * p.d - p.b * p.c);\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const tx = (x * p.d - y * p.c) * id - bone.ax;\n        const ty = (y * p.a - x * p.b) * id - bone.ay;\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n     * target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, alpha: number) {\n        if (alpha == 0) {\n            child.updateWorldTransform();\n\n            return;\n        }\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let sx = psx;\n        let psy = parent.ascaleY;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = targetX - pp.tx;\n        let y = targetY - pp.ty;\n        const tx = (x * d - y * b) * id - px;\n        const ty = (y * a - x * c) * id - py;\n        const dd = tx * tx + ty * ty;\n\n        x = cwx - pp.tx;\n        y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1 = 0;\n        let a2 = 0;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) cos = -1;\n            else if (cos > 1) {\n                cos = 1;\n                if (stretch && l1 + l2 > 0.0001) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n            }\n            a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n", "import type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class IkConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    bendDirection = 1;\n    compress = false;\n    stretch = false;\n    uniform = false;\n    mix = 1;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n", "import type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport type { RotateMode, PositionMode, IPathConstraintData } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraintData implements IPathConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: SlotData;\n    positionMode: PositionMode;\n    spacingMode: SpacingMode;\n    rotateMode: RotateMode;\n    offsetRotation: number;\n    position: number;\n    spacing: number;\n    rotateMix: number;\n    translateMix: number;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\n/**\n * @public\n */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n}\n", "import { PathAttachment } from './attachments';\nimport type { Constraint } from './Constraint';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathConstraint implements Constraint {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    data: PathConstraintData;\n    bones: Array<Bone>;\n    target: Slot;\n    position = 0;\n    spacing = 0;\n    rotateMix = 0;\n    translateMix = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const translate = translateMix > 0;\n        const rotate = rotateMix > 0;\n\n        if (!translate && !rotate) return;\n\n        const data = this.data;\n        const spacingMode = data.spacingMode;\n        const lengthSpacing = spacingMode == SpacingMode.Length;\n        const rotateMode = data.rotateMode;\n        const tangents = rotateMode == RotateMode.Tangent;\n        const scale = rotateMode == RotateMode.ChainScale;\n        const boneCount = this.bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const bones = this.bones;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        let lengths: Array<number> = null;\n        const spacing = this.spacing;\n\n        if (scale || lengthSpacing) {\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n            for (let i = 0, n = spacesCount - 1; i < n; ) {\n                const bone = bones[i];\n                const setupLength = bone.data.length;\n\n                if (setupLength < PathConstraint.epsilon) {\n                    if (scale) lengths[i] = 0;\n                    spaces[++i] = 0;\n                } else {\n                    const x = setupLength * bone.matrix.a;\n                    const y = setupLength * bone.matrix.b;\n                    const length = Math.sqrt(x * x + y * y);\n\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                }\n            }\n        } else {\n            for (let i = 1; i < spacesCount; i++) spaces[i] = spacing;\n        }\n\n        const positions = this.computeWorldPositions(\n            <PathAttachment>attachment,\n            spacesCount,\n            tangents,\n            data.positionMode == PositionMode.Percent,\n            spacingMode == SpacingMode.Percent\n        );\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * translateMix;\n            mat.ty += (boneY - mat.ty) * translateMix;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (rotate) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents)\n                    if (tangents) r = positions[p - 1];\n                    else if (spaces[i + 1] == 0) r = positions[p + 2];\n                    else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= rotateMix;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.appliedValid = false;\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean, percentSpacing: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = null;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i];\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n        if (percentPosition) position *= pathLength;\n        if (percentSpacing) {\n            for (let i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i];\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n}\n", "import type { Constraint } from './Constraint';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/**\n * @public\n */\nexport class TransformConstraint implements Constraint {\n    data: TransformConstraintData;\n    bones: Array<Bone>;\n    target: Bone;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    temp = new Vector2();\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (data == null) throw new Error('data cannot be null.');\n        if (skeleton == null) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n        this.target = skeleton.findBone(data.target.name);\n    }\n\n    apply() {\n        this.update();\n    }\n\n    update() {\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * translateMix;\n                mat.ty += (temp.y - mat.ty) * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                let ts = Math.sqrt(ta * ta + tc * tc);\n\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                mat.a *= s;\n                mat.b *= s;\n                s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                ts = Math.sqrt(tb * tb + td * td);\n                if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyRelativeWorld() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            let modified = false;\n            const mat = bone.matrix;\n\n            if (rotateMix != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                r *= rotateMix;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                modified = true;\n            }\n\n            if (translateMix != 0) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * translateMix;\n                mat.ty += temp.y * translateMix;\n                modified = true;\n            }\n\n            if (scaleMix > 0) {\n                let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n                s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                mat.c *= s;\n                mat.d *= s;\n                modified = true;\n            }\n\n            if (shearMix > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n                modified = true;\n            }\n\n            if (modified) bone.appliedValid = false;\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * rotateMix;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax - x + this.data.offsetX) * translateMix;\n                y += (target.ay - y + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n            }\n\n            const shearY = bone.ashearY;\n\n            if (shearMix > 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.shearY += r * shearMix;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const rotateMix = this.rotateMix;\n        const translateMix = this.translateMix;\n        const scaleMix = this.scaleMix;\n        const shearMix = this.shearMix;\n        const target = this.target;\n\n        if (!target.appliedValid) target.updateAppliedTransform();\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n\n            let rotation = bone.arotation;\n\n            if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            if (translateMix != 0) {\n                x += (target.ax + this.data.offsetX) * translateMix;\n                y += (target.ay + this.data.offsetY) * translateMix;\n            }\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (scaleMix > 0) {\n                if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n            }\n\n            let shearY = bone.ashearY;\n\n            if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    getOrder() {\n        return this.data.order;\n    }\n}\n", "import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    data: SkeletonData;\n    bones: Array<Bone>;\n    slots: Array<Slot>;\n    drawOrder: Array<Slot>;\n    ikConstraints: Array<IkConstraint>;\n    transformConstraints: Array<TransformConstraint>;\n    pathConstraints: Array<PathConstraint>;\n    _updateCache = new Array<Updatable>();\n    updateCacheReset = new Array<Updatable>();\n    skin: Skin;\n    color: Color;\n    time = 0;\n    scaleX = 1;\n    scaleY = 1;\n    x = 0;\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (data == null) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (boneData.parent == null) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n        this.updateCacheReset.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].sorted = false;\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n            const child = constrained[constrained.length - 1];\n\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\n        for (let ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (pathBones == null) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n            let i = 0;\n\n            while (i < pathBones.length) {\n                const boneCount = pathBones[i++];\n\n                for (let n = i + boneCount; i < n; i++) {\n                    const boneIndex = pathBones[i];\n\n                    this.sortBone(bones[boneIndex]);\n                }\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies constraints. */\n    updateWorldTransform() {\n        const updateCacheReset = this.updateCacheReset;\n\n        for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n            const bone = updateCacheReset[i] as Bone;\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n            bone.appliedValid = true;\n        }\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.mix = constraint.data.mix;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n        }\n    }\n\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @return May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @return May be null. */\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** @return May be null. */\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @return -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     * @see #setSkin(Skin) */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (skin == null) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin | null) {\n        if (newSkin != null) {\n            if (this.skin != null) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name != null) {\n                        const attachment: Attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    }\n\n    /** @return May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment {\n        if (attachmentName == null) throw new Error('attachmentName cannot be null.');\n        if (this.skin != null) {\n            const attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment != null) return attachment;\n        }\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** @param attachmentName May be null. */\n    setAttachment(slotName: string, attachmentName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment = null;\n\n                if (attachmentName != null) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (attachment == null) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size The width and height of the AABB.\n     * @param temp Working memory */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number>) {\n        if (offset == null) throw new Error('offset cannot be null.');\n        if (size == null) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n            let verticesLength = 0;\n            let vertices: ArrayLike<number> = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices != null) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    update(delta: number) {\n        this.time += delta;\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n", "import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n", "import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/**\n * @public\n */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    name: string;\n    bones = new Array<BoneData>(); // Ordered parents first.\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n    defaultSkin: Skin;\n    events = new Array<EventData>();\n    animations = new Array<Animation>();\n    ikConstraints = new Array<IkConstraintData>();\n    transformConstraints = new Array<TransformConstraintData>();\n    pathConstraints = new Array<PathConstraintData>();\n    width: number;\n    height: number;\n    version: string;\n    hash: string;\n\n    // Nonessential\n    fps = 0;\n    imagesPath: string;\n\n    findBone(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    findBoneIndex(boneName: string) {\n        if (boneName == null) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    findSlot(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    findSlotIndex(slotName: string) {\n        if (slotName == null) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    findSkin(skinName: string) {\n        if (skinName == null) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    findEvent(eventDataName: string) {\n        if (eventDataName == null) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    findAnimation(animationName: string) {\n        if (animationName == null) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    findIkConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findTransformConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraint(constraintName: string) {\n        if (constraintName == null) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n", "import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport type { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class SlotData implements ISlotData {\n    index: number;\n    name: string;\n    boneData: BoneData;\n    color = new Color(1, 1, 1, 1);\n    darkColor: Color;\n    attachmentName: string;\n    blendMode: BLEND_MODES;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (name == null) throw new Error('name cannot be null.');\n        if (boneData == null) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n", "import type { BoneData } from './BoneData';\n\n/**\n * @public\n */\nexport class TransformConstraintData {\n    name: string;\n    order = 0;\n    bones = new Array<BoneData>();\n    target: BoneData;\n    rotateMix = 0;\n    translateMix = 0;\n    scaleMix = 0;\n    shearMix = 0;\n    offsetRotation = 0;\n    offsetX = 0;\n    offsetY = 0;\n    offsetScaleX = 0;\n    offsetScaleY = 0;\n    offsetShearY = 0;\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n}\n", "import type { Attachment } from './attachments';\nimport type { Skeleton } from './Skeleton';\n\nimport type { Map, ISkin } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class Skin implements ISkin {\n    name: string;\n    attachments = new Array<Map<Attachment>>();\n\n    constructor(name: string) {\n        if (name == null) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    addAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (attachment == null) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** @return May be null. */\n    getAttachment(slotIndex: number, name: string): Attachment {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment != null) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n", "import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport {\n    Animation,\n    AttachmentTimeline,\n    ColorTimeline,\n    CurveTimeline,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ShearTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TwoColorTimeline,\n} from './Animation';\nimport { ArrayLike, Color, Utils, PositionMode, RotateMode, TransformMode, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\n\n/**\n * @public\n */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap != null) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = this.getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = this.getValue(boneMap, 'length', 0) * scale;\n                data.x = this.getValue(boneMap, 'x', 0) * scale;\n                data.y = this.getValue(boneMap, 'y', 0) * scale;\n                data.rotation = this.getValue(boneMap, 'rotation', 0);\n                data.scaleX = this.getValue(boneMap, 'scaleX', 1);\n                data.scaleY = this.getValue(boneMap, 'scaleY', 1);\n                data.shearX = this.getValue(boneMap, 'shearX', 0);\n                data.shearY = this.getValue(boneMap, 'shearY', 0);\n                data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, 'transform', 'normal'));\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const slotName: string = slotMap.name;\n                const boneName: string = slotMap.bone;\n                const boneData = skeletonData.findBone(boneName);\n\n                if (boneData == null) throw new Error(`Slot bone not found: ${boneName}`);\n                const data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                const color: string = this.getValue(slotMap, 'color', null);\n\n                if (color != null) data.color.setFromString(color);\n\n                const dark: string = this.getValue(slotMap, 'dark', null);\n\n                if (dark != null) {\n                    data.darkColor = new Color(1, 1, 1, 1);\n                    data.darkColor.setFromString(dark);\n                }\n\n                data.attachmentName = this.getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`IK target bone not found: ${targetName}`);\n\n                data.bendDirection = this.getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.mix = this.getValue(constraintMap, 'mix', 1);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findBone(targetName);\n                if (data.target == null) throw new Error(`Transform constraint target bone not found: ${targetName}`);\n\n                data.local = this.getValue(constraintMap, 'local', false);\n                data.relative = this.getValue(constraintMap, 'relative', false);\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.offsetX = this.getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = this.getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = this.getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = this.getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = this.getValue(constraintMap, 'shearY', 0);\n\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n                data.scaleMix = this.getValue(constraintMap, 'scaleMix', 1);\n                data.shearMix = this.getValue(constraintMap, 'shearMix', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = this.getValue(constraintMap, 'order', 0);\n\n                for (let j = 0; j < constraintMap.bones.length; j++) {\n                    const boneName = constraintMap.bones[j];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`Transform constraint bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n\n                data.target = skeletonData.findSlot(targetName);\n                if (data.target == null) throw new Error(`Path target slot not found: ${targetName}`);\n\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, 'positionMode', 'percent'));\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, 'spacingMode', 'length'));\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, 'rotateMode', 'tangent'));\n                data.offsetRotation = this.getValue(constraintMap, 'rotation', 0);\n                data.position = this.getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = this.getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.rotateMix = this.getValue(constraintMap, 'rotateMix', 1);\n                data.translateMix = this.getValue(constraintMap, 'translateMix', 1);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (const skinName in root.skins) {\n                const skinMap = root.skins[skinName];\n                const skin = new Skin(skinName);\n\n                for (const slotName in skinMap) {\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                    const slotMap = skinMap[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (skin == null) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (parent == null) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // linkedMesh.mesh.updateUVs();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = this.getValue(eventMap, 'int', 0);\n                data.floatValue = this.getValue(eventMap, 'float', 0);\n                data.stringValue = this.getValue(eventMap, 'string', '');\n                data.audioPath = this.getValue(eventMap, 'audio', null);\n                if (data.audioPath != null) {\n                    data.volume = this.getValue(eventMap, 'volume', 1);\n                    data.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n        const scale = this.scale;\n\n        name = this.getValue(map, 'name', name);\n\n        const type = this.getValue(map, 'type', 'region');\n\n        switch (type) {\n            case 'region': {\n                const path = this.getValue(map, 'path', name);\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n\n                if (region == null) return null;\n                region.path = path;\n                region.x = this.getValue(map, 'x', 0) * scale;\n                region.y = this.getValue(map, 'y', 0) * scale;\n                region.scaleX = this.getValue(map, 'scaleX', 1);\n                region.scaleY = this.getValue(map, 'scaleY', 1);\n                region.rotation = this.getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) region.color.setFromString(color);\n\n                // region.updateOffset();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (box == null) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = this.getValue(map, 'path', name);\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n\n                if (mesh == null) return null;\n                mesh.path = path;\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) mesh.color.setFromString(color);\n\n                const parent: string = this.getValue(map, 'parent', null);\n\n                if (parent != null) {\n                    mesh.inheritDeform = this.getValue(map, 'deform', true);\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>this.getValue(map, 'skin', null), slotIndex, parent));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // mesh.updateUVs();\n\n                mesh.hullLength = this.getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (path == null) return null;\n                path.closed = this.getValue(map, 'closed', false);\n                path.constantSpeed = this.getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (point == null) return null;\n                point.x = this.getValue(map, 'x', 0) * scale;\n                point.y = this.getValue(map, 'y', 0) * scale;\n                point.rotation = this.getValue(map, 'rotation', 0);\n\n                const color = this.getValue(map, 'color', null);\n\n                if (color != null) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (clip == null) return null;\n\n                const end = this.getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = this.getValue(map, 'color', null);\n\n                if (color != null) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n        let duration = 0;\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                if (slotIndex == -1) throw new Error(`Slot not found: ${slotName}`);\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    } else if (timelineName == 'color') {\n                        const timeline = new ColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const color = new Color();\n\n                            color.setFromString(valueMap.color || 'ffffffff');\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n                    } else if (timelineName == 'twoColor') {\n                        const timeline = new TwoColorTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const light = new Color();\n                            const dark = new Color();\n\n                            light.setFromString(valueMap.light);\n                            dark.setFromString(valueMap.dark);\n                            timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const boneIndex = skeletonData.findBoneIndex(boneName);\n\n                if (boneIndex == -1) throw new Error(`Bone not found: ${boneName}`);\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n\n                    if (timelineName === 'rotate') {\n                        const timeline = new RotateTimeline(timelineMap.length);\n\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n                    } else if (timelineName === 'translate' || timelineName === 'scale' || timelineName === 'shear') {\n                        let timeline: TranslateTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'scale') timeline = new ScaleTimeline(timelineMap.length);\n                        else if (timelineName === 'shear') timeline = new ShearTimeline(timelineMap.length);\n                        else {\n                            timeline = new TranslateTimeline(timelineMap.length);\n                            timelineScale = scale;\n                        }\n                        timeline.boneIndex = boneIndex;\n\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n                            const x = this.getValue(valueMap, 'x', 0);\n                            const y = this.getValue(valueMap, 'y', 0);\n\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n                    } else throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                const constraint = skeletonData.findIkConstraint(constraintName);\n                const timeline = new IkConstraintTimeline(constraintMap.length);\n\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        valueMap.time,\n                        this.getValue(valueMap, 'mix', 1),\n                        this.getValue(valueMap, 'bendPositive', true) ? 1 : -1,\n                        this.getValue(valueMap, 'compress', false),\n                        this.getValue(valueMap, 'stretch', false)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const constraintMap = map.transform[constraintName];\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n                const timeline = new TransformConstraintTimeline(constraintMap.length);\n\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                let frameIndex = 0;\n\n                for (let i = 0; i < constraintMap.length; i++) {\n                    const valueMap = constraintMap[i];\n\n                    timeline.setFrame(\n                        frameIndex,\n                        valueMap.time,\n                        this.getValue(valueMap, 'rotateMix', 1),\n                        this.getValue(valueMap, 'translateMix', 1),\n                        this.getValue(valueMap, 'scaleMix', 1),\n                        this.getValue(valueMap, 'shearMix', 1)\n                    );\n                    this.readCurve(valueMap, timeline, frameIndex);\n                    frameIndex++;\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.paths) {\n            for (const constraintName in map.paths) {\n                const constraintMap = map.paths[constraintName];\n                const index = skeletonData.findPathConstraintIndex(constraintName);\n\n                if (index == -1) throw new Error(`Path constraint not found: ${constraintName}`);\n                const data = skeletonData.pathConstraints[index];\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n\n                    if (timelineName === 'position' || timelineName === 'spacing') {\n                        let timeline: PathConstraintPositionTimeline = null;\n                        let timelineScale = 1;\n\n                        if (timelineName === 'spacing') {\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                        } else {\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                        }\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(timelineMap.length);\n\n                        timeline.pathConstraintIndex = index;\n                        let frameIndex = 0;\n\n                        for (let i = 0; i < timelineMap.length; i++) {\n                            const valueMap = timelineMap[i];\n\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, 'rotateMix', 1), this.getValue(valueMap, 'translateMix', 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                    }\n                }\n            }\n        }\n\n        // Deform timelines.\n        if (map.deform) {\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const skin = skeletonData.findSkin(deformName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${deformName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const slotIndex = skeletonData.findSlotIndex(slotName);\n\n                    if (slotIndex == -1) throw new Error(`Slot not found: ${slotMap.name}`);\n                    for (const timelineName in slotMap) {\n                        const timelineMap = slotMap[timelineName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n\n                        if (attachment == null) throw new Error(`Deform attachment not found: ${timelineMap.name}`);\n                        const weighted = attachment.bones != null;\n                        const vertices = attachment.vertices;\n                        const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                        const timeline = new DeformTimeline(timelineMap.length);\n\n                        timeline.slotIndex = slotIndex;\n                        timeline.attachment = attachment;\n\n                        let frameIndex = 0;\n\n                        for (let j = 0; j < timelineMap.length; j++) {\n                            const valueMap = timelineMap[j];\n                            let deform: ArrayLike<number>;\n                            const verticesValue: Array<number> = this.getValue(valueMap, 'vertices', null);\n\n                            if (verticesValue == null) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                            else {\n                                deform = Utils.newFloatArray(deformLength);\n                                const start = <number>this.getValue(valueMap, 'offset', 0);\n\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                if (scale != 1) {\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                }\n                                if (!weighted) {\n                                    for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                }\n                            }\n\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        let drawOrderNode = map.drawOrder;\n\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n        if (drawOrderNode != null) {\n            const timeline = new DrawOrderTimeline(drawOrderNode.length);\n            const slotCount = skeletonData.slots.length;\n            let frameIndex = 0;\n\n            for (let j = 0; j < drawOrderNode.length; j++) {\n                const drawOrderMap = drawOrderNode[j];\n                let drawOrder: Array<number> = null;\n                const offsets = this.getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets != null) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let i = 0; i < offsets.length; i++) {\n                        const offsetMap = offsets[i];\n                        const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n\n                        if (slotIndex == -1) throw new Error(`Slot not found: ${offsetMap.slot}`);\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        // Event timeline.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frameIndex = 0;\n\n            for (let i = 0; i < map.events.length; i++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (eventData == null) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\n\n                event.intValue = this.getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = this.getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = this.getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath != null) {\n                    event.volume = this.getValue(eventMap, 'volume', 1);\n                    event.balance = this.getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frameIndex++, event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n\n    readCurve(map: any, timeline: CurveTimeline, frameIndex: number) {\n        if (!map.curve) return;\n        if (map.curve === 'stepped') timeline.setStepped(frameIndex);\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n            const curve: Array<number> = map.curve;\n\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n    }\n\n    getValue(map: any, prop: string, defaultValue: any) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n    }\n\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n\n    static positionModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'fixed') return PositionMode.Fixed;\n        if (str == 'percent') return PositionMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static spacingModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'length') return SpacingMode.Length;\n        if (str == 'fixed') return SpacingMode.Fixed;\n        if (str == 'percent') return SpacingMode.Percent;\n        throw new Error(`Unknown position mode: ${str}`);\n    }\n\n    static rotateModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'tangent') return RotateMode.Tangent;\n        if (str == 'chain') return RotateMode.Chain;\n        if (str == 'chainscale') return RotateMode.ChainScale;\n        throw new Error(`Unknown rotate mode: ${str}`);\n    }\n\n    static transformModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return TransformMode.Normal;\n        if (str == 'onlytranslation') return TransformMode.OnlyTranslation;\n        if (str == 'norotationorreflection') return TransformMode.NoRotationOrReflection;\n        if (str == 'noscale') return TransformMode.NoScale;\n        if (str == 'noscaleorreflection') return TransformMode.NoScaleOrReflection;\n        throw new Error(`Unknown transform mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n    }\n}\n", "import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n", "export { Attachment, VertexAttachment } from './core/attachments/Attachment.mjs';\nexport { BoundingBoxAttachment } from './core/attachments/BoundingBoxAttachment.mjs';\nexport { ClippingAttachment } from './core/attachments/ClippingAttachment.mjs';\nexport { MeshAttachment } from './core/attachments/MeshAttachment.mjs';\nexport { PathAttachment } from './core/attachments/PathAttachment.mjs';\nexport { PointAttachment } from './core/attachments/PointAttachment.mjs';\nexport { RegionAttachment } from './core/attachments/RegionAttachment.mjs';\nexport { Sequence, SequenceMode, SequenceModeValues } from './core/attachments/Sequence.mjs';\nexport { AlphaTimeline, Animation, AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline, RotateTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, SequenceTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, Timeline, TransformConstraintTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline } from './core/Animation.mjs';\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry } from './core/AnimationState.mjs';\nexport { AnimationStateData } from './core/AnimationStateData.mjs';\nexport { AtlasAttachmentLoader } from './core/AtlasAttachmentLoader.mjs';\nexport { Bone } from './core/Bone.mjs';\nexport { BoneData } from './core/BoneData.mjs';\nexport { ConstraintData } from './core/ConstraintData.mjs';\nexport { Event } from './core/Event.mjs';\nexport { EventData } from './core/EventData.mjs';\nexport { IkConstraint } from './core/IkConstraint.mjs';\nexport { IkConstraintData } from './core/IkConstraintData.mjs';\nexport { PathConstraint } from './core/PathConstraint.mjs';\nexport { PathConstraintData, SpacingMode } from './core/PathConstraintData.mjs';\nexport { Skeleton } from './core/Skeleton.mjs';\nexport { SkeletonBinary } from './core/SkeletonBinary.mjs';\nexport { SkeletonBounds } from './core/SkeletonBounds.mjs';\nexport { SkeletonData } from './core/SkeletonData.mjs';\nexport { SkeletonJson } from './core/SkeletonJson.mjs';\nexport { Skin, SkinEntry } from './core/Skin.mjs';\nexport { Slot } from './core/Slot.mjs';\nexport { SlotData } from './core/SlotData.mjs';\nexport { TransformConstraint } from './core/TransformConstraint.mjs';\nexport { TransformConstraintData } from './core/TransformConstraintData.mjs';\nexport { Spine } from './Spine.mjs';\n//# sourceMappingURL=index.mjs.map\n", "import { AttachmentType, Utils } from '@pixi-spine/base';\nimport type { IAttachment, NumberArrayLike } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * The base class for all attachments.\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    abstract copy(): Attachment;\n}\n\n/**\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}.\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    /** The unique ID for this attachment. */\n    id = VertexAttachment.nextID++;\n\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    bones: Array<number> | null = null;\n\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    vertices: NumberArrayLike = [];\n\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    worldVerticesLength = 0;\n\n    /** Timelines for the timeline attachment are also applied to this attachment.\n     * May be null if no attachment-specific timelines should be applied. */\n    timelineAttachment: Attachment = this;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n     * not empty, it is used to deform the vertices.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide.\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n     *           `stride` / 2.\n     * @param offset The `worldVertices` index to begin writing values.\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.deform;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (!bones) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Does not copy id (generated) or name (set on construction). **/\n    copyTo(attachment: VertexAttachment) {\n        if (this.bones) {\n            attachment.bones = new Array<number>(this.bones.length);\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n        } else attachment.bones = null;\n\n        if (this.vertices) {\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n        }\n\n        attachment.worldVerticesLength = this.worldVerticesLength;\n        attachment.timelineAttachment = this.timelineAttachment;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class BoundingBoxAttachment extends VertexAttachment {\n    type = AttachmentType.BoundingBox;\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new BoundingBoxAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IClippingAttachment } from '@pixi-spine/base';\nimport type { SlotData } from '../SlotData';\n\n/**\n * @public\n */\nexport class ClippingAttachment extends VertexAttachment implements IClippingAttachment {\n    type = AttachmentType.Clipping;\n    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of\n     * the skeleton's rendering. */\n    endSlot: SlotData | null = null;\n\n    // Nonessential.\n    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons\n     * are not usually rendered at runtime. */\n    color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new ClippingAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.endSlot = this.endSlot;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, IHasTextureRegion, NumberArrayLike, TextureRegion, Utils } from '@pixi-spine/base';\nimport type { Sequence } from './Sequence';\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion | null = null;\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    /** The UV pair for each vertex, normalized within the texture region. */\n    regionUVs: Float32Array;\n\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    triangles: Array<number> = [];\n\n    /** The color to tint the mesh. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    width = 0;\n\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    height = 0;\n\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    hullLength = 0;\n\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    edges: Array<number> = [];\n\n    private parentMesh: MeshAttachment | null = null;\n\n    sequence: Sequence | null = null;\n\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string, path: string) {\n        super(name);\n        this.path = path;\n    }\n\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n        // Nonessential.\n        if (this.edges) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        if (this.sequence != null) this.sequence.apply(slot, this);\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n    }\n\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n        copy.timelineAttachment = this.timelineAttachment;\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n        // if (copy.region != null) copy.updateRegion();\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\n\n/**\n * @public\n */\nexport class PathAttachment extends VertexAttachment {\n    type = AttachmentType.Path;\n\n    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */\n    lengths: Array<number> = [];\n\n    /** If true, the start and end knots are connected. */\n    closed = false;\n\n    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer\n     * calculations are performed but calculating positions along the path is less accurate. */\n    constantSpeed = false;\n\n    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually\n     * rendered at runtime. */\n    color = new Color(1, 1, 1, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    copy(): Attachment {\n        const copy = new PathAttachment(this.name);\n\n        this.copyTo(copy);\n        copy.lengths = new Array<number>(this.lengths.length);\n        Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\n        copy.closed = closed;\n        copy.constantSpeed = this.constantSpeed;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Bone } from '../Bone';\n\n/**\n * @public\n */\nexport class PointAttachment extends VertexAttachment {\n    type = AttachmentType.Point;\n\n    x = 0;\n    y = 0;\n    rotation = 0;\n\n    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments\n     * are not usually rendered at runtime. */\n    color = new Color(0.38, 0.94, 0, 1);\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldPosition(bone: Bone, point: Vector2) {\n        const mat = bone.matrix;\n\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n\n        return point;\n    }\n\n    computeWorldRotation(bone: Bone) {\n        const mat = bone.matrix;\n        const cos = MathUtils.cosDeg(this.rotation);\n        const sin = MathUtils.sinDeg(this.rotation);\n        const x = cos * mat.a + sin * mat.c;\n        const y = cos * mat.b + sin * mat.d;\n\n        return Math.atan2(y, x) * MathUtils.radDeg;\n    }\n\n    copy(): Attachment {\n        const copy = new PointAttachment(this.name);\n\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.rotation = this.rotation;\n        copy.color.setFromColor(this.color);\n\n        return copy;\n    }\n}\n", "import { Attachment } from './Attachment';\nimport { AttachmentType, NumberArrayLike, Color, TextureRegion, Utils, IHasTextureRegion, IRegionAttachment } from '@pixi-spine/base';\nimport type { Sequence } from './Sequence';\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class RegionAttachment extends Attachment implements IRegionAttachment, IHasTextureRegion {\n    type = AttachmentType.Region;\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local scaleX. */\n    scaleX = 1;\n\n    /** The local scaleY. */\n    scaleY = 1;\n\n    /** The local rotation. */\n    rotation = 0;\n\n    /** The width of the region attachment in Spine. */\n    width = 0;\n\n    /** The height of the region attachment in Spine. */\n    height = 0;\n\n    /** The color to tint the region attachment. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    private rendererObject: any = null;\n    region: TextureRegion | null = null;\n    sequence: Sequence | null = null;\n\n    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.\n     *\n     * See {@link #updateOffset()}. */\n    offset = Utils.newFloatArray(8);\n\n    uvs = Utils.newFloatArray(8);\n\n    tempColor = new Color(1, 1, 1, 1);\n\n    constructor(name: string, path: string) {\n        super(name);\n        this.path = path;\n    }\n\n    /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */\n    updateRegion(): void {\n        if (!this.region) throw new Error('Region not set.');\n        const region = this.region;\n        const regionScaleX = (this.width / this.region.originalWidth) * this.scaleX;\n        const regionScaleY = (this.height / this.region.originalHeight) * this.scaleY;\n        const localX = (-this.width / 2) * this.scaleX + this.region.offsetX * regionScaleX;\n        const localY = (-this.height / 2) * this.scaleY + this.region.offsetY * regionScaleY;\n        const localX2 = localX + this.region.width * regionScaleX;\n        const localY2 = localY + this.region.height * regionScaleY;\n        const radians = (this.rotation * Math.PI) / 180;\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const x = this.x;\n        const y = this.y;\n        const localXCos = localX * cos + x;\n        const localXSin = localX * sin;\n        const localYCos = localY * cos + y;\n        const localYSin = localY * sin;\n        const localX2Cos = localX2 * cos + x;\n        const localX2Sin = localX2 * sin;\n        const localY2Cos = localY2 * cos + y;\n        const localY2Sin = localY2 * sin;\n        const offset = this.offset;\n\n        offset[0] = localXCos - localYSin;\n        offset[1] = localYCos + localXSin;\n        offset[2] = localXCos - localY2Sin;\n        offset[3] = localY2Cos + localXSin;\n        offset[4] = localX2Cos - localY2Sin;\n        offset[5] = localY2Cos + localX2Sin;\n        offset[6] = localX2Cos - localYSin;\n        offset[7] = localYCos + localX2Sin;\n\n        const uvs = this.uvs;\n\n        if (region.degrees == 90) {\n            uvs[2] = region.u;\n            uvs[3] = region.v2;\n            uvs[4] = region.u;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v;\n            uvs[0] = region.u2;\n            uvs[1] = region.v2;\n        } else {\n            uvs[0] = region.u;\n            uvs[1] = region.v2;\n            uvs[2] = region.u;\n            uvs[3] = region.v;\n            uvs[4] = region.u2;\n            uvs[5] = region.v;\n            uvs[6] = region.u2;\n            uvs[7] = region.v2;\n        }\n    }\n\n    /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may\n     * be changed.\n     * <p>\n     * See <a href=\"http://esotericsoftware.com/spine-runtime-skeletons#World-transforms\">World transforms</a> in the Spine\n     * Runtimes Guide.\n     * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.\n     * @param offset The <code>worldVertices</code> index to begin writing values.\n     * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */\n    computeWorldVertices(slot: Slot, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        if (this.sequence != null) this.sequence.apply(slot, this);\n\n        const bone = slot.bone;\n        const vertexOffset = this.offset;\n        const mat = bone.matrix;\n        const x = mat.tx;\n        const y = mat.ty;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        offsetX = vertexOffset[0];\n        offsetY = vertexOffset[1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[2];\n        offsetY = vertexOffset[3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[4];\n        offsetY = vertexOffset[5];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n\n        offsetX = vertexOffset[6];\n        offsetY = vertexOffset[7];\n        worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n    }\n\n    copy(): Attachment {\n        const copy = new RegionAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.rendererObject = this.rendererObject;\n        copy.x = this.x;\n        copy.y = this.y;\n        copy.scaleX = this.scaleX;\n        copy.scaleY = this.scaleY;\n        copy.rotation = this.rotation;\n        copy.width = this.width;\n        copy.height = this.height;\n        Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n        Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n        copy.color.setFromColor(this.color);\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n        return copy;\n    }\n\n    static X1 = 0;\n    static Y1 = 1;\n    static C1R = 2;\n    static C1G = 3;\n    static C1B = 4;\n    static C1A = 5;\n    static U1 = 6;\n    static V1 = 7;\n\n    static X2 = 8;\n    static Y2 = 9;\n    static C2R = 10;\n    static C2G = 11;\n    static C2B = 12;\n    static C2A = 13;\n    static U2 = 14;\n    static V2 = 15;\n\n    static X3 = 16;\n    static Y3 = 17;\n    static C3R = 18;\n    static C3G = 19;\n    static C3B = 20;\n    static C3A = 21;\n    static U3 = 22;\n    static V3 = 23;\n\n    static X4 = 24;\n    static Y4 = 25;\n    static C4R = 26;\n    static C4G = 27;\n    static C4B = 28;\n    static C4A = 29;\n    static U4 = 30;\n    static V4 = 31;\n}\n", "import { Utils, TextureRegion, IHasTextureRegion, ISequence } from '@pixi-spine/base';\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class Sequence implements ISequence {\n    private static _nextID = 0;\n\n    id = Sequence.nextID();\n    regions: TextureRegion[];\n    start = 0;\n    digits = 0;\n    /** The index of the region to show for the setup pose. */\n    setupIndex = 0;\n\n    constructor(count: number) {\n        this.regions = new Array<TextureRegion>(count);\n    }\n\n    copy(): Sequence {\n        const copy = new Sequence(this.regions.length);\n\n        Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);\n        copy.start = this.start;\n        copy.digits = this.digits;\n        copy.setupIndex = this.setupIndex;\n\n        return copy;\n    }\n\n    apply(slot: Slot, attachment: IHasTextureRegion) {\n        let index = slot.sequenceIndex;\n\n        if (index == -1) index = this.setupIndex;\n        if (index >= this.regions.length) index = this.regions.length - 1;\n        const region = this.regions[index];\n\n        if (attachment.region != region) {\n            attachment.region = region;\n            // attachment.updateRegion();\n        }\n    }\n\n    getPath(basePath: string, index: number): string {\n        let result = basePath;\n        const frame = (this.start + index).toString();\n\n        for (let i = this.digits - frame.length; i > 0; i--) result += '0';\n        result += frame;\n\n        return result;\n    }\n\n    private static nextID(): number {\n        return Sequence._nextID++;\n    }\n}\n\n/**\n * @public\n */\nexport enum SequenceMode {\n    hold = 0,\n    once = 1,\n    loop = 2,\n    pingpong = 3,\n    onceReverse = 4,\n    loopReverse = 5,\n    pingpongReverse = 6,\n}\n\n/**\n * @public\n */\nexport const SequenceModeValues = [\n    SequenceMode.hold,\n    SequenceMode.once,\n    SequenceMode.loop,\n    SequenceMode.pingpong,\n    SequenceMode.onceReverse,\n    SequenceMode.loopReverse,\n    SequenceMode.pingpongReverse,\n];\n", "import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { NumberArrayLike, IAnimation, ITimeline, MathUtils, MixBlend, StringSet, Utils, MixDirection, IHasTextureRegion } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\nimport { SequenceMode, SequenceModeValues } from './attachments/Sequence';\n\n/**\n * A simple container for a list of timelines and a name.\n * @public\n * */\nexport class Animation implements IAnimation<Timeline> {\n    /** The animation's name, which is unique across all animations in the skeleton. */\n    name: string;\n    timelines: Array<Timeline> = [];\n    timelineIds: StringSet = new StringSet();\n\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n        this.setTimelines(timelines);\n        this.duration = duration;\n    }\n\n    setTimelines(timelines: Array<Timeline>) {\n        if (!timelines) throw new Error('timelines cannot be null.');\n        this.timelines = timelines;\n        this.timelineIds.clear();\n        for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n    }\n\n    hasTimeline(ids: string[]): boolean {\n        for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n\n        return false;\n    }\n\n    /** Applies all the animation's timelines to the specified skeleton.\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\n     * @param events May be null to ignore fired events. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n}\n\nconst Property = {\n    rotate: 0,\n    x: 1,\n    y: 2,\n    scaleX: 3,\n    scaleY: 4,\n    shearX: 5,\n    shearY: 6,\n\n    rgb: 7,\n    alpha: 8,\n    rgb2: 9,\n\n    attachment: 10,\n    deform: 11,\n\n    event: 12,\n    drawOrder: 13,\n\n    ikConstraint: 14,\n    transformConstraint: 15,\n\n    pathConstraintPosition: 16,\n    pathConstraintSpacing: 17,\n    pathConstraintMix: 18,\n\n    sequence: 19,\n};\n\n/** The interface for all timelines.\n * @public\n * */\nexport abstract class Timeline implements ITimeline {\n    propertyIds: string[];\n    frames: NumberArrayLike;\n\n    constructor(frameCount: number, propertyIds: string[]) {\n        this.propertyIds = propertyIds;\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n    }\n\n    getPropertyIds() {\n        return this.propertyIds;\n    }\n\n    getFrameEntries(): number {\n        return 1;\n    }\n\n    getFrameCount() {\n        return this.frames.length / this.getFrameEntries();\n    }\n\n    getDuration(): number {\n        return this.frames[this.frames.length - this.getFrameEntries()];\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n    static search1(frames: NumberArrayLike, time: number) {\n        const n = frames.length;\n\n        for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n\n        return n - 1;\n    }\n\n    static search(frames: NumberArrayLike, time: number, step: number) {\n        const n = frames.length;\n\n        for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n\n        return n - step;\n    }\n}\n\n/**\n * @public\n */\nexport interface BoneTimeline {\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n    boneIndex: number;\n}\n\n/**\n * @public\n */\nexport interface SlotTimeline {\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n    slotIndex: number;\n}\n\n/** The base class for timelines that use interpolation between key frame values.\n * @public\n * */\nexport abstract class CurveTimeline extends Timeline {\n    protected curves: NumberArrayLike; // type, x, y, ...\n\n    constructor(frameCount: number, bezierCount: number, propertyIds: string[]) {\n        super(frameCount, propertyIds);\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18 /* BEZIER_SIZE*/);\n        this.curves[frameCount - 1] = 1 /* STEPPED*/;\n    }\n\n    /** Sets the specified key frame to linear interpolation. */\n    setLinear(frame: number) {\n        this.curves[frame] = 0 /* LINEAR*/;\n    }\n\n    /** Sets the specified key frame to stepped interpolation. */\n    setStepped(frame: number) {\n        this.curves[frame] = 1 /* STEPPED*/;\n    }\n\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n     * than the actual number of Bezier curves. */\n    shrink(bezierCount: number) {\n        const size = this.getFrameCount() + bezierCount * 18; /* BEZIER_SIZE*/\n\n        if (this.curves.length > size) {\n            const newCurves = Utils.newFloatArray(size);\n\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n            this.curves = newCurves;\n        }\n    }\n\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n     * one curve per frame.\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n     *           in the constructor), inclusive.\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n     * @param value The index of the value for this frame that this curve is used for.\n     * @param time1 The time for the first key.\n     * @param value1 The value for the first key.\n     * @param cx1 The time for the first Bezier handle.\n     * @param cy1 The value for the first Bezier handle.\n     * @param cx2 The time of the second Bezier handle.\n     * @param cy2 The value for the second Bezier handle.\n     * @param time2 The time for the second key.\n     * @param value2 The value for the second key. */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = value1 + dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    /** Returns the Bezier interpolated value for the specified time.\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n    getBezierValue(time: number, frameIndex: number, valueOffset: number, i: number) {\n        const curves = this.curves;\n\n        if (curves[i] > time) {\n            const x = this.frames[frameIndex];\n            const y = this.frames[frameIndex + valueOffset];\n\n            return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        frameIndex += this.getFrameEntries();\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((time - x) / (this.frames[frameIndex] - x)) * (this.frames[frameIndex + valueOffset] - y);\n    }\n}\n/**\n * @public\n */\nexport abstract class CurveTimeline1 extends CurveTimeline {\n    constructor(frameCount: number, bezierCount: number, propertyId: string) {\n        super(frameCount, bezierCount, [propertyId]);\n    }\n\n    getFrameEntries() {\n        return 2 /* ENTRIES*/;\n    }\n\n    /** Sets the time and value for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value: number) {\n        frame <<= 1;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE*/] = value;\n    }\n\n    /** Returns the interpolated value for the specified time. */\n    getCurveValue(time: number) {\n        const frames = this.frames;\n        let i = frames.length - 2;\n\n        for (let ii = 2; ii <= i; ii += 2) {\n            if (frames[ii] > time) {\n                i = ii - 2;\n                break;\n            }\n        }\n\n        const curveType = this.curves[i >> 1];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n                const value = frames[i + 1 /* VALUE*/];\n\n                return value + ((time - before) / (frames[i + 2 /* ENTRIES*/] - before)) * (frames[i + 2 /* ENTRIES*/ + 1 /* VALUE*/] - value);\n            case 1 /* STEPPED*/:\n                return frames[i + 1 /* VALUE*/];\n        }\n\n        return this.getBezierValue(time, i, 1 /* VALUE*/, curveType - 2 /* BEZIER*/);\n    }\n}\n\n/** The base class for a {@link CurveTimeline} which sets two properties.\n * @public\n * */\nexport abstract class CurveTimeline2 extends CurveTimeline {\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n    constructor(frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\n        super(frameCount, bezierCount, [propertyId1, propertyId2]);\n    }\n\n    getFrameEntries() {\n        return 3 /* ENTRIES*/;\n    }\n\n    /** Sets the time and values for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value1: number, value2: number) {\n        frame *= 3 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE1*/] = value1;\n        this.frames[frame + 2 /* VALUE2*/] = value2;\n    }\n}\n\n/** Changes a bone's local {@link Bone#rotation}.\n * @public\n * */\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n            }\n\n            return;\n        }\n\n        let r = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + r * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += r * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\n * @public\n * */\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n        x *= bone.data.scaleX;\n        y *= bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time) * bone.data.scaleX;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;\n            else bone.scaleX = x;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let bx = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time) * bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;\n            else bone.scaleY = y;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = bone.data.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = bone.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 5 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number) {\n        frame *= 5 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.setFromColor(setup);\n\n                    return;\n                case MixBlend.first:\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        const i = Timeline.search(frames, time, 5 /* ENTRIES*/);\n        const curveType = this.curves[i / 5 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                const t = (time - before) / (frames[i + 5 /* ENTRIES*/] - before);\n\n                r += (frames[i + 5 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 5 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 5 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 5 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) color.set(r, g, b, a);\n        else {\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number) {\n        frame <<= 2;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.r = setup.r;\n                    color.g = setup.g;\n                    color.b = setup.b;\n\n                    return;\n                case MixBlend.first:\n                    color.r += (setup.r - color.r) * alpha;\n                    color.g += (setup.g - color.g) * alpha;\n                    color.b += (setup.b - color.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                r += (frames[i + 4 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 4 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 4 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) {\n            color.r = r;\n            color.g = g;\n            color.b = b;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setup = slot.data.color;\n\n                color.r = setup.r;\n                color.g = setup.g;\n                color.b = setup.b;\n            }\n            color.r += (r - color.r) * alpha;\n            color.g += (g - color.g) * alpha;\n            color.b += (b - color.b) * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\n        this.slotIndex = slotIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const color = slot.color;\n\n        if (time < this.frames[0]) {\n            // Time is before first frame.\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.a = setup.a;\n\n                    return;\n                case MixBlend.first:\n                    color.a += (setup.a - color.a) * alpha;\n            }\n\n            return;\n        }\n\n        const a = this.getCurveValue(time);\n\n        if (alpha == 1) color.a = a;\n        else {\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\n            color.a += (a - color.a) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 8 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frame <<= 3;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n        this.frames[frame + 5 /* R2*/] = r2;\n        this.frames[frame + 6 /* G2*/] = g2;\n        this.frames[frame + 7 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.setFromColor(setupLight);\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 8 /* ENTRIES*/);\n        const curveType = this.curves[i >> 3];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                const t = (time - before) / (frames[i + 8 /* ENTRIES*/] - before);\n\n                r += (frames[i + 8 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 8 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 8 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 8 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                r2 += (frames[i + 8 /* ENTRIES*/ + 5 /* R2*/] - r2) * t;\n                g2 += (frames[i + 8 /* ENTRIES*/ + 6 /* G2*/] - g2) * t;\n                b2 += (frames[i + 8 /* ENTRIES*/ + 7 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 5 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 6 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 7 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 6 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.set(r, g, b, a);\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                const setupDark = slot.data.darkColor;\n\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\n        frame *= 7 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* R2*/] = r2;\n        this.frames[frame + 5 /* G2*/] = g2;\n        this.frames[frame + 6 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.r = setupLight.r;\n                    light.g = setupLight.g;\n                    light.b = setupLight.b;\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.r += (setupLight.r - light.r) * alpha;\n                    light.g += (setupLight.g - light.g) * alpha;\n                    light.b += (setupLight.b - light.b) * alpha;\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                r += (frames[i + 7 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 7 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 7 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                r2 += (frames[i + 7 /* ENTRIES*/ + 4 /* R2*/] - r2) * t;\n                g2 += (frames[i + 7 /* ENTRIES*/ + 5 /* G2*/] - g2) * t;\n                b2 += (frames[i + 7 /* ENTRIES*/ + 6 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 4 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 5 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 6 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.r = r;\n            light.g = g;\n            light.b = b;\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setupLight = slot.data.color;\n                const setupDark = slot.data.darkColor;\n\n                light.r = setupLight.r;\n                light.g = setupLight.g;\n                light.b = setupLight.b;\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.r += (r - light.r) * alpha;\n            light.g += (g - light.g) * alpha;\n            light.b += (b - light.b) * alpha;\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#attachment}.\n * @public\n * */\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\n    attachmentNames: Array<string | null>;\n\n    constructor(frameCount: number, slotIndex: number) {\n        super(frameCount, [`${Property.attachment}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\n    setFrame(frame: number, time: number, attachmentName: string | null) {\n        this.frames[frame] = time;\n        this.attachmentNames[frame] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\n * @public\n * */\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment that will be deformed. */\n    attachment: VertexAttachment;\n\n    /** The vertices for each key frame. */\n    vertices: Array<NumberArrayLike>;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\n        super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\n        this.slotIndex = slotIndex;\n        this.attachment = attachment;\n        this.vertices = new Array<NumberArrayLike>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the vertices for the specified key frame.\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n    setFrame(frame: number, time: number, vertices: NumberArrayLike) {\n        this.frames[frame] = time;\n        this.vertices[frame] = vertices;\n    }\n\n    /** @param value1 Ignored (0 is used for a deform timeline).\n     * @param value2 Ignored (1 is used for a deform timeline). */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = cy2 * 0.03 - cy1 * 0.06;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    getCurvePercent(time: number, frame: number) {\n        const curves = this.curves;\n        let i = curves[frame];\n\n        switch (i) {\n            case 0 /* LINEAR*/:\n                const x = this.frames[frame];\n\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n            case 1 /* STEPPED*/:\n                return 0;\n        }\n        i -= 2 /* BEZIER*/;\n        if (curves[i] > time) {\n            const x = this.frames[frame];\n\n            return (curves[i + 1] * (time - x)) / (curves[i] - x);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((1 - y) * (time - x)) / (this.frames[frame + this.getFrameEntries()] - x);\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment: Attachment | null = slot.getAttachment();\n\n        if (!slotAttachment) return;\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment) return;\n\n        const deform: Array<number> = slot.deform;\n\n        if (deform.length == 0) blend = MixBlend.setup;\n\n        const vertices = this.vertices;\n        const vertexCount = vertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    deform.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        deform.length = 0;\n\n                        return;\n                    }\n                    deform.length = vertexCount;\n                    const vertexAttachment = <VertexAttachment>slotAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        deform.length = vertexCount;\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = vertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n                    }\n                } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n                        break;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Timeline.search1(frames, time);\n        const percent = this.getCurvePercent(time, frame);\n        const prevVertices = vertices[frame];\n        const nextVertices = vertices[frame + 1];\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (!vertexAttachment.bones) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/** Fires an {@link Event} when specific animation times are reached.\n * @public\n * */\nexport class EventTimeline extends Timeline {\n    static propertyIds = [`${Property.event}`];\n\n    /** The event for each key frame. */\n    events: Array<Event>;\n\n    constructor(frameCount: number) {\n        super(frameCount, EventTimeline.propertyIds);\n\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the event for the specified key frame. */\n    setFrame(frame: number, event: Event) {\n        this.frames[frame] = event.time;\n        this.events[frame] = event;\n    }\n\n    /** Fires events for frames > `lastTime` and <= `time`. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!firedEvents) return;\n\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let i = 0;\n\n        if (lastTime < frames[0]) i = 0;\n        else {\n            i = Timeline.search1(frames, lastTime) + 1;\n            const frameTime = frames[i];\n\n            while (i > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[i - 1] != frameTime) break;\n                i--;\n            }\n        }\n        for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n    }\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\n * @public\n * */\nexport class DrawOrderTimeline extends Timeline {\n    static propertyIds = [`${Property.drawOrder}`];\n\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n    drawOrders: Array<Array<number> | null>;\n\n    constructor(frameCount: number) {\n        super(frameCount, DrawOrderTimeline.propertyIds);\n        this.drawOrders = new Array<Array<number> | null>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the draw order for the specified key frame.\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n     *           draw order. */\n    setFrame(frame: number, time: number, drawOrder: Array<number> | null) {\n        this.frames[frame] = time;\n        this.drawOrders[frame] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const idx = Timeline.search1(this.frames, time);\n        const drawOrderToSetupIndex = this.drawOrders[idx];\n\n        if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n        else {\n            const drawOrder: Array<Slot> = skeleton.drawOrder;\n            const slots: Array<Slot> = skeleton.slots;\n\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\n * @public\n * */\nexport class IkConstraintTimeline extends CurveTimeline {\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    ikConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, ikConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\n        this.ikConstraintIndex = ikConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 6 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n    setFrame(frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frame *= 6 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* MIX*/] = mix;\n        this.frames[frame + 2 /* SOFTNESS*/] = softness;\n        this.frames[frame + 3 /* BEND_DIRECTION*/] = bendDirection;\n        this.frames[frame + 4 /* COMPRESS*/] = compress ? 1 : 0;\n        this.frames[frame + 5 /* STRETCH*/] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.softness = constraint.data.softness;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        let mix = 0;\n        let softness = 0;\n        const i = Timeline.search(frames, time, 6 /* ENTRIES*/);\n        const curveType = this.curves[i / 6 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                const t = (time - before) / (frames[i + 6 /* ENTRIES*/] - before);\n\n                mix += (frames[i + 6 /* ENTRIES*/ + 1 /* MIX*/] - mix) * t;\n                softness += (frames[i + 6 /* ENTRIES*/ + 2 /* SOFTNESS*/] - softness) * t;\n                break;\n            case 1 /* STEPPED*/:\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                break;\n            default:\n                mix = this.getBezierValue(time, i, 1 /* MIX*/, curveType - 2 /* BEZIER*/);\n                softness = this.getBezierValue(time, i, 2 /* SOFTNESS*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        } else {\n            constraint.mix += (mix - constraint.mix) * alpha;\n            constraint.softness += (softness - constraint.softness) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        }\n    }\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\n * @public\n * */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    transformConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, transformConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\n        this.transformConstraintIndex = transformConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number, mixShearY: number) {\n        const frames = this.frames;\n\n        frame *= 7 /* ENTRIES*/;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n        frames[frame + 4 /* SCALEX*/] = mixScaleX;\n        frames[frame + 5 /* SCALEY*/] = mixScaleY;\n        frames[frame + 6 /* SHEARY*/] = mixShearY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = data.mixRotate;\n                    constraint.mixX = data.mixX;\n                    constraint.mixY = data.mixY;\n                    constraint.mixScaleX = data.mixScaleX;\n                    constraint.mixScaleY = data.mixScaleY;\n                    constraint.mixShearY = data.mixShearY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        let scaleX;\n        let scaleY;\n        let shearY;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 7 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 7 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 7 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                scaleX += (frames[i + 7 /* ENTRIES*/ + 4 /* SCALEX*/] - scaleX) * t;\n                scaleY += (frames[i + 7 /* ENTRIES*/ + 5 /* SCALEY*/] - scaleY) * t;\n                shearY += (frames[i + 7 /* ENTRIES*/ + 6 /* SHEARY*/] - shearY) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                scaleX = this.getBezierValue(time, i, 4 /* SCALEX*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                scaleY = this.getBezierValue(time, i, 5 /* SCALEY*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                shearY = this.getBezierValue(time, i, 6 /* SHEARY*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n        }\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}.\n * @public\n * */\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        const position = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}.\n * @public\n * */\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        const spacing = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\n * {@link PathConstraint#getMixY()}.\n * @public\n * */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\n        const frames = this.frames;\n\n        frame <<= 2;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = constraint.data.mixRotate;\n                    constraint.mixX = constraint.data.mixX;\n                    constraint.mixY = constraint.data.mixY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 4 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 4 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 4 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}.\n * @public\n * */\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\n    static ENTRIES = 3;\n    static MODE = 1;\n    static DELAY = 2;\n\n    slotIndex: number;\n    attachment: IHasTextureRegion;\n\n    constructor(frameCount: number, slotIndex: number, attachment: IHasTextureRegion) {\n        super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);\n        this.slotIndex = slotIndex;\n        this.attachment = attachment;\n    }\n\n    getFrameEntries() {\n        return SequenceTimeline.ENTRIES;\n    }\n\n    getSlotIndex() {\n        return this.slotIndex;\n    }\n\n    getAttachment() {\n        return this.attachment as unknown as Attachment;\n    }\n\n    /** Sets the time, mode, index, and frame time for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time Seconds between frames. */\n    setFrame(frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\n        const frames = this.frames;\n\n        frame *= SequenceTimeline.ENTRIES;\n        frames[frame] = time;\n        frames[frame + SequenceTimeline.MODE] = mode | (index << 4);\n        frames[frame + SequenceTimeline.DELAY] = delay;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment = slot.attachment;\n        const attachment = this.attachment as unknown as Attachment;\n\n        if (slotAttachment != attachment) {\n            if (!(slotAttachment instanceof VertexAttachment) || (slotAttachment as VertexAttachment).timelineAttachment != attachment) return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\n\n            return;\n        }\n\n        const i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\n        const before = frames[i];\n        const modeAndIndex = frames[i + SequenceTimeline.MODE];\n        const delay = frames[i + SequenceTimeline.DELAY];\n\n        if (!this.attachment.sequence) return;\n        let index = modeAndIndex >> 4;\n        const count = this.attachment.sequence.regions.length;\n        const mode = SequenceModeValues[modeAndIndex & 0xf];\n\n        if (mode != SequenceMode.hold) {\n            index += ((time - before) / delay + 0.00001) | 0;\n            switch (mode) {\n                case SequenceMode.once:\n                    index = Math.min(count - 1, index);\n                    break;\n                case SequenceMode.loop:\n                    index %= count;\n                    break;\n                case SequenceMode.pingpong: {\n                    const n = (count << 1) - 2;\n\n                    index = n == 0 ? 0 : index % n;\n                    if (index >= count) index = n - index;\n                    break;\n                }\n                case SequenceMode.onceReverse:\n                    index = Math.max(count - 1 - index, 0);\n                    break;\n                case SequenceMode.loopReverse:\n                    index = count - 1 - (index % count);\n                    break;\n                case SequenceMode.pingpongReverse: {\n                    const n = (count << 1) - 2;\n\n                    index = n == 0 ? 0 : (index + count - 1) % n;\n                    if (index >= count) index = n - index;\n                }\n            }\n        }\n        slot.sequenceIndex = index;\n    }\n}\n", "import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, StringSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport type { Slot } from './Slot';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\n * @public\n * */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static _emptyAnimation = new Animation('<empty>', [], 0);\n    private static emptyAnimation(): Animation {\n        return AnimationState._emptyAnimation;\n    }\n\n    /** The AnimationStateData to look up mix durations. */\n    data: AnimationStateData;\n\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    tracks = new Array<TrackEntry | null>();\n\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    timeScale = 1;\n    unkeyedState = 0;\n\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new StringSet();\n    animationsChanged = false;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.clearNext(current);\n                continue;\n            }\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from: TrackEntry | null = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from) from.mixingTo = null;\n                while (from) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    /** Returns true when all mixing from entries are complete. */\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (!from) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n     * animation state can be applied to multiple skeletons to pose them identically.\n     * @returns True if any animations were applied. */\n    apply(skeleton: Skeleton): boolean {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            let applyTime = animationTime;\n            let applyEvents: Event[] | null = events;\n\n            if (current.reverse) {\n                applyTime = current.animation.duration - applyTime;\n                applyEvents = null;\n            }\n            const timelines = current.animation.timelines;\n            const timelineCount = timelines.length;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    const timeline = timelines[ii];\n\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const shortestRotation = current.shortestRotation;\n                const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (!shortestRotation && timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n                    } else if (timeline instanceof AttachmentTimeline) {\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n        // the time is before the first key).\n        const setupState = this.unkeyedState + SETUP;\n        const slots = skeleton.slots;\n\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.attachmentState == setupState) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n            }\n        }\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const timelines = from.animation.timelines;\n        const timelineCount = timelines.length;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        let applyTime = animationTime;\n        let events = null;\n\n        if (from.reverse) applyTime = from.animation.duration - applyTime;\n        else if (mix < from.eventThreshold) events = this.events;\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const shortestRotation = from.shortestRotation;\n            const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case SUBSEQUENT:\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case HOLD_SUBSEQUENT:\n                        timelineBlend = blend;\n                        alpha = alphaHold;\n                        break;\n                    case HOLD_FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n\n                if (!shortestRotation && timeline instanceof RotateTimeline)\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n        const slot = skeleton.slots[timeline.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (time < timeline.frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n        } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n    }\n\n    applyRotateTimeline(\n        timeline: RotateTimeline,\n        skeleton: Skeleton,\n        time: number,\n        alpha: number,\n        blend: MixBlend,\n        timelinesRotation: Array<number>,\n        i: number,\n        firstFrame: boolean\n    ) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const bone = skeleton.bones[timeline.boneIndex];\n\n        if (!bone.active) return;\n        const frames = timeline.frames;\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        bone.rotation = r1 + total * alpha;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n    }\n\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    /** Removes all animations from the track, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (!current) return;\n\n        this.queue.end(current);\n\n        this.clearNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (!from) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n        current.previous = null;\n\n        if (from) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    /** Sets an animation by name.\n     *\n     * See {@link #setAnimationWith()}. */\n    setAnimation(trackIndex: number, animationName: string, loop = false) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n     * applied to a skeleton, it is replaced (not mixed from).\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    setAnimationWith(trackIndex: number, animation: Animation, loop = false) {\n        if (!animation) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.clearNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.clearNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    /** Queues an animation by name.\n     *\n     * See {@link #addAnimationWith()}. */\n    addAnimation(trackIndex: number, animationName: string, loop = false, delay = 0) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n     * equivalent to calling {@link #setAnimationWith()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n     *           previous entry is looping, its next loop completion is used instead of its duration.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addAnimationWith(trackIndex: number, animation: Animation, loop = false, delay = 0) {\n        if (!animation) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last) {\n            while (last.next) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (!last) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            entry.previous = last;\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n     *\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n     * 0 still mixes out over one frame.\n     *\n     * Mixing in is done by first setting an empty animation, then adding an animation using\n     * {@link #addAnimation()} and on the returned track entry, set the\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n    setEmptyAnimation(trackIndex: number, mixDuration = 0) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n     * {@link #setEmptyAnimation()}.\n     *\n     * See {@link #setEmptyAnimation()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n     *           loop completion is used instead of its duration.\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addEmptyAnimation(trackIndex: number, mixDuration = 0, delay = 0) {\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\n\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n     * duration. */\n    setEmptyAnimations(mixDuration = 0) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    /** @param last May be null. */\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.reset();\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.reverse = false;\n        entry.shortestRotation = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n        entry.interruptAlpha = 1;\n        entry.totalAlpha = 0;\n        entry.mixBlend = MixBlend.replace;\n\n        return entry;\n    }\n\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n    clearNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            let entry = tracks[i];\n\n            if (!entry) continue;\n            while (entry.mixingFrom) entry = entry.mixingFrom;\n            do {\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                entry = entry.mixingTo;\n            } while (entry);\n        }\n    }\n\n    computeHold(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = entry.timelineMode;\n\n        timelineMode.length = timelinesCount;\n        const timelineHoldMix = entry.timelineHoldMix;\n\n        timelineHoldMix.length = 0;\n        const propertyIDs = this.propertyIDs;\n\n        if (to && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const timeline = timelines[i];\n            const ids = timeline.getPropertyIds();\n\n            if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\n            else if (\n                !to ||\n                timeline instanceof AttachmentTimeline ||\n                timeline instanceof DrawOrderTimeline ||\n                timeline instanceof EventTimeline ||\n                !to.animation.hasTimeline(ids)\n            ) {\n                timelineMode[i] = FIRST;\n            } else {\n                for (let next = to.mixingTo; next; next = next.mixingTo) {\n                    if (next.animation.hasTimeline(ids)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = HOLD_MIX;\n                        timelineHoldMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = HOLD_FIRST;\n            }\n        }\n    }\n\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all track entries. */\n    addListener(listener: AnimationStateListener) {\n        if (!listener) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener()}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    /** Removes all listeners added with {@link #addListener()}. */\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n     * are not wanted because new animations are being set. */\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\n * @public\n * */\nexport class TrackEntry implements ITrackEntry {\n    /** The animation to apply for this track entry. */\n    animation: Animation | null = null;\n\n    previous: TrackEntry | null = null;\n\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    next: TrackEntry | null = null;\n\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    mixingFrom: TrackEntry | null = null;\n\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    mixingTo: TrackEntry | null = null;\n\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    listener: AnimationStateListener | null = null;\n\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    trackIndex = 0;\n\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    loop = false;\n\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    holdPrevious = false;\n\n    reverse = false;\n\n    shortestRotation = false;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    eventThreshold = 0;\n\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    attachmentThreshold = 0;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    drawOrderThreshold = 0;\n\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    animationStart = 0;\n\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    animationEnd = 0;\n\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    animationLast = 0;\n\n    nextAnimationLast = 0;\n\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    delay = 0;\n\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    trackTime = 0;\n\n    trackLast = 0;\n    nextTrackLast = 0;\n\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    trackEnd = 0;\n\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    timeScale = 0;\n\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    alpha = 0;\n\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    mixTime = 0;\n\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    mixDuration = 0;\n    interruptAlpha = 0;\n    totalAlpha = 0;\n\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.previous = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n     * `animationStart` time. */\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    /** Returns true if at least one loop has been completed.\n     *\n     * See {@link AnimationStateListener#complete()}. */\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n     * long way around when using {@link #alpha} and starting animations on other tracks.\n     *\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    getTrackComplete() {\n        const duration = this.animationEnd - this.animationStart;\n\n        if (duration != 0) {\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\n            if (this.trackTime < duration) return duration; // Before duration.\n        }\n\n        return this.trackTime; // Next update.\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: Boolean = false;\n    private static deprecatedWarning2: Boolean = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.start) listener.start(entry);\n                    }\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.interrupt) listener.interrupt(entry);\n                    }\n                    break;\n                case EventType.end:\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.end) listener.end(entry);\n                    }\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.dispose) listener.dispose(entry);\n                    }\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.complete) listener.complete(entry);\n                    }\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.event) listener.event(entry, event);\n                    }\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\n * events.\n *\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\n * {@link AnimationState#addListener()}.\n * @public\n * */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?: (entry: TrackEntry) => void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?: (entry: TrackEntry) => void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?: (entry: TrackEntry, event: Event) => void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nconst SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nconst FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nconst HOLD_MIX = 4;\n\nconst SETUP = 1;\nconst CURRENT = 2;\n", "import type { SkeletonData } from './SkeletonData';\nimport type { IAnimationStateData, StringMap } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\n\n/** Stores mix (crossfade) durations to be applied when {@link AnimationState} animations are changed.\n * @public\n * */\nexport class AnimationStateData implements IAnimationStateData<SkeletonData, Animation> {\n    /** The SkeletonData to look up animations when they are specified by name. */\n    skeletonData: SkeletonData;\n\n    animationToMixTime: StringMap<number> = {};\n\n    /** The mix duration to use when no mix duration has been defined between two animations. */\n    defaultMix = 0;\n\n    constructor(skeletonData: SkeletonData) {\n        if (!skeletonData) throw new Error('skeletonData cannot be null.');\n        this.skeletonData = skeletonData;\n    }\n\n    /** Sets a mix duration by animation name.\n     *\n     * See {@link #setMixWith()}. */\n    setMix(fromName: string, toName: string, duration: number) {\n        const from = this.skeletonData.findAnimation(fromName);\n\n        if (!from) throw new Error(`Animation not found: ${fromName}`);\n        const to = this.skeletonData.findAnimation(toName);\n\n        if (!to) throw new Error(`Animation not found: ${toName}`);\n        this.setMixWith(from, to, duration);\n    }\n\n    /** Sets the mix duration when changing from the specified animation to the other.\n     *\n     * See {@link TrackEntry#mixDuration}. */\n    setMixWith(from: Animation, to: Animation, duration: number) {\n        if (!from) throw new Error('from cannot be null.');\n        if (!to) throw new Error('to cannot be null.');\n        const key = `${from.name}.${to.name}`;\n\n        this.animationToMixTime[key] = duration;\n    }\n\n    /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if\n     * no mix duration has been set. */\n    getMix(from: Animation, to: Animation) {\n        const key = `${from.name}.${to.name}`;\n        const value = this.animationToMixTime[key];\n\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n", "import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment, Sequence } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    loadSequence(name: string, basePath: string, sequence: Sequence) {\n        const regions = sequence.regions;\n\n        for (let i = 0, n = regions.length; i < n; i++) {\n            const path = sequence.getPath(basePath, i);\n            const region = this.atlas.findRegion(path);\n\n            if (region == null) throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);\n            regions[i] = region;\n            regions[i].renderObject = regions[i];\n        }\n    }\n\n    newRegionAttachment(skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\n        const attachment = new RegionAttachment(name, path);\n\n        if (sequence != null) {\n            this.loadSequence(name, path, sequence);\n        } else {\n            const region = this.atlas.findRegion(path);\n\n            if (!region) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n            region.renderObject = region;\n            attachment.region = region;\n        }\n\n        return attachment;\n    }\n\n    newMeshAttachment(skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\n        const attachment = new MeshAttachment(name, path);\n\n        if (sequence != null) {\n            this.loadSequence(name, path, sequence);\n        } else {\n            const region = this.atlas.findRegion(path);\n\n            if (!region) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n            region.renderObject = region;\n            attachment.region = region;\n        }\n\n        return attachment;\n    }\n\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n", "import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/** Stores a bone's current pose.\n *\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\n * constraint or application code modifies the world transform after it was computed from the local transform.\n * @public\n * */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    /** The bone's setup pose data. */\n    data: BoneData;\n\n    /** The skeleton this bone belongs to. */\n    skeleton: Skeleton;\n\n    /** The parent bone, or null if this is the root bone. */\n    parent: Bone | null = null;\n\n    /** The immediate children of this bone. */\n    children = new Array<Bone>();\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local rotation in degrees, counter clockwise. */\n    rotation = 0;\n\n    /** The local scaleX. */\n    scaleX = 0;\n\n    /** The local scaleY. */\n    scaleY = 0;\n\n    /** The local shearX. */\n    shearX = 0;\n\n    /** The local shearY. */\n    shearY = 0;\n\n    /** The applied local x translation. */\n    ax = 0;\n\n    /** The applied local y translation. */\n    ay = 0;\n\n    /** The applied local rotation in degrees, counter clockwise. */\n    arotation = 0;\n\n    /** The applied local scaleX. */\n    ascaleX = 0;\n\n    /** The applied local scaleY. */\n    ascaleY = 0;\n\n    /** The applied local shearX. */\n    ashearX = 0;\n\n    /** The applied local shearY. */\n    ashearY = 0;\n\n    sorted = false;\n    active = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone | null) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n    isActive() {\n        return this.active;\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\n    update() {\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform.\n     *\n     * See {@link #updateWorldTransformWith()}. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n     * specified local transform. Child bones are not updated.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (!parent) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pa /= sx;\n                    pc /= sy;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0)) s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    /** Sets this bone's local transform to the setup pose. */\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.b * m.b);\n    }\n\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.c * m.c + m.d * m.d);\n    }\n\n    /** Computes the applied transform values from the world transform.\n     *\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n     * constraints).\n     *\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n    updateAppliedTransform() {\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (!parent) {\n            this.ax = m.tx - this.skeleton.x;\n            this.ay = m.ty - this.skeleton.y;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    /** Transforms a world rotation to a local rotation. */\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    /** Transforms a local rotation to a world rotation. */\n    localToWorldRotation(localRotation: number) {\n        localRotation -= this.rotation - this.shearX;\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    /** Rotates the world transform the specified amount.\n     * <p>\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n     * need to be called on any child bones, recursively. */\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n    }\n}\n", "import { Color, TransformMode } from '@pixi-spine/base';\n\n/** Stores the setup pose for a {@link Bone}.\n * @public\n * */\nexport class BoneData {\n    /** The index of the bone in {@link Skeleton#getBones()}. */\n    index = 0;\n\n    /** The name of the bone, which is unique across all bones in the skeleton. */\n    name: string;\n\n    /** @returns May be null. */\n    parent: BoneData | null = null;\n\n    /** The bone's length. */\n    length = 0;\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local rotation. */\n    rotation = 0;\n\n    /** The local scaleX. */\n    scaleX = 1;\n\n    /** The local scaleY. */\n    scaleY = 1;\n\n    /** The local shearX. */\n    shearX = 0;\n\n    /** The local shearX. */\n    shearY = 0;\n\n    /** The transform mode for how parent world transforms affect this bone. */\n    transformMode = TransformMode.Normal;\n\n    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this\n     * bone.\n     * @see Skin#bones */\n    skinRequired = false;\n\n    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually\n     * rendered at runtime. */\n    color = new Color();\n\n    constructor(index: number, name: string, parent: BoneData | null) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (!name) throw new Error('name cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n    }\n}\n", "/** The base class for all constraint datas.\n * @public\n * */\nexport abstract class ConstraintData {\n    constructor(public name: string, public order: number, public skinRequired: boolean) {}\n}\n", "import type { EventData } from './EventData';\nimport type { IEvent } from '@pixi-spine/base';\n\n/** Stores the current pose values for an {@link Event}.\n *\n * See Timeline {@link Timeline#apply()},\n * AnimationStateListener {@link AnimationStateListener#event()}, and\n * [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\n * @public\n * */\nexport class Event implements IEvent {\n    data: EventData;\n    intValue = 0;\n    floatValue = 0;\n    stringValue: string | null = null;\n    time = 0;\n    volume = 0;\n    balance = 0;\n\n    constructor(time: number, data: EventData) {\n        if (!data) throw new Error('data cannot be null.');\n        this.time = time;\n        this.data = data;\n    }\n}\n", "import type { IEventData } from '@pixi-spine/base';\n\n/** Stores the setup pose values for an {@link Event}.\n *\n * See [Events](http://esotericsoftware.com/spine-events) in the Spine User Guide.\n * @public\n * */\nexport class EventData implements IEventData {\n    name: string;\n    intValue = 0;\n    floatValue = 0;\n    stringValue: string | null = null;\n    audioPath: string | null = null;\n    volume = 0;\n    balance = 0;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n", "import type { Updatable } from './Updatable';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, settings, TransformMode } from '@pixi-spine/base';\n\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\n * the last bone is as close to the target bone as possible.\n *\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\n * @public\n * */\nexport class IkConstraint implements Updatable {\n    /** The IK constraint's setup pose data. */\n    data: IkConstraintData;\n\n    /** The bones that will be modified by this IK constraint. */\n    bones: Array<Bone>;\n\n    /** The bone that is the IK target. */\n    target: Bone;\n\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    bendDirection = 0;\n\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    compress = false;\n\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    stretch = false;\n\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    mix = 1;\n\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    softness = 0;\n    active = false;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.softness = data.softness;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const bone = skeleton.findBone(data.bones[i].name);\n\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n            this.bones.push(bone);\n        }\n        const target = skeleton.findBone(data.target.name);\n\n        if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\n        this.target = target;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        if (this.mix == 0) return;\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n                break;\n        }\n    }\n\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        const p = bone.parent.matrix;\n\n        if (!p) throw new Error('IK bone must have parent.');\n        const pa = p.a;\n        let pb = p.c;\n        const pc = p.b;\n        let pd = p.d;\n        let rotationIK = -bone.ashearX - bone.arotation;\n        let tx = 0;\n        let ty = 0;\n\n        const skelX = bone.skeleton.scaleX;\n        const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\n\n        switch (bone.data.transformMode) {\n            case TransformMode.OnlyTranslation:\n                tx = targetX - bone.worldX;\n                ty = targetY - bone.worldY;\n                // TODO: possible bug in spine-ts runtime!\n                if (settings.yDown) {\n                    ty = -ty;\n                }\n                break;\n            case TransformMode.NoRotationOrReflection:\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                const sa = pa / skelX;\n                const sc = pc / skelY;\n\n                pb = -sc * s * skelX;\n                pd = sa * s * skelY;\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n            // Fall through\n            default:\n                const x = targetX - p.tx;\n                const y = targetY - p.ty;\n                const d = pa * pd - pb * pc;\n\n                tx = (x * pd - y * pb) / d - bone.ax;\n                ty = (y * pa - x * pc) / d - bone.ay;\n        }\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            switch (bone.data.transformMode) {\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n            }\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let psy = parent.ascaleY;\n        let sx = psx;\n        let sy = psy;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u || stretch) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        if (!pp) throw new Error('IK parent must itself have a parent.');\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = cwx - pp.tx;\n        let y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1;\n        let a2;\n\n        if (l1 < 0.0001) {\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\n            return;\n        }\n        x = targetX - pp.tx;\n        y = targetY - pp.ty;\n        let tx = (x * d - y * b) * id - px;\n        let ty = (y * a - x * c) * id - py;\n        let dd = tx * tx + ty * ty;\n\n        if (softness != 0) {\n            softness *= psx * (csx + 1) * 0.5;\n            const td = Math.sqrt(dd);\n            const sd = td - l1 - l2 * psx + softness;\n\n            if (sd > 0) {\n                let p = Math.min(1, sd / (softness * 2)) - 1;\n\n                p = (sd - softness * (1 - p * p)) / td;\n                tx -= p * tx;\n                ty -= p * ty;\n                dd = tx * tx + ty * ty;\n            }\n        }\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) {\n                cos = -1;\n                a2 = Math.PI * bendDir;\n            } else if (cos > 1) {\n                cos = 1;\n                a2 = 0;\n                if (stretch) {\n                    a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n                    sx *= a;\n                    if (uniform) sy *= a;\n                }\n            } else a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) * 0.5;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) * 0.5) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180)\n            //\n            a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180)\n            //\n            a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n", "import { ConstraintData } from './ConstraintData';\nimport type { BoneData } from './BoneData';\n\n/** Stores the setup pose for an {@link IkConstraint}.\n * <p>\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\n * @public\n * */\nexport class IkConstraintData extends ConstraintData {\n    /** The bones that are constrained by this IK constraint. */\n    bones = new Array<BoneData>();\n\n    /** The bone that is the IK target. */\n    private _target: BoneData | null = null;\n    public set target(boneData: BoneData) {\n        this._target = boneData;\n    }\n    public get target() {\n        if (!this._target) throw new Error('BoneData not set.');\n        else return this._target;\n    }\n\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    bendDirection = 1;\n\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    compress = false;\n\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    stretch = false;\n\n    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone\n     * is scaled on both the X and Y axes. */\n    uniform = false;\n\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    mix = 1;\n\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    softness = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n", "import { ConstraintData } from './ConstraintData';\nimport type { SlotData } from './SlotData';\nimport type { BoneData } from './BoneData';\nimport { PositionMode, RotateMode } from '@pixi-spine/base';\n\n/** Stores the setup pose for a {@link PathConstraint}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\n * @public\n * */\nexport class PathConstraintData extends ConstraintData {\n    /** The bones that will be modified by this path constraint. */\n    bones = new Array<BoneData>();\n\n    /** The slot whose path attachment will be used to constrained the bones. */\n    private _target: SlotData | null = null;\n    public set target(slotData: SlotData) {\n        this._target = slotData;\n    }\n    public get target() {\n        if (!this._target) throw new Error('SlotData not set.');\n        else return this._target;\n    }\n\n    /** The mode for positioning the first bone on the path. */\n    positionMode: PositionMode = PositionMode.Fixed;\n\n    /** The mode for positioning the bones after the first bone on the path. */\n    spacingMode: SpacingMode = SpacingMode.Fixed;\n\n    /** The mode for adjusting the rotation of the bones. */\n    rotateMode: RotateMode = RotateMode.Chain;\n\n    /** An offset added to the constrained bone rotation. */\n    offsetRotation = 0;\n\n    /** The position along the path. */\n    position = 0;\n\n    /** The spacing between bones. */\n    spacing = 0;\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n\n/** Controls how bones after the first bone are positioned along the path.\n *\n * [Spacing mode](http://esotericsoftware.com/spine-path-constraints#Spacing-mode) in the Spine User Guide.\n * @public\n * */\nexport enum SpacingMode {\n    Length,\n    Fixed,\n    Percent,\n    Proportional,\n}\n", "import { PathAttachment } from './attachments';\nimport type { Updatable } from './Updatable';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\n * constrained bones so they follow a {@link PathAttachment}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\n * @public\n * */\nexport class PathConstraint implements Updatable {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    /** The path constraint's setup pose data. */\n    data: PathConstraintData;\n\n    /** The bones that will be modified by this path constraint. */\n    bones: Array<Bone>;\n\n    /** The slot whose path attachment will be used to constrained the bones. */\n    target: Slot;\n\n    /** The position along the path. */\n    position = 0;\n\n    /** The spacing between bones. */\n    spacing = 0;\n\n    mixRotate = 0;\n\n    mixX = 0;\n\n    mixY = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    active = false;\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) {\n            const bone = skeleton.findBone(data.bones[i].name);\n\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n            this.bones.push(bone);\n        }\n        const target = skeleton.findSlot(data.target.name);\n\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\n        this.target = target;\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n\n        const data = this.data;\n        const tangents = data.rotateMode == RotateMode.Tangent;\n        const scale = data.rotateMode == RotateMode.ChainScale;\n\n        const bones = this.bones;\n        const boneCount = bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        const lengths: Array<number> = scale ? (this.lengths = Utils.setArraySize(this.lengths, boneCount)) : [];\n        const spacing = this.spacing;\n\n        switch (data.spacingMode) {\n            case SpacingMode.Percent:\n                if (scale) {\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\n                        const bone = bones[i];\n                        const setupLength = bone.data.length;\n\n                        if (setupLength < PathConstraint.epsilon) lengths[i] = 0;\n                        else {\n                            const x = setupLength * bone.matrix.a;\n                            const y = setupLength * bone.matrix.b;\n\n                            lengths[i] = Math.sqrt(x * x + y * y);\n                        }\n                    }\n                }\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\n                break;\n            case SpacingMode.Proportional:\n                let sum = 0;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = length;\n                        sum += length;\n                    }\n                }\n                if (sum > 0) {\n                    sum = (spacesCount / sum) * spacing;\n                    for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n                }\n                break;\n            default:\n                const lengthSpacing = data.spacingMode == SpacingMode.Length;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                    }\n                }\n        }\n\n        const positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * mixX;\n            mat.ty += (boneY - mat.ty) * mixY;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (mixRotate > 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents) r = positions[p - 1];\n                else if (spaces[i + 1] == 0) r = positions[p + 2];\n                else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.updateAppliedTransform();\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = this.world;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n            let multiplier;\n\n            switch (this.data.spacingMode) {\n                case SpacingMode.Percent:\n                    multiplier = pathLength;\n                    break;\n                case SpacingMode.Proportional:\n                    multiplier = pathLength / spacesCount;\n                    break;\n                default:\n                    multiplier = 1;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i] * multiplier;\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n        let multiplier;\n\n        switch (this.data.spacingMode) {\n            case SpacingMode.Percent:\n                multiplier = pathLength;\n                break;\n            case SpacingMode.Proportional:\n                multiplier = pathLength / spacesCount;\n                break;\n            default:\n                multiplier = 1;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i] * multiplier;\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) {\n            out[o] = x1;\n            out[o + 1] = y1;\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\n            return;\n        }\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) {\n            if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n            else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n        }\n    }\n}\n", "import { Color, ISlot } from '@pixi-spine/base';\n\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\nimport type { Skeleton } from './Skeleton';\n\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\n * across multiple skeletons.\n * @public\n * */\nexport class Slot implements ISlot {\n    // this is canon\n    blendMode: number;\n    /** The slot's setup pose data. */\n    data: SlotData;\n\n    /** The bone this slot belongs to. */\n    bone: Bone;\n\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    color: Color;\n\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    darkColor: Color | null = null;\n\n    attachment: Attachment | null = null;\n\n    attachmentState = 0;\n\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n     * {@link Sequence#getSetupIndex()}. */\n    sequenceIndex = -1;\n\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n     *\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n    deform = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!bone) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = !data.darkColor ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** The skeleton this slot belongs to. */\n    getSkeleton(): Skeleton {\n        return this.bone.skeleton;\n    }\n\n    /** The current attachment for the slot, or null if the slot has no attachment. */\n    getAttachment(): Attachment | null {\n        return this.attachment;\n    }\n\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n     * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n     * specified attachment. */\n    setAttachment(attachment: Attachment | null) {\n        if (this.attachment == attachment) return;\n        if (\n            !(attachment instanceof VertexAttachment) ||\n            !(this.attachment instanceof VertexAttachment) ||\n            (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment\n        ) {\n            this.deform.length = 0;\n        }\n        this.attachment = attachment;\n        this.sequenceIndex = -1;\n    }\n\n    /** Sets this slot to the setup pose. */\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor);\n        if (!this.data.attachmentName) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n", "import type { Updatable } from './Updatable';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { Bone } from './Bone';\nimport { MathUtils, Vector2 } from '@pixi-spine/base';\nimport type { Skeleton } from './Skeleton';\n\n/** Stores the current pose for a transform constraint. A transform constraint adjusts the world transform of the constrained\n * bones to match that of the target bone.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\nexport class TransformConstraint implements Updatable {\n    /** The transform constraint's setup pose data. */\n    data: TransformConstraintData;\n\n    /** The bones that will be modified by this transform constraint. */\n    bones: Array<Bone>;\n\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    target: Bone;\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n    mixScaleX = 0;\n    mixScaleY = 0;\n    mixShearY = 0;\n\n    temp = new Vector2();\n    active = false;\n\n    constructor(data: TransformConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n        this.mixScaleX = data.mixScaleX;\n        this.mixScaleY = data.mixScaleY;\n        this.mixShearY = data.mixShearY;\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const bone = skeleton.findBone(data.bones[i].name);\n\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n            this.bones.push(bone);\n        }\n        const target = skeleton.findBone(data.target.name);\n\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}.`);\n        this.target = target;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0) return;\n\n        if (this.data.local) {\n            if (this.data.relative) this.applyRelativeLocal();\n            else this.applyAbsoluteLocal();\n        } else if (this.data.relative) this.applyRelativeWorld();\n        else this.applyAbsoluteWorld();\n    }\n\n    applyAbsoluteWorld() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n        const translate = mixX != 0 || mixY != 0;\n\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += (temp.x - mat.tx) * mixX;\n                mat.ty += (temp.y - mat.ty) * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n\n                if (s != 0) s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n\n                if (s != 0) s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;\n                mat.c *= s;\n                mat.d *= s;\n            }\n\n            if (mixShearY > 0) {\n                const b = mat.c;\n                const d = mat.d;\n                const by = Math.atan2(d, b);\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r = by + (r + offsetShearY) * mixShearY;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyRelativeWorld() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n        const translate = mixX != 0 || mixY != 0;\n\n        const target = this.target;\n        const targetMat = target.matrix;\n        const ta = targetMat.a;\n        const tb = targetMat.c;\n        const tc = targetMat.b;\n        const td = targetMat.d;\n        const degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        const offsetRotation = this.data.offsetRotation * degRadReflect;\n        const offsetShearY = this.data.offsetShearY * degRadReflect;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            if (mixRotate != 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = Math.atan2(tc, ta) + offsetRotation;\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                const cos = Math.cos(r);\n                const sin = Math.sin(r);\n\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n\n            if (translate) {\n                const temp = this.temp;\n\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                mat.tx += temp.x * mixX;\n                mat.ty += temp.y * mixY;\n            }\n\n            if (mixScaleX != 0) {\n                const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;\n\n                mat.a *= s;\n                mat.b *= s;\n            }\n            if (mixScaleY != 0) {\n                const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;\n\n                mat.c *= s;\n                mat.d *= s;\n            }\n\n            if (mixShearY > 0) {\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                const b = mat.c;\n                const d = mat.d;\n\n                r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * mixShearY;\n                const s = Math.sqrt(b * b + d * d);\n\n                mat.c = Math.cos(r) * s;\n                mat.d = Math.sin(r) * s;\n            }\n\n            bone.updateAppliedTransform();\n        }\n    }\n\n    applyAbsoluteLocal() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n\n        const target = this.target;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            let rotation = bone.arotation;\n\n            if (mixRotate != 0) {\n                let r = target.arotation - rotation + this.data.offsetRotation;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                rotation += r * mixRotate;\n            }\n\n            let x = bone.ax;\n            let y = bone.ay;\n\n            x += (target.ax - x + this.data.offsetX) * mixX;\n            y += (target.ay - y + this.data.offsetY) * mixY;\n\n            let scaleX = bone.ascaleX;\n            let scaleY = bone.ascaleY;\n\n            if (mixScaleX != 0 && scaleX != 0) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;\n            if (mixScaleY != 0 && scaleY != 0) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;\n\n            let shearY = bone.ashearY;\n\n            if (mixShearY != 0) {\n                let r = target.ashearY - shearY + this.data.offsetShearY;\n\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                shearY += r * mixShearY;\n            }\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n\n    applyRelativeLocal() {\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n        const mixScaleX = this.mixScaleX;\n        const mixScaleY = this.mixScaleY;\n        const mixShearY = this.mixShearY;\n\n        const target = this.target;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;\n            const x = bone.ax + (target.ax + this.data.offsetX) * mixX;\n            const y = bone.ay + (target.ay + this.data.offsetY) * mixY;\n            const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);\n            const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);\n            const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;\n\n            bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n    }\n}\n", "import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, MathUtils, NumberArrayLike, settings, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    /** The skeleton's setup pose data. */\n    data: SkeletonData;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones: Array<Bone>;\n\n    /** The skeleton's slots. */\n    slots: Array<Slot>;\n\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n    drawOrder: Array<Slot>;\n\n    /** The skeleton's IK constraints. */\n    ikConstraints: Array<IkConstraint>;\n\n    /** The skeleton's transform constraints. */\n    transformConstraints: Array<TransformConstraint>;\n\n    /** The skeleton's path constraints. */\n    pathConstraints: Array<PathConstraint>;\n\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    _updateCache = new Array<Updatable>();\n\n    /** The skeleton's current skin. May be null. */\n    skin: Skin | null = null;\n\n    /** The color to tint all the skeleton's attachments. */\n    color: Color;\n\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleX = 1;\n\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleY = 1;\n\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    x = 0;\n\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (!data) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (!boneData.parent) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n     * constraints, or weighted path attachments are added or removed. */\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin) {\n            const skinBones = this.skin.bones;\n\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone: Bone | null = this.bones[skinBones[i].index];\n\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length == 1) {\n            this._updateCache.push(constraint);\n            this.sortReset(parent.children);\n        } else {\n            const child = constrained[constrained.length - 1];\n\n            this.sortBone(child);\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            child.sorted = true;\n        }\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                this.sortBone(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (!pathBones) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n\n            for (let i = 0, n = pathBones.length; i < n; ) {\n                let nn = pathBones[i++];\n\n                nn += i;\n                while (i < nn) this.sortBone(bones[pathBones[i++]]);\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (!bone) return;\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies all constraints.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransform() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n        }\n\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    updateWorldTransformWith(parent: Bone) {\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n        const rootBone = this.getRootBone();\n        const pa = parent.matrix.a;\n        const pb = parent.matrix.c;\n        const pc = parent.matrix.b;\n        const pd = parent.matrix.d;\n\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n\n        const rotationY = rootBone.rotation + 90 + rootBone.shearY;\n        const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n        const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n\n        const sx = this.scaleX;\n        const sy = settings.yDown ? -this.scaleY : this.scaleY;\n\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n\n        // Update everything except root bone.\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) {\n            const updatable = updateCache[i];\n\n            if (updatable != rootBone) updatable.update();\n        }\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n            constraint.mixScaleX = data.mixScaleX;\n            constraint.mixScaleY = data.mixScaleY;\n            constraint.mixShearY = data.mixShearY;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n        }\n    }\n\n    /** Sets the slots and draw order to their setup pose values. */\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @returns May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @returns May be null. */\n    findBone(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * repeatedly.\n     * @returns May be null. */\n    findSlot(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     *\n     * See {@link #setSkin()}. */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (!skin) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n     * skin is changed, {@link #updateCache()} is called.\n     *\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     *\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin) {\n            if (this.skin) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name) {\n                        const attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n     * name.\n     *\n     * See {@link #getAttachment()}.\n     * @returns May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment | null {\n        const slot = this.data.findSlot(slotName);\n\n        if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n\n        return this.getAttachment(slot.index, attachmentName);\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n     *\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n     * @returns May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment | null {\n        if (!attachmentName) throw new Error('attachmentName cannot be null.');\n        if (this.skin) {\n            const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n     * @param attachmentName May be null to clear the slot's attachment. */\n    setAttachment(slotName: string, attachmentName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment | null = null;\n\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (!attachment) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it repeatedly.\n     * @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n    getBoundsRect() {\n        const offset = new Vector2();\n        const size = new Vector2();\n\n        this.getBounds(offset, size);\n\n        return { x: offset.x, y: offset.y, width: size.x, height: size.y };\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size An output value, the width and height of the AABB.\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (!offset) throw new Error('offset cannot be null.');\n        if (!size) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: NumberArrayLike | null = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n", "import type { ISkeletonData } from '@pixi-spine/base';\nimport type { Animation } from './Animation';\nimport type { BoneData } from './BoneData';\nimport type { SlotData } from './SlotData';\nimport type { Skin } from './Skin';\nimport type { EventData } from './EventData';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { TransformConstraintData } from './TransformConstraintData';\nimport type { PathConstraintData } from './PathConstraintData';\n\n/** Stores the setup pose and all of the stateless data for a skeleton.\n *\n * See [Data objects](http://esotericsoftware.com/spine-runtime-architecture#Data-objects) in the Spine Runtimes\n * Guide.\n * @public\n * */\nexport class SkeletonData implements ISkeletonData<BoneData, SlotData, Skin, Animation, EventData, IkConstraintData, TransformConstraintData, PathConstraintData> {\n    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */\n    name: string | null = null;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones = new Array<BoneData>(); // Ordered parents first.\n\n    /** The skeleton's slots. */\n    slots = new Array<SlotData>(); // Setup pose draw order.\n    skins = new Array<Skin>();\n\n    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.\n     *\n     * See {@link Skeleton#getAttachmentByName()}.\n     * May be null. */\n    defaultSkin: Skin | null = null;\n\n    /** The skeleton's events. */\n    events = new Array<EventData>();\n\n    /** The skeleton's animations. */\n    animations = new Array<Animation>();\n\n    /** The skeleton's IK constraints. */\n    ikConstraints = new Array<IkConstraintData>();\n\n    /** The skeleton's transform constraints. */\n    transformConstraints = new Array<TransformConstraintData>();\n\n    /** The skeleton's path constraints. */\n    pathConstraints = new Array<PathConstraintData>();\n\n    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    x = 0;\n\n    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */\n    y = 0;\n\n    /** The width of the skeleton's axis aligned bounding box in the setup pose. */\n    width = 0;\n\n    /** The height of the skeleton's axis aligned bounding box in the setup pose. */\n    height = 0;\n\n    /** The Spine version used to export the skeleton data, or null. */\n    version: string | null = null;\n\n    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */\n    hash: string | null = null;\n\n    // Nonessential\n    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */\n    fps = 0;\n\n    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    imagesPath: string | null = null;\n\n    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */\n    audioPath: string | null = null;\n\n    /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findBone(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/\n    findBoneIndex(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findSlot(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/\n    findSlotIndex(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findSkin(skinName: string) {\n        if (!skinName) throw new Error('skinName cannot be null.');\n        const skins = this.skins;\n\n        for (let i = 0, n = skins.length; i < n; i++) {\n            const skin = skins[i];\n\n            if (skin.name == skinName) return skin;\n        }\n\n        return null;\n    }\n\n    /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it\n     * multiple times.\n     * @returns May be null. */\n    findEvent(eventDataName: string) {\n        if (!eventDataName) throw new Error('eventDataName cannot be null.');\n        const events = this.events;\n\n        for (let i = 0, n = events.length; i < n; i++) {\n            const event = events[i];\n\n            if (event.name == eventDataName) return event;\n        }\n\n        return null;\n    }\n\n    /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to\n     * call it multiple times.\n     * @returns May be null. */\n    findAnimation(animationName: string) {\n        if (!animationName) throw new Error('animationName cannot be null.');\n        const animations = this.animations;\n\n        for (let i = 0, n = animations.length; i < n; i++) {\n            const animation = animations[i];\n\n            if (animation.name == animationName) return animation;\n        }\n\n        return null;\n    }\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it multiple times.\n     * @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it multiple times.\n     * @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it multiple times.\n     * @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** removed from spine-ts runtime **/ findPathConstraintIndex(pathConstraintName: string) {\n        if (pathConstraintName == null) throw new Error('pathConstraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n    }\n}\n", "import { Color } from '@pixi-spine/base';\n\nimport type { ISlotData } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport type { BoneData } from './BoneData';\n\n/** Stores the setup pose for a {@link Slot}.\n * @public\n * */\nexport class SlotData implements ISlotData {\n    /** The index of the slot in {@link Skeleton#getSlots()}. */\n    index = 0;\n\n    /** The name of the slot, which is unique across all slots in the skeleton. */\n    name: string;\n\n    /** The bone this slot belongs to. */\n    boneData: BoneData;\n\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    darkColor: Color | null = null;\n\n    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */\n    attachmentName: string | null = null;\n\n    /** The blend mode for drawing the slot's attachment. */\n    blendMode: BLEND_MODES = BLEND_MODES.NORMAL;\n\n    constructor(index: number, name: string, boneData: BoneData) {\n        if (index < 0) throw new Error('index must be >= 0.');\n        if (!name) throw new Error('name cannot be null.');\n        if (!boneData) throw new Error('boneData cannot be null.');\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n    }\n}\n", "import type { BoneData } from './BoneData';\nimport { ConstraintData } from './ConstraintData';\n\n/** Stores the setup pose for a {@link TransformConstraint}.\n *\n * See [Transform constraints](http://esotericsoftware.com/spine-transform-constraints) in the Spine User Guide.\n * @public\n * */\nexport class TransformConstraintData extends ConstraintData {\n    /** The bones that will be modified by this transform constraint. */\n    bones = new Array<BoneData>();\n\n    /** The target bone whose world transform will be copied to the constrained bones. */\n    private _target: BoneData | null = null;\n    public set target(boneData: BoneData) {\n        this._target = boneData;\n    }\n    public get target() {\n        if (!this._target) throw new Error('BoneData not set.');\n        else return this._target;\n    }\n\n    mixRotate = 0;\n    mixX = 0;\n    mixY = 0;\n    mixScaleX = 0;\n    mixScaleY = 0;\n    mixShearY = 0;\n\n    /** An offset added to the constrained bone rotation. */\n    offsetRotation = 0;\n\n    /** An offset added to the constrained bone X translation. */\n    offsetX = 0;\n\n    /** An offset added to the constrained bone Y translation. */\n    offsetY = 0;\n\n    /** An offset added to the constrained bone scaleX. */\n    offsetScaleX = 0;\n\n    /** An offset added to the constrained bone scaleY. */\n    offsetScaleY = 0;\n\n    /** An offset added to the constrained bone shearY. */\n    offsetShearY = 0;\n\n    relative = false;\n    local = false;\n\n    constructor(name: string) {\n        super(name, 0, false);\n    }\n}\n", "import { Attachment, MeshAttachment } from './attachments';\nimport type { BoneData } from './BoneData';\nimport type { ConstraintData } from './ConstraintData';\nimport type { Skeleton } from './Skeleton';\n\nimport type { StringMap, ISkin } from '@pixi-spine/base';\n\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\n * @public\n * **/\nexport class SkinEntry {\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\n}\n\n/** Stores attachments by slot index and attachment name.\n *\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skin implements ISkin {\n    /** The skin's name, which is unique across all skins in the skeleton. */\n    name: string;\n\n    attachments = new Array<StringMap<Attachment>>();\n    bones = Array<BoneData>();\n    constraints = new Array<ConstraintData>();\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    /** Adds an attachment to the skin for the specified slot index and name. */\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (!attachment) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n    addSkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n        }\n    }\n\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n    copySkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            if (!attachment.attachment) continue;\n            if (attachment.attachment instanceof MeshAttachment) {\n                attachment.attachment = attachment.attachment.newLinkedMesh();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            } else {\n                attachment.attachment = attachment.attachment.copy();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            }\n        }\n    }\n\n    /** Returns the attachment for the specified slot index and name, or null. */\n    getAttachment(slotIndex: number, name: string): Attachment | null {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\n    removeAttachment(slotIndex: number, name: string) {\n        const dictionary = this.attachments[slotIndex];\n\n        if (dictionary) delete dictionary[name];\n    }\n\n    /** Returns all attachments in this skin. */\n    getAttachments(): Array<SkinEntry> {\n        const entries = new Array<SkinEntry>();\n\n        for (let i = 0; i < this.attachments.length; i++) {\n            const slotAttachments = this.attachments[i];\n\n            if (slotAttachments) {\n                for (const name in slotAttachments) {\n                    const attachment = slotAttachments[name];\n\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\n                }\n            }\n        }\n\n        return entries;\n    }\n\n    /** Returns all attachments in this skin for the specified slot index. */\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n        const slotAttachments = this.attachments[slotIndex];\n\n        if (slotAttachments) {\n            for (const name in slotAttachments) {\n                const attachment = slotAttachments[name];\n\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n            }\n        }\n    }\n\n    /** Clears all attachments, bones, and constraints. */\n    clear() {\n        this.attachments.length = 0;\n        this.bones.length = 0;\n        this.constraints.length = 0;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n", "import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    SequenceTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { AttachmentType, BinaryInput, Color, IHasTextureRegion, PositionMode, Utils } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceModeValues } from './attachments';\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonBinary {\n    ver40 = false;\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n\n    attachmentLoader: AttachmentLoader;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(binary: Uint8Array): SkeletonData {\n        const scale = this.scale;\n\n        const skeletonData = new SkeletonData();\n\n        skeletonData.name = ''; // BOZO\n\n        const input = new BinaryInput(binary);\n\n        const lowHash = input.readInt32();\n        const highHash = input.readInt32();\n\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n        skeletonData.version = input.readString();\n        const verShort = skeletonData.version.substr(0, 3);\n\n        if (verShort !== '4.0' && verShort !== '4.1') {\n            const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n\n            console.error(error);\n        }\n        this.ver40 = verShort === '4.0';\n        skeletonData.x = input.readFloat();\n        skeletonData.y = input.readFloat();\n        skeletonData.width = input.readFloat();\n        skeletonData.height = input.readFloat();\n\n        const nonessential = input.readBoolean();\n\n        if (nonessential) {\n            skeletonData.fps = input.readFloat();\n\n            skeletonData.imagesPath = input.readString();\n            skeletonData.audioPath = input.readString();\n        }\n\n        let n = 0;\n        // Strings.\n\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const str = input.readString();\n\n            if (!str) throw new Error('String in string table must not be null.');\n            input.strings.push(str);\n        }\n\n        // Bones.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Bone name must not be null.');\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n            const data = new BoneData(i, name, parent);\n\n            data.rotation = input.readFloat();\n            data.x = input.readFloat() * scale;\n            data.y = input.readFloat() * scale;\n            data.scaleX = input.readFloat();\n            data.scaleY = input.readFloat();\n            data.shearX = input.readFloat();\n            data.shearY = input.readFloat();\n            data.length = input.readFloat() * scale;\n            data.transformMode = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n            skeletonData.bones.push(data);\n        }\n\n        // Slots.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const slotName = input.readString();\n\n            if (!slotName) throw new Error('Slot name must not be null.');\n            const boneData = skeletonData.bones[input.readInt(true)];\n            const data = new SlotData(i, slotName, boneData);\n\n            Color.rgba8888ToColor(data.color, input.readInt32());\n\n            const darkColor = input.readInt32();\n\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\n\n            data.attachmentName = input.readStringRef();\n            data.blendMode = input.readInt(true);\n            skeletonData.slots.push(data);\n        }\n\n        // IK constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('IK constraint data name must not be null.');\n            const data = new IkConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.mix = input.readFloat();\n            data.softness = input.readFloat() * scale;\n            data.bendDirection = input.readByte();\n            data.compress = input.readBoolean();\n            data.stretch = input.readBoolean();\n            data.uniform = input.readBoolean();\n            skeletonData.ikConstraints.push(data);\n        }\n\n        // Transform constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Transform constraint data name must not be null.');\n            const data = new TransformConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.local = input.readBoolean();\n            data.relative = input.readBoolean();\n            data.offsetRotation = input.readFloat();\n            data.offsetX = input.readFloat() * scale;\n            data.offsetY = input.readFloat() * scale;\n            data.offsetScaleX = input.readFloat();\n            data.offsetScaleY = input.readFloat();\n            data.offsetShearY = input.readFloat();\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            data.mixScaleX = input.readFloat();\n            data.mixScaleY = input.readFloat();\n            data.mixShearY = input.readFloat();\n            skeletonData.transformConstraints.push(data);\n        }\n\n        // Path constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Path constraint data name must not be null.');\n            const data = new PathConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.slots[input.readInt(true)];\n            data.positionMode = input.readInt(true);\n            data.spacingMode = input.readInt(true);\n            data.rotateMode = input.readInt(true);\n            data.offsetRotation = input.readFloat();\n            data.position = input.readFloat();\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n            data.spacing = input.readFloat();\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            skeletonData.pathConstraints.push(data);\n        }\n\n        // Default skin.\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\n        if (defaultSkin) {\n            skeletonData.defaultSkin = defaultSkin;\n            skeletonData.skins.push(defaultSkin);\n        }\n\n        // Skins.\n        {\n            let i = skeletonData.skins.length;\n\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\n            for (; i < n; i++) {\n                const skin = this.readSkin(input, skeletonData, false, nonessential);\n\n                if (!skin) throw new Error('readSkin() should not have returned null.');\n                skeletonData.skins[i] = skin;\n            }\n        }\n\n        // Linked meshes.\n        n = this.linkedMeshes.length;\n        for (let i = 0; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (!skin) throw new Error('Not skin found for linked mesh.');\n            if (!linkedMesh.parent) throw new Error('Linked mesh parent must not be null');\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? (parent as VertexAttachment) : linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const eventName = input.readStringRef();\n\n            if (!eventName) throw new Error();\n            const data = new EventData(eventName);\n\n            data.intValue = input.readInt(false);\n            data.floatValue = input.readFloat();\n            data.stringValue = input.readString();\n            data.audioPath = input.readString();\n            if (data.audioPath) {\n                data.volume = input.readFloat();\n                data.balance = input.readFloat();\n            }\n            skeletonData.events.push(data);\n        }\n\n        // Animations.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const animationName = input.readString();\n\n            if (!animationName) throw new Error('Animatio name must not be null.');\n            skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n        }\n\n        return skeletonData;\n    }\n\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin | null {\n        let skin = null;\n        let slotCount = 0;\n\n        if (defaultSkin) {\n            slotCount = input.readInt(true);\n            if (slotCount == 0) return null;\n            skin = new Skin('default');\n        } else {\n            const skinName = input.readStringRef();\n\n            if (!skinName) throw new Error('Skin name must not be null.');\n            skin = new Skin(skinName);\n            skin.bones.length = input.readInt(true);\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n            slotCount = input.readInt(true);\n        }\n\n        for (let i = 0; i < slotCount; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const name = input.readStringRef();\n\n                if (!name) throw new Error('Attachment name must not be null');\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\n            }\n        }\n\n        return skin;\n    }\n\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment | null {\n        const scale = this.scale;\n\n        let name = input.readStringRef();\n\n        if (!name) name = attachmentName;\n\n        switch (input.readByte()) {\n            case AttachmentType.Region: {\n                let path = input.readStringRef();\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const scaleX = input.readFloat();\n                const scaleY = input.readFloat();\n                const width = input.readFloat();\n                const height = input.readFloat();\n                const color = input.readInt32();\n                const sequence = this.readSequence(input);\n\n                if (!path) path = name;\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = x * scale;\n                region.y = y * scale;\n                region.scaleX = scaleX;\n                region.scaleY = scaleY;\n                region.rotation = rotation;\n                region.width = width * scale;\n                region.height = height * scale;\n                Color.rgba8888ToColor(region.color, color);\n                region.sequence = sequence;\n                if (sequence == null) region.updateRegion();\n\n                return region;\n            }\n            case AttachmentType.BoundingBox: {\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                box.worldVerticesLength = vertexCount << 1;\n                box.vertices = vertices.vertices;\n                box.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\n\n                return box;\n            }\n            case AttachmentType.Mesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const vertexCount = input.readInt(true);\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n                const triangles = this.readShortArray(input);\n                const vertices = this.readVertices(input, vertexCount);\n                const hullLength = input.readInt(true);\n                const sequence = this.readSequence(input);\n                let edges: number[] = [];\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    edges = this.readShortArray(input);\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.bones = vertices.bones;\n                mesh.vertices = vertices.vertices;\n                mesh.worldVerticesLength = vertexCount << 1;\n                mesh.triangles = triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // if (sequence == null) mesh.updateRegion();\n                mesh.hullLength = hullLength << 1;\n                mesh.sequence = sequence;\n                if (nonessential) {\n                    mesh.edges = edges;\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n\n                return mesh;\n            }\n            case AttachmentType.LinkedMesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const skinName = input.readStringRef();\n                const parent = input.readStringRef();\n                const inheritTimelines = input.readBoolean();\n                const sequence = this.readSequence(input);\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.sequence = sequence;\n                if (nonessential) {\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n\n                return mesh;\n            }\n            case AttachmentType.Path: {\n                const closed = input.readBoolean();\n                const constantSpeed = input.readBoolean();\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const lengths = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n                const color = nonessential ? input.readInt32() : 0;\n\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = closed;\n                path.constantSpeed = constantSpeed;\n                path.worldVerticesLength = vertexCount << 1;\n                path.vertices = vertices.vertices;\n                path.bones = vertices.bones;\n                path.lengths = lengths;\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\n\n                return path;\n            }\n            case AttachmentType.Point: {\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const color = nonessential ? input.readInt32() : 0;\n\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = x * scale;\n                point.y = y * scale;\n                point.rotation = rotation;\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\n\n                return point;\n            }\n            case AttachmentType.Clipping: {\n                const endSlotIndex = input.readInt(true);\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n                clip.endSlot = skeletonData.slots[endSlotIndex];\n                clip.worldVerticesLength = vertexCount << 1;\n                clip.vertices = vertices.vertices;\n                clip.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    private readSequence(input: BinaryInput) {\n        if (this.ver40 || !input.readBoolean()) return null;\n        const sequence = new Sequence(input.readInt(true));\n\n        sequence.start = input.readInt(true);\n        sequence.digits = input.readInt(true);\n        sequence.setupIndex = input.readInt(true);\n\n        return sequence;\n    }\n\n    private readDeformTimelineType(input: BinaryInput) {\n        if (this.ver40) return ATTACHMENT_DEFORM;\n\n        return input.readByte();\n    }\n\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\n        const scale = this.scale;\n        const verticesLength = vertexCount << 1;\n        const vertices = new Vertices();\n\n        if (!input.readBoolean()) {\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\n            return vertices;\n        }\n        const weights = new Array<number>();\n        const bonesArray = new Array<number>();\n\n        for (let i = 0; i < vertexCount; i++) {\n            const boneCount = input.readInt(true);\n\n            bonesArray.push(boneCount);\n            for (let ii = 0; ii < boneCount; ii++) {\n                bonesArray.push(input.readInt(true));\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat());\n            }\n        }\n        vertices.vertices = Utils.toFloatArray(weights);\n        vertices.bones = bonesArray;\n\n        return vertices;\n    }\n\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\n        const array = new Array<number>(n);\n\n        if (scale == 1) {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\n        } else {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n        }\n\n        return array;\n    }\n\n    private readShortArray(input: BinaryInput): number[] {\n        const n = input.readInt(true);\n        const array = new Array<number>(n);\n\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\n\n        return array;\n    }\n\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n        input.readInt(true); // Number of timelines.\n        const timelines = new Array<Timeline>();\n        const scale = this.scale;\n        // Slot timelines.\n\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n                const frameLast = frameCount - 1;\n\n                switch (timelineType) {\n                    case SLOT_ATTACHMENT: {\n                        const timeline = new AttachmentTimeline(frameCount, slotIndex);\n\n                        for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n                            const a2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const na = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            a = na;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_ALPHA: {\n                        const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n                        let time = input.readFloat();\n                        let a = input.readUnsignedByte() / 255;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, a);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const a2 = input.readUnsignedByte() / 255;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const boneIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const type = input.readByte();\n                const frameCount = input.readInt(true);\n                const bezierCount = input.readInt(true);\n\n                switch (type) {\n                    case BONE_ROTATE:\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_TRANSLATE:\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEX:\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEY:\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_SCALE:\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEX:\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEY:\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEAR:\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARX:\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARY:\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mix = input.readFloat();\n            let softness = input.readFloat() * scale;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mix2 = input.readFloat();\n                const softness2 = input.readFloat() * scale;\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n                }\n                time = time2;\n                mix = mix2;\n                softness = softness2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Transform constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            let mixScaleX = input.readFloat();\n            let mixScaleY = input.readFloat();\n            let mixShearY = input.readFloat();\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mixRotate2 = input.readFloat();\n                const mixX2 = input.readFloat();\n                const mixY2 = input.readFloat();\n                const mixScaleX2 = input.readFloat();\n                const mixScaleY2 = input.readFloat();\n                const mixShearY2 = input.readFloat();\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                }\n                time = time2;\n                mixRotate = mixRotate2;\n                mixX = mixX2;\n                mixY = mixY2;\n                mixScaleX = mixScaleX2;\n                mixScaleY = mixScaleY2;\n                mixShearY = mixShearY2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Path constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const data = skeletonData.pathConstraints[index];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                switch (input.readByte()) {\n                    case PATH_POSITION:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                                data.positionMode == PositionMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_SPACING:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_MIX:\n                        const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n                        let time = input.readFloat();\n                        let mixRotate = input.readFloat();\n                        let mixX = input.readFloat();\n                        let mixY = input.readFloat();\n\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const mixRotate2 = input.readFloat();\n                            const mixX2 = input.readFloat();\n                            const mixY2 = input.readFloat();\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                        }\n                        timelines.push(timeline);\n                }\n            }\n        }\n\n        // Deform timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const skin = skeletonData.skins[input.readInt(true)];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const slotIndex = input.readInt(true);\n\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n                    const attachmentName = input.readStringRef();\n\n                    if (!attachmentName) throw new Error('attachmentName must not be null.');\n                    const attachment = skin.getAttachment(slotIndex, attachmentName);\n                    const timelineType = this.readDeformTimelineType(input);\n                    const frameCount = input.readInt(true);\n                    const frameLast = frameCount - 1;\n\n                    switch (timelineType) {\n                        case ATTACHMENT_DEFORM: {\n                            const vertexAttachment = attachment as VertexAttachment;\n                            const weighted = vertexAttachment.bones;\n                            const vertices = vertexAttachment.vertices;\n                            const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                            const bezierCount = input.readInt(true);\n                            const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n\n                            let time = input.readFloat();\n\n                            for (let frame = 0, bezier = 0; ; frame++) {\n                                let deform;\n                                let end = input.readInt(true);\n\n                                if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                else {\n                                    deform = Utils.newFloatArray(deformLength);\n                                    const start = input.readInt(true);\n\n                                    end += start;\n                                    /* eslint-disable max-depth*/\n                                    if (scale == 1) {\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                                    } else {\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                                    }\n                                    if (!weighted) {\n                                        for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                                    }\n                                    /* eslint-enable max-depth*/\n                                }\n\n                                timeline.setFrame(frame, time, deform);\n                                if (frame == frameLast) break;\n                                const time2 = input.readFloat();\n\n                                switch (input.readByte()) {\n                                    case CURVE_STEPPED:\n                                        timeline.setStepped(frame);\n                                        break;\n                                    case CURVE_BEZIER:\n                                        setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                                }\n                                time = time2;\n                            }\n                            timelines.push(timeline);\n                            break;\n                        }\n                        case ATTACHMENT_SEQUENCE: {\n                            const timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as IHasTextureRegion);\n\n                            for (let frame = 0; frame < frameCount; frame++) {\n                                const time = input.readFloat();\n                                const modeAndIndex = input.readInt32();\n\n                                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 0xf], modeAndIndex >> 4, input.readFloat());\n                            }\n                            timelines.push(timeline);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        const drawOrderCount = input.readInt(true);\n\n        if (drawOrderCount > 0) {\n            const timeline = new DrawOrderTimeline(drawOrderCount);\n            const slotCount = skeletonData.slots.length;\n\n            for (let i = 0; i < drawOrderCount; i++) {\n                const time = input.readFloat();\n                const offsetCount = input.readInt(true);\n                const drawOrder = Utils.newArray(slotCount, 0);\n\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n                let originalIndex = 0;\n                let unchangedIndex = 0;\n\n                for (let ii = 0; ii < offsetCount; ii++) {\n                    const slotIndex = input.readInt(true);\n                    // Collect unchanged items.\n\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                    // Set changed items.\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n                }\n                // Collect remaining unchanged items.\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                // Fill in unchanged items.\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                timeline.setFrame(i, time, drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timeline.\n        const eventCount = input.readInt(true);\n\n        if (eventCount > 0) {\n            const timeline = new EventTimeline(eventCount);\n\n            for (let i = 0; i < eventCount; i++) {\n                const time = input.readFloat();\n                const eventData = skeletonData.events[input.readInt(true)];\n                const event = new Event(time, eventData);\n\n                event.intValue = input.readInt(false);\n                event.floatValue = input.readFloat();\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n                if (event.data.audioPath) {\n                    event.volume = input.readFloat();\n                    event.balance = input.readFloat();\n                }\n                timeline.setFrame(i, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n\n        return new Animation(name, timelines, duration);\n    }\n}\n\nclass LinkedMesh {\n    parent: string | null;\n    skin: string | null;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritTimeline: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string | null, slotIndex: number, parent: string | null, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritTimeline = inheritDeform;\n    }\n}\n\nclass Vertices {\n    constructor(public bones: Array<number> | null = null, public vertices: Array<number> | Float32Array | null = null) {}\n}\n\nfunction readTimeline1(input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\n    let time = input.readFloat();\n    let value = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const value2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n        }\n        time = time2;\n        value = value2;\n    }\n\n    return timeline;\n}\n\nfunction readTimeline2(input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\n    let time = input.readFloat();\n    let value1 = input.readFloat() * scale;\n    let value2 = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const nvalue1 = input.readFloat() * scale;\n        const nvalue2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n    }\n\n    return timeline;\n}\n\nfunction setBezier(\n    input: BinaryInput,\n    timeline: CurveTimeline,\n    bezier: number,\n    frame: number,\n    value: number,\n    time1: number,\n    time2: number,\n    value1: number,\n    value2: number,\n    scale: number\n) {\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\n\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\n\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\n\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\n\n// const CURVE_LINEAR = 0;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n", "import type { BoundingBoxAttachment } from './attachments';\nimport { SkeletonBoundsBase } from '@pixi-spine/base';\n\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBounds extends SkeletonBoundsBase<BoundingBoxAttachment> {}\n", "import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    SequenceTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { NumberArrayLike, Color, IHasTextureRegion, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceMode } from './attachments/Sequence';\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            const verShort = skeletonData.version.substr(0, 3);\n\n            if (verShort !== '4.0' && verShort !== '4.1') {\n                const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = getValue(boneMap, 'length', 0) * scale;\n                data.x = getValue(boneMap, 'x', 0) * scale;\n                data.y = getValue(boneMap, 'y', 0) * scale;\n                data.rotation = getValue(boneMap, 'rotation', 0);\n                data.scaleX = getValue(boneMap, 'scaleX', 1);\n                data.scaleY = getValue(boneMap, 'scaleY', 1);\n                data.shearX = getValue(boneMap, 'shearX', 0);\n                data.shearY = getValue(boneMap, 'shearY', 0);\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\n                data.skinRequired = getValue(boneMap, 'skin', false);\n\n                const color = getValue(boneMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const boneData = skeletonData.findBone(slotMap.bone);\n\n                if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\n                const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n\n                const color: string = getValue(slotMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                const dark: string = getValue(slotMap, 'dark', null);\n\n                if (dark) data.darkColor = Color.fromString(dark);\n\n                data.attachmentName = getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                data.target = skeletonData.findBone(constraintMap.target);\n\n                data.mix = getValue(constraintMap, 'mix', 1);\n                data.softness = getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = getValue(constraintMap, 'compress', false);\n                data.stretch = getValue(constraintMap, 'stretch', false);\n                data.uniform = getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n                const target = skeletonData.findBone(targetName);\n\n                if (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n                data.target = target;\n\n                data.local = getValue(constraintMap, 'local', false);\n                data.relative = getValue(constraintMap, 'relative', false);\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.offsetX = getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = getValue(constraintMap, 'shearY', 0);\n\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n                data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\n                data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\n                data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n                const target = skeletonData.findSlot(targetName);\n\n                if (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n                data.target = target;\n\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.position = getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const boneName = skinMap.bones[ii];\n                        const bone = skeletonData.findBone(boneName);\n\n                        if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraintName = skinMap.ik[ii];\n                        const constraint = skeletonData.findIkConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraintName = skinMap.transform[ii];\n                        const constraint = skeletonData.findTransformConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraintName = skinMap.path[ii];\n                        const constraint = skeletonData.findPathConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = getValue(eventMap, 'int', 0);\n                data.floatValue = getValue(eventMap, 'float', 0);\n                data.stringValue = getValue(eventMap, 'string', '');\n                data.audioPath = getValue(eventMap, 'audio', null);\n                if (data.audioPath) {\n                    data.volume = getValue(eventMap, 'volume', 1);\n                    data.balance = getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\n        const scale = this.scale;\n\n        name = getValue(map, 'name', name);\n\n        switch (getValue(map, 'type', 'region')) {\n            case 'region': {\n                const path = getValue(map, 'path', name);\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = getValue(map, 'x', 0) * scale;\n                region.y = getValue(map, 'y', 0) * scale;\n                region.scaleX = getValue(map, 'scaleX', 1);\n                region.scaleY = getValue(map, 'scaleY', 1);\n                region.rotation = getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n                region.sequence = sequence;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) region.color.setFromString(color);\n\n                // if (region.region != null) region.updateRegion();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = getValue(map, 'color', null);\n\n                if (color) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = getValue(map, 'path', name);\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n\n                const color = getValue(map, 'color', null);\n\n                if (color) mesh.color.setFromString(color);\n\n                mesh.width = getValue(map, 'width', 0) * scale;\n                mesh.height = getValue(map, 'height', 0) * scale;\n                mesh.sequence = sequence;\n\n                const parent: string = getValue(map, 'parent', null);\n\n                if (parent) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, 'skin', null), slotIndex, parent, getValue(map, 'timelines', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // if (mesh.region != null) mesh.updateRegion();\n\n                mesh.edges = getValue(map, 'edges', null);\n                mesh.hullLength = getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = getValue(map, 'closed', false);\n                path.constantSpeed = getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = getValue(map, 'x', 0) * scale;\n                point.y = getValue(map, 'y', 0) * scale;\n                point.rotation = getValue(map, 'rotation', 0);\n\n                const color = getValue(map, 'color', null);\n\n                if (color) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n\n                const end = getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readSequence(map: any) {\n        if (map == null) return null;\n        const sequence = new Sequence(getValue(map, 'count', 0));\n\n        sequence.start = getValue(map, 'start', 1);\n        sequence.digits = getValue(map, 'digits', 0);\n        sequence.setupIndex = getValue(map, 'setup', 0);\n\n        return sequence;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slot = skeletonData.findSlot(slotName);\n\n                if (!slot) throw new Error(`Slot not found: ${slotName}`);\n                const slotIndex = slot.index;\n\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (!timelineMap) continue;\n                    const frames = timelineMap.length;\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(frames, slotIndex);\n\n                        for (let frame = 0; frame < frames; frame++) {\n                            const keyMap = timelineMap[frame];\n\n                            timeline.setFrame(frame, getValue(keyMap, 'time', 0), getValue(keyMap, 'name', null));\n                        }\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgba') {\n                        const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb') {\n                        const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'alpha') {\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n                    } else if (timelineName == 'rgba2') {\n                        const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb2') {\n                        const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const bone = skeletonData.findBone(boneName);\n\n                if (!bone) throw new Error(`Bone not found: ${boneName}`);\n                const boneIndex = bone.index;\n\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n                    const frames = timelineMap.length;\n\n                    if (frames == 0) continue;\n\n                    if (timelineName === 'rotate') {\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n                    } else if (timelineName === 'translate') {\n                        const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\n                    } else if (timelineName === 'translatex') {\n                        const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'translatey') {\n                        const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'scale') {\n                        const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\n                    } else if (timelineName === 'scalex') {\n                        const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'scaley') {\n                        const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'shear') {\n                        const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\n                    } else if (timelineName === 'shearx') {\n                        const timeline = new ShearXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    } else if (timelineName === 'sheary') {\n                        const timeline = new ShearYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    }\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                let keyMap = constraintMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findIkConstraint(constraintName);\n\n                if (!constraint) throw new Error(`IK Constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mix = getValue(keyMap, 'mix', 1);\n                let softness = getValue(keyMap, 'softness', 0) * scale;\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(\n                        frame,\n                        time,\n                        mix,\n                        softness,\n                        getValue(keyMap, 'bendPositive', true) ? 1 : -1,\n                        getValue(keyMap, 'compress', false),\n                        getValue(keyMap, 'stretch', false)\n                    );\n                    const nextMap = constraintMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mix2 = getValue(nextMap, 'mix', 1);\n                    const softness2 = getValue(nextMap, 'softness', 0) * scale;\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n                    }\n\n                    time = time2;\n                    mix = mix2;\n                    softness = softness2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const timelineMap = map.transform[constraintName];\n                let keyMap = timelineMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n\n                if (!constraint) throw new Error(`Transform constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                let mixX = getValue(keyMap, 'mixX', 1);\n                let mixY = getValue(keyMap, 'mixY', mixX);\n                let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\n                let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\n                const mixShearY = getValue(keyMap, 'mixShearY', 1);\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                    const nextMap = timelineMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                    const mixX2 = getValue(nextMap, 'mixX', 1);\n                    const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                    const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\n                    const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\n                    const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                    }\n\n                    time = time2;\n                    mixRotate = mixRotate2;\n                    mixX = mixX2;\n                    mixY = mixY2;\n                    mixScaleX = mixScaleX2;\n                    mixScaleY = mixScaleY2;\n                    mixScaleX = mixScaleX2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const constraint = skeletonData.findPathConstraint(constraintName);\n\n                if (!constraint) throw new Error(`Path constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n                    let keyMap = timelineMap[0];\n\n                    if (!keyMap) continue;\n\n                    const frames = timelineMap.length;\n\n                    if (timelineName === 'position') {\n                        const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n                    } else if (timelineName === 'spacing') {\n                        const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(\n                            readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\n                        );\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n                        let time = getValue(keyMap, 'time', 0);\n                        let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                        let mixX = getValue(keyMap, 'mixX', 1);\n                        let mixY = getValue(keyMap, 'mixY', mixX);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                            const mixX2 = getValue(nextMap, 'mixX', 1);\n                            const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // ver40 compatibility\n        if (map.deform) {\n            map.attachments = {};\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const outMap = (map.attachments[deformName] = {});\n\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const outMap2 = (outMap[slotName] = {});\n\n                    for (const innerMapName in slotMap) {\n                        outMap2[innerMapName] = {\n                            deform: slotMap[innerMapName],\n                        };\n                    }\n                }\n            }\n        }\n\n        // Attachment timelines.\n        if (map.attachments) {\n            for (const attachmentsName in map.attachments) {\n                const attachmentsMap = map.attachments[attachmentsName];\n                const skin = skeletonData.findSkin(attachmentsName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${attachmentsName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotMapName in attachmentsMap) {\n                    const slotMap = attachmentsMap[slotMapName];\n                    const slot = skeletonData.findSlot(slotMapName);\n\n                    if (!slot) throw new Error(`Slot not found: ${slotMapName}`);\n                    const slotIndex = slot.index;\n\n                    for (const attachmentMapName in slotMap) {\n                        const attachmentMap = slotMap[attachmentMapName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\n\n                        for (const timelineMapName in attachmentMap) {\n                            const timelineMap = attachmentMap[timelineMapName];\n                            let keyMap = timelineMap[0];\n\n                            if (!keyMap) continue;\n\n                            if (timelineMapName == 'deform') {\n                                const weighted = attachment.bones;\n                                const vertices = attachment.vertices;\n                                const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                                let time = getValue(keyMap, 'time', 0);\n\n                                for (let frame = 0, bezier = 0; ; frame++) {\n                                    let deform: NumberArrayLike;\n                                    const verticesValue: Array<Number> = getValue(keyMap, 'vertices', null);\n\n                                    if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                    else {\n                                        deform = Utils.newFloatArray(deformLength);\n                                        const start = <number>getValue(keyMap, 'offset', 0);\n\n                                        Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                        if (scale != 1) {\n                                            for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                        }\n                                        if (!weighted) {\n                                            for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                        }\n                                    }\n\n                                    timeline.setFrame(frame, time, deform);\n                                    const nextMap = timelineMap[frame + 1];\n\n                                    if (!nextMap) {\n                                        timeline.shrink(bezier);\n                                        break;\n                                    }\n                                    const time2 = getValue(nextMap, 'time', 0);\n                                    const curve = keyMap.curve;\n\n                                    if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                                    time = time2;\n                                    keyMap = nextMap;\n                                }\n                                timelines.push(timeline);\n                            } else if (timelineMapName == 'sequence') {\n                                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment as unknown as IHasTextureRegion);\n                                let lastDelay = 0;\n\n                                for (let frame = 0; frame < timelineMap.length; frame++) {\n                                    const delay = getValue(keyMap, 'delay', lastDelay);\n                                    const time = getValue(keyMap, 'time', 0);\n                                    const mode = SequenceMode[getValue(keyMap, 'mode', 'hold')] as unknown as number;\n                                    const index = getValue(keyMap, 'index', 0);\n\n                                    timeline.setFrame(frame, time, mode, index, delay);\n                                    lastDelay = delay;\n                                    keyMap = timelineMap[frame + 1];\n                                }\n                                timelines.push(timeline);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Draw order timelines.\n        if (map.drawOrder) {\n            const timeline = new DrawOrderTimeline(map.drawOrder.length);\n            const slotCount = skeletonData.slots.length;\n            let frame = 0;\n\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n                const drawOrderMap = map.drawOrder[i];\n                let drawOrder: Array<number> | null = null;\n                const offsets = getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let ii = 0; ii < offsets.length; ii++) {\n                        const offsetMap = offsets[ii];\n                        const slot = skeletonData.findSlot(offsetMap.slot);\n\n                        if (!slot) throw new Error(`Slot not found: ${slot}`);\n                        const slotIndex = slot.index;\n                        // Collect unchanged items.\n\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timelines.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frame = 0;\n\n            for (let i = 0; i < map.events.length; i++, frame++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (!eventData) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath) {\n                    event.volume = getValue(eventMap, 'volume', 1);\n                    event.balance = getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frame, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritTimeline: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritTimeline = inheritDeform;\n    }\n}\n\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value = getValue(keyMap, 'value', defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const value2 = getValue(nextMap, 'value', defaultValue) * scale;\n\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n        time = time2;\n        value = value2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readTimeline2(keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n        const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n        const curve = keyMap.curve;\n\n        if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readCurve(curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number, value1: number, value2: number, scale: number) {\n    if (curve == 'stepped') {\n        timeline.setStepped(frame);\n\n        return bezier;\n    }\n    const i = value << 2;\n    const cx1 = curve[i];\n    const cy1 = curve[i + 1] * scale;\n    const cx2 = curve[i + 2];\n    const cy2 = curve[i + 3] * scale;\n\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n\n    return bezier + 1;\n}\n\nfunction getValue(map: any, property: string, defaultValue: any) {\n    return map[property] !== undefined ? map[property] : defaultValue;\n}\n", "import { SpineBase } from '@pixi-spine/base';\nimport { Skeleton } from './core/Skeleton';\nimport type { SkeletonData } from './core/SkeletonData';\nimport { AnimationState } from './core/AnimationState';\nimport { AnimationStateData } from './core/AnimationStateData';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<Skeleton, SkeletonData, AnimationState, AnimationStateData> {\n    createSkeleton(spineData: SkeletonData) {\n        this.skeleton = new Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new AnimationStateData(spineData);\n        this.state = new AnimationState(this.stateData);\n    }\n}\n", "/**\n * @public\n */\nexport enum SPINE_VERSION {\n    UNKNOWN = 0,\n    VER37 = 37,\n    VER38 = 38,\n    VER40 = 40,\n    VER41 = 41,\n}\n\n/**\n * @public\n */\nexport function detectSpineVersion(version: string): SPINE_VERSION {\n    const ver3 = version.substr(0, 3);\n    const verNum = Math.floor(Number(ver3) * 10 + 1e-3);\n\n    if (ver3 === '3.7') {\n        return SPINE_VERSION.VER37;\n    }\n    if (ver3 === '3.8') {\n        return SPINE_VERSION.VER38;\n    }\n    if (ver3 === '4.0') {\n        return SPINE_VERSION.VER40;\n    }\n    if (ver3 === '4.1') {\n        return SPINE_VERSION.VER41;\n    }\n    // try parse old versions with 3.7\n    if (verNum < SPINE_VERSION.VER37) {\n        return SPINE_VERSION.VER37;\n    }\n\n    return SPINE_VERSION.UNKNOWN;\n}\n", "import { ISpineResource, SpineLoaderAbstract } from '@pixi-spine/loader-base';\r\nimport { BinaryInput, ISkeletonData, ISkeletonParser, TextureAtlas } from '@pixi-spine/base';\r\nimport * as spine38 from '@pixi-spine/runtime-3.8';\r\nimport * as spine37 from '@pixi-spine/runtime-3.7';\r\nimport * as spine41 from '@pixi-spine/runtime-4.1';\r\nimport { detectSpineVersion, SPINE_VERSION } from './versions';\r\n\r\nclass UniBinaryParser implements ISkeletonParser {\r\n    scale = 1;\r\n\r\n    readSkeletonData(atlas: TextureAtlas, dataToParse: Uint8Array): ISkeletonData {\r\n        let parser: any = null;\r\n        let version = this.readVersionOldFormat(dataToParse);\r\n        let ver = detectSpineVersion(version);\r\n\r\n        if (ver === SPINE_VERSION.VER38) {\r\n            parser = new spine38.SkeletonBinary(new spine38.AtlasAttachmentLoader(atlas));\r\n        }\r\n        version = this.readVersionNewFormat(dataToParse);\r\n        ver = detectSpineVersion(version);\r\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\r\n            parser = new spine41.SkeletonBinary(new spine41.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (!parser) {\r\n            const error = `Unsupported version of spine model ${version}, please update pixi-spine`;\r\n\r\n            console.error(error);\r\n        }\r\n\r\n        parser.scale = this.scale;\r\n\r\n        return parser.readSkeletonData(dataToParse);\r\n    }\r\n\r\n    readVersionOldFormat(dataToParse: Uint8Array) {\r\n        const input = new BinaryInput(dataToParse);\r\n        let version;\r\n\r\n        try {\r\n            input.readString();\r\n            version = input.readString();\r\n        } catch (e) {\r\n            version = '';\r\n        }\r\n\r\n        return version || '';\r\n    }\r\n\r\n    readVersionNewFormat(dataToParse: Uint8Array) {\r\n        const input = new BinaryInput(dataToParse);\r\n\r\n        input.readInt32();\r\n        input.readInt32();\r\n        let version;\r\n\r\n        try {\r\n            version = input.readString();\r\n        } catch (e) {\r\n            version = '';\r\n        }\r\n\r\n        return version || '';\r\n    }\r\n}\r\n\r\nclass UniJsonParser implements ISkeletonParser {\r\n    scale = 1;\r\n\r\n    readSkeletonData(atlas: TextureAtlas, dataToParse: any): ISkeletonData {\r\n        const version = dataToParse.skeleton.spine;\r\n        const ver = detectSpineVersion(version);\r\n        let parser: any = null;\r\n\r\n        if (ver === SPINE_VERSION.VER37) {\r\n            parser = new spine37.SkeletonJson(new spine37.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (ver === SPINE_VERSION.VER38) {\r\n            parser = new spine38.SkeletonJson(new spine38.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\r\n            parser = new spine41.SkeletonJson(new spine41.AtlasAttachmentLoader(atlas));\r\n        }\r\n        if (!parser) {\r\n            const error = `Unsupported version of spine model ${version}, please update pixi-spine`;\r\n\r\n            console.error(error);\r\n        }\r\n\r\n        parser.scale = this.scale;\r\n\r\n        return parser.readSkeletonData(dataToParse);\r\n    }\r\n}\r\n\r\n/**\r\n * @public\r\n */\r\nexport class SpineLoader extends SpineLoaderAbstract<ISkeletonData> {\r\n    createBinaryParser(): ISkeletonParser {\r\n        return new UniBinaryParser();\r\n    }\r\n\r\n    createJsonParser(): ISkeletonParser {\r\n        return new UniJsonParser();\r\n    }\r\n\r\n    parseData(parser: ISkeletonParser, atlas: TextureAtlas, dataToParse: any): ISpineResource<ISkeletonData> {\r\n        const parserCast = parser as UniBinaryParser | UniJsonParser;\r\n\r\n        return {\r\n            spineData: parserCast.readSkeletonData(atlas, dataToParse),\r\n            spineAtlas: atlas,\r\n        };\r\n    }\r\n}\r\n", "import { IAnimationState, IAnimationStateData, ISkeleton, ISkeletonData, SpineBase } from '@pixi-spine/base';\nimport * as spine38 from '@pixi-spine/runtime-3.8';\nimport * as spine37 from '@pixi-spine/runtime-3.7';\nimport * as spine41 from '@pixi-spine/runtime-4.1';\nimport { detectSpineVersion, SPINE_VERSION } from './versions';\n\n/**\n * @public\n */\nexport class Spine extends SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData> {\n    createSkeleton(spineData: ISkeletonData) {\n        const ver = detectSpineVersion(spineData.version);\n        let spine: any = null;\n\n        if (ver === SPINE_VERSION.VER37) {\n            spine = spine37;\n        }\n        if (ver === SPINE_VERSION.VER38) {\n            spine = spine38;\n        }\n        if (ver === SPINE_VERSION.VER40 || ver === SPINE_VERSION.VER41) {\n            spine = spine41;\n        }\n        if (!spine) {\n            const error = `Cant detect version of spine model ${spineData.version}`;\n\n            console.error(error);\n        }\n        this.skeleton = new spine.Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n        this.stateData = new spine.AnimationStateData(spineData);\n        this.state = new spine.AnimationState(this.stateData);\n    }\n}\n", "/* eslint-disable spaced-comment */\r\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\r\n/// <reference path=\"../global.d.ts\" />\r\nimport '@pixi-spine/loader-base'; // Side effect install atlas loader\r\nimport { SpineLoader } from './SpineLoader';\r\nexport * from './Spine';\r\nexport * from './versions';\r\n\r\n// Install the loader\r\nnew SpineLoader().installLoader();\r\n"],
  "mappings": "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",
  "names": ["AttachmentType", "MixBlend", "MixDirection", "PositionMode", "RotateMode", "TransformMode", "TextureFilter", "TextureWrap", "settings", "settings", "transform", "i", "len", "textureAtlas", "lib_exports", "v", "TimelineType", "TimelineType2", "r", "deform", "vertexAttachment", "EventType", "EventType2", "settings", "SpacingMode", "SpacingMode2", "closed", "pathLength", "closed", "LinkedMesh", "settings", "lib_exports", "Animation", "AnimationState", "AnimationStateData", "AtlasAttachmentLoader", "Attachment", "AttachmentTimeline", "Bone", "BoneData", "BoundingBoxAttachment", "ClippingAttachment", "ColorTimeline", "CurveTimeline", "DeformTimeline", "DrawOrderTimeline", "Event", "EventData", "EventQueue", "EventTimeline", "EventType", "IkConstraint", "IkConstraintData", "IkConstraintTimeline", "JitterEffect", "MeshAttachment", "PathAttachment", "PathConstraint", "PathConstraintData", "PathConstraintMixTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PointAttachment", "RegionAttachment", "RotateTimeline", "ScaleTimeline", "ShearTimeline", "Skeleton", "SkeletonBounds", "SkeletonData", "SkeletonJson", "Skin", "Slot", "SlotData", "SpacingMode", "Spine", "SwirlEffect", "TimelineType", "TrackEntry", "TransformConstraint", "TransformConstraintData", "TransformConstraintTimeline", "TranslateTimeline", "TwoColorTimeline", "VertexAttachment", "Attachment", "_VertexAttachment", "v", "VertexAttachment", "BoundingBoxAttachment", "VertexAttachment", "ClippingAttachment", "VertexAttachment", "MeshAttachment", "VertexAttachment", "PathAttachment", "VertexAttachment", "PointAttachment", "VertexAttachment", "Slot", "_RegionAttachment", "Attachment", "Slot", "RegionAttachment", "JitterEffect", "_SwirlEffect", "SwirlEffect", "Animation", "TimelineType", "TimelineType2", "_CurveTimeline", "CurveTimeline", "_RotateTimeline", "r", "RotateTimeline", "_TranslateTimeline", "TranslateTimeline", "ScaleTimeline", "ShearTimeline", "_ColorTimeline", "ColorTimeline", "_TwoColorTimeline", "TwoColorTimeline", "AttachmentTimeline", "attachmentName", "zeros", "DeformTimeline", "VertexAttachment", "vertices", "vertexAttachment", "EventTimeline", "DrawOrderTimeline", "_IkConstraintTimeline", "IkConstraintTimeline", "_TransformConstraintTimeline", "TransformConstraintTimeline", "_PathConstraintPositionTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "_PathConstraintMixTimeline", "PathConstraintMixTimeline", "_AnimationState", "EventQueue", "TrackEntry", "RotateTimeline", "AttachmentTimeline", "DrawOrderTimeline", "Animation", "AnimationState", "_TrackEntry", "_EventQueue", "EventType", "EventType2", "_AnimationStateData", "AnimationStateData", "AtlasAttachmentLoader", "RegionAttachment", "MeshAttachment", "BoundingBoxAttachment", "PathAttachment", "PointAttachment", "ClippingAttachment", "Bone", "settings", "BoneData", "Event", "EventData", "IkConstraint", "IkConstraintData", "PathConstraintData", "SpacingMode", "SpacingMode2", "_PathConstraint", "PathAttachment", "SpacingMode", "closed", "pathLength", "PathConstraint", "TransformConstraint", "_Skeleton", "Bone", "Slot", "IkConstraint", "TransformConstraint", "PathConstraint", "PathAttachment", "RegionAttachment", "MeshAttachment", "Skeleton", "SkeletonBounds", "SkeletonData", "SlotData", "TransformConstraintData", "Skin", "SkeletonJson", "SkeletonData", "BoneData", "SlotData", "IkConstraintData", "TransformConstraintData", "PathConstraintData", "SpacingMode", "Skin", "EventData", "LinkedMesh", "AttachmentTimeline", "ColorTimeline", "TwoColorTimeline", "RotateTimeline", "ScaleTimeline", "ShearTimeline", "TranslateTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintSpacingTimeline", "PathConstraintPositionTimeline", "PathConstraintMixTimeline", "settings", "DeformTimeline", "DrawOrderTimeline", "EventTimeline", "Event", "Animation", "Spine", "Skeleton", "AnimationStateData", "AnimationState", "lib_exports", "Animation", "AnimationState", "AnimationStateAdapter", "AnimationStateData", "AtlasAttachmentLoader", "Attachment", "AttachmentTimeline", "Bone", "BoneData", "BoundingBoxAttachment", "ClippingAttachment", "ConstraintData", "CurveTimeline", "CurveTimeline2", "DeformTimeline", "DrawOrderTimeline", "Event", "EventData", "EventQueue", "EventTimeline", "EventType", "IkConstraint", "IkConstraintData", "IkConstraintTimeline", "MeshAttachment", "PathAttachment", "PathConstraint", "PathConstraintData", "PathConstraintMixTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PointAttachment", "RegionAttachment", "RotateTimeline", "ScaleTimeline", "ShearTimeline", "Skeleton", "SkeletonBinary", "SkeletonBounds", "SkeletonData", "SkeletonJson", "Skin", "SkinEntry", "Slot", "SlotData", "SpacingMode", "Spine", "TrackEntry", "TransformConstraint", "TransformConstraintData", "TransformConstraintTimeline", "TranslateTimeline", "VertexAttachment", "Attachment", "_VertexAttachment", "v", "VertexAttachment", "BoundingBoxAttachment", "VertexAttachment", "ClippingAttachment", "VertexAttachment", "MeshAttachment", "VertexAttachment", "PathAttachment", "VertexAttachment", "PointAttachment", "VertexAttachment", "_RegionAttachment", "Attachment", "RegionAttachment", "SequenceMode", "Animation", "CurveTimeline", "x", "y", "CurveTimeline2", "RotateTimeline", "TranslateTimeline", "ScaleTimeline", "ShearTimeline", "AttachmentTimeline", "DeformTimeline", "VertexAttachment", "vertexAttachment", "EventTimeline", "DrawOrderTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "_AnimationState", "EventQueue", "TrackEntry", "AttachmentTimeline", "RotateTimeline", "DrawOrderTimeline", "EventTimeline", "AnimationState", "Animation", "_TrackEntry", "EventType", "EventType2", "AnimationStateAdapter", "AnimationStateData", "AtlasAttachmentLoader", "RegionAttachment", "MeshAttachment", "BoundingBoxAttachment", "PathAttachment", "PointAttachment", "ClippingAttachment", "Bone", "settings", "BoneData", "ConstraintData", "Event", "EventData", "IkConstraint", "settings", "IkConstraintData", "ConstraintData", "PathConstraintData", "ConstraintData", "SpacingMode", "SpacingMode2", "_PathConstraint", "PathAttachment", "SpacingMode", "closed", "pathLength", "multiplier", "PathConstraint", "Slot", "VertexAttachment", "TransformConstraint", "_Skeleton", "Bone", "Slot", "IkConstraint", "TransformConstraint", "PathConstraint", "PathAttachment", "settings", "RegionAttachment", "MeshAttachment", "Skeleton", "SkeletonData", "SlotData", "TransformConstraintData", "ConstraintData", "SkinEntry", "Skin", "MeshAttachment", "SkeletonBinary", "SkeletonData", "BoneData", "SlotData", "IkConstraintData", "TransformConstraintData", "PathConstraintData", "SpacingMode", "EventData", "Skin", "LinkedMesh", "closed", "Vertices", "AttachmentTimeline", "RotateTimeline", "TranslateTimeline", "ScaleTimeline", "ShearTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "DeformTimeline", "DrawOrderTimeline", "EventTimeline", "Event", "Animation", "SkeletonBounds", "SkeletonJson", "SkeletonData", "BoneData", "SlotData", "IkConstraintData", "TransformConstraintData", "PathConstraintData", "SpacingMode", "Skin", "EventData", "LinkedMesh", "AttachmentTimeline", "readTimeline1", "RotateTimeline", "TranslateTimeline", "readTimeline2", "ScaleTimeline", "ShearTimeline", "IkConstraintTimeline", "TransformConstraintTimeline", "PathConstraintPositionTimeline", "PathConstraintSpacingTimeline", "PathConstraintMixTimeline", "settings", "DeformTimeline", "DrawOrderTimeline", "EventTimeline", "Event", "Animation", "Spine", "Skeleton", "AnimationStateData", "AnimationState", "SPINE_VERSION", "SkeletonBinary", "AtlasAttachmentLoader", "SkeletonJson", "Spine", "lib_exports"]
}
